<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
C (KNK) - Current Chapter
</title>
<link rel="stylesheet" href="./myStyle.css">
</head>
<body>
<hr class="chapterDivider">
<h1 id="pointers-and-arrays">12 Pointers and Arrays</h1>
<!-- START: div -->
<div class="theQuote">
<p>Optimization hinders evolution.</p>
</div>
<!-- END: div -->
<p>Chapter 11 introduced pointers and showed how they’re used as
function arguments and as values returned by functions. This chapter
covers another application for pointers. When pointers point to array
elements, C allows us to perform arithmetic—addition and subtraction—on
the pointers, which leads to an alternative way of processing arrays in
which pointers take the place of array subscripts.</p>
<p>The relationship between pointers and arrays in C is a close one, as
we’ll soon see. We’ll exploit this relationship in subsequent chapters,
including Chapter 13 (Strings) and Chapter 17 (Advanced Uses of
Pointers). Understanding the connection between pointers and arrays is
critical for mastering C: it will give you insight into how C was
designed and help you understand existing programs. Be aware, however,
that one of the primary reasons for using pointers to process
arrays—efficiency—is no longer as important as it once was, thanks to
improved compilers.</p>
<p>Section 12.1 discusses pointer arithmetic and shows how pointers can
be compared using the relational and equality operators. Section 12.2
then demonstrates how we can use pointer arithmetic for processing array
elements. Section 12.3 reveals a key fact about arrays—an array name can
serve as a pointer to the array’s first element—and uses it to show how
array arguments really work. Section 12.4 shows how the topics of the
first three sections apply to multidimensional arrays. Section 12.5
wraps up the chapter by exploring the relationship between pointers and
variable-length arrays, a C99 feature.</p>
<h2 id="pointer-arithmetic">12.1 Pointer Arithmetic</h2>
<p>We saw in Section 11.5 that pointers can point to array elements. For
example, suppose that <code>a</code> and <code>p</code> have been
declared as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">],</span> <span class="op">*</span>p<span class="op">;</span></span></code></pre></div>
<p>We can make <code>p</code> point to <code>a[0]</code> by writing</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span></code></pre></div>
<p>Graphically, here’s what we’ve just done:</p>
<p><img src="./images/cknkCh12Sec12p1_1.png" alt="cknkCh12Sec12p1_1.png"/></p>
<p>We can now access <code>a[0]</code> through <code>p</code>; for
example, we can store the value 5 in <code>a[0]</code> by writing</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span></code></pre></div>
<p>Here’s our picture now:</p>
<p><img src="./images/cknkCh12Sec12p1_2.png" alt="cknkCh12Sec12p1_2.png"/></p>
<p>Making a pointer <code>p</code> point to an element of an array
<code>a</code> isn’t particularly exciting. However. by performing
pointer arithmetic (or address arithmetic) on <code>p</code>, we can
access the other elements of <code>a</code>. C supports three (and only
three) forms of pointer arithmetic:</p>
<pre><code>- Adding an integer to a pointer
- Subtracting an integer from a pointer
- Subtracting one pointer from another</code></pre>
<p>Let’s take a close look at each of these operations. Our examples
assume that the following declarations are in effect:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="op">*</span>p<span class="op">,</span> <span class="op">*</span>q<span class="op">,</span> i<span class="op">;</span></span></code></pre></div>
<h3 id="adding-an-integer-to-a-pointer">12.1.1 Adding an Integer to a
Pointer</h3>
<p><span class="QandA"></span></p>
<p>Adding an integer <code>j</code> to a pointer <code>p</code> yields a
pointer to the element <code>j</code> places after the one that
<code>p</code> points to. More precisely, if <code>p</code> points to
the array element <code>a[i]</code>. then <code>p + j</code> points to
<code>a[i + j]</code> (provided, of course, that <code>a[i + j]</code>
exists).</p>
<p>The following example illustrates pointer addition; diagrams show the
values of <code>p</code> and <code>q</code> at various points in the
computation.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span></code></pre></div>
<p><img src="./images/cknkCh12Sec12p1p1_1.png" alt="cknkCh12Sec12p1p1_1.png"/></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> p <span class="op">+</span> <span class="dv">3</span><span class="op">;</span></span></code></pre></div>
<p><img src="./images/cknkCh12Sec12p1p1_2.png" alt="cknkCh12Sec12p1p1_2.png"/></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">+=</span> <span class="dv">6</span><span class="op">;</span></span></code></pre></div>
<p><img src="./images/cknkCh12Sec12p1p1_3.png" alt="cknkCh12Sec12p1p1_3.png"/></p>
<h3 id="subtracting-an-integer-from-a-pointer">12.1.2 Subtracting an
Integer from a Pointer</h3>
<p>If <code>p</code> points to the array element <code>a[i]</code>, then
<code>p - j</code> points to <code>a[i - j]</code>. For example:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">8</span><span class="op">];</span></span></code></pre></div>
<p><img src="./images/cknkCh12Sec12p1p2_1.png" alt="cknkCh12Sec12p1p2_1.png"/></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> p <span class="op">-</span> <span class="dv">3</span><span class="op">;</span></span></code></pre></div>
<p><img src="./images/cknkCh12Sec12p1p2_2.png" alt="cknkCh12Sec12p1p2_2.png"/></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">-=</span> <span class="dv">6</span><span class="op">;</span></span></code></pre></div>
<p><img src="./images/cknkCh12Sec12p1p2_3.png" alt="cknkCh12Sec12p1p2_3.png"/></p>
<h3 id="subtracting-one-pointer-from-another">12.1.3 Subtracting One
Pointer from Another</h3>
<p>When one pointer is subtracted from another, the result is the
distance (measured in array elements) between the pointers. Thus, if
<code>p</code> points to <code>a[i]</code> and <code>q</code> points to
<code>a[j]</code>.then <code>p - q</code> is equal to
<code>i - j</code>. For example:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span></code></pre></div>
<p><img src="./images/cknkCh12Sec12p1p3_1.png" alt="cknkCh12Sec12p1p3_1.png"/></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> p <span class="op">-</span> q<span class="op">;</span> <span class="co">/* i is 4 */</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> q <span class="op">-</span> p<span class="op">;</span> <span class="co">/* i is -4 */</span></span></code></pre></div>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Performing arithmetic on a pointer that doesn’t point to an array
element causes undefined behavior. Furthermore, the effect of
subtracting one pointer from another is undefined unless both point to
elements of the same array.</p>
</div>
<!-- END: div -->
<h3 id="comparing-pointers">12.1.4 Comparing Pointers</h3>
<p>We can compare pointers using the relational operators
(<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>,
<code>&gt;=</code>) and the equality operators (<code>==</code> and
<code>|=</code>). Using the relational operators to compare two pointers
is meaningful only when both point to elements of the same array. The
outcome of the comparison depends on the relative positions of the two
elements in the array. For example, after the assignments</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span></code></pre></div>
<p>the value of <code>p &lt;= q</code> is 0 and the value of
<code>p &gt;= q</code> is 1.</p>
<p><span class="C99Symbol"></span></p>
<h3 id="pointers-to-compound-literals">12.1.5 Pointers to Compound
Literals</h3>
<p>It’s legal for a pointer to point to an element within an array
created by a compound literal. A compound literal, you may recall, is a
C99 feature that can be used to create an array with no name.</p>
<p>Consider the following example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">[</span><span class="dv">1</span><span class="op">]){</span><span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span></code></pre></div>
<p><code>p</code> points to the first element of a five-element array
containing the integers 3, 0, 3, 4, and 1. Using a compound literal
saves us the trouble of first declaring an array variable and then
making <code>p</code> point to the first element of that array:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">}:</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span></code></pre></div>
<h2 id="using-pointers-for-array-processing">12.2 Using Pointers for
Array Processing</h2>
<p>Pointer arithmetic allows us to visit the elements of an array by
repeatedly incrementing a pointer variable. The following program
fragment, which sums the elements of an array <code>a</code>,
illustrates the technique. In this example, the pointer variable
<code>p</code> initially points to <code>a[0]</code>. Each time through
the loop, <code>p</code> is incremented; as a result, it points to
<code>a[1]</code>, then <code>a[2]</code>, and so forth. The loop
terminates when <code>p</code> steps past the last element of
<code>a</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N 10</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>N<span class="op">],</span> sum<span class="op">,</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span> p <span class="op">&lt;</span> <span class="op">&amp;</span>a<span class="op">[</span>N<span class="op">];</span> p<span class="op">++)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> <span class="op">*</span>p<span class="op">;</span></span></code></pre></div>
<p>The following figures show the contents of <code>a</code>,
<code>sum</code>, and <code>p</code> at the end of the first three loop
iterations (before <code>p</code> has been incremented).</p>
<p>At the end of the first iteration: I</p>
<p><img src="./images/cknkCh12Sec12p2_1.png" alt="cknkCh12Sec12p2_1.png"/></p>
<p>At the end of the second iteration:</p>
<p><img src="./images/cknkCh12Sec12p2_2.png" alt="cknkCh12Sec12p2_2.png"/></p>
<p>At the end of the third iteration</p>
<p><img src="./images/cknkCh12Sec12p2_3.png" alt="cknkCh12Sec12p2_3.png"/></p>
<p>The condition <code>p &lt; &amp;a[N]</code> in the <code>for</code>
statement deserves special mention. Strange as it may seem, it’s legal
to apply the address operator to <code>a[N]</code>, even though this
element doesn’t exist (<code>a</code> is indexed from 0 to
<code>N — 1</code>). Using <code>a[N]</code> in this fashion is
perfectly safe, since the loop doesn’t attempt to examine its value. The
body of the loop will be executed with <code>p</code> equal to
<code>&amp;a[0]</code>, <code>&amp;a[1]</code>, <code>...</code>,
<code>&amp;a [N-1]</code>, but when <code>p</code> is equal to
<code>&amp;a[N]</code>, the loop terminates.</p>
<p><span class="QandA"></span></p>
<p>We could just as easily have written the loop without pointers, of
course, using subscripting instead. The argument most often cited in
support of pointer arithmetic is that it can save execution time.
However, that depends on the implementation—some C compilers actually
produce better code <code>for</code> loops that rely on
subscripting.</p>
<h3 id="combining-the-and-operators">12.2.1 Combining the * and ++
Operators</h3>
<p>C programmers often combine the <code>*</code> (indirection) and
<code>++</code> operators in statements that process array elements.
Consider the simple case of storing a value into an array element and
then advancing to the next element. Using array subscripting, we might
write</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">[</span>i<span class="op">++]</span> <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>If <code>p</code> is pointing to an array element, the corresponding
statement would be</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p<span class="op">++</span> <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>Because the postfix version of <code>++</code> takes precedence over
<code>*</code>, the compiler sees this as</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">*(</span>p<span class="op">++)</span> <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>The value of <code>p++</code> is <code>p</code>. (Since we’re using
the postfix version of <code>++</code>, p won’t be incremented until
after the expression has been evaluated.) Thus, the value of
<code>*(p++)</code> will be <code>*p</code>—the object to which
<code>p</code> is pointing.</p>
<p>Of course, <code>*p++</code> isn’t the only legal combination of
<code>*</code> and <code>++</code>. We could write <code>(*p)++</code>,
for example, which returns the value of the object that <code>p</code>
points to, and then increments that object (<code>p</code> itself is
unchanged). If you find this confusing, the following table may
help:</p>
<!-- START: table -->
<table>
<tr>
<th>
<p><em>Expression</em></p>
</th>
<th>
<p><em>Meaning</em></p>
</th>
</tr>
<tr>
<td>
<p><code>*p++</code> or <code>*(p++)</code></p>
</td>
<td>
<p>Value of expression is <code>*p</code> before increment; increment
<code>p</code> later</p>
</td>
</tr>
<tr>
<td>
<p><code>(*p)++</code></p>
</td>
<td>
<p>Value of expression is <code>*p</code> before increment: increment
<code>*p</code> later</p>
</td>
</tr>
<tr>
<td>
<p><code>*++p</code> or <code>*(++p)</code></p>
</td>
<td>
<p>Increment <code>p</code> first; value of expression is
<code>*p</code> after increment</p>
</td>
</tr>
<tr>
<td>
<p><code>++*p</code> or <code>++(*p)</code></p>
</td>
<td>
<p>Increment <em>p first; value of expression is </em>p after
increment</p>
</td>
</tr>
</table>
<!-- END: table -->
<p>All four combinations appear in programs, although some are far more
common than others. The one we’ll see most frequently is
<code>*p++</code>, which is handy in loops. Instead of writing</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span> p <span class="op">&lt;</span> <span class="op">&amp;</span>a<span class="op">[</span>N<span class="op">];</span> p<span class="op">++)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> <span class="op">*</span>p<span class="op">;</span></span></code></pre></div>
<p>to sum the elements of the array <code>a</code>, we could write</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>p <span class="op">&lt;</span> <span class="op">&amp;</span>a<span class="op">[</span>N<span class="op">])</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> <span class="op">*</span>p<span class="op">++;</span></span></code></pre></div>
<p>The <code>*</code> and <code>--</code> operators mix in the same way
as <code>*</code> and <code>++</code>. For an application that combines
<code>*</code> and <code>--</code>, let’s return to the stack example of
Section 10.2. The original version of the stack relied on an integer
variable named <code>top</code> to keep track of the “top-of-stack”
position in the <code>contents</code> array. Let’s replace
<code>top</code> by a pointer variable that points initially to element
0 of the <code>contents</code> array:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>top_ptr <span class="op">=</span> <span class="op">&amp;</span>contents<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span></code></pre></div>
<p>Here are the new <code>push</code> and <code>pop</code> functions
(updating the other stack functions is left as an exercise):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> push<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>is_full<span class="op">())</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        stack_overflow<span class="op">()</span> <span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>top_ptr<span class="op">++</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> pop<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>is_empty<span class="op">())</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>        stack_underflow<span class="op">()</span> <span class="op">;</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*--</span>top_ptr<span class="op">;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that I’ve written <code>*--top_ptr</code>, not
<code>*top_ptr--</code>, since I want <code>pop</code> to decrement
<code>top_ptr</code> <em>before</em> fetching the value to which it
points.</p>
<h2 id="using-an-array-name-as-a-pointer">12.3 Using an Array Name as a
Pointer</h2>
<p>Pointer arithmetic is one way in which arrays and pointers are
related, but it’s not the only connection between the two. Here’s
another key relationship: The name of an array can be used as a pointer
to the first element in the array. This relationship simplifies pointer
arithmetic and makes both arrays and pointers more versatile.</p>
<p>For example, suppose that <code>a</code> is declared as follows:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span></code></pre></div>
<p>Using <code>a</code> as a pointer to the first element in the array,
we can modify <code>a[0]</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>a <span class="op">=</span> <span class="dv">7</span><span class="op">;</span> <span class="co">/* stores 7 in a[0] */</span></span></code></pre></div>
<p>We can modify <code>a[1]</code> through the pointer
<code>a + 1</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="op">*(</span>a<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="dv">12</span><span class="op">;</span> <span class="co">/* stores 12 in a[1] */</span></span></code></pre></div>
<p>In general, <code>a + i</code> is the same as <code>&amp;a[1]</code>
(both represent a pointer to element <code>i</code> of <code>a</code>)
and <code>*(a+i)</code> is equivalent to <code>a[i]</code> (both
represent element <code>i</code> itself). In other words, array
subscripting can be viewed as a form of pointer arithmetic.</p>
<p>The fact that an array name can serve as a pointer makes it easier to
write loops that step through an array. Consider the following loop from
Section 12.2:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span> p <span class="op">&lt;</span> <span class="op">&amp;</span>a<span class="op">[</span>N<span class="op">];</span> p<span class="op">++)</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> <span class="op">*</span>p<span class="op">;</span></span></code></pre></div>
<p>To simplify the loop, we can replace <code>&amp;a[0]</code> by
<code>a</code> and <code>&amp;a[N]</code> by <code>a + N</code>:</p>
<p><strong>idiom</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>p <span class="op">=</span> a<span class="op">;</span> p <span class="op">&lt;</span> a <span class="op">+</span> N<span class="op">;</span> p<span class="op">++)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> <span class="op">*</span>p<span class="op">;</span></span></code></pre></div>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Although an array name can be used as a pointer, it’s not possible to
assign it a new value. Attempting to make it point elsewhere is an
error:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(*</span>a <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">++;</span> <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>This is no great loss; we can always copy a into a pointer variable,
then change the pointer variable:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(*</span>p <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    p<span class="op">++;</span></span></code></pre></div>
</div>
<!-- END: div -->
<h3 id="program-reversing-a-series-of-numbers-revisited">12.3.1
(PROGRAM) Reversing a Series of Numbers (Revisited)</h3>
<p>The <code>reverse.c</code> program of Section 8.1 reads 10 numbers,
then writes the numbers in reverse order. As the program reads the
numbers, it stores them in an array. Once all the numbers are read, the
program steps through the array backwards as it prints the numbers.</p>
<p>The original program used subscripting to access elements of the
array, Here’s a new version in which I’ve replaced subscripting with
pointer arithmetic.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">/********************************************************************************</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * File: reverse3.c</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Reverses a series of numbers (pointer version)</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co"> ********************************************************************************/</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co">/* START: Header inclusions*/</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span><span class="re">END</span><span class="co">: Header inclusions*/</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="co">/* START: MACRO definitions*/</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N 10</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span><span class="re">END</span><span class="co">: MACRO definitions*/</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="co">/* START: type definitions*/</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span><span class="re">END</span><span class="co">: type definitions*/</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="co">/* START: Variable declarations*/</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span><span class="re">END</span><span class="co">: Variable declarations*/</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a><span class="co">/* START: Function prototypes*/</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span><span class="re">END</span><span class="co">: Function prototypes*/</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * Function name: main</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * Return type: int</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="co"> * Return value description: </span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a><span class="co"> * Parameters: void</span></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a><span class="co"> * Param1 descr.: </span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a><span class="co"> * Param2 descr.: </span></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="co"> * Param3 descr.: </span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a><span class="co"> * Function description: </span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span>N<span class="op">],</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter %d numbers: &quot;</span><span class="op">,</span> N<span class="op">);</span></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>p <span class="op">=</span> a<span class="op">;</span> p <span class="op">&lt;</span> a <span class="op">+</span> N<span class="op">;</span> p<span class="op">++)</span></span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> p<span class="op">);</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>   <span class="co">// for statement: get the numbers</span></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;In reverse order: &quot;</span><span class="op">);</span></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>p <span class="op">=</span> a <span class="op">+</span> N <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> p <span class="op">&gt;=</span> a<span class="op">;</span> p<span class="op">--)</span></span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot; %d&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span></span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>   <span class="co">// for statement: print the numbers in reverse order</span></span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>   <span class="co">//FUNCTION </span><span class="re">END</span><span class="co">: main</span></span></code></pre></div>
<p>In the original program, an integer variable <code>i</code> kept
track of the current position within the array. The new version replaces
<code>i</code> with <code>p</code>, a pointer variable. The numbers are
still stored in an array: we’re simply using a different technique to
keep track of where we are in the array.</p>
<p>Note that the second argument to <code>scanf</code> is
<code>p</code>, not <code>&amp;p</code>. Since <code>p</code> points to
an array element, it’s a satisfactory argument for <code>scanf</code>;
<code>&amp;p</code>, on the other hand, would be a pointer to a pointer
to an array element.</p>
<h3 id="array-arguments-revisited">12.3.2 Array Arguments
(Revisited)</h3>
<p>When passed to a function, an array name is always treated as a
pointer. Consider the following function, which returns the largest
element in an array of integers:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_largest<span class="op">(</span><span class="dt">int</span> a<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> max<span class="op">;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    max <span class="op">=</span> a<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    Eor <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>a<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> max<span class="op">)</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>            max <span class="op">=</span> a<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max<span class="op">;</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Suppose that we call <code>find_largest</code> as follows:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>largest <span class="op">=</span> find_largest<span class="op">(</span>b<span class="op">,</span> N<span class="op">);</span></span></code></pre></div>
<p>This call causes a pointer to the first element of <code>b</code> to
be assigned to <code>a</code>: the array itself isn’t copied.</p>
<p>The fact that an array argument is treated as a pointer has some
important consequences:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>When an ordinary variable is passed to a function, its value is
copied; any changes to the corresponding parameter don’t affect the
variable. In contrast, an array used as an argument isn’t protected
against change, since no copy is made of the array itself. For example,
the following function (which we first saw in Section 9.3) modifies an
array by storing zero into each of its elements:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> store_zeros<span class="op">(</span><span class="dt">int</span> a<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>   <span class="co">// for statement: </span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To indicate that an array parameter won’t be changed, we can include
the word <code>const</code> in its declaration:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_largest<span class="op">(</span><span class="dt">const</span> <span class="dt">int</span> a<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If <code>const</code> is present, the compiler will check that no
assignment to an element of <code>a</code> appears in the body of
<code>find_largest</code>.</p>
</li>
<li>
<p>The time required to pass an array to a function doesn’t depend on
the size of the array. There’s no penalty for passing a large array,
since no copy of the array is made.</p>
</li>
<li>
<p>An array paramecter can be declared as a pointer if desired. For
example, <code>find_largest</code> could be defined as follows:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_largest <span class="op">(</span><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>Declaring <code>a</code> to be a pointer is equivalent to declaring
it to be an array; the compiler treats the declarations as though they
were identical.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Although declaring a parameter to be an array is the same as
declaring it to be a pointer, the same isn’t true for a variable. The
declaration</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span></code></pre></div>
<p>causes the compiler to set aside space for 10 integers. In contrast,
the declaration</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>a<span class="op">;</span></span></code></pre></div>
<p>causes the compiler to allocate space for a pointer variable. In the
latter case, <code>a</code> is not an array; attempting to use it as an
array can have disastrous results. For example, the assignment</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>will store 0 where <code>a</code> is pointing. Since we don’t know
where <code>a</code> is pointing, the effect on the program is
undefined.</p>
</div>
<!-- END: div -->
</li>
<li>
<p>A function with an array parameter can be passed an array “slice”—a
sequence of consecutive elements. Suppose that we want
<code>find_largest</code> to locate the largest element in some portion
of an array <code>b</code>, say elements <code>b[5]</code>,
<code>...</code>, <code>b[14]</code>. When we call
<code>find_largest</code>, we’ll pass it the address of
<code>b[5]</code> and the number 10, indicating that we want
<code>find_largest</code> to examine 10 array elements, starting at
<code>b[5]</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>largest <span class="op">=</span> find_largest <span class="op">(&amp;</span>b<span class="op">[</span><span class="dv">5</span><span class="op">],</span> <span class="dv">10</span><span class="op">);</span></span></code></pre></div>
</li>
</ul>
<!-- END: unordered-list -->
<h3 id="using-a-pointer-as-an-array-name">12.3.3 Using a Pointer as an
Array Name</h3>
<p>If we can use an array name as a pointer, will C allow us to
subscript a pointer as though it were an array name? By now, you’d
probably expect the answer to be yes, and you’d be right. Here’s an
example:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N 10</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>N<span class="op">],</span> i<span class="op">,</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> <span class="op">*</span>p <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="dv">1</span> <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> p<span class="op">[</span>i<span class="op">];</span></span></code></pre></div>
<p>The compiler treats <code>p[1]</code> as <code>*(p+1)</code>, which
is a perfectly legal use of pointer arithmetic. Although the ability to
subscript a pointer may seem to be little more than a curiosity, we’ll
see in Section 17.3 that it’s actually quite useful.</p>
<h2 id="pointers-and-multidimensional-arrays">12.4 Pointers and
Multidimensional Arrays</h2>
<p>Just as pointers can point to elements of one-dimensional arrays,
they can also point to elements of multidimensional arrays. In this
section, we’ll explore common techniques for using pointers to process
the elements of multidimensional arrays. For simplicity, I’ll stick to
two-dimensional arrays, but everything we’ll do applies equally to
higher-dimensional arrays.</p>
<h3 id="processing-the-elements-of-a-multidimensional-array">12.4.1
Processing the Elements of a Multidimensional Array</h3>
<p>We saw in Section 8.2 that C stores two-dimensional arrays in
row-major order; in other words, the elements of row 0 come first.
followed by the elements of row 1, and so forth. An array with
<code>r</code> rows would have the following appearance:</p>
<p><img src="./images/cknkCh12Sec12p4p1_1.png" alt="cknkCh12Sec12p4p1_1.png"/></p>
<p>We can take advantage of this layout when working with pointers. If
we make a pointer <code>p</code> point to the first element in a
two-dimensional array (the element in row 0, column 0), we can visit
every element in the array by incrementing <code>p</code>
repeatedly.</p>
<p>As an example, let’s look at the problem of initializing all elements
of a two dimensional array to zero. Suppose that the array has been
declared as follows:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>NUM_ROWS<span class="op">][</span>NUM_COLS<span class="op">];</span></span></code></pre></div>
<p>The obvious technique would be to use nested <code>for</code>
loops:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> row<span class="op">,</span> col<span class="op">;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>row <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> row <span class="op">&lt;</span> NUM_ROWS<span class="op">;</span> row<span class="op">++)</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> col <span class="op">&lt;</span> NUM_COLS<span class="op">;</span> col<span class="op">++)</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        a<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>But if we view <code>a</code> as a one-dimensional array of integers
(which is how it’s stored), we can replace the pair of loops by a single
loop:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span> p <span class="op">&lt;=</span> <span class="op">&amp;</span>a<span class="op">[</span>NUM_ROWS <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>NUM_COLS <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> p<span class="op">++)</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>The loop begins with <code>p</code> pointing to <code>a[0][0]</code>.
Successive increments of <code>p</code> make it point to
<code>a[0][1]</code>, <code>a[0][2]</code>, <code>a[0][3]</code>, and so
on. When <code>p</code> reaches <code>a[0][NUM_COLS-1]</code> (the last
element in row 0), incrementing it again makes <code>p</code> point to
<code>a[1][0]</code>, the first element in row 1. The process continues
until <code>p</code> goes past <code>a[NUM_ROWS-1][NUM_COLS-1]</code>,
the last element in the array.</p>
<p><span class="QandA"></span></p>
<p>Although treating a two-dimensional array as one-dimensional may seem
like cheating, it works with most C compilers. Whether it’s a good idea
to do so is another matter. Techniques like this one definitely hurt
program readability, but—at least with some older compilers—produce a
compensating increase in efficiency. With many modern compilers, though,
there’s often little or no speed advantage.</p>
<h3 id="processing-the-rows-of-a-multidimensional-array">12.4.2
Processing the Rows of a Multidimensional Array</h3>
<p>What about processing the elements in just one row of a
two-dimensional array? Again, we have the option of using a pointer
variable <code>p</code>. To visit the elements of row <code>i</code>,
we’d initialize <code>p</code> to point to element 0 in row
<code>i</code> in the array <code>a</code>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span></code></pre></div>
<p>Or we could simply write</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> a<span class="op">[</span>i<span class="op">];</span></span></code></pre></div>
<p>since, for any two-dimensional array <code>a</code>, the expression
<code>a[1]</code> is a pointer to the first element in row 1. To see why
this works, recall the magic formula that relates array subscripting to
pointer arithmetic: for any array <code>a</code>, the expression
<code>a[1]</code> is equivalent to <code>*(a + 1)</code>. Thus,
<code>&amp;a[1][0]</code> is the same as
<code>&amp;(*(a[1] + 0))</code>, which is equivalent to
<code>&amp;*a[1]</code>, which is the same as <code>a[1]</code>, since
the <code>&amp;</code> and <code>*</code> operators cancel. We’ll use
this simplification in the following loop, which clears row
<code>i</code> of the array <code>a</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>NUM_ROWS<span class="op">][</span>NUM_COLS<span class="op">],</span> <span class="op">*</span>p<span class="op">,</span> i<span class="op">;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>p <span class="op">=</span> a<span class="op">[</span>i<span class="op">];</span> p <span class="op">&lt;</span> a<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> NUM_COLS<span class="op">;</span> p<span class="op">++)</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>Since <code>a[i]</code> is a pointer to row <code>i</code> of the
array <code>a</code>, we can pass <code>a[i]</code> to a function that’s
expecting a one-dimensional array as its argument. In other words, a
function that’s designed to work with one-dimensional arrays will also
work with a row belonging to a two-dimensional array. As a result,
functions such as <code>find_largest</code> and <code>store_zeros</code>
are more versatile than you might expect. Consider
<code>find_largest</code>, which we originally designed to find the
largest element of a one-dimensional array. We can just as easily use
<code>find_largest</code> to determine the largest element in row
<code>i</code> of the two-dimensional array <code>a</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>largest <span class="op">=</span> find_largest<span class="op">(</span>a<span class="op">[</span>i<span class="op">],</span> NUM_COLS<span class="op">);</span></span></code></pre></div>
<h3 id="processing-the-columns-of-a-multidimensional-array">12.4.3
Processing the Columns of a Multidimensional Array</h3>
<p>Processing the elements in a <em>column</em> of a two-dimensional
array isn’t as easy, because arrays are stored by row, not by column.
Here’s a loop that clears column 1 of the array a:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>NUM_ROWS<span class="op">][</span>NUM_COLS<span class="op">],</span> <span class="op">(*</span>p<span class="op">)</span> <span class="op">[</span>NUM_COLS<span class="op">],</span> i<span class="op">;</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span> p <span class="op">&lt;</span> <span class="op">&amp;</span>a<span class="op">[</span>NUM_ROWS<span class="op">];</span> p<span class="op">++)</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*</span>p<span class="op">)[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>I’ve declared <code>p</code> to be a pointer to an array of length
<code>NUM_COLS</code> whose elements are integers. The parentheses
around <code>*p</code> in <code>(*p)[NUM_COLS]</code> are required;
without them, the compiler would treat <code>p</code> as an <em>array of
pointers instead of a pointer to an array</em>. The expression
<code>p++</code> advances <code>p</code> to the beginning of the next
row. In the expression <code>(*p)[1]</code>, <code>*p</code> represents
an entire row of <code>a</code>, so <code>(*p)[i]</code> selects the
element in column <code>i</code> of that row. The parentheses in
<code>(*p)[1]</code> are essential, because the compiler would interpret
<code>*p[i]</code> as <code>*(p[i])</code>.</p>
<h3 id="using-the-name-of-a-multidimensional-array-as-a-pointer">12.4.4
Using the Name of a Multidimensional Array as a Pointer</h3>
<p>Just as the name of a one-dimensional array can be used as a pointer,
so can the name of any array, regardless of how many dimensions it has.
Some care is required, though. Consider the following array:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>NUM_ROWS<span class="op">][</span>NUM_COLS<span class="op">];</span></span></code></pre></div>
<p><code>a</code> is not a pointer to <code>a[0][0]</code>; instead,
it’s a pointer to <code>a[0]</code>. This makes more sense if we look at
it from the standpoint of C. which regards <code>a</code> not as a
two-dimensional array but as a one-dimensional array whose elements are
one dimensional arrays. When used as a pointer, <code>a</code> has type
<code>int(*)[NUM_COLS]</code> (pointer to an integer array of length
<code>NUM_COLS</code>).</p>
<p>Knowing that <code>a</code> points to <code>a[0]</code> is useful for
simplifying loops that process the elements of a two-dimensional array.
For example, instead of writing</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span> p <span class="op">&lt;</span> <span class="op">&amp;</span>a<span class="op">[</span>NUM_ROWS<span class="op">];</span> p<span class="op">++)</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*</span>p<span class="op">)[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>to clear column 1 of the array <code>a</code>, we can write</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>p <span class="op">=</span> a<span class="op">;</span> p <span class="op">&lt;</span> a <span class="op">+</span> NUM_ROWS<span class="op">;</span> p<span class="op">++)</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*</span>p<span class="op">)[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>Another situation in which this knowledge comes in handy is when we
want to “trick” a function into thinking that a multidimensional array
is really one-dimensional. For example, consider how we might use
<code>find_largest</code> to find the largest element in <code>a</code>.
As the first argument to <code>find_largest</code>, let’s try passing
<code>a</code> (the address of the array); as the second, we’ll pass
<code>NUM_ROWS * NUM_COLS</code> (the total number of elements in
<code>a</code>):</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>largest <span class="op">=</span> find_largest<span class="op">(</span>a<span class="op">,</span> NUM_ROWS <span class="op">*</span> NUM_COLS<span class="op">);</span> <span class="co">/* WRONG */</span></span></code></pre></div>
<p>Unfortunately, the compiler will object to this statement, because
the type of <code>a</code> is <code>int(*)[NUM_COLS]</code> but
<code>find_largest</code> is expecting an argument of type
<code>int *</code>. The correct call is</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>largest <span class="op">=</span> find_largest<span class="op">(</span>a<span class="op">[</span><span class="dv">0</span><span class="op">],</span> NUM_ROWS <span class="op">*</span> NUM_COLS<span class="op">);</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p><code>a[0]</code> points to element 0 in row 0, and it has type
<code>int *</code> (after conversion by the compiler), so the latter
call will work correctly.</p>
<h2 id="pointers-and-variable-length-arrays-c99">12.5 Pointers and
Variable-Length Arrays (C99)</h2>
<p>Pointers are allowed to point to elements of variable-length arrays
(VLAs), a feature of C99. An ordinary pointer variable would be used to
point to an element of a one-dimensional VLA:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span>n<span class="op">],</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When the VLA has more than one dimension, the type of the pointer
depends on the length of each dimension except for the first. Let’s look
at the two-dimensional case:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span>m<span class="op">][</span>n<span class="op">],</span> <span class="op">(*</span>p<span class="op">)[</span>n<span class="op">];</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Since the type of <code>p</code> depends on <code>n</code>, which
isn’t constant, <code>p</code> is said to have a variably modified type.
Note that the validity of an assignment such as <code>p = a</code> can’t
always be determined by the compiler. For example, the following code
will compile but is correct only if <code>m</code> and 1 are equal:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>m<span class="op">][</span>n<span class="op">],</span> <span class="op">(*</span>p<span class="op">)[</span>m<span class="op">];</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> a<span class="op">;</span></span></code></pre></div>
<p>If m<span class="unicode_NOT_EQUAL_TO"></span>n, any subsequent use
of <code>p</code> will cause undefined behavior.</p>
<p>Variably modified types are subject to certain restrictions, just as
variable-length arrays are. The most important restriction is that the
declaration of a variably modified type must be inside the body of a
function or in a function prototype.</p>
<p>Pointer arithmetic works with VLAs just as it does for ordinary
arrays. Returning to the example of Section 12.4 that clears a single
column of a two-dimensional array <code>a</code>, let’s declare
<code>a</code> as a VLA this time:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span></code></pre></div>
<p>A pointer capable of pointing to a row of <code>a</code> would be
declared as follows:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">(*</span>p<span class="op">)[</span>n<span class="op">];</span></span></code></pre></div>
<p>The loop that clears column <code>i</code> is almost identical to the
one we used in Section</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>p <span class="op">=</span> a<span class="op">;</span> p <span class="op">&lt;</span> a <span class="op">+</span> m<span class="op">;</span> p<span class="op">++)</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">(*</span>p<span class="op">)[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<h2 id="qa">Q&amp;A</h2>
<!-- START: div -->
<div class="QandA_question">
<p><span class="ques"></span>I don’t understand pointer arithmetic. If a
pointer is an address, does that mean that an expression like
<code>p + j</code> adds <code>j</code> to the address stored in
<code>p</code>?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="ans"></span>No. Integers used in pointer arithmetic are
scaled depending on the type of the pointer. If <code>p</code> is of
type <code>int *</code>, for example, then <code>p + j</code> typically
adds 4x<code>j</code> to <code>p</code>, assuming that <code>int</code>
values are stored using 4 bytes. But if <code>p</code> has type
<code>double *</code>, then <code>p + j</code> will probably add 8 x
<code>j</code> to <code>p</code>, since <code>double</code> values are
usually 8 bytes long.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p><span class="ques"></span>When writing a loop to process an array, is
it better to use array subscripting or pointer arithmetic?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="ans"></span>There’s no easy answer to this question,
since it depends on the machine you’re using and the compiler itself. In
the early days of C on the PDP-11, pointer arithmetic yielded a faster
program. On today’s machines, using today’s compilers, array
subseripting is often just as good, and sometimes even better. The
bottom line: Learn both ways and then use whichever is more natural for
the kind of program you’re writing.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p><span class="ques"></span>I read somewhere that <code>i[a]</code> is
the same as <code>a[i]</code>. Is this true?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="ans"></span>Yes, it is, oddly enough. The compiler
treats <code>i[a]</code> as <code>*(i + a)</code>, which is the same as
<code>*(a + 1)</code>. (Pointer addition, like ordinary addition, is
commutative.) But <code>*(a + 1)</code> is equivalent to
<code>a[i]</code>. Q.E.D. But please don’t use <code>i[a]</code> in
programs unless you’re planning to enter the next Obfuscated C
contest.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p><span class="ques"></span>Why is <code>*a</code> the same as
<code>a[]</code> in a parameter declaration?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="ans"></span>Both indicate that the argument is expected
to be a pointer. The same operations on <code>a</code> are possible in
both cases (pointer arithmetic and array subscripting, in particular).
And, in both cases, <code>a</code> itself can be assigned a new value
within the function. (Although C allows us to use the name of an array
variable only as a “constant pointer,” there’s no such restriction on
the name of an array parameter.)</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p><span class="ques"></span>Is it better style to declare an array
parameter as <code>*a</code> or <code>a[]</code>?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="ans"></span>That’s a tough one. From one standpoint,
<code>a[]</code> is the obvious choice, since <code>*a</code> is
ambiguous (does the function want an array of objects or a pointer to a
single object?). On the other hand, many programmers argue that
declaring the parameter as <code>*a</code> is more accurate, since it
reminds us that only a pointer is passed, not a copy of the array.
Others switch between <code>*a</code> and <code>a[]</code>, depending on
whether the function uses pointer arithmetic or subscripting to access
the elements of the array. (That’s the approach I’ll use.) In practice,
<code>*a</code> is more common than <code>a[]</code>, so you’d better
get used to it. For what it’s worth, Dennis Ritchie now refers to the
<code>a[]</code> notation as “a living fossil” that “serves as much to
confuse the learner as to alert the reader.”</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p><span class="ques"></span>We’ve seen that arrays and pointers are
closely related in C. Would it be accurate to say that they’re
interchangeable?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="ans"></span>No. It’s true that array <em>parameters</em>
are interchangeable with pointer parameters, but array
<em>variables</em> aren’t the same as pointer variables. Technically,
the name of an array isn’t a pointer; rather, the C compiler converts it
to a pointer when necessary. To see this difference more clearly,
consider what happens when we apply the <code>sizeof</code> operator to
an array <code>a</code>. The value of <code>sizeof(a)</code> is the
total number of bytes in the array—the size of each element multiplied
by the number of elements. But if <code>p</code> is a pointer variable,
<code>sizeof(p)</code> is the number of bytes required to store a
pointer value.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p><span class="ques"></span>You said that treating a two-dimensional
array as one-dimensional works with “most” C compilers. Doesn’t it work
with all compilers?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>No. Some modern “bounds-checking” compilers track not only the type
of a pointer, but—when it points to an array—also the length of the
array. For example, suppose that <code>p</code> is assigned a pointer to
<code>a[0][0]</code>. Technically, <code>p</code> points to the first
element of <code>a[0]</code>, a one-dimensional array. If we increment
<code>p</code> repeatedly in an effort to visit all the elements of
<code>a</code>, we’ll go out of bounds once <code>p</code> goes past the
last element of <code>a[0]</code>. A compiler that performs
bounds-checking may insert code to check that <code>p</code> is used
only to access elements in the array pointed to by <code>a[0]</code>; an
attempt to increment <code>p</code> past the end of this array would be
detected as an error.</p>
<p><span class="ans"></span></p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p><span class="ques"></span>If <code>a</code> is a two-dimensional
array, why can we pass <code>a[0]</code>—but not <code>a</code>
itself—to <code>find_largest</code>? Don’t both <code>a</code> and
<code>a[0]</code> point to the same place (the beginning of the
array)?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="ans"></span>They do, as a matter of fact—both point to
element <code>a[0][0]</code>. The problem is that <code>a</code> has the
wrong type. When used as an argument, it’s a pointer to an array, but
<code>find_largest</code> is expecting a pointer to an integer. However,
<code>a[0]</code> has type <code>int *</code>, so it’s an acceptable
argument for <code>find_largest</code>. This concern about types is
actually good: if C weren’t so picky, we could make all kinds of
horrible pointer mistakes without the compiler noticing.</p>
</div>
<!-- END: div -->
<hr />
<h2 id="examples">Examples</h2>
<ul>
<li>Programs: <span class="unicode_LINK_SYMBOL"></span><a
href="./cknkCh12/cknkCh12Exmp/">./cknkCh12/cknkCh12Exmp/</a></li>
</ul>
<h2 id="exercises">Exercises</h2>
<ul>
<li>Readme: <span class="unicode_LINK_SYMBOL"></span><a
href="./cknkCh12/cknkCh12Exrc/README.md">./cknkCh12/cknkCh12Exrc/README.md</a><br />
</li>
<li>Readme (html): <span class="unicode_LINK_SYMBOL"></span><a
href="./cknkCh12/cknkCh12Exrc/cknkCh12ExrcReadme.html">./cknkCh12/cknkCh12Exrc/cknkCh12ExrcReadme.html</a><br />
</li>
<li>Programs: <span class="unicode_LINK_SYMBOL"></span><a
href="./cknkCh12/cknkCh12Exrc/">./cknkCh12/cknkCh12Exrc/</a></li>
</ul>
<h2 id="programming-projects">Programming Projects</h2>
<ul>
<li>Readme: <span class="unicode_LINK_SYMBOL"></span><a
href="./cknkCh12/cknkCh12Prj/README.md">./cknkCh12/cknkCh12Prj/README.md</a><br />
</li>
<li>Readme: <span class="unicode_LINK_SYMBOL"></span><a
href="./cknkCh12/cknkCh12Prj/cknkCh12PrjReadme.html">./cknkCh12/cknkCh12Prj/cknkCh12PrjReadme.html</a><br />
</li>
<li>Programs: <span class="unicode_LINK_SYMBOL"></span><a
href="./cknkCh12/cknkCh12Prj/">./cknkCh12/cknkCh12Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
</body>
</html>
