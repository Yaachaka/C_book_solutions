==========================================================================
@@@@ Exercise 13 (Section 17.5): knkcch17e13: The following function is supposed 
to insert a new node into its proper place in an ordered list, returning a 
pointer to the first node in the modified list. Unfortunately, the function 
doesn’t work correctly in all cases. Explain what’s wrong with it and show how 
to fix it. Assume that the node structure is the one defined in Section 17.5.

	struct node *insert_into_ordered_list(struct node *list,struct node *new_node)
	{
		struct node *cur = list, *prev = NULL;
		while (cur->value <= new_node->value) {
			prev = cur;
			cur = cur->next;
		}
		prev->next = new_node;
		new_node->next = cur;
		return list;
	}
==========================================================================
SOLUTION:
@@@@ Check PROGRAM OUTPUT.
==========================================================================
PROGRAM: (FLAGS: -std=c99): knkcch17e13.c
#include <stdio.h>
#include <stdlib.h>  //NULL
//---------------------------------------------------------------------------
struct node
{
	int value;
	struct node *next;
};
//---------------------------------------------------------------------------
struct node *insert_into_ordered_list(struct node *list,struct node *new_node);
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//------------------------START OF MAIN()--------------------------------------
int main(void)
{
	printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	printf("File: %s, C Version: %d, Date: %s, Time: %s\n\n", __FILE__, __STDC_VERSION__, __DATE__, __TIME__);



	printf("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	return 0;
}
//-------------------------END OF MAIN()---------------------------------------
struct node *insert_into_ordered_list(struct node *list, struct node *new_node)
{
	struct node *cur = list, *prev = NULL;
	while (cur->value <= new_node->value && cur)
	{
		prev = cur;
		cur = cur->next;
	}
	if(!cur)
		cur=new_node;
	else
	{
		prev->next = new_node;
		new_node->next = cur;
	}
	return list;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
==========================================================================
PROGRAM OUTPUT: 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
File: knkcch17e13.c, C Version: 199901, Date: Mar 16 2021, Time: 22:08:16


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
==========================================================================