<html>
<head>
<title>
C Programming
</title>
<meta charset="utf-8">
<link rel="stylesheet" href="./myStyle.css">
</head>
<body>
<h1 id="title-of-the-book-c-programming-a-modern-approach">Title of the
Book: C Programming A Modern Approach</h1>
<h2 id="edition-second-edition-2008">Edition: Second Edition (2008)</h2>
<h3 id="author-k.n.king">Author: K.N.King</h3>
<p><i>A clear, complete, and engaging presentation of the C programming
language – now with coverage of both C89 and C99.</i></p>
<div class="theQuote">
In computing, turning the obvious into the useful is a living definition
of the word “frustration.”
</div>
<hr class="chapterDivider"/>
<h1 id="introducing-c">1 Introducing C</h1>
<div class="theQuote">
When someone says “I want a programming language in which I need only
say what I wish done,” give him a lollipop.
</div>
<p><strong>Few points on C:</strong><br />
- Developed in the early 1970s at Bell Laboratories by <strong>Ken
Thompson</strong>, <strong>Dennis Ritchie</strong>, and others.<br />
- <em>The C Programming Language</em>, written by <strong>Brian
Kernighan</strong> and <strong>Dennis Ritchie</strong> published in
1978.<br />
- In December 1989, standardisation of C under <em>ANSI (American
National Standards Institute)</em> was approved as <em>ANSI standard
X3.159-1989</em>.<br />
- In 1990, it was approved by the <em>International Organization for
Standardization (ISO)</em> as <em>internation standard ISO/IEC
9899:1990</em>.</p>
<hr class="chapterDivider"/>
<h1 id="c-fundamentals">2 C Fundamentals</h1>
<div class="theQuote">
One man’s constant is another man’s variable
</div>
<p>This chapter introduces several basic concepts, including
preprocessing directives, functions, variables, and statements, that
we’ll need in order to write even the simplest programs. Later chapters
will cover these topics in much greater detail.</p>
<p>To start off, Section 2.1 presents a small C program and describes
how to compile and link it. Section 2.2 then discusses how to generalize
the program, and Section 2.3 shows how to add explantory remarks, known
as comments. Section 2.4 introduces variables, which store data that may
change during the execution of a program, and Section 2.5 shows how to
use the <code>scanf</code> function to read data into variables.
Constants – data that won’t change during program execution – can be
given names, as Section 2.6 shows. Finally, Section 2.7 explains C’s
rules for creating names (identifiers) and Section 2.8 gives the rules
for laying out a program.</p>
<h2 id="writing-a-simple-program">2.1 Writing a Simple Program</h2>
<p>In contrast to programs written in some languages, C programs require
little “boilerplate” – a complete program can be as short as a few
lines.</p>
<h3 id="program-printing-a-pun">2.1.1 (PROGRAM) Printing a Pun</h3>
<p>The first program which we will name <code>pun.c</code>, is expected
to display the following message each time it is run.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">To</span> C, or not to C: that is the question.</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: pun.c */</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Section 2.2 explains the form of this program in some detail. For
now, I’ll just make a few brief observations. The line</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span></code></pre></div>
<p>is necessary to “include” information about C’s standard I/O
(input/output) library. The program’s executable code goes inside
<code>main</code>, which represents the “main” program. The only line
inside <code>main</code> is a command to display the desired message.
<code>printf</code> is a function from the standard I/O library that can
produce nicely formatted output. The <code>\n</code> code tells
<code>printf</code> to advance to the next line after printing the
message. The line</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>indicates that the program “returns” the value 0 to the operating
system when it terminates.</p>
<h3 id="compiling-and-linking">2.1.2 Compiling and Linking</h3>
<p>Despite its brevity, getting <code>pun.c</code> to run is more
involved than you might expect. First, we need to create a file named
<code>pun.c</code> containing the program (any text editor will do). The
name of the file doesn’t matter, but the <code>.c</code> extension is
often required by compilers.</p>
<p>Next, we’ve got to convert the program to a form that the machine can
execute. For a C program, that usually involves three steps:</p>
<ul>
<li><strong>Preprocessing.</strong> The program is first given to a
<strong>preprocessor</strong>, which obeys commands that begin with
<code>#</code> (known as <strong><em>directives</em></strong>). A
preprocessor is a bit like an editor; it can add things to the program
and make modifications.<br />
</li>
<li><strong>Compiling.</strong> The modified program now goes to a
<strong>Compiler</strong>. which translates it into machine instructions
(<strong><em>object code</em></strong>). The program isn’t quite ready
to run yet, however.<br />
</li>
<li><strong>Linking.</strong> In the final step, a
<strong>linker</strong> combines the object code produced by the
compiler with any additional code needed to yield a complete executable
program. This additional code includes library functions (like
<code>printf</code>) that are used in the program.</li>
</ul>
<p>Fortunately, this process is often automated, so you won’t find it
too onerous. In fact, the preprocessor is usually integrated with the
compiler, so you probably won’t even notice it at work.</p>
<p>The commands necessary to compile and link vary, depending on the
compiler and operating system. Under UNIX, the C compiler is usually
named <code>cc</code>. To compile and link the <code>pun.c</code>
program, enter the following command in a terminal or command-line
window:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> cc pun.c</span></code></pre></div>
<p>(The <code>%</code> character is the UNIX prompt, not something that
you need to enter.) Linking is automatic when using <code>cc</code>; no
separate link command is necessary.</p>
<p>After compiling and linking the program, <code>cc</code> leaves the
executable program in a file named <code>a.out</code> by default.
<code>cc</code> has many options; one of them (the <code>-o</code>
option) allows us to choose the name of the file containing the
executable program. For example, if we want the executable version of
<code>pun.c</code> to be named <code>pun</code>, we would enter the
following command:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> cc <span class="at">-o</span> pun pun.c</span></code></pre></div>
<section id="the-gcc-compiler" class="infoBox">
<h3>The GCC Compiler</h3>
<p>One of the most popular C compilers is the GCC compiler, which is
supplied with Linux but is available for many other platforms as well.
Using this compiler is similar to using the traditional UNIX
<code>cc</code> compiler. For example, to compile the <code>pun.c</code>
program, we would use the following command:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> gcc <span class="at">-o</span> pun pun.c</span></code></pre></div>
<p>The Q&amp;A section at the end of the chapter provides more
information about GCC.</p>
</section>
<h3 id="integrated-development-environments">2.1.3 Integrated
development environments</h3>
<p>so far, we’ve assumed the use of a “command-line” compiler that’s
invoked by entering a command in a special window provided by the
operating system. The alternative is to use an <strong><em>integrated
development environment (IDE)</em></strong>, a software package that
allows us to
<code>edit, compile, link, execute, and even debug a program</code>
without leaving the environment. The components of an IDE are designed
to work together. For example, when the compiler detects an error in a
program, it can arrange for the editor to highlight the line that
contains the error. There’s a great deal of variation among IDEs, so I
won’t discuss them further in this book. However, I would recommend
checking to see which IDEs are available for your platform.</p>
<h2 id="the-general-form-of-a-simple-program">2.2 The General Form of a
Simple Program</h2>
<p>Let’s take a closer look at <code>pun.c</code> and see how we can
generalize it a bit. Simple C programs have the form</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>directives</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    statements</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice how the braces show where <code>main</code> begins and ends. C
uses <code>{</code> and <code>}</code> in much the same way that some
other languages use words like <code>begin</code> and <code>end</code>.
This illustrates a general point about C: it relies heavily on
abbreviations and special symbols, one reason that C programs are
concise (or – less charitably – cryptic).</p>
<p>Even the simplest C programs rely on three key language features:
directives (editing commands that modify the program prior to
compilation), functions (named blocks of executable code, of which
<code>main</code> is an example), and statements (commands to be
performed when the program is run). We’ll take a closer look at these
features now.</p>
<h3 id="directives">2.2.1 Directives</h3>
<p>Before a C program is compiled, it is first edited by a preprocessor.
Commands intended for the preprocessor are called directives. Chapter 14
and Chapter 15 discuss directives in detail. For now, we’re interested
only in the <code>#include</code> directive.</p>
<p>The <code>pun.c</code> program begins with the line</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span></code></pre></div>
<p>This directive states that the information is
<code>&lt;stdio.h&gt;</code> is to be “included” into the program before
it is compiled. <code>&lt;stdio.h&gt;</code> contains information about
C’s standard I/O library. C has a number of <em>headers</em> like
<code>&lt;stdio.h&gt;</code>; each contains information about some part
of the standard library. The reason we’re including
<code>&lt;stdio.h&gt;</code> is that C, unlike some programming
languages, has no built-in “read” and “write” commands. The ability to
perform input and output is provided instead by functions in the
standard library.</p>
<p>Directives always begin with <code>#</code> character, which
distinguishes them from other items in a C program. By default,
directives are one line long; there’s no semicolon or other special
marker at the end of a directive.</p>
<h3 id="functions">2.2.2 Functions</h3>
<p><strong>Functions</strong> are like “procedures” or “subroutines” in
other programming languages – they’re the building blocks from which
programs are constructed. In fact, a C program is little more than a
collection of functions. Functions fall into two categories: those
written by the programmer and those provided as part of the c
implementation. I’ll refer to the latter as <em>library functions</em>,
since they belong to a “library” of functions that are supplied with the
compiler.</p>
<p>The term “function” comes from mathematics, where a function is a
rule for computing a value when given one or more arguments:</p>
<p><span
class="math display"><em>f</em>(<em>x</em>) = <em>x</em> + 1</span></p>
<p><span
class="math display"><em>g</em>(<em>y</em>,<em>z</em>) = <em>y</em><sup>2</sup> − <em>z</em><sup>2</sup></span></p>
<p>C uses the term “function” more loosely. In C, a function is simply a
series of statements that have been grouped together and given a name.
Some functions compute a value; some don’t. A function that computes a
value uses the <code>return</code> statement to specify what value it
“returns.” For example, a function that adds 1 to its argument might
execute the statement <code>return x + 1;</code> while a function that
computes the difference of the squares of its arguments might execute
the statement <code>return y * y - z * z;</code></p>
<p>Although a C program may consist of many functions, only the
<code>main</code> function is mandatory. <code>main</code> is special:
it gets called automatically when the program is executed. Until Chapter
9, where we’ll learn how to write other functions, <code>main</code>
will be the only function in our programs.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>The name <code>main</code> is critical; it can’t be
<code>begin</code> or <code>start</code> or even <code>MAIN</code>.</p>
</div>
<p>If <code>main</code> is a function, does it return a value? Yes: it
returns a status code that is given to the operating system when the
program terminates. Let’s take another look at the <code>pun.c</code>
program:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The word <code>int</code> just before <code>main</code> indicates
that the <code>main</code> function returns an integer value. The word
<code>void</code> in parenthesis indicates that <code>mian</code> has no
arguments.</p>
<p>The statement <code>return 0;</code> has two effects: it causes the
main function to terminate (thus ending the program) and it indicates
that the <code>main</code> function returns a value of 0. We will have
more to say about <code>main</code>’s return value in a later chapter.
For now, we’ll always have <code>main</code> return the value 0, which
indicates normal program termination.</p>
<p>If there’s no <code>return</code> statement at the end of the
<code>main</code> function, the program will still terminate. However,
many compilers will produce a warning message (because the function was
supposed to return an integer but failed to).</p>
<h3 id="statements">2.2.3 Statements</h3>
<p>A <strong>Statement</strong> is a command to be executed when the
program runs. We’ll explore statements later in the book, primarily in
Chpater 5 and 6. The <code>pun.c</code> program uses only two kinds of
statements. One is the <code>return</code> statement; the other is the
<em>function call</em>. Asking a function to perform its assigned task
is known as <em>calling</em> the function. The <code>pun.c</code>
program, for example, calls the <code>printf</code> function to display
a string on the screen:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question. </span><span class="sc">\n</span><span class="st">);</span></span></code></pre></div>
<p>C requires that each statement end with a semicolon. (As with any
good rule, there’s one exception: the compound statement, which we’ll
encounter later.) The semicolon shows the compiler where the statement
ends; since statements can continue over several lines, it’s not always
obvious where they end. Directives, on the other hand, are normally one
line long, and they don’t end with a semicolon.</p>
<h3 id="printing-strings">2.2.4 Printing Strings</h3>
<p><code>printf</code> is a powerful function that we’ll examine in
Chapter 3. So far, we’ve only used <code>printf</code> to display a
<strong>string literal</strong> – a series of characters enclosed in
double quotation marks. When <code>printf</code> displays a string
literal, it doesn’t show the quotation marks.</p>
<p><code>printf</code> doesn’t automatically advance to the next output
line when it finishes printing. To instruct <code>printf</code> to
advance one line, we must include <code>\n</code> (the <em>new-line
character</em>) in the string to be printed. Writing a new-line
character terminates the current output line; subsequent output goes on
to the next line. to illustrate this point, consider the effect of
replacing the statement</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>by two calls of <code>printf</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: &quot;</span><span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>The first call of <code>printf</code> writes
<code>To C, or not to C:</code>. The second call writes
<code>that is the question.</code> and advances to the next line. The
net effect is the same as the original <code>printf</code> – the user
can’t tell the difference.</p>
<p>The new-line character can appear more than once in a string literal.
To display the message</p>
<pre><code>Brevity is the soul of wit.
  --Shakespeare</code></pre>
<p>we could write</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Brevity is the soul of wit.</span><span class="sc">\n</span><span class="st">  --Shakespeare</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<h2 id="comments">2.3 Comments</h2>
<p>Our <code>pun.c</code> program still lacks something important:
documentation. Every program should contain identifying information: the
program name, the date written, the author, the purpose of the program,
and so forth. In C, this information is placed in
<strong><em>Comments</em></strong>. The symbol <code>/*</code> marks the
beginning of a comment and the symbol <code>*/</code> marks the end:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* This is a comment */</span></span></code></pre></div>
<p>Comments may appear almost anywhere in a program, either on separate
lines or on the same lines as other program text. Here’s what
<code>pun.c</code> might look like with comments added at the
beginning:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c */</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* Purpose: Prints a bad pun. */</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* Author: K. N. King */</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Comments may extend over more than one line; once it has seen the
<code>/*</code> symbol, the compiler reads (and ignores) whatever
follows until it encounters the <code>*/</code> symbol. If we like, we
can combine a series of short comments into one long comment:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">   Purpose: Prints a bad pun.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">   Author: K. N. King */</span></span></code></pre></div>
<p>A comment like this can be hard to read, though, because it’s not
easy to see where the comment ends. Putting <code>*/</code> on a line by
itself helps:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">   Purpose: Prints a bad pun.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">   Author: K. N. King </span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span></code></pre></div>
<p>Even better, we can form a “box” around the comment to make it stand
out:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">/************************************************************ </span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">* Name: pun.c                                               *</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">* Purpose: Prints a bad pun.                                *</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">* Author: K. N. King                                        *</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">************************************************************/</span></span></code></pre></div>
<p>Programmers often simplify boxed comments by omitting three of the
sides:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Name: pun.c</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a bad pun.</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span></code></pre></div>
<p>A short comment can go on the same line with other program code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span>    <span class="co">/* Beginning of main program */</span></span></code></pre></div>
<p>A comment like this is sometimes called a “winged comment”.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Forgetting to terminate a comment may cause the compiler to ignore
part of your program. Consider the following example:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;My &quot;</span><span class="op">);</span>    <span class="co">/* forgot to close this comment...</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">printf(&quot;cat &quot;);</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">printf(&quot;has &quot;);    /* so it ends here */</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;fleas&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Because we have neglected to terminate the first comment, the
compiler ignores the middle two statements, and the example prints
<code>My fleas</code>.</p>
</div>
<p><span class="C99Symbol"></span></p>
<p>C99 provides a second kind of comment, which begins with
<code>//</code> (two adjacent slashes):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a comment</span></span></code></pre></div>
<p>This style of comment ends automatically at the end of a line. To
create a commet that’s more than one line long, we can either use the
older comment style (<code>/* ... */</code>) or else put <code>//</code>
at the beginning of each comment line:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Name: pun.c</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Purpose: Prints a bad pun.</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Author: K. N. King</span></span></code></pre></div>
<p>The newer comment style has a couple of important advantages. First,
because a comment automatically ends at the end of a line, there’s no
chance that an unterminated comment will accidentally consume part of a
program. Second, multiline comments stand out better, thanks to the
<code>//</code> that’s required at the beginning of each line.</p>
<h2 id="variables-and-assignment">2.4 Variables and Assignment</h2>
<p>Few programs are as simple as the one in Section 2.1. Most programs
need to perform a series of calculations before producing output, and
thus need a way to store data temporarily during program execution. In
C, as in most programming languages, these storage locations are called
<strong>variables</strong>.</p>
<h3 id="types">2.4.1 Types</h3>
<p>Every variable must have a <strong><em>type</em></strong>, which
specifies what kind of data it will hold. C has a wide variety of types.
For now, we’ll limit ourselves to just two: <code>int</code> and
<code>float</code>. Choosing the proper type is critical, since the type
affects how the variable is stored and what operations can be performed
on the variable. The type of a numeric variable determines the largest
and smallest numbers that the variable can store; it also determines
whether or not digits are allowed after the decimal point.</p>
<p>A variable of type <code>int</code> (short for <em>integer</em>) can
store a whole number such as 0, 1, 392, or -2553. The range of possible
values is limited, though. The largest <code>int</code> value is
typically 2,147,483,647 but can be as small as 32,767.</p>
<p><span class="QandA"></span></p>
<p>A variable of type <code>float</code> (short for
<em>floating-point</em>) can store much larger numbers than an
<code>int</code> variable. Furthermore, a <code>float</code> variable
can store numbers with digits after the decimal point, like 379.125.
<code>float</code> variables have drawbacks, however. Arithmetic on
<code>float</code> numbers may be slower than arithmetic on
<code>int</code> numbers. Most significantly, the value of a
<code>float</code> variable is often just an approximation of the number
that was stored in it. If we store 0.1 in a <code>float</code> variable,
we may later find that the variable has a value such as
0.09999999999999987, thanks to rounding error.</p>
<h3 id="declarations">2.4.2 Declarations</h3>
<p>Variables must be <strong>declared</strong>–described for the benefit
of the compiler–before they can be used. To declare a variable, we first
specify the <em>type</em> of the variable, then its <em>name</em>.
(Variable names are chosen by the programmer, subject to the rules
described in Section 2.7.) For example, we might declare variables
<code>height</code> and <code>profit</code> as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> profit<span class="op">;</span></span></code></pre></div>
<p>The first declaration states that <code>height</code> is a variable
of type <code>int</code>, meaning that <code>height</code> can store an
integer value. The second declaration says that <code>profit</code> is a
variable of type <code>float</code>.</p>
<p>If several variables have the same type, their declarations can be
combined:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> profit<span class="op">,</span> loss<span class="op">;</span></span></code></pre></div>
<p>Notice that each complete declaration ends with a semicolon. Ou Our
first template for <code>main</code> didn’t include declarations. When
<code>main</code> contains declarations, these must precede
statements:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    declarations</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    statements</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As we’ll see in Chapter 9, this is true of functions in general, as
well as blocks (statements that contain embedded declarations). As a
matter of style, it’s a good idea to leave a blank line between the
declarations and the statements.</p>
<p><span class="C99Symbol"></span></p>
<p>In C99, declarations don’t have to come before statements. For,
example, <code>main</code> might contain a declaration, then a
statement, and then another declaration. For compatibility with older
compilers, the programs in this book don’t take advantage of this rule.
However, it’s common in C++ and Java programs not to declare variables
until they’re first needed, so this practice can be expected to become
popular in C99 programs as well.</p>
<h3 id="assignment">2.4.3 Assignment</h3>
<p>A variable can be given a value by means of
<strong><em>assignment</em></strong>. For example, the statements</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<p>assign values to <code>height</code>, <code>length</code>, and
<code>width</code>. The numbers 8, 12, and 10 are said to be
<strong><em>constants</em></strong>.</p>
<p>Before a variable can be assigned a value–or used in any other way,
for that matter–it must first be declared. Thus, we could write</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span></code></pre></div>
<p>but not</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span></code></pre></div>
<p>A constant assigned to a <code>float</code> variable usually contains
a decimal point. For example, if <code>profit</code> is a
<code>float</code> variable, we might write</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>profit <span class="op">=</span> <span class="fl">2150.48</span><span class="op">;</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>It’s best to append the letter <code>f</code> (for “float”) to a
constant that contains a decimal point if the number is assigned to a
<code>float</code> variable:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>profit <span class="op">=</span> <span class="fl">2150.48</span><span class="bu">f</span><span class="op">;</span></span></code></pre></div>
<p>Failing to include the <code>f</code> may cause a warning from the
compiler.</p>
<p>An <code>int</code> variable is normally assigned a value of type
<code>int</code>, and a <code>float</code> variable is normally assigned
a value of type <code>float</code>. Mixing types (such as assigning an
<code>int</code> value to a <code>float</code> variable or assigning a
<code>float</code> value to an <code>int</code> variable) is possible
but not always safe, as we’ll see in Section 4.2.</p>
<p>Once a variable has been assigned a value, it can be used to help
compute the value of another variable:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span>    <span class="co">/* volume is now 960 */</span></span></code></pre></div>
<p>In C, <code>*</code> represents the multiplication operator, so this
statement multiplies the values stored in <code>height</code>,
<code>length</code>, and <code>width</code>, then assigns the result to
the variable <code>volume</code>. In general, the right side of an
assignment can be a formula (or <strong><em>expression</em></strong>, in
C terminology) involving constants, variables, and operators.</p>
<h3 id="printing-the-value-of-a-variable">2.4.4 Printing the Value of a
Variable</h3>
<p>We can use <code>printf</code> to display the current value of a
variable. For example, to write the message</p>
<pre class="shell"><code>Height: h</code></pre>
<p>where <code>h</code> is the current value of the <code>height</code>
variable, we’d use the following call of <code>printf</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">);</span></span></code></pre></div>
<p><code>%d</code> is a placeholder indicating where the value of
<code>height</code> is to be filled in during printing. Note the
placement of <code>\n</code> just after <code>%d</code>, so that
<code>printf</code> will advance to the next line after printing the
value of <code>height</code>.</p>
<p><code>%d</code> works only for <code>int</code> variables; to print a
<code>float</code> variable, we’d use <code>%f</code> instead. By
default, <code>%f</code> displays a number with six digits after the
decimal point. To force <code>%f</code> to display <code>p</code> digits
after the decimal point, we can put <code>.p</code> between
<code>%</code> and <code>f</code>. For example, to print the line</p>
<pre class="shell"><code>Profit: $2150.48</code></pre>
<p>we’d call <code>printf</code> as follows:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Profit: $%.2f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> profit<span class="op">);</span></span></code></pre></div>
<p>There’s no limit to the number of variables that can be printed a
single call of <code>printf</code>. To display the values of both the
<code>height</code> and <code>length</code> variables, we could use the
following call of <code>printf</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d  Length: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">,</span> length<span class="op">);</span></span></code></pre></div>
<h3 id="program-computing-the-dimensional-weight-of-a-box">2.4.5
(PROGRAM) Computing the Dimensional Weight of a Box</h3>
<p>Shipping companies don’e especially like boxes that are larger but
very light, since they take up valuable space in a truck or airplane. In
fact, companies often charge extra for such a box, basing the fee on its
volume instead of its weight. In the United States, the usual method is
to divide the volume by 166 (the allowable number of cubic inches per
pound). If this number–the box’s “dimensional” or “volumetric”
weight–exceeds its actual weight, the shipping fee is based on the
dimensional weight. (The 166 divisor is for international shipments; the
dimensional weight of a domestic shipment is typically calculated using
194 instead).</p>
<p>Let’s say that you’ve been hired by a shipping company to write a
program that computes the dimensional weight of a box. Since you’re new
to C, you decide to start off by writing a program that calculates the
dimensional weight of a particular box that’s
<code>12" x 10" x 8"</code>. Division is represented by <code>/</code>
in C, so the obvious way to compute the dimensional weight would be</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> volume <span class="op">/</span> <span class="dv">166</span></span></code></pre></div>
<p>where <code>weight</code> and <code>volume</code> are integer
variables representing the box’s weight and volume. Unfortunately, this
formula isn’t quite what we need. In C, when one integer is divided by
another, the answer is “truncated”: all digits after the decimal point
are lost. The volume of a <code>12" x 10" x 8"</code> box will be 960
cubic inches. Dividing by 166 gives the answer 5 instead of 5.783, so we
have in effect rounded <em>down</em> to the next lowest pound; the
shipping company expects us to round <em>up</em>. One solution is to add
165 to the volume before dividing by 166:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span></code></pre></div>
<p>A volume of 166 would give a weight of 331/166, or 1, while a volume
of 167 would yield 332/166, or 2. Calculating the weight in this fashion
gives us the following program.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: dweight.c */</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* Computes the dimensional weight of a 12&quot; x 10&quot; x 8&quot; box */</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">,</span> weight<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Dimensions: %dx%dx%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> height<span class="op">);</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Volume (cubic inches): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    printd<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> weight<span class="op">);</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The output of the program is</p>
<pre class="shell"><code>Dimensions: 12x10x8
Volume (cubic inches): 960
Dimensional weight (pounds): 6</code></pre>
<h3 id="initialization">2.4.6 Initialization</h3>
<p>Some variables are automatically set to zero when a program begins to
execute, but most are not. A variable that doesn’t have a default value
and hasn’t yet been assigned a value by the program is said to be
<strong><em>uninitialized</em></strong>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Attempting to access the value of an uninitialized variable (for
example, by displaying the variable using <code>printf</code> or using
it in an expression) may yield an unpredictable result such as 2568,
-30891, or some equally strange number. With some compilers, worse
behavior–even a program crash–may occur.</p>
</div>
<p>We can always give a variable an initial value by using assignment,
of course. But there’s an easier way: put the initial value of the
variable in its declaration. For example, we can declare the
<code>height</code> variable and initialize it in one step:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span></code></pre></div>
<p>In C jargon, the value <code>8</code> is said to be an
<strong><em>initializer</em></strong>.</p>
<p>Any number o variables can be initialized in the same
declaration:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height <span class="op">=</span> <span class="dv">8</span><span class="op">,</span> length <span class="op">=</span> <span class="dv">12</span><span class="op">,</span> width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<p>Notice that each variable requires its own initializer. In the
ollowing example, the initializer <code>10</code> is good only or the
variable <code>width</code>, not for <code>height</code> or
<code>length</code> (which remain uninitialized):</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<h3 id="printing-expressions">2.4.7 Printing Expressions</h3>
<p><code>printf</code> isn’t limited to displaying numbers stored in
variables; it can display the value of <em>any</em> numeric expression.
Taking advantage of this property can simplify a program and reduce the
number of variables. For instance, the statements</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span></code></pre></div>
<p>could be replaced by</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">);</span></span></code></pre></div>
<p><code>printf</code>’s ability to print expressions illustrates one of
C’s general principles: <em>Wherever a value is needed, any expression
of the same type will do</em>.</p>
<h2 id="reading-input">2.5 Reading Input</h2>
<p>Because the <code>dweight.c</code> program calculates the dimensional
weight of just one box, it isn’t especially useful. To improve the
program, we’ll need to allow the user to enter the dimensions.</p>
<p>To obtain input, we’ll use the <code>scanf</code> function, the C
library’s counterpart to <code>printf</code>. The <code>f</code> in
<code>scanf</code>, like the <code>f</code> in <code>printf</code>,
stands for “formatted”; both <code>scanf</code> and <code>printf</code>
require the use of a <strong><em>format string</em></strong> to specify
the appearance of the input or output data. <code>scanf</code> needs to
know what form the input data will take, just as <code>printf</code>
needs to know how to display output data.</p>
<p>To read an <code>int</code> value, we’d use <code>scanf</code> as
follows:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span>    <span class="co">/* reads an integer; stores into i */</span></span></code></pre></div>
<p>The <code>"%d"</code> string tells <code>scanf</code> to read input
that represents an integer; <code>i</code> is an <code>int</code>
variable into which we want <code>scanf</code> to store the input. The
<code>&amp;</code> symbol is hard to explain at this point; for now,
I’ll just note that it is usually (but not always) required when using
<code>scanf</code>.</p>
<p>Reading a <code>float</code> value requires a slightly different call
of <code>scanf</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>x<span class="op">);</span>    <span class="co">/* reads a float value; stores into x */</span></span></code></pre></div>
<p><code>%f</code> works only with variables of type <code>float</code>,
so I’m assuming that <code>x</code> is a <code>float</code> variable.
The <code>"%f"</code> string tells <code>scanf</code> to look for an
input value in <code>float</code> format (the number may contain a
decimal point, but doesn’t have to).</p>
<h3
id="program-computing-the-dimensional-weight-of-a-box-revisited">2.5.1
(PROGRAM) Computing the Dimensional Weight of a Box (Revisited)</h3>
<p>Here’s an improved version of the dimensional weight program in which
the user enters the dimensions. Note that each call of
<code>scanf</code> is immediately preceeded by a call of
<code>printf</code>. That way, the user will know when to enter input
and what input to enter.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: dweight2.c</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co">   purpose: Computes the dimensional weight of a </span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co">   box from input provided by the user */</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">,</span> weight<span class="op">;</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter height of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>height<span class="op">);</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter length of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>length<span class="op">);</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter width of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>width<span class="op">);</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Volume (cubic inches): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> weight<span class="op">);</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The output of the program has the following appearance</p>
<pre class="shell"><code>Enter height of box: 8
Enter length of box: 12
Enter width of box: 10
Volume (cubic inches): 960
Dimensional weight (pounds): 6</code></pre>
<p>A message that asks the user to enter input (a
<strong><em>prompt</em></strong>) normally shouldn’t end with a new-line
character, because we want the user to enter input on the same line as
the prompt itself. When the user presses the Enter key, the cursor
automatically moves to the next line–the program doesn’t need to display
a new-line character to terminate the current line.</p>
<p>The <code>dweight2.c</code> program suffers from one problem: it
doesn’t work correctly if the user enters nonnumeric input. Section 3.2
discusses this issue in more detail.</p>
<h2 id="defining-names-for-constants">2.6 Defining Names for
Constants</h2>
<p>When a program contains constants, it’s often a good idea to give
them names. The <code>dweight.c</code> and <code>dweight2.c</code>
programs rely on constant 166, whose meaning may not be at all clear to
someone reading the program later. Using feature know as
<strong><em>macro definition</em></strong>, we can name this
constant:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INCHES_PER_POUND 166</span></span></code></pre></div>
<p><code>#define</code> is a preprocessing directive, just as
<code>#include</code> is, so there’s no semicolon at the end of the
line.</p>
<p>When a program is compiled, the preprocessor replaces each macro by
the value that it represents. For example, the statement</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> INCHES_PER_POUND <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">/</span> INCHES_PER_POUND<span class="op">;</span></span></code></pre></div>
<p>will become</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">166</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span></code></pre></div>
<p>giving the same effect as if we’d written the latter statement in the
first place.</p>
<p>The value of a macro can be an expression:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define RECIPROCAL_OF_PI (1.0f / 3.14159f)</span></span></code></pre></div>
<p>If it contains operators; the expression should be enclosed ina
prantheses.</p>
<p>Notice that we’ve used only upper-case letters in macros names. This
a convention that most C programmers follow, not a requirement of the
language. (Still, C programmers have been doing this for decades; you
wouldn’t want to be the first to deviate.)</p>
<h3 id="program-converting-from-fahrenheit-to-celsius">2.6.1 (PROGRAM)
Converting from Fahrenheit to Celsius</h3>
<p>The following program prompts the user to enter a Fahrenheit
temperature; it then prints the equivalent Celsius temperature. The
output of the program will have the following appearance:</p>
<pre class="shell"><code>Enter Fahrenheit temperature: 212
Celsius equivalent: 100.0</code></pre>
<p>The program will allow temperatures that aren’t integers; that’s why
the Celsius temperature is displayed as 100.0 instead of 100. Let’s look
first at the entire program, then see how it’s put together.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * File: celsius.c</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Converts a Fahrenheit temperature to Celsius</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FREEZING_PT 32.0f</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCALE_FACTOR (5.0f /9.0f)</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fahrenheit<span class="op">,</span> celsius<span class="op">;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>fahrenheit<span class="op">);</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The statement</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span></code></pre></div>
<p>converts the Fahrenheit temperature to Celsius. Since
<code>FREEZING_PT</code> stands for <code>32.0f</code> and
<code>SCALE_FACTOR</code> stands for <code>(5.0f /9.0f)</code>, the
compiler sees this statement as</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> <span class="fl">32.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fl">5.0</span><span class="bu">f</span> <span class="op">/</span> <span class="fl">9.0</span><span class="bu">f</span><span class="op">);</span></span></code></pre></div>
<p>Defining <code>SCALE_FACTOR</code> to be <code>(5.0f / 9.0f)</code>
instead of <code>(5 / 9)</code> is important, becasuse C truncates the
result when two integers are divided. The value of <code>(5 / 9)</code>
would be <code>0</code>, which definitely isn’t what we want.</p>
<p>The call of <code>printf</code> writes the Celsius temperature:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span></code></pre></div>
<p>Notice the use of <code>%.1f</code> to display <code>celsius</code>
with just one digit after the decimal point.</p>
<h2 id="identifiers">Identifiers</h2>
<p>As we’re writing a program, we’ll have to choose names for variables,
functions, macros, and other entities. These names are called
<strong><em>identifiers</em></strong>. In C, an identifier may contain
letters, digits, and underscores, but must begin with a letter or
underscore.</p>
<p><span class="C99Symbol"></span></p>
<p>(In C99, identifiers may contain certain “universal character names”
as well.)</p>
<p>Here are some examples of legal identifers:</p>
<pre><code>times10
get_next_char
_done</code></pre>
<p>The following are <em>not</em> legal identifiers:</p>
<pre><code>10times
get-next-char</code></pre>
<p>The symbol <code>10times</code> begins with a digit, not a letter or
underscore. <code>get-next-char</code> contains minus signs, not
underscores.</p>
<p>C is <strong><em>case-sensitive</em></strong>: it distinguishes
between upper-case and lower-case letters in identifiers. For example,
the following identifiers are all different:</p>
<pre><code>job
joB
jOb
jOB
Job
JoB
JOb
JOB</code></pre>
<p>These eight identifiers could all be used simultaneously, each for a
completely different purpose. (Talk about obfuscation!) Sensible
programmers try to make identifiers look different unless they’re
somehow related.</p>
<p>Since case matters in C, many programmers follow the convention of
using only lower-case letters in identifiers (other than macros), with
underscores inserted when necessary for legibility:</p>
<pre><code>symbol_table
current_page
name_and_address</code></pre>
<p>Other programmers avoid underscores, instead using an upper-case
letter to begin each word within an identifier:</p>
<pre><code>symbolTable
currentPage
nameAndAddress</code></pre>
<p>(The first letter is sometimes capitalized as well.) Although the
former style is common in traditional C, the latter style is becoming
more popular thanks to its widespread use in Java and C# (and, to a
lesser extent, C++). Other reasonable conventions exist; just be sure to
capitalize an identifier the same way each time it appears in a
program.</p>
<p><span class="QandA"></span></p>
<p>C places no limit on the maximum length of an identifier, so don’t be
afraid to use long, descriptive names. A name such as
<code>current_page</code> is a lot easier to understand than a name like
<code>cp</code>.</p>
<h3 id="keywords">2.7.1 Keywords</h3>
<p><span class="C99Symbol"></span></p>
<p>The <strong><em>keywords</em></strong> in Table 2.1 have special
significance to C compilers and therefore can’t be used as identifiers.
Note that five keywords were added in C99.</p>
<p><strong>Table 2.1</strong><br>Keywords</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<tbody>
<tr class="odd">
<td><code>auto</code></td>
<td><code>enum</code></td>
<td><code>restrict</code><span class="staffOfHermis"></span></td>
<td><code>unsigned</code></td>
</tr>
<tr class="even">
<td><code>break</code></td>
<td><code>extern</code></td>
<td><code>return</code></td>
<td><code>void</code></td>
</tr>
<tr class="odd">
<td><code>case</code></td>
<td><code>float</code></td>
<td><code>short</code></td>
<td><code>volatile</code></td>
</tr>
<tr class="even">
<td><code>char</code></td>
<td><code>for</code></td>
<td><code>signed</code></td>
<td><code>while</code></td>
</tr>
<tr class="odd">
<td><code>const</code></td>
<td><code>goto</code></td>
<td><code>sizeof</code></td>
<td><code>_Bool</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="even">
<td><code>continue</code></td>
<td><code>if</code></td>
<td><code>static</code></td>
<td><code>_Complex</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="odd">
<td><code>default</code></td>
<td><code>inline</code><span class="staffOfHermis"></span></td>
<td><code>struct</code></td>
<td><code>_Imaginary</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="even">
<td><code>do</code></td>
<td><code>int</code></td>
<td><code>switch</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>double</code></td>
<td><code>long</code></td>
<td><code>typedef</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>else</code></td>
<td><code>register</code></td>
<td><code>union</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="staffOfHermis"></span>C99 only</p>
<p>Because of C’s case-sensitivity, keywords must appear in programs
exactly as shown in Table 2.1, with all letters in lower case. Names of
functions in the standard library (such as <code>printf</code>) contain
only lower-case letters also. Avoid the plight of the unfortunate
programmer who enters an entire program in upper case, only to find that
the compiler can’t recognize keywords and calls of library
functions.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Watch out for other restrictions on identifiers. Some compilers treat
certain identifiers (<code>asm</code>, for example) as additional
keywords. Identifiers that belong to the standard library are restricted
as well. Accidentally using one of these names can cause an error during
compilation or linking. Identifiers that begin with an underscore are
also restricted.</p>
</div>
<h2 id="layout-of-a-c-program">2.8 Layout of a C Program</h2>
<p>We think of a C program as a series of
<strong><em>tokens</em></strong>: groups of characters that can’t be
split up without changing their meaning. Identifiers and keywords are
tokens. So are operators like <code>+</code> and <code>-</code>,
punctuation marks such as the comma and semicolon, and string literals.
For example, the statement</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">);</span></span></code></pre></div>
<p>consists of seven tokens:</p>
<table>
<tbody>
<tr class="odd">
<td><code>printf</code></td>
<td><span class="circled1"></span></td>
</tr>
<tr class="even">
<td><code>(</code></td>
<td><span class="circled2"></span></td>
</tr>
<tr class="odd">
<td><code>"Height: %d\n"</code></td>
<td><span class="circled3"></span></td>
</tr>
<tr class="even">
<td><code>,</code></td>
<td><span class="circled4"></span></td>
</tr>
<tr class="odd">
<td><code>height</code></td>
<td><span class="circled5"></span></td>
</tr>
<tr class="even">
<td><code>)</code></td>
<td><span class="circled6"></span></td>
</tr>
<tr class="odd">
<td><code>;</code></td>
<td><span class="circled7"></span></td>
</tr>
</tbody>
</table>
<p>Tokens <span class="circled1"></span> and <span
class="circled5"></span> are identifiers, token <span
class="circled3"></span> is a string literal, and tokens <span
class="circled2"></span>, <span class="circled4"></span>, <span
class="circled6"></span>, and <span class="circled7"></span> are
punctuation.</p>
<p>The amount of space between tokens in a program isn’t critical in
most cases. At one extreme, tokens can be crammed together with no space
between them at all, except where this would cause two tokens to merge
into a third token. For example, we could delete most of the space in
the <code>celsius.c</code> program of Section 2.6, provided that we
leave space between tokens such as <code>int</code> and
<code>main</code> and between <code>float</code> and
<code>fahrenheit</code>:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Converts a Fahrenheit temperature to Celsius */</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FREEZING_PT 32.0f</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCALE_FACTOR (5.0f/9.0f)</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">){</span><span class="dt">float</span> fahrenheit<span class="op">,</span>celsius<span class="op">;</span>printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span>scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,&amp;</span>fahrenheit<span class="op">);</span>celsius<span class="op">=(</span>fahrenheit<span class="op">-</span>FREEZING_PT<span class="op">)*</span>SCALE_FACTOR<span class="op">;</span>printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>celsius<span class="op">);</span><span class="cf">return</span> <span class="dv">0</span><span class="op">;}</span></span></code></pre></div>
<p>In fact, if the page were wider, we could put the entire
<code>main</code> function on a single line. We can’t put the whole
<em>program</em> on one line, though, because each preprocessing
directive requires a separate line.</p>
<p>Compressing programs in this fashion isn’t good idea. In fact, adding
spaces and blank lines to a program can make it easier to read and
understand. Fortunately, C allows us to insert any amouont of
space–blanks, tabs, and new-line characters–between tokens. This rule
has several important consequences for program layout:</p>
<!-- Ordered list Start here -->
<ul>
<li>
<p><em>Statements can be divided</em> over any number of lines. The
following statement, for example, is so long that it would be hard to
sqeeze it onto a single line:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span>volume <span class="op">+</span> INCHES_PER_POUND <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> INCHES_PER_POUND<span class="op">);</span></span></code></pre></div>
</li>
<li>
<p><em>Space between tokens</em> makes it easier for the eye to separate
them. For this reason, I usually put a space before and after each
operator:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span></code></pre></div>
<p>I also put a space after each comma. Some programmers go even
further, putting spaces around parentheses and other punctuation.</p>
</li>
<p><span class="QandA"></span></p>
<li>
<p><em>Indentation</em> can make nesting easier to spot. For example, we
should indent declarations and statements to make it clear that they’re
nested inside <code>main</code>.</p>
</li>
<li>
<p><em>Blank lines</em> can divide a program into logical units, making
it easier for the reader to discern the program’s structure. A program
with no blank lines is as hard to read as a book with no chapters.</p>
</li>
</ul>
<!-- Un ordered list end here -->
<p>The <code>celsius.c</code> program of Section 2.6 illustrates several
of these guidelines. Let’s take a closer look at the <code>main</code>
function in that program:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fahrenheit<span class="op">,</span> celsius<span class="op">;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>fahrenheit<span class="op">);</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>First, observe how the space around <code>=</code>, <code>-</code>,
and <code>*</code> makes these operators stand out. Second, notice how
the indentation of declarations and statements makes it obvious that
they all belong to <code>main</code>. Finally, note how blank lines
divide <code>main</code> into five parts: (1) declaring the
<code>fahrenheit</code> and <code>celsius</code> variables; (2)
obtaining the Fahrenheit temperature; (3) calculating the value of
<code>celsius</code>; (4) printing the Celsius temperature; and (5)
returning to the operating system.</p>
<p>While we’re on the subject of program layout, notice how I’ve placed
the <code>{</code> token underneath <code>main()</code> and put the
matching <code>}</code> on a separate line, aligned with <code>{</code>.
Putting <code>}</code> on a separate line lets us insert or delete
statements at the end of the function; aligning it with <code>{</code>
makes it easy to spot the end of <code>main</code>.</p>
<p>A final note: Although extra spaces can be added <em>between</em>
tokens, it’s not possible to add space <em>within</em> a token without
changing the meaning of the program or causing an error. Writing</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>fl oat fahrenheit<span class="op">,</span> celsius<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>fl</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>oat fahrenheit<span class="op">,</span> celsius<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>produces an error when the program is compiled. Putting a space
inside a string literal is allowed, although it changes the meaning of
the string. However, putting a new-line character in a string (in other
words, splitting the string over two lines) is illegal:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C:</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>that is the question<span class="op">.</span>\n<span class="st">&quot;);    /*** WRONG ***/</span></span></code></pre></div>
<p>Continuing a string from one line to the next requires a special
technique that we’ll learn in a later chapter.</p>
<hr />
<h2 id="q-a">Q &amp; A</h2>
<div class="QandA_question">
<p>Q: What does GCC stand for? [p. 11]</p>
</div>
<div class="QandA_answer">
<p>A: GCC originally stood for “<u>G</u>NU <u>C</u> <u>C</u>ompiler.” It
now stands for “<u>G</u>NU <u>C</u>ompiler <u>C</u>ollection,” because
the current version of GCC compiles programs written in a variety of
languages, including Ada, C, C++, Fortran, Java, and Objective-C.</p>
</div>
<div class="QandA_question">
<p>Q: OK, so what does GNU stand for?</p>
</div>
<div class="QandA_answer">
<p>A: GNU stands for “<u>G</u>NU’s <u>N</u>ot <u>U</u>nix!” (and is
pronounced <em>guh-NEW</em>, by the way). GNU is a project of the Free
Software Foundation, an organization set up by <strong>Ritchard M.
Stallman</strong> as a protest against the restrictions of licensed UNIX
software. According to its web site, the Free Software Foundation
believes that the users should be free to “run, copy, distribute, study,
change and improve” software. The GNU Project has rewritten much
traditional UNIX software from scratch and made it publicly available at
no charge.</p>
<p>GCC and other GNU software are crucial to Linux. Linux itself is only
the “kernel” of an operating system (the part that handles program
scheduling and basic I/O services); the GNU software is necessary to
have a fully functional operating system.</p>
<p>For more information on the GNU Project, visit <a
href="https://www.gnu.org/">www.gnu.org</a>.</p>
</div>
<div class="QandA_question">
<p>Q: What’s the big deal about the GCC anyway?</p>
</div>
<div class="QandA_answer">
<p>A: GCC is significant for many reasons, not least the fact that it’s
free and capable of compiling a number of languages. It runs under many
operating systems and generates code for many different CPUs, including
all the widely used ones. GCC is the primary compiler for many
UNIX-based operating systems, including Linux, BSD, and Mac OS X, and
it’s used extensively for commercial software development. For more
information about GCC, visit <a
href="https://gcc.gnu.org">gcc.gnu.org</a></p>
</div>
<div class="QandA_question">
<p>Q: How good is GCC at finding errors in programs?</p>
</div>
<div class="QandA_answer">
<p>A: GCC has various command-line options that control how thoroughly
it checks programs. When these options are used, GCC is quite good at
finding potential trouble spots in a program. Here are some of the more
popular options:</p>
<ul>
<li>
<p><code>-Wall</code></p>
<p>Causes the compiler to produce warning messages when it detects
possible errors. (<code>-W</code> can be followed by codes for specific
warnings; <code>-Wall</code> means “all <code>-W</code> options.”)
Should be used in conjunction with <code>-O</code> for maximum
effect.</p>
</li>
<li>
<p><code>-W</code></p>
<p>Issues additional warning messages beyond those produced by
<code>-Wall</code>.</p>
</li>
<li>
<p><code>-pedantic</code></p>
<p>Issues all warnings required by the C standard. Causes programs that
use non-standard features to be rejected.</p>
</li>
<li>
<p><code>-ansi</code></p>
<p>Turns off features of GCC that aren’t standard C and enables a few
standard features that are normally disabled.</p>
</li>
<li>
<pre><code>-std=c89
-std=c99</code></pre>
<p>Specifies which version of C the compiler should use to check the
program.</p>
</li>
</ul>
<p>These options are often used in combination:</p>
<pre class="shell"><code>gcc -O -Wall -W -pedantic -ansi -std=c99 -o pun pun.c</code></pre>
</div>
<div class="QandA_question">
<p>Q: Why is C so terse? It seems as though programs would be more
readable if C used <code>begin</code> and <code>end</code> instead of
<code>{</code> and <code>}</code>, <code>integer</code> instead of
<code>int</code>, and so forth. [p. 12]</p>
</div>
<div class="QandA_answer">
<p>A: Legend has it that the brevity of C programs is due to the
environment that existed in Bell Labs at the time the language was
developed. The first C compiler ran on a DEC PDP-11 (an early
minicomputer); programmers used a teletype–essentially a typewriter
connected to a computer–to enter programs and print listings. Because
teletypes were very slow (they could print only 10 characters per
second), minimizing the number of characters in a program was clearly
advantageous.</p>
</div>
<div class="QandA_question">
<p>Q: In some C books, the <code>main</code> function ends with
<code>exit(0)</code> instead of <code>return 0</code>. Are these the
same? [p. 14]</p>
</div>
<div class="QandA_answer">
<p>A: When they appear inside <code>main</code>, these statements are
indeed equivalent: both terminate the program, returning the value
<code>0</code> to the operating system. Which one to use is mostly a
matter of taste.</p>
</div>
<div class="QandA_question">
<p>Q: What happens if a program reaches the end of the <code>main</code>
function without executing a <code>return</code> statement? [p. 14]</p>
</div>
<div class="QandA_answer">
<p><span class="C99Symbol"></span></p>
<p>A: The <code>return</code> statement isn’t mandatory; if it’s
missing, the program will still terminate. In C89, the value returned to
the operating system is undefined. In C99, if <code>main</code> is
declared to return an <code>int</code> (as in our examples), the program
returns <code>0</code> to the operating system; otherwise, the program
returns an unspecified value.</p>
</div>
<div class="QandA_question">
<p>Q: Does the compiler remove a comment entirely or replace it with
blank space?</p>
</div>
<div class="QandA_answer">
<p>A: Some old C compilers deleted all the characters in each comment,
making it possible to write</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>a<span class="co">/**/</span>b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>and have the compiler interpret it as</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>ab <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>According to the C standard, however, the compiler must replace each
comment by a single space character, so this trick doesn’t work.
Instead, we’d end up with the following (illegal) statement:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>a b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
</div>
<div class="QandA_question">
<p>Q: How can I tell if my program has an unterminated comment?</p>
</div>
<div class="QandA_answer">
<p>A: If you’re lucky, the program won’t compile because the comment has
rendered the program illegal. If the program does compile, there are
several techniques that you can use. Stepping through the program line
by line with a debugger will reveal if any lines are being skipped. Some
IDEs display comments in a distinctive color to distinuish them from
sorrounding code. If you’re using such an environment, you can easily
spot unterminated comments, since program text will have different color
of it’s accidentally included in a comment. A program such as
<code>lint</code> can also help.</p>
</div>
<div class="QandA_question">
<p>Q: Is it legal to nest one comment inside another?</p>
</div>
<div class="QandA_answer">
<p>A: Old-style comments (<code>/* ... */</code>) can’t be nested. For
instance, the following code is illegal:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="co">    /*** WRONG ***/</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="op">*/</span></span></code></pre></div>
<p>The <code>*/</code> symbol on the second line matches the
<code>/*</code> symbol on the first line, so the compiler will flag the
<code>*/</code> symbol on the third line as an error.</p>
<p><span class="C99Symbol"></span></p>
<p>C’s prohibition against nested comments can sometimes be a problem.
Suppose we’ve written a long program containing many short comments. To
disable a portion of the program temporarily (during testing, say), our
first impulse is to “comment out” the offending lines with
<code>/*</code> and <code>*/</code>. Unfortunately, this method won’t
work if the lines contain old-style comments. C99 comments (those
beginning with <code>//</code>) can be nested inside old-style comments,
however–another advantage to using this kind of comment.</p>
<p>In any event, there’s a better way to disable portions of a program,
as we’ll see later.</p>
</div>
<div class="QandA_question">
<p>Q: Where does the <code>float</code> type get its name? [p. 17]</p>
</div>
<div class="QandA_answer">
<p>A: <code>float</code> is short for “floating-point”, a technique for
storing numbers in which the decimal point “floats”. A float value is
usually stored in two parts: the fraction (or mantissa) and the
exponent. The number 12.0 might be stored as <span
class="displayInlineMath"><span
class="math display">1.5 × 2<sup>3</sup></span></span>, for example,
where 1.5 is the fraction and 3 is the exponent. Some programming
languages call this type <code>real</code> instead of
<code>float</code>.</p>
</div>
<div class="QandA_question">
<p>Q: Why do floating-point constants need to end with letter
<code>f</code>? [p. 19]</p>
</div>
<div class="QandA_answer">
<p>A: For the full explanation, see Chapter 7. Here’s the short answer:
a constant that contains a decimal point but doesn’t end with
<code>f</code> has type <code>double</code> (short for
“double-precision”). <code>double</code> values are stored more
accurately than <code>float</code> values. Moreover, <code>double</code>
values can be larger than <code>float</code> values, which is why we
need to add the letter <code>f</code> when assigning to a
<code>float</code> variable. Without the <code>f</code>, a warning may
be generated about the possibility of a number being stored into a
<code>float</code> variable that exceeds the capacity of the
variable.</p>
</div>
<div class="QandA_question">
<p>*Q: Is it really true that there’s no limit on the length of an
identifier? [p. 26]</p>
</div>
<div class="QandA_answer">
<p>A:</p>
<p><span class="C99Symbol"></span></p>
<p>Yes and no. The C89 standard says that identifiers may be arbitrarily
long. However, compilers are only required to remember the first 31
characters (63 characters in C99). Thus, if two names begin with the
same 31 characters, a compiler might be unable to distinguish between
them.</p>
<p><span class="C99Symbol"></span></p>
<p>To make matters even more complicated, there are special rules for
identifiers with external linkage; most function names fall into this
category. Since these names must be made available to the linker, and
since some older linkers can handle only short names, only the first six
characters are significant in C89. Moreover, the case of letters may not
matter. As a result, <code>ABCDEFG</code> and <code>abcdefg</code> might
be treated as the same name. (In C99, the first 31 characters are
significant, and the case of letters is taken into account.)</p>
<p>Most compilers and linkers are more generous than the standard, so
these rules aren’t a problem in practice. Don’t worry about making
identifiers too long–worry about making them too short.</p>
</div>
<div class="QandA_question">
<p>Q: How many spaces should I use for indentation? [p. 28]</p>
</div>
<div class="QandA_answer">
<p>A: That’s a tough question. Leave too little space, and the eye has
trouble detecting indentation. Leave too much, and the lines run off the
screen (or page). Many C programmers indent nested statements eight
spaces (one tab stop), which is probably too much. Studies have shown
that the optimum amount of indentation is three spaces, but many
programmers feel uncomfortable with numbers that aren’t a power of two.
Although I normally prefer to indent three or four spaces. I’ll use two
spaces in this book so that my programs will fit within the margins.</p>
</div>
<h2 id="examples">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh02/cknkCh02Exmp/">./cknkCh02/cknkCh02Exmp/</a></li>
</ul>
<h2 id="exercises">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh02/cknkCh02Exrc/README.md">./cknkCh02/cknkCh02Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh02/cknkCh02Exrc/cknkCh02ExrcReadme.html">./cknkCh02/cknkCh02Exrc/cknkCh02ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh02/cknkCh02Exrc/">./cknkCh02/cknkCh02Exrc/</a></li>
</ul>
<h2 id="programming-projects">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh02/cknkCh02Prj/README.md">./cknkCh02/cknkCh02Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh02/cknkCh02Prj/cknkCh02PrjReadme.html">./cknkCh02/cknkCh02Prj/cknkCh02PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh02/cknkCh02Prj/">./cknkCh02/cknkCh02Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="formatted-inputoutput">3 Formatted Input/Output</h1>
<div class="theQuote">
In seeking the unattainable, simplicity only gets in the way.
</div>
<p><code>scanf</code> and <code>printf</code>, which support formatted
reading and writing, are two of the most frequently used functions in C.
As this chapter shows, both are powerful but tricky to use properly.
Section 3.1 describes <code>printf</code>, and Sectioon 3.2 covers
<code>scanf</code>. Neither section gives complete details, which will
have to wait until Chapter 22.</p>
<h2 id="the-printf-function">3.1 The <code>printf</code> Function</h2>
<p>The <code>printf</code> function is designed to display the contents
of a string, known as the <strong><em>format string</em></strong>, with
values possibly inserted at specified points in the string. When it’s
called, <code>printf</code> must be supplied with the format string,
followed by any values that are to be inserted into the string during
printing:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span>string<span class="op">,</span> expr1<span class="op">,</span> expr2<span class="op">,</span> <span class="op">...);</span></span></code></pre></div>
<p>The values displayed can be constants, variables, or more complicated
expressions. There’s no limit on the number of values that can be
printed by a single call of <code>printf</code>.</p>
<p>The format string may contain both ordinary characters and
<strong><em>conversion specifications</em></strong>, which begin with
the <code>%</code> character. A conversion specification is a place
holder representing a value to be filled in during printing. The
information that follows the % character <em>specifies</em> how the
value is <em>converted</em> from its internal form (binary) to printed
form (characters)–that’s where the term “conversion specification” comes
from. For example, the conversion specification <code>%d</code>
specifies that <code>printf</code> is to convert an <code>int</code>
value from binary to a string of decimal digits, while <code>%f</code>
does the same for a <code>float</code> value.</p>
<p>Ordinary characters in a format string are printed exactly as they
appear in the string; conversion specifications are replaced by the
values to be printed. Consider the following example:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">43.2892</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fl">5527.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i = %d, j = %d, x = %f, y = %f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span></code></pre></div>
<p>This call of <code>printf</code> produces the following output:</p>
<pre class="shell"><code>i = 10, j = 20, x = 43.289200, y = 5527.000000</code></pre>
<p>The ordinary characters in the format string are simply copied to the
output line. The four conversion specifications are replaced by the
values of the variables <code>i</code>, <code>j</code>, <code>x</code>,
and <code>y</code>, in that order.</p>
<div class="infoBox">
<p><span class="warningEmoji"><span></p>
<p>C compilers aren’t required to check that the number of conversion
specifications in a format string matches the number of output items.
The following call of <code>printf</code> has more conversion
specifications than values to be printed:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p><code>printf</code> will print the value of <code>i</code> correctly,
then print a second (meaningless) integer value. A call with too few
conversion specifications has similar problems:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>In this case, <code>printf</code> prints the value of <code>i</code>
but doesn’t show the value of <code>j</code>.</p>
<p>Furthermore, compilers aren’t required to check that a conversion
specification is appropriate for the type of item being printed. If the
programmer uses an incorrect specification, the program will simply
produce meaningless output. Consider the following call of
<code>printf</code>, in which the <code>int</code> variable
<code>i</code> and the <code>float</code> variable <code>x</code> are in
the wrong order:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%f %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> x<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>Since <code>printf</code> must obey the format string, it will
dutifully display a <code>float</code> value, followed by an
<code>int</code> value. Unfortunately, both will be meaningless.</p>
</div>
<h3 id="conversion-specifications">3.1.1 Conversion Specifications</h3>
<p>Conversion specifications give the programmer a great deal of control
over the appearance of output. On the other hand, they can be
complicated and hard to read. In fact, describing conversion
specifications in complete detail is too arduous a task to tackle this
early in the book. Instead, we’ll just take a brief look at some of
their more important capabilities.</p>
<p>In chapter 2 , we saw that a conversion specification can include
formatting information. In particular, we used <code>%.1f</code> to
display a <code>float</code> value with one digit after the decimal
point. More generally, a conversion specification can have the form
<code>%m.pX</code> or <code>%-m.pX</code>, where <code>m</code> and
<code>p</code> are integer constants and <code>X</code> is a letter.
Both <code>m</code> and <code>p</code> are optional; if <code>p</code>
is omitted, the period that separates <code>m</code> and <code>p</code>
is also dropped. In the conversion specification <code>%10.2f</code>,
<code>m</code> is <code>10</code>, <code>p</code> is <code>2</code>, and
<code>X</code> is <code>f</code>. In the specification
<code>%.2f</code>, <code>p</code> is <code>2</code> and <code>m</code>
is missing.</p>
<p>The <strong><em>minimum field width</em></strong>, <code>m</code>,
specifies the minimum number of characters to print. If the value to be
printed requires fewer than <code>m</code> characters, the values is
right justified within the field. (in other words, extra spaces precede
the value.) For example, the specification <code>%4d</code> would
display the number 123 as <code>123</code>. (Please notice the
preceeding space). If the value to be porinted requires more than
<code>m</code> characters, the field width automatically expands to the
necessary size. Thus, the specification <code>%4d</code> would display
the number 12345 as <code>12345</code>–no digits are lost. Putting a
minus sign in front of <code>m</code> causes left justification; the
specification <code>%-4d</code> would display 123 as
<code>123</code>.</p>
<p>The meaning of the <strong><em>precision</em></strong>,
<code>p</code> isn’t as easily described, since it depends on the choice
of <code>X</code>, the <strong><em>conversion specifier</em></strong>.
<code>X</code> indicates which conversion should be applied to the value
before it’s printed. The most common conversion specifiers for numbers
are:</p>
<ul>
<li>
<p><span class="QandA"></span></p>
<p><code>d</code> – Displays an integer in decimal (base 10) form.
<code>p</code> indicates the minimum number of digits to display (extra
zeros are added to the beginning of the number if necessary); if
<code>p</code> is omitted, it is assumed to have the value 1. (In other
words, <code>%d</code> is the same as <code>%.1d</code>.)</p>
</li>
<li>
<p><code>e</code> – Displays a floating-point number in exponential
format (scientific notation). <code>p</code> indicates how many digits
should appear after the decimal point (the default is 6). If
<code>p</code> is 0, the decimal point is not displayed.</p>
</li>
<li>
<p><code>f</code> – Displays a floating-point number in “fixed decimal”
format, without an exponent. <code>p</code> has the same meaning as for
the <code>e</code> specifier.</p>
</li>
<li>
<p><code>g</code> – Displays a floating-point number in either
exponential format or fixed decimal format, depending on the number’s
size. <code>p</code> indicates the maximum number of significant digits
(<em>not</em> digits after the decimal point) to be displayed. Unlike
the <code>f</code> conversion, the <code>g</code> conversion won’t show
trailing zeros. Furthermore, if the value to be printed has no digits
after the decimal point, <code>g</code> doesn’t display the decimal
point.</p>
</li>
</ul>
<p>The <code>g</code> specifier is especially useful for displaying
numbers whose size can’t be predicted when the program is written or
that tend to vary widely in size. When used to print a moderately large
or moderately small number, the <code>g</code> specifier uses fixed
decimal format. But when used to print a very large or very small
number, the <code>g</code> specifier switches to exponential format so
that the number will require fewer characters.</p>
<p>There are many other specifiers besides <code>%d</code>,
<code>%e</code>, <code>%f</code>, and <code>%g</code>. I’ll gradually
introduce many of them in subsequent chapters. For the full list, and
for a complete explanation of the other capabilities of conversion
specifications, consult Section 22.3.</p>
<h3 id="using-printf-to-format-numbers">3.1.2 Using <code>printf</code>
to Format Numbers</h3>
<p>The following program illustrates the use of <code>printf</code> to
print integers and floating-point numbers in various formats.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">/** </span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co">  * file: tprintf.c</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co">  * Purpose: Prints int and float values in various formats</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="co">  * Author: K. N. King</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="co">  */</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x<span class="op">;</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">40</span><span class="op">;</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="fl">839.21</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;|%d|%5d|%-5d|%5.3d|</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> i<span class="op">,</span> i<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;|%10.3f|%10.3e|%-10g|</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> x<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The character <code>|</code> in the <code>printf</code> format
strings are there merely to help show how much space each number
occupies when printed; unlike <code>%</code> or <code>\</code>, the
<code>|</code> character has no special significance to
<code>printf</code>. The output of this program is:</p>
<pre class="shell"><code>|40|   40|40   |  040|
|   839.210| 8.392e+02|839.21    |</code></pre>
<p>Let’s take a closer look at the conversion specifications used in
this program:</p>
<ul>
<li>
<p><code>%d</code> – Displays <code>i</code> in decimal form, using a
minimum amount of space.</p>
</li>
<li>
<p><code>%5d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters. Since <code>i</code> requires only two
characters,three spaces were added.</p>
</li>
<li>
<p><code>%-5d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters; since the value of <code>i</code> doesn’t
require five characters, the spaces are added afterward (that is,
<code>i</code> is left-justified in a field of length five).</p>
</li>
<li>
<p><code>%5.3d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters overall and a minimum of three digits. Since
<code>i</code> is only two digits long, an extra zero was added to
guarantee three digits. The resulting number is only three characters
long, so two spaces were added, for a total of five characters
(<code>i</code> is right-justified).</p>
</li>
<li>
<p><code>%10.3f</code> – Display <code>x</code> in fixed decimal form,
using 10 characters overall with three digits after the decimal point.
Since <code>x</code> requires only seven charcaters (three before the
decimal point, three after the decimal point, and one for the decimal
point itself), three spaces precede <code>x</code>.</p>
</li>
<li>
<p><code>%10.3e</code> – Displays <code>x</code> in exponential form,
using 10 characters overall, with three digits after the decimal point.
<code>x</code> requires nine characters altogether (including the
exponent), so one space precedes <code>x</code>.</p>
</li>
<li>
<p><code>%-10g</code> – Display <code>x</code> in either fixed decimal
form or exponential form, using 10 characters overall. In this case,
<code>printf</code> chose to display <code>x</code> in fixed decimal
form. The presence of the minus sign forces left justification, so
<code>x</code> is followed by spaces.</p>
</li>
</ul>
<h3 id="escape-sequences">3.1.3 Escape Sequences</h3>
<p>The <code>\n</code> code that we often use in format strings is
called an <strong><em>escape sequence</em></strong>. Escape sequences
enable strings to contain characters that would otherwise cause problems
for the compiler, including nonprinting (control) characters and
characters that have special meaning to the compiler (such as
<code>"</code>). We’ll provide a complete list of escape sequences
later; for now, here’s a sample:</p>
<table>
<tbody>
<tr class="odd">
<td>Alert (bell)</td>
<td><code>\a</code></td>
</tr>
<tr class="even">
<td>Backspace</td>
<td><code>\b</code></td>
</tr>
<tr class="odd">
<td>New line</td>
<td><code>\n</code></td>
</tr>
<tr class="even">
<td>Horizontal tab</td>
<td><code>\t</code></td>
</tr>
</tbody>
</table>
<p><span class="QandA"><span></p>
<p>When they appear in <code>printf</code> format strings, these escape
sequences represent actions to perform upon printing. printing
<code>\a</code> causes an audible beep on most machines. Printing
<code>\b</code> moves the cursor back one position. Printing
<code>\n</code> advances the cursor to the beginning of the next line.
printing <code>\t</code> moves the cursor to the next tab stop.</p>
<p>A string may contain any number of escape sequences. consider the
following <code>printf</code> example, in which the format string
contains six escape sequences:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Item</span><span class="sc">\t</span><span class="st">Unit</span><span class="sc">\t</span><span class="st">Purchase</span><span class="sc">\n\t</span><span class="st">Price</span><span class="sc">\t</span><span class="st">Date</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Executing this statement prints a two-line heading:</p>
<pre class="shell"><code>Item    Unit    Purchase
        Price   Date</code></pre>
<p>Another common escape sequence is <code>\"</code>, which represents
the <code>"</code> character. Since the <code>"</code> charcater marks
the beginning of this sequence. here’s and example:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">Hello!</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>This statement produces the following output:</p>
<pre class="shell"><code>&quot;Hello!&quot;</code></pre>
<p>Incidentally, you can’t just put a single <code>\</code> character in
a string; the compiler will assume that it’s the beginning of an escape
sequence. To print a single <code>\</code> character, put two
<code>\</code> characters in the string:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\\</span><span class="st">&quot;</span><span class="op">);</span>    <span class="co">/* prints one \ character */</span></span></code></pre></div>
<h2 id="the-scanf-function">3.2 The <code>scanf</code> Function</h2>
<p>Just as <code>printf</code> prints output in a specified format,
<code>scanf</code> reads input according to a particular format. A
<code>scanf</code> format string, like a <code>printf</code> format
string, may contain both ordinary characers and conversion
specifications. The conversions allowed with <code>scanf</code> are
essentially the same as those used with <code>printf</code>.</p>
<p>In many cases, a <code>scanf</code> format string will contain only
conversion specifications, as in the following example:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f, &amp;i, &amp;j, &amp;x, &amp;y);</span></span></code></pre></div>
<p>Suppose that the user enters the following input line:</p>
<pre class="shell"><code>1 -20 .3 -4.0e3</code></pre>
<p><code>scanf</code> will read the line, converting its characters to
the numbers they represent, and then assign 1, -20, 0.3, and -4000.0 to
<code>i</code>, <code>j</code>, <code>x</code>, and <code>y</code>,
respectively. “tightly packed” format strings like
<code>"%d%d%f%f</code> are common in <code>scanf</code> calls.
<code>printf</code> format strings are less likely to have adjacent
conversion specifications.</p>
<p><code>scanf</code>, like <code>printf</code>, contains several traps
for the unwary. When using <code>scanf</code>, the programmer must check
that the number of conversion specifications matches the number of input
variables and that each conversion is appropriate for the corresponding
variable–as with <code>printf</code>, the compiler isn’t required to
check for a possible mismatch. Another trap involves the
<code>&amp;</code> symbol, which normally precedes each variable in a
<code>scanf</code> call. The <code>&amp;</code> is usually (but not
always) required, and it’s the programmer’s responsibility to remember
to use it.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Forgetting to put the <code>&amp;</code> symbol in front of variable
in a call of <code>scanf</code> will have unpredictable–and possibly
disastrous–results. A program crash is a common outcome. At the very
least, the value that is read from the input won’t be stored in the
variable; instead, the variable will retain its old value (which may be
meaningles if the variable wasn’t given an initial value). Omitting the
<code>&amp;</code> is an extremely common error–be careful! Some
compilers can spot this error and produce a warning message such as
<em>“format argument is not a pointer”</em>. (The term <em>pointer</em>
is defined in Chapter 11; the <code>&amp;</code> symbol is used to
create a pointer to a variable.) If you get a warning, check for a
missing <code>&amp;</code>.</p>
</div>
<p>Calling <code>scanf</code> is a powerful but unforgiving way to read
data. Many professional C programmers avoid <code>scanf</code>, instead
reading all data in character form and converting it to numeric form
later. We’ll use <code>scanf</code> quite a bit, especially in the early
chapters of this book, because it provides a simple way to read numbers.
Be aware, however, that many of our programs won’t behave properly if
the user enters unexpected input. As we’ll see later, it’s possible to
have a program test whether <code>scanf</code> successfully read the
requested data (and attempt to recover if it didn’t). Such tests are
impractical for the programs in this book–they would add too many
statements and obscure the point of the examples.</p>
<h3 id="how-scanf-works">3.2.1 How <code>scanf</code> Works</h3>
<p><code>scanf</code> can actually do much more than I’ve indicated so
far. It is essentially a “pattern-matching” function that tries to match
up groups of input characters with conversion specifications.</p>
<p>Like the <code>printf</code> function, <code>scanf</code> is
controlled by the format string. When it is called, <code>scanf</code>
begins processing the information in the string, starting at the left.
For each conversion specification in the format string,
<code>scanf</code> tries to locate an item of the appropriate type in
the input data, skipping blank space if necessary. <code>scanf</code>
then reads the item, stopping when it encounters a character that can’t
possibly belong to the item. If the item was read sucessfully,
<code>scanf</code> continues processing the rest of the format string.
If any item is not read successfully, <code>scanf</code> returns
immediately without looking at the rest of the format string (or the
remaining input data).</p>
<p>As it searches for the beginning of a number, <code>scanf</code>
ignores <strong><em>white-space characters</em></strong> (the space,
horizontal and vertical tab, form-feed, and new-line characters). As a
result, numbers can be put on a single line or spread out over several
lines. Consider the following call of <code>scanf</code>:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span></code></pre></div>
<p>Suppose the user enters three lines of input:</p>
<pre class="shell"><code>  1
-20   .3
   -4.0e3</code></pre>
<p><code>scanf</code> sees one continuous stream of characters:</p>
<pre><code>&lt;space&gt;&lt;space&gt;1&lt;newLine&gt;-20&lt;space&gt;&lt;space&gt;&lt;space&gt;.3&lt;newLine&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;-4.0e3&lt;newLine&gt;</code></pre>
<p>(I’m using <code>&lt;space&gt;</code> to represent the space
character and <code>&lt;newLine&gt;</code> to represent the new-line
character.) Since it skips over white-space characters as it looks for
the beginning of each number, <code>scanf</code> will be able to read
the numbers successfully.</p>
<p><code>scanf</code> “peeks” at the final new-line character without
actually reading it. This new-line will be the first character read by
the next call of <code>scanf</code>.</p>
<p>What rules does <code>scanf</code> follow to recognize an integer or
a floating-point number? When asked to read an integer,
<code>scanf</code> first searches for a digit, a plus sign, or a minus
sign; it then reads digits until it reaches a nondigit. when asked to
read a floating-point number, <code>scanf</code> looks for<br />
- a plus or minus sign (optional), followed by<br />
- a series of digits (possibly containing a decimal point), followed
by<br />
- an exponent (optional). An exponent consists of the letter
<code>e</code> (or <code>E</code>), an optional sign, and one or more
digits.</p>
<p>The <code>%e</code>, <code>%f</code>, and <code>%g</code> conversions
are interchangeable when used with <code>scanf</code>; all three follow
the same rules for recognizing a floating-point number.</p>
<p><span class="QandA"><span></p>
<p>When <code>scanf</code> encounters a character that can’t be part of
the current item, the character is “put back” to be read again during
the scanning of the next input item or during the next call of
<code>scanf</code>. Consider the following (admittedly pathological)
arrangement of our four numbers:</p>
<pre class="shell"><code>1-20.3-4.0e3
</code></pre>
<p>Let’s use the same call of <code>scanf</code> as before:</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span></code></pre></div>
<p>Here’s how <code>scanf</code> would process the new input:</p>
<ul>
<li>Conversion specification: <code>%d</code>. The first nonblank input
character is <code>1</code>; since integers can begin with 1,
<code>scanf</code> then reads the next character, <code>-</code>.
Recognizing that <code>-</code> can’t appear inside an integer,
<code>scanf</code> stores <code>1</code> into <code>i</code> and puts
the <code>-</code> character back.<br />
</li>
<li>Conversion specification: <code>%d</code>. <code>scanf</code> then
reads the characters <code>-</code>, <code>2</code>, <code>0</code>, and
<code>.</code> (period). Since an integer can’t contain a decimal point,
<code>scanf</code> stores <code>-20</code> into <code>j</code> and puts
the <code>.</code> character back.<br />
</li>
<li>Conversion specification: <code>%f</code>. <code>scanf</code> reads
the characters <code>.</code>, <code>3</code>, and <code>-</code>. Since
a floating-point number can’t contain a minus sign after a digit,
<code>scanf</code> stores <code>0.3</code> into <code>x</code> and puts
the <code>-</code> character back.<br />
</li>
<li>conversion specification <code>%f</code>. Lastly, <code>scanf</code>
reads the characters <code>-</code>, <code>4</code>, <code>.</code>,
<code>0</code>, <code>e</code>, <code>3</code>, and a new line. Since a
floating-point number can’t contain a new-line character,
<code>scanf</code> stores <span class="displayInlineMath"><span
class="math display">−4.0 × 10<sup>3</sup></span></span> into
<code>y</code> and puts the new-line character back.</li>
</ul>
<p>In this example, <code>scanf</code> was able to match every
conversion specification in the format string with an input item. Since
the new-line character wasn’t read, it will be left for the next call of
<code>scanf</code>.</p>
<h3 id="ordinary-characters-in-format-strings">3.2.2 Ordinary Characters
in Format Strings</h3>
<p>The concept of pattern-matching can be taken one step further by
writing format strings that contain ordinary characters in addition to
conversion specifications. The action that <code>scanf</code> takes when
it processes an ordinary character in a format string depends on whether
or not it’s a white-space character.</p>
<ul>
<li>
<p><strong><em>White-space characters.</em></strong> When it encounters
one or more consecutive white-space characters in a format string,
<code>scanf</code> repeatedly reads white-space characters from the
input until it reaches a non-white-space character (which is “put
back”). The number of white-space characters in the format string is
irrelevant; one white-space character in the format string will match
any number of white-space characters in the input. (Incidentally,
putting a white-space character in a format string doesn’t force the
input to contain white-space characters. A white-space character in a
format string matches <em>any</em> number of white-space characters in
the input, including none.)</p>
</li>
<li>
<p><strong><em>Other characters.</em></strong> When it encounters a
non-white-space character in a format string, <code>scanf</code>
compares it with the next input character. if the two characters match,
<code>scanf</code> discards the input character and continues processing
the format string. If the characters don’t match, <code>scanf</code>
puts the offencing character back into the input, then aborts without
further processing the format string or reading characters from the
input.</p>
<p>For example, suppose that the format string is <code>"%d/%d"</code>.
If the input is <code>&lt;space&gt;5/&lt;space&gt;96</code>,
<code>scanf</code> skips the first space while looking for an integer,
matches <code>%d</code> with <code>5</code>, matches <code>/</code> with
<code>/</code>, skips a space while looking for another integer, and
matches <code>%d</code> with <code>96</code>. On the other hand, if the
input is <code>&lt;space&gt;5&lt;space&gt;/&lt;space&gt;96</code>,
<code>scanf</code> skips one space, matches <code>%d</code> with
<code>5</code>, then attempts to match the <code>/</code> in the format
string with a space in the input. There’s no match, so
<code>scanf</code> puts the space back; the
<code>&lt;space&gt;/&lt;space&gt;96</code> characters remain to be read
by the next call of <code>scanf</code>. To allow spaces after the first
number, we should use the format string <code>"%d /%d"</code>
instead.</p>
</li>
</ul>
<h3 id="confusing-printf-with-scanf">3.2.3 Confusing <code>printf</code>
with <code>scanf</code></h3>
<p>Although calls of <code>scanf</code> and <code>printf</code> may
appear similar, there are significant differences between the two
functions; ignoring these differences can be hazardous to the health of
your program.</p>
<p>One common mistake is to put <code>&amp;</code> in front of variables
in a call of <code>printf</code>:</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>Fortunately, this mistake is fairly easy to spot: <code>printf</code>
will display a couple of odd-looking numbers instead of the values of
<code>i</code> and <code>j</code>.</p>
<p>Since <code>scanf</code> normally skips white-space characters when
looking for data items, there’s often no need for a format string to
include characters other than conversion specifications. Incorrectly
assuming that <code>scanf</code> format strings should resemble
<code>printf</code> format strings–another common error–may cause
<code>scanf</code> to behave in unexpected ways. Let’s see what happens
when the following call of <code>scanf</code> is executed:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d, %d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
<p><code>scanf</code> will first look for an integer in the input, which
it stores in the variables <code>i</code>. <code>scanf</code> will then
try to match a comma with the next input character. If the next input
character is a space, not a comma, <code>scanf</code> will terminate
without reading a value for <code>j</code>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Although <code>printf</code> format strings often end with
<code>\n</code>, putting a new-line character at the end of a
<code>scanf</code> format string is usually a bad idea. To
<code>scanf</code>, a new-line character in a format string is
equivalent to a space; both cause <code>scanf</code> to advance to the
next non-white-space character. For example, if the format string is
<code>" %d\n"</code>, <code>scanf</code> will skip white space, read an
integer, then skip to the next non-white-space character. A format
string like this can cause an interactive program to “hang” until user
enters a nonblank character.</p>
</div>
<h3 id="program-adding-fractions">3.2.4 (PROGRAM) Adding Fractions</h3>
<p>To illustrate <code>scanf</code>’s ability to match patterns,
consider the problem of reading a fraction entered by the user.
Fractions are customarily written in the form
<em>numerator/denominator</em>. Instead of having the user enter the
numerator and denominator of a fraction as separate integers,
<code>scanf</code> makes it possible to read the entire fraction. The
following program, which adds two fractions, illustartes this
technique.</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: addfrac.c</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Adds two fractions</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num1<span class="op">,</span> denom1<span class="op">,</span> num2<span class="op">,</span> denom2<span class="op">,</span> result_num<span class="op">,</span> result_denom<span class="op">;</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter first fraction: &quot;</span><span class="op">);</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d/%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num1<span class="op">,</span> <span class="op">&amp;</span>denom1<span class="op">);</span></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter second fraction: &quot;</span><span class="op">);</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d/%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num2<span class="op">,</span> <span class="op">&amp;</span>denom2<span class="op">);</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>    result_num <span class="op">=</span> num1 <span class="op">*</span> denom2 <span class="op">+</span> num2 <span class="op">*</span> denom1<span class="op">;</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>    result_denom <span class="op">=</span> denom1 <span class="op">*</span> denom2<span class="op">;</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;The sum is %d/%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> result_num<span class="op">,</span> result_denom<span class="op">);</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A session with this program might have the following appearance:</p>
<pre class="shell"><code>Enter first fraction: 5/6
Enter second fraction: 3/4
The sum is 38/24</code></pre>
<p>Note that the resulting fraction isn’t reduced to lowest terms.</p>
<hr />
<h2 id="q-a-1">Q &amp; A</h2>
<div class="QandA_question">
<p>*Q: I’ve seen the <code>%i</code> conversion used to read and write
integers. What’s the difference between <code>%i</code> and
<code>%d</code>? [p. 39]</p>
</div>
<div class="QandA_answer">
<p>A: In a <code>printf</code> format string, there’s no difference
between the two. In a <code>scanf</code> format string, however,
<code>%d</code> can only match an integer written in decimal (base 10)
form, while <code>%i</code> can match an integer expressed in octal
(base 8), decimal, or hexadecimal (base 16). If an input number has a
<code>0</code> prefix (as in <code>056</code>), <code>%i</code> treats
it as an octal number, if it has a <code>0x</code> or <code>0X</code>
prefix (as in <code>0x56</code>), <code>%i</code> treats it as a hex
number. Using <code>%i</code> instead of <code>%d</code> to read a
number can have surprising results if the user should accidentally put
<code>0</code> at the beginning of the number. Because of this trap, I
recommend sticking with <code>%d</code>.</p>
</div>
<div class="QandA_question">
<p>Q: If <code>printf</code> treats <code>%</code> as the beginning of a
conversion specification, how can I print the <code>%</code>
character?</p>
</div>
<div class="QandA_answer">
<p>A: If <code>printf</code> encounters two consecutive <code>%</code>
characters in a format strring, it prints a single <code>%</code>
character. For example, the statement</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Net profit: %d%%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> profit<span class="op">);</span></span></code></pre></div>
<p>might print</p>
<pre class="shell"><code>Net profit: 10%</code></pre>
</div>
<div class="QandA_question">
<p>Q: The <code>\t</code> escape is supposed to cause
<code>printf</code> to advance to the next tab stop. How do I know how
far apart tab stops are? [p. 41]</p>
</div>
<div class="QandA_answer">
<p>A: You don’t. The effect of printing <code>\t</code> isn’t defined in
C; it depends on what your operating system does when asked to print a
tab character. Tab stops are typically eight characters apart, but C
makes no guarantee.</p>
</div>
<div class="QandA_question">
<p>Q: What does <code>scanf</code> do if it’s asked to read a number but
the user enters nonnumeric input?</p>
</div>
<div class="QandA_answer">
<p>A: Let’s look at the following example:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter a number: &quot;</span><span class="op">);</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span></code></pre></div>
<p>Suppose that the user enters a valid number, followed by nonnumeric
characters:</p>
<pre class="shell"><code>Enter a number: 23foo</code></pre>
<p>In this case, <code>scanf</code> reads the <code>2</code> and the
<code>3</code>, storing <code>23</code> in <code>i</code>. The remaining
characters (<code>foo</code>) are left to be read by the next call of
<code>scanf</code> (or some other input function). On the other hand,
suppose that the input is invalid from the beginning:</p>
<pre class="shell"><code>Enter a number: foo</code></pre>
<p>In this case, the value of <code>i</code> is undefined and
<code>foo</code> is left for the next <code>scanf</code>.</p>
<p>What can we do about this sad state of affairs? Later, we’ll see how
to test whether a call of <code>scanf</code> has succeeded. If the call
fails, we can have the program either terminate or try to recover,
perhaps by discarding the offending input and asking the user to try
again. (Ways to discard bad input are discussed in the Q&amp;A section
at the end of chapter 22.)</p>
</div>
<div class="QandA_question">
<p>Q: I don’t understand how <code>scanf</code> can “put back”
characters and read them again later. [p. 44]</p>
</div>
<div class="QandA_answer">
<p>A: As it turns out, programs don’t read user input as it is typed.
Instead input is stored in a hidden buffer, to which <code>scanf</code>
has access. It’s easy for <code>scanf</code> to put characters back into
the buffer for subsequent reading. Chapter 22 discusses input buffering
in more detail.</p>
</div>
<div class="QandA_question">
<p>Q: What does <code>scanf</code> do if the user puts punctuation marks
(commas, for example) between numbers?</p>
</div>
<div class="QandA_answer">
<p>A: Let’s look at a simple example. Suppose that we try to read a pair
of integers using <code>scanf</code>:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter two numbers: &quot;</span><span class="op">);</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
<p>If the user enters</p>
<pre class="shell"><code>4,28</code></pre>
<p><code>scanf</code> will read <code>4</code> and store it in
<code>i</code>, As it searches for the beginning of the second number,
<code>scanf</code> encounters the comma. Since numbers can’t begin with
a comma, <code>scanf</code> returns immediately. The comma and the
second number are left for the next call of <code>scanf</code>.</p>
<p>Of course, we can easily solve the problem by adding a comma to the
format string if we’re sure that the numbers will <em>always</em> be
separated by a comma:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter two numbers, separated by a comma: &quot;</span><span class="op">);</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d,%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
</div>
<h2 id="examples-1">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh03/cknkCh03Exmp/">./cknkCh03/cknkCh03Exmp/</a></li>
</ul>
<h2 id="exercises-1">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh03/cknkCh03Exrc/README.md">./cknkCh03/cknkCh03Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh03/cknkCh03Exrc/cknkCh03ExrcReadme.html">./cknkCh03/cknkCh03Exrc/cknkCh03ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh03/cknkCh03Exrc/">./cknkCh03/cknkCh03Exrc/</a></li>
</ul>
<h2 id="programming-projects-1">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh03/cknkCh03Prj/README.md">./cknkCh03/cknkCh03Prj/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh03/cknkCh03Prj/cknkCh03PrjReadme.html">./cknkCh03/cknkCh03Prj/cknkCh03PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh03/cknkCh03Prj/">./cknkCh03/cknkCh03Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="expressions">4 Expressions</h1>
<div class="theQuote">
<p>One does not learn computing by using a hand calculator, but one can
forget arithmetic.</p>
</div>
<p>One of C’s distinguishing characteristics is its emphasis on
expressions–formulas that show how to compute a value–rather than
statements. The simplest expressions are variables and constants. A
variable represents a value to be computed as the program runs; a
constant represents a value that doesn’t change. More complicated
expressions apply operators to operands (which are themselves
expressions). In the expression <code>a + (b * c)</code>, the
<code>+</code> operator is applied to the operands <code>a</code> and
<code>(b * c)</code>, both of which are expressions in their own
right.</p>
<p>Operators are the basic tools for building expressions, and C has an
unusually rich collection of them. To start off, C provides the
rudimentary operators that are found in most programming
languages:<br />
- Arithmetic operators, including addition, subtraction, multiplication,
and division.<br />
- Relational operators to perform comparisons such as “<code>i</code> is
<em>greater than</em> 0.”<br />
- Logical operators to build conditions such as “<code>i</code> is
greater than 0 <em>and</em> <code>i</code> is less than 10.”</p>
<p>But C doesn’t stop here; it goes on to provide dozens of other
operators. There are so many operators, in fact, that we’ll need to
introduce them gradually over the first twenty chapters of this book.
Mastering so many operators can be a chore, but it’s essential to
becoming proficient at C.</p>
<p>In this chapter, we’ll cover some of C’s most fundamental operators:
the arithmetic operators (Section 4.1), the assignment operators
(Section 4.2), and the increment and decrement operators (Section 4.3).
Section 4.1 also explains operator precedence and associativity, which
are important for expressions that contain more than one operator.
Section 4.4 describes how C expressions are evaluated. Finally, Section
4.5 introduces the expression statement, an unusual feature that allows
any expression to serve as a statement.</p>
<h2 id="arithmetic-operators">4.1 Arithmetic Operators</h2>
<p>The <strong><em>arithmetic operators</em></strong>–operators that
perform addition, subtraction, multiplication, and division–are the
workhorses of many programming languages, including C. Table 4.1 shows
C’s arithmetic operators.</p>
<p><strong>Table 4.1:</strong> Arithmetic Operators</p>
<table>
<thead>
<tr>
<th rowspan="2" style="text-align: center">
<p><strong><em>Unary</em></strong></p>
</th>
<th colspan="2" style="text-align: center">
<p><strong><em>Binary</em></strong></p>
</th>
</tr>
<tr>
<th style="text-align: center">
<p><strong><em>Additive</em></strong></p>
</th>
<th style="text-align: center">
<p><strong><em>Multiplicative</em></strong></p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><code>+</code> unary plus</p>
</td>
<td>
<p><code>+</code> addition</p>
</td>
<td>
<p><code>*</code> multiplication</p>
</td>
</tr>
<tr>
<td>
<p><code>-</code> unary minus</p>
</td>
<td>
<p><code>-</code> subtraction</p>
</td>
<td>
<p><code>/</code> division</p>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
<p><code>%</code> remainder</p>
</td>
</tr>
</tbody>
</table>
<p>The additive and multiplicative operators are said to be
<strong><em>binary</em></strong> because they require <em>two</em>
operands. The <strong><em>unary</em></strong> operators require
<em>one</em> operand:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">+</span><span class="dv">1</span><span class="op">;</span>    <span class="co">/* + used as a unary operator */</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span>    <span class="co">/* - used as a unary operator */</span></span></code></pre></div>
<p>The unary <code>+</code> operator does nothing; in fact, it didn’t
even exist in K &amp; R C. It’s used primarily to emphasize that a
numeric constant is positive.</p>
<p>The binary operators probably look familiar. The only one that might
not is <code>%</code>, the remainder operator. The value of
<code>i % j</code> is the remainder when <code>i</code> is divided by
<code>j</code>. For example, the value of <code>10 % 3</code> is 1, and
the value of <code>12 % 4</code> is 0.</p>
<p><span class="QandA"></span></p>
<p>The binary operators in Table 4.1–with the exception of
<code>%</code>–allow either integer or floating-point operands, with
mixing allowed. When <code>int</code> and <code>float</code> operands
are mixed, the result has type <code>float</code>. Thus,
<code>9 + 2.5f</code> has the value <code>11.5</code>, and
<code>6.7f / 2</code> has the value <code>3.35</code>.</p>
<p>The <code>/</code> and <code>%</code> operators require special
care:</p>
<ul>
<li>
<p>The <code>/</code> operator can produce surprising results. When both
of its operands are integers, the <code>/</code> operator “truncates”
the result by dropping the fractional part. Thus, the value of
<code>1 / 2</code> is 0, not <code>0.5</code>.</p>
</li>
<li>
<p>The <code>%</code> operator requires integer operands; if either
operand is not an integer, the program won’t compile.</p>
</li>
<li>
<p>Using zero as the right operand of either <code>/</code> or
<code>%</code> causes undefined behavior.</p>
</li>
<li>
<p><span class="QandA"></span></p>
<p><span class="C99Symbol"></span></p>
<p>Describing the result when <code>/</code> and <code>%</code> are used
with negative operands is tricky. The C89 standard states that if either
operand is negative, the result of a division can be rounded either up
or down. (For example, the value of <code>-9 / 7</code> could be either
-1 or -2). If <code>i</code> or <code>j</code> is negative, the sign of
<code>i % j</code> in C89 depends on the implementation. (For example,
the value of <code>-9 % 7</code> could be either -2 or 5). In C99, on
the other hand, the result of a division is always truncated toward zero
(so <code>-9 / 7</code> has the value -1) and the value of
<code>i % j</code> has the same sign as <code>i</code> (hence the value
of <code>-9 % 7</code> is -2).</p>
</li>
</ul>
<section id="implementation-defined-behaviour" class="infoBox">
<h3>Implementation-Defined Behaviour</h3>
<p>The term <strong><em>Implementation-defined</em></strong> will arise
often enough that it’s worth taking a moment to discuss it. The C
standard deliberately leaves parts of the language unspecified, with the
understanding that an “implementation”–the software needed to compile,
link, and execute programs on a particular platform–will fill in the
details. As a result, the behavior of the program may vary somewhat from
one implementation to another. The behavior of the <code>/</code> and
<code>%</code> operators for negative operands in C89 is an example of
implementation-defined behavior.</p>
<p>Leaving parts of the language unspecified may seem odd or even
dangerous, but it reflects C’s philosophy. One of the language’s goals
is efficiency, which often means matching the way that hardware behaves.
Some CPUs yield -1 when -9 is divided by 7, while others produce -2; the
C89 standard simply reflects this fact of life.</p>
<p>It’s best to avoid writing programs that depend on
implementation-defined behavior. If that’s not possible, at least check
the manual carefully–the C standard requires that implementation-defined
behaior be documented.</p>
</section>
<h3 id="operator-precedence-and-associativity">4.1.1 Operator Precedence
and Associativity</h3>
<p>When an expression contains more than one operator, its
interpretation may not be immediately clear. For example, does
<code>i + j * k</code> mean “add <code>i</code> and <code>j</code>, then
multiply the result by <code>k</code>,” or does it mean “multiply
<code>j</code> and <code>k</code>, then add <code>i</code>”? One
solution to this problem is to add parentheses, writing either
<code>(i + j) * k</code> or <code>i + (j * K)</code>. As a general rule,
C allows the use of parentheses for grouping in all expressions.</p>
<p>What if we don’t use parentheses, though? Will the compiler interpret
<code>i + j * k</code> as <code>(i + j) * k</code> or
<code>i + (j * k)</code>? Like many other languages, C user
<strong><em>operator precedence</em></strong> rules to resolve this
potential ambiguity. The arithmetic operators have the following
relative precedence:</p>
<table>
<tbody>
<tr class="odd">
<td>Highest:</td>
<td><code>+</code></td>
<td><code>-</code></td>
<td>(unary)</td>
</tr>
<tr class="even">
<td></td>
<td><code>*</code></td>
<td><code>/</code></td>
<td><code>%</code></td>
</tr>
<tr class="odd">
<td>Lowest:</td>
<td><code>+</code></td>
<td><code>-</code></td>
<td>(binary)</td>
</tr>
</tbody>
</table>
<p>Operators listed on the same line (such as <code>+</code> and
<code>-</code>) have equal precedence.</p>
<p>When two or more operators appear in the same expression, we can
determine how the compiler will interpret the expression by repeatedly
putting parentheses around subexpressions, starting with high-precedence
operators and working down to low-precedence operators. The following
examples illustrate the result:</p>
<table>
<tbody>
<tr class="odd">
<td><code>i + j * k</code></td>
<td>is equivalent to</td>
<td><code>i + (j * k)</code></td>
</tr>
<tr class="even">
<td><code>-i * -j</code></td>
<td>is equivalent to</td>
<td><code>(-i) * (-j)</code></td>
</tr>
<tr class="odd">
<td><code>+i + j / k</code></td>
<td>is equivalent to</td>
<td><code>(+i) + (j / k)</code></td>
</tr>
</tbody>
</table>
<p>Operator precedence rules alone aren’t enough when an expression
contains two or more operators at the same level of precedence. In this
situation, the <strong><em>associativity</em></strong> of the operators
comes into play. An operator is said to be <strong><em>left
associative</em></strong> if it groups from left to right. The binary
arithmetic operators (<code>*</code>, <code>/</code>, <code>%</code>,
<code>+</code>, and <code>-</code>) are all left associative, so</p>
<table>
<tbody>
<tr class="odd">
<td><code>i - j - k</code></td>
<td>is equivalent to</td>
<td><code>(i - j) - k</code></td>
</tr>
<tr class="even">
<td><code>i * j / k</code></td>
<td>is equivalent to</td>
<td><code>(i * j) / k</code></td>
</tr>
</tbody>
</table>
<p>An operator is <strong><em>right associative</em></strong> if it
groups from right to left. The unary arithmetic operators
(<code>+</code> and <code>-</code>) are both right associative, so</p>
<table>
<tbody>
<tr class="odd">
<td><code>- + i</code></td>
<td>is equivalent to</td>
<td><code>-(+i)</code></td>
</tr>
</tbody>
</table>
<p>Precedence and associativity rules are important in many laguages,
but especially so in C. However, C has so many operators (almost fifty!)
that few programmers bother to memorize the precedence and associativity
rules. Instead, they consult a table of operators when in doubt or just
use plenty of parentheses.</p>
<h3 id="program-computing-a-upc-check-digit">4.1.2 (PROGRAM) Computing a
UPC Check Digit</h3>
<p>For a number of years, manufacturers of goods sold in U.S. and
Canadian stores have put a bar code on each product. This code, known as
a Universal Product Code (UPC), identifies both the manufacturer and the
product. Each bar code represents a twelve-digit number, which is
usually printed underneath the bars. For example, the following bar code
comes from a package of Stouffer’s French Bread Pepperoni Pizza:</p>
<p><img src="./images/cknkCh04_barcode.jpg" style="width:200px; position: relative; left: 50%; right: 50%"/></p>
<p>The digits <code>0  13800 15173  5</code> appear underneath the bar
code. The first digit identifies the type of item (0 or 7 for most
items, 2 for items that must be weighed, 3 for drugs and health-related
merchandise, and 5 for coupons). The first group of five digits
identifies the manufacturer (13800 is the code for Nestlé USA’s Frozen
Food Division). The second group of five digits identifies the product
(including package size). The final digit is a “check digit,” whose only
purpose is to help identify an error in the preceding digits. If the UPC
is scanned incorrectly, the first 11 digits probably won’t be consistent
with the last digit, and the store’s scanner will reject the entire
code.</p>
<p>Here’s one method of computing the check digit:</p>
<blockquote>
<p>Add the first, third, fifth, seventh, ninth, and eleventh
digits.<br />
Add the second, fourth, sixth, eighth, and tenth digits.<br />
Multiply the first sum by 3 and add it to the second sum.<br />
Subtract 1 from the total.<br />
Compute the remainder when the adjusted total is divided by 10.<br />
Subtract the remainder fom 9.</p>
</blockquote>
<p>Using the Stouffer’s example, we get <span
class="displayInlineMath"><span
class="math display">0 + 3 + 0 + 1 + 1 + 3 = 8</span></span> for the
first sum and <span class="displayInlineMath"><span
class="math display">1 + 8 + 0 + 5 + 7 = 21</span></span> for the second
sum. Multiplying the first sum by 3 and adding the second yields 45.
Subtracting 1 gives 44. The remainder upon dividing by 10 is 4. When the
remainder is subtracted from 9, the result is 5. Here are a couple of
other UPCs, in case you want to try your hand at computing the check
digit (raiding the kitchen cabinet for the answer is <em>not</em>
allowed):</p>
<p>Jif Creamy Peanut Butter (18 oz.):
<code>0   51500 24128   ?</code><br />
Ocean Spray Jellied Cranberry Sauce (8 oz.):
<code>0   31200 01005   ?</code></p>
<p>The answers: 8 for Jif and 6 for Ocean Spray.</p>
<p>Let’s write a program that calculates the check digit for an
arbitrary UPC. We’ll ask the user to enter the first 11 digits of the
UPC, then we’ll display the corresponding check digit. To avoid
confusion, we’ll ask the user to enter the number in three parts: the
single digit at the left, the first group of five digits, and the second
group of five digits. Here’s what a session with the program will look
like:</p>
<pre class="shell"><code>Enter the first (single) digit: 0
Enter first group of five digits: 138000
Enter second group of five digits: 15173
Check digit: 5</code></pre>
<p>Instead of reading each digit group as a <em>five</em>-digit number,
we’ll read it as five <em>one</em>-digit numbers. Reading the numbers as
single digits is more convenient; also, we won’t have to worry that one
of the five-digit numbers is too large to store in an <code>int</code>
variable. (Some older compilers limit the maximum value of an
<code>int</code> variable to 32,767.) To read single digits, we’ll use
<code>scanf</code> with the <code>%1d</code> conversion specification,
which matches a one-digit integer.</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: upc.c</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Computes a Universal Product Code check digit</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d<span class="op">,</span> i1<span class="op">,</span> i2<span class="op">,</span> i3<span class="op">,</span> i4<span class="op">,</span> i5<span class="op">,</span> j1<span class="op">,</span> j2<span class="op">,</span> j3<span class="op">,</span> j4<span class="op">,</span> j5<span class="op">,</span> first_sum<span class="op">,</span> second_sum<span class="op">,</span> total<span class="op">;</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter the first (single) digit: &quot;</span><span class="op">);</span></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>d<span class="op">);</span></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter first group of five digits: &quot;</span><span class="op">);</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d%1d%1d%1d%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i1<span class="op">,</span> <span class="op">&amp;</span>i2<span class="op">,</span> <span class="op">&amp;</span>i3<span class="op">,</span> <span class="op">&amp;</span>i4<span class="op">,</span> <span class="op">&amp;</span>i5<span class="op">);</span></span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter second group of five digits: &quot;</span><span class="op">);</span></span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d%1d%1d%1d%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>j1<span class="op">,</span> <span class="op">&amp;</span>j2<span class="op">,</span> <span class="op">&amp;</span>j3<span class="op">,</span> <span class="op">&amp;</span>j4<span class="op">,</span> <span class="op">&amp;</span>j5<span class="op">);</span></span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>    first_sum <span class="op">=</span> d <span class="op">+</span> i2 <span class="op">+</span> i4 <span class="op">+</span> j1 <span class="op">+</span> j3 <span class="op">+</span> j5<span class="op">;</span></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>    second_sum <span class="op">=</span> i1 <span class="op">+</span> i3 <span class="op">+</span> i5 <span class="op">+</span> j2 <span class="op">+</span> j4<span class="op">;</span></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> first_sum <span class="op">+</span> second_sum<span class="op">;</span></span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Check digit: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">9</span> <span class="op">-</span> <span class="op">((</span>total <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="dv">10</span><span class="op">));</span></span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the expression <code>9 - ((total - 1) % 10)</code> could
have been written as <code>9 - (total - 1) % 10</code>, but the extra
set of parentheses makes it easier to understand.</p>
<h2 id="assignment-operators">4.2 Assignment Operators</h2>
<p>Once the value of an expression has been computed, we’ll often need
to store it in a variable for later use. C’s <code>=</code>
(<strong><em>simple assignment</em></strong>) operator is used for that
purpose. For updating a value already stored in a variable, C provides
an assortment of compound assignment operators.</p>
<h3 id="simple-assignment">4.2.1 Simple Assignment</h3>
<p>The effect of the assignment <span class="displayInlineMath"><span
class="math display"><em>v</em> = <em>e</em></span></span> is to
evaluate the expression <code>e</code> and copy its value into
<code>v</code>. As the following examples show, <code>e</code> can be a
constant, a variable, or a more complicated expression:</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>    <span class="co">/* i is now 5 */</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> i<span class="op">;</span>    <span class="co">/* j is now 5 */</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> i <span class="op">+</span> j<span class="op">;</span>    <span class="co">/* k is now 55 */</span></span></code></pre></div>
<p>If <code>v</code> and <code>e</code> don’t have the same type, then
the value of <code>e</code> is converted to the type of <code>v</code>
as the assignment takes place:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="fl">72.99</span><span class="bu">f</span><span class="op">;</span>    <span class="co">/* i is now 72 */</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="dv">136</span><span class="op">;</span>    <span class="co">/* f is now 136.0 */</span></span></code></pre></div>
<p>We’ll return to the topic of type conversion later.</p>
<p>In many programming languages, assignment is a <em>statement</em>; in
C, however, assignment is an <em>operator</em>, just like
<code>+</code>. In other words, the act of assignment produces a result,
just as adding two numbers produces a result. The value of an assignment
<span class="displayInlineMath"><span
class="math display"><em>v</em> = <em>e</em></span></span> is the value
of <code>v</code> after the assignment. Thus, the value of
<code>i = 72.99f</code> is 72 (not 72.99).</p>
<section id="side-effects" class="infoBox">
<h3>Side effects</h3>
<p>We don’t normally expect operators to modify their operands, since
operators in mathematics don’t. Writing <code>i + j</code> doesn’t
modify either <code>i</code> or <code>j</code>; it simply computes the
result of adding <code>i</code> and <code>j</code>.</p>
<p>Most C operators don’t modify their operands, but some do. We say
that these operators have <strong><em>side effects</em></strong>, since
they do more than just compute a value. The simple assignment operator
is the first operator we’ve seen that has side effects; it modifies its
left operand. Evaluating the expression <code>i = 0</code> produces the
result 0 and–as a side effect–assigns 0 to <code>i</code>.</p>
</section>
<p>Since assignment is an operator, several assignments can be chained
together:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> j <span class="op">=</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>The <code>=</code> operator is right associative, so this assignment
is equivalent to</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">(</span>j <span class="op">=</span> <span class="op">(</span>k <span class="op">=</span> <span class="dv">0</span><span class="op">));</span></span></code></pre></div>
<p>The effect is to assign 0 first to <code>k</code>, then to
<code>j</code>, and finally to <code>i</code>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Watch out for unexpected results in chained assignments as a result
of type conversion:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> i <span class="op">=</span> <span class="fl">33.3</span><span class="bu">f</span><span class="op">;</span></span></code></pre></div>
<p><code>i</code> is assigned the value 33, then <code>f</code> is
assigned 33.0 (not 33.3, as you might think).</p>
</div>
<p>In general, an assignment of the form <code>v = e</code> is allowed
wherever a value of type <code>v</code> would be permitted. In the
following example, the expression <code>j = i</code> copies
<code>i</code> to <code>j</code>; the new value of <code>j</code> is
then added to 1, producing the new value of <code>k</code>:</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="op">(</span>j <span class="op">=</span> i<span class="op">);</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">);</span>    <span class="co">/*prints &quot;1 1 2&quot; */</span></span></code></pre></div>
<p>Using the assignment operator in this fashion usually isn’t a good
idea. For one thing, “embedded assignments” can make programs hard to
read. They can also be a source of subtle bugs, as we’ll see in Section
4.4.</p>
<h3 id="lvalues">4.2.2 Lvalues</h3>
<p>Most C operators allow their operands to be variables, constants, or
expressions containing other operators. The assignment operator,
however, requires an <strong><em>lvalue</em></strong> as its left
operand. An lvalue (pronounced “L-value”) represents an object stored in
computer memory, not a constant or the result of a computation.
Variables are lvalues; expressions such as <code>10</code> or
<code>2 * i</code> are not. At this point, variables are the only
lvalues that we know about; other kinds of lvalues will appear in later
chapters.</p>
<p>Since the assignment operator requires an lvalue as its left operand,
it’s illegal to put any other kind of expression on the left side of an
assignment expression:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span> <span class="op">=</span> i<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">+</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="op">-</span>i <span class="op">=</span> j<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>The compiler will detect errors of this nature, and you’ll get an
error message such as “<em>invalid lvalue in assignment</em>.”</p>
<h3 id="compound-assignment">3.2.3 Compound Assignment</h3>
<p>Assignments that use the old value of a variable to compute its new
value are common in C programs. The following statement, for example,
adds 2 to the value stored in <code>i</code>:</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>C’s <strong><em>compound assignment</em></strong> operators allow us
to shorten this statement and others like it. Using the <code>+=</code>
operator, we simply write:</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span>    <span class="co">/* same as i = i + 2; */</span></span></code></pre></div>
<p>The <code>+=</code> operator adds the value of the right operand to
the variable on the left.</p>
<p>There are nine other compound assignment operators, including the
following:</p>
<p><code>-=   *=   /=   %=</code></p>
<p>(We’ll cover the remaining compound assignment operators in a later
chapter.) All compound assignment operators work in much the same
way:</p>
<blockquote>
<p><code>v += e</code> adds <code>v</code> to <code>e</code>, storing
the result in <code>v</code><br />
<code>v -= e</code> subtracts <code>e</code> from <code>v</code>,
storing the result in <code>v</code><br />
<code>v *= e</code> multiplies <code>v</code> by <code>e</code>, storing
the result in <code>v</code><br />
<code>v /= e</code> divides <code>v</code> by <code>e</code>, storing
the result in <code>v</code><br />
<code>v %= e</code> computes the remainder when <code>v</code> is
divided by <code>e</code>, storing the result in <code>v</code>.</p>
</blockquote>
<p><span class="QandA"></span></p>
<p>Note that I’ve been careful not to say that <code>v += e</code> is
“equivalent” to <code>v = v + e</code>. One problem is operator
precedence: <code>i *= j + k</code> isn’t the same as
<code>i = i * j + k</code>. There are also rare cases in which
<code>v += e</code> differs from <code>v = v + e</code> because
<code>v</code> itself has a side effect. Similar remarks apply to the
other compound assignment operators.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>When using the compound assignment operators, be carefull not to
switch the two characters that make up the operator. Switching the
characters may yield an expression that is acceptable to the compiler
but that doesn’t have the intended meaning. For example, if you meant to
write <code>i += j</code> but you typed <code>i =+ j</code> instead, the
program will still compile. Unfortunately, the latter expression is
equivalent to <code>i = (+j)</code>, which merely copies the value of
<code>j</code> into <code>i</code>.</p>
</div>
<p>The compound assignment operators have the same properties as the
<code>=</code> operator. In particular, they’re right associative, so
the statement</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> j <span class="op">+=</span> k<span class="op">;</span></span></code></pre></div>
<p>means</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="op">(</span>j <span class="op">+=</span> k<span class="op">);</span></span></code></pre></div>
<h2 id="incremet-and-decrement-operators">4.3 Incremet and Decrement
Operators</h2>
<p>Two of the most common operations on a variable are “incrementing”
(adding 1) and “decrementing” (subtracting 1). We can, of course,
accomplish these tasks by writing</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> j <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>The compound assignment operators allow us to condense these
statements a bit:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>But C allows increments and decrements to be shortened even further,
using the <code>++</code> (<strong><em>increment</em></strong>) and
<code>--</code> (<strong><em>decrement</em></strong>) operators.</p>
<p>At first glance, the increment and decrement operators are simplicity
itself: <code>++</code> adds 1 to its operand, whereas <code>--</code>
subtracts 1. Unfortunately, this simplicity is misleading–the increment
and decrement operators can be tricky to use. One complication is that
<code>++</code> and <code>--</code> can be used as
<strong><em>prefix</em></strong> operators (<code>++i</code> and
<code>--i</code>, for example) or <strong><em>postfix</em></strong>
operators (<code>i++</code> and <code>i--</code>). The correctness of a
program may hinge on picking the proper version.</p>
<p>Another complication is that, like the assignment operators,
<code>++</code> and <code>--</code> have side effects: they modify the
values of their operands. Evaluating the expression <code>++i</code> (a
“pre-increment”) yields <code>i + 1</code> and–as a side
effect–increments <code>i</code>:</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">++</span>i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span></code></pre></div>
<p>Evaluating th expression <code>i++</code> (a “post-increment”)
produces the result <code>i</code>, but causes <code>i</code> to be
incremented afterwards:</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">++);</span>    <span class="co">/* prints &quot;i is 1&quot; */</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>The first <code>printf</code> shows the original value of
<code>i</code>, before it is incremented. The second <code>printf</code>
shows the new value. As these examples illustrate, <code>++i</code>
means “increment <code>i</code> immediately,” while <code>i++</code>
means “use the old value of <code>i</code> for now, but increment
<code>i</code> later.” How much later? The C standard doesn’t specify a
precise time, but it’s safe to assume that <code>i</code> will be
incremented before the next statement is executed.</p>
<p>The <code>--</code> operator has similar properties:</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">--</span>i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span></code></pre></div>
<div class="sourceCode" id="cb132"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span>    <span class="co">/* prints &quot;i is 1&quot; */</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span></code></pre></div>
<p>When <code>++</code> or <code>--</code> is used more than once in the
same expression, the result can often be hard to understand. Consider
the following statements:</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="op">++</span>i <span class="op">+</span> j<span class="op">++;</span></span></code></pre></div>
<p>What are the values of <code>i</code>, <code>j</code> and
<code>k</code> after these statements are executed? Since <code>i</code>
is incremented <em>before</em> its value is used, but <code>j</code> is
incremented <em>after</em> it is used, the last statement is equivalent
to</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> i <span class="op">+</span> j<span class="op">;</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>so the final values of <code>i</code>, <code>j</code>, and
<code>k</code> are 2, 3, and 4, respectively. In contrast, executing the
statements</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> i<span class="op">++</span> <span class="op">+</span> j<span class="op">++;</span></span></code></pre></div>
<p>will give <code>i</code>, <code>j</code>, and <code>k</code> the
values 2, 3, and 3, respectively.</p>
<p>For the record, the postfix versions of <code>++</code> and
<code>--</code> have higher precedence than unary plus and minus and are
left associative. The prefix versions have the same precedence as unary
plus and minus and are right associative.</p>
</body>
</html>
