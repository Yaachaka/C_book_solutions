<html>
<head>
<title>
C Programming
</title>
<meta charset="utf-8">
<link rel="stylesheet" href="./myStyle.css">
</head>
<body>
<h1 id="title-of-the-book-c-programming-a-modern-approach">Title of the
Book: C Programming A Modern Approach</h1>
<h2 id="edition-second-edition-2008">Edition: Second Edition (2008)</h2>
<h3 id="author-k.n.king">Author: K.N.King</h3>
<p><i>A clear, complete, and engaging presentation of the C programming
language – now with coverage of both C89 and C99.</i></p>
<div class="theQuote">
In computing, turning the obvious into the useful is a living definition
of the word “frustration.”
</div>
<hr class="chapterDivider"/>
<h1 id="introducing-c">1 Introducing C</h1>
<div class="theQuote">
When someone says “I want a programming language in which I need only
say what I wish done,” give him a lollipop.
</div>
<p><strong>Few points on C:</strong><br />
- Developed in the early 1970s at Bell Laboratories by <strong>Ken
Thompson</strong>, <strong>Dennis Ritchie</strong>, and others.<br />
- <em>The C Programming Language</em>, written by <strong>Brian
Kernighan</strong> and <strong>Dennis Ritchie</strong> published in
1978.<br />
- In December 1989, standardisation of C under <em>ANSI (American
National Standards Institute)</em> was approved as <em>ANSI standard
X3.159-1989</em>.<br />
- In 1990, it was approved by the <em>International Organization for
Standardization (ISO)</em> as <em>internation standard ISO/IEC
9899:1990</em>.</p>
<hr class="chapterDivider"/>
<h1 id="c-fundamentals">2 C Fundamentals</h1>
<div class="theQuote">
One man’s constant is another man’s variable
</div>
<p>This chapter introduces several basic concepts, including
preprocessing directives, functions, variables, and statements, that
we’ll need in order to write even the simplest programs. Later chapters
will cover these topics in much greater detail.</p>
<p>To start off, Section 2.1 presents a small C program and describes
how to compile and link it. Section 2.2 then discusses how to generalize
the program, and Section 2.3 shows how to add explantory remarks, known
as comments. Section 2.4 introduces variables, which store data that may
change during the execution of a program, and Section 2.5 shows how to
use the <code>scanf</code> function to read data into variables.
Constants – data that won’t change during program execution – can be
given names, as Section 2.6 shows. Finally, Section 2.7 explains C’s
rules for creating names (identifiers) and Section 2.8 gives the rules
for laying out a program.</p>
<h2 id="writing-a-simple-program">2.1 Writing a Simple Program</h2>
<p>In contrast to programs written in some languages, C programs require
little “boilerplate” – a complete program can be as short as a few
lines.</p>
<h3 id="program-printing-a-pun">2.1.1 (PROGRAM) Printing a Pun</h3>
<p>The first program which we will name <code>pun.c</code>, is expected
to display the following message each time it is run.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">To</span> C, or not to C: that is the question.</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: pun.c */</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Section 2.2 explains the form of this program in some detail. For
now, I’ll just make a few brief observations. The line</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span></code></pre></div>
<p>is necessary to “include” information about C’s standard I/O
(input/output) library. The program’s executable code goes inside
<code>main</code>, which represents the “main” program. The only line
inside <code>main</code> is a command to display the desired message.
<code>printf</code> is a function from the standard I/O library that can
produce nicely formatted output. The <code>\n</code> code tells
<code>printf</code> to advance to the next line after printing the
message. The line</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>indicates that the program “returns” the value 0 to the operating
system when it terminates.</p>
<h3 id="compiling-and-linking">2.1.2 Compiling and Linking</h3>
<p>Despite its brevity, getting <code>pun.c</code> to run is more
involved than you might expect. First, we need to create a file named
<code>pun.c</code> containing the program (any text editor will do). The
name of the file doesn’t matter, but the <code>.c</code> extension is
often required by compilers.</p>
<p>Next, we’ve got to convert the program to a form that the machine can
execute. For a C program, that usually involves three steps:</p>
<ul>
<li><strong>Preprocessing.</strong> The program is first given to a
<strong>preprocessor</strong>, which obeys commands that begin with
<code>#</code> (known as <strong><em>directives</em></strong>). A
preprocessor is a bit like an editor; it can add things to the program
and make modifications.<br />
</li>
<li><strong>Compiling.</strong> The modified program now goes to a
<strong>Compiler</strong>. which translates it into machine instructions
(<strong><em>object code</em></strong>). The program isn’t quite ready
to run yet, however.<br />
</li>
<li><strong>Linking.</strong> In the final step, a
<strong>linker</strong> combines the object code produced by the
compiler with any additional code needed to yield a complete executable
program. This additional code includes library functions (like
<code>printf</code>) that are used in the program.</li>
</ul>
<p>Fortunately, this process is often automated, so you won’t find it
too onerous. In fact, the preprocessor is usually integrated with the
compiler, so you probably won’t even notice it at work.</p>
<p>The commands necessary to compile and link vary, depending on the
compiler and operating system. Under UNIX, the C compiler is usually
named <code>cc</code>. To compile and link the <code>pun.c</code>
program, enter the following command in a terminal or command-line
window:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> cc pun.c</span></code></pre></div>
<p>(The <code>%</code> character is the UNIX prompt, not something that
you need to enter.) Linking is automatic when using <code>cc</code>; no
separate link command is necessary.</p>
<p>After compiling and linking the program, <code>cc</code> leaves the
executable program in a file named <code>a.out</code> by default.
<code>cc</code> has many options; one of them (the <code>-o</code>
option) allows us to choose the name of the file containing the
executable program. For example, if we want the executable version of
<code>pun.c</code> to be named <code>pun</code>, we would enter the
following command:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> cc <span class="at">-o</span> pun pun.c</span></code></pre></div>
<section id="the-gcc-compiler" class="infoBox">
<h3>The GCC Compiler</h3>
<p>One of the most popular C compilers is the GCC compiler, which is
supplied with Linux but is available for many other platforms as well.
Using this compiler is similar to using the traditional UNIX
<code>cc</code> compiler. For example, to compile the <code>pun.c</code>
program, we would use the following command:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> gcc <span class="at">-o</span> pun pun.c</span></code></pre></div>
<p>The Q&amp;A section at the end of the chapter provides more
information about GCC.</p>
</section>
<h3 id="integrated-development-environments">2.1.3 Integrated
development environments</h3>
<p>so far, we’ve assumed the use of a “command-line” compiler that’s
invoked by entering a command in a special window provided by the
operating system. The alternative is to use an <strong><em>integrated
development environment (IDE)</em></strong>, a software package that
allows us to
<code>edit, compile, link, execute, and even debug a program</code>
without leaving the environment. The components of an IDE are designed
to work together. For example, when the compiler detects an error in a
program, it can arrange for the editor to highlight the line that
contains the error. There’s a great deal of variation among IDEs, so I
won’t discuss them further in this book. However, I would recommend
checking to see which IDEs are available for your platform.</p>
<h2 id="the-general-form-of-a-simple-program">2.2 The General Form of a
Simple Program</h2>
<p>Let’s take a closer look at <code>pun.c</code> and see how we can
generalize it a bit. Simple C programs have the form</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>directives</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    statements</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice how the braces show where <code>main</code> begins and ends. C
uses <code>{</code> and <code>}</code> in much the same way that some
other languages use words like <code>begin</code> and <code>end</code>.
This illustrates a general point about C: it relies heavily on
abbreviations and special symbols, one reason that C programs are
concise (or – less charitably – cryptic).</p>
<p>Even the simplest C programs rely on three key language features:
directives (editing commands that modify the program prior to
compilation), functions (named blocks of executable code, of which
<code>main</code> is an example), and statements (commands to be
performed when the program is run). We’ll take a closer look at these
features now.</p>
<h3 id="directives">2.2.1 Directives</h3>
<p>Before a C program is compiled, it is first edited by a preprocessor.
Commands intended for the preprocessor are called directives. Chapter 14
and Chapter 15 discuss directives in detail. For now, we’re interested
only in the <code>#include</code> directive.</p>
<p>The <code>pun.c</code> program begins with the line</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span></code></pre></div>
<p>This directive states that the information is
<code>&lt;stdio.h&gt;</code> is to be “included” into the program before
it is compiled. <code>&lt;stdio.h&gt;</code> contains information about
C’s standard I/O library. C has a number of <em>headers</em> like
<code>&lt;stdio.h&gt;</code>; each contains information about some part
of the standard library. The reason we’re including
<code>&lt;stdio.h&gt;</code> is that C, unlike some programming
languages, has no built-in “read” and “write” commands. The ability to
perform input and output is provided instead by functions in the
standard library.</p>
<p>Directives always begin with <code>#</code> character, which
distinguishes them from other items in a C program. By default,
directives are one line long; there’s no semicolon or other special
marker at the end of a directive.</p>
<h3 id="functions">2.2.2 Functions</h3>
<p><strong>Functions</strong> are like “procedures” or “subroutines” in
other programming languages – they’re the building blocks from which
programs are constructed. In fact, a C program is little more than a
collection of functions. Functions fall into two categories: those
written by the programmer and those provided as part of the c
implementation. I’ll refer to the latter as <em>library functions</em>,
since they belong to a “library” of functions that are supplied with the
compiler.</p>
<p>The term “function” comes from mathematics, where a function is a
rule for computing a value when given one or more arguments:</p>
<p><span
class="math display"><em>f</em>(<em>x</em>) = <em>x</em> + 1</span></p>
<p><span
class="math display"><em>g</em>(<em>y</em>,<em>z</em>) = <em>y</em><sup>2</sup> − <em>z</em><sup>2</sup></span></p>
<p>C uses the term “function” more loosely. In C, a function is simply a
series of statements that have been grouped together and given a name.
Some functions compute a value; some don’t. A function that computes a
value uses the <code>return</code> statement to specify what value it
“returns.” For example, a function that adds 1 to its argument might
execute the statement <code>return x + 1;</code> while a function that
computes the difference of the squares of its arguments might execute
the statement <code>return y * y - z * z;</code></p>
<p>Although a C program may consist of many functions, only the
<code>main</code> function is mandatory. <code>main</code> is special:
it gets called automatically when the program is executed. Until Chapter
9, where we’ll learn how to write other functions, <code>main</code>
will be the only function in our programs.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>The name <code>main</code> is critical; it can’t be
<code>begin</code> or <code>start</code> or even <code>MAIN</code>.</p>
</div>
<p>If <code>main</code> is a function, does it return a value? Yes: it
returns a status code that is given to the operating system when the
program terminates. Let’s take another look at the <code>pun.c</code>
program:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The word <code>int</code> just before <code>main</code> indicates
that the <code>main</code> function returns an integer value. The word
<code>void</code> in parenthesis indicates that <code>mian</code> has no
arguments.</p>
<p>The statement <code>return 0;</code> has two effects: it causes the
main function to terminate (thus ending the program) and it indicates
that the <code>main</code> function returns a value of 0. We will have
more to say about <code>main</code>’s return value in a later chapter.
For now, we’ll always have <code>main</code> return the value 0, which
indicates normal program termination.</p>
<p>If there’s no <code>return</code> statement at the end of the
<code>main</code> function, the program will still terminate. However,
many compilers will produce a warning message (because the function was
supposed to return an integer but failed to).</p>
<h3 id="statements">2.2.3 Statements</h3>
<p>A <strong>Statement</strong> is a command to be executed when the
program runs. We’ll explore statements later in the book, primarily in
Chpater 5 and 6. The <code>pun.c</code> program uses only two kinds of
statements. One is the <code>return</code> statement; the other is the
<em>function call</em>. Asking a function to perform its assigned task
is known as <em>calling</em> the function. The <code>pun.c</code>
program, for example, calls the <code>printf</code> function to display
a string on the screen:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question. </span><span class="sc">\n</span><span class="st">);</span></span></code></pre></div>
<p>C requires that each statement end with a semicolon. (As with any
good rule, there’s one exception: the compound statement, which we’ll
encounter later.) The semicolon shows the compiler where the statement
ends; since statements can continue over several lines, it’s not always
obvious where they end. Directives, on the other hand, are normally one
line long, and they don’t end with a semicolon.</p>
<h3 id="printing-strings">2.2.4 Printing Strings</h3>
<p><code>printf</code> is a powerful function that we’ll examine in
Chapter 3. So far, we’ve only used <code>printf</code> to display a
<strong>string literal</strong> – a series of characters enclosed in
double quotation marks. When <code>printf</code> displays a string
literal, it doesn’t show the quotation marks.</p>
<p><code>printf</code> doesn’t automatically advance to the next output
line when it finishes printing. To instruct <code>printf</code> to
advance one line, we must include <code>\n</code> (the <em>new-line
character</em>) in the string to be printed. Writing a new-line
character terminates the current output line; subsequent output goes on
to the next line. to illustrate this point, consider the effect of
replacing the statement</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>by two calls of <code>printf</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: &quot;</span><span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>The first call of <code>printf</code> writes
<code>To C, or not to C:</code>. The second call writes
<code>that is the question.</code> and advances to the next line. The
net effect is the same as the original <code>printf</code> – the user
can’t tell the difference.</p>
<p>The new-line character can appear more than once in a string literal.
To display the message</p>
<pre><code>Brevity is the soul of wit.
  --Shakespeare</code></pre>
<p>we could write</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Brevity is the soul of wit.</span><span class="sc">\n</span><span class="st">  --Shakespeare</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<h2 id="comments">2.3 Comments</h2>
<p>Our <code>pun.c</code> program still lacks something important:
documentation. Every program should contain identifying information: the
program name, the date written, the author, the purpose of the program,
and so forth. In C, this information is placed in
<strong><em>Comments</em></strong>. The symbol <code>/*</code> marks the
beginning of a comment and the symbol <code>*/</code> marks the end:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* This is a comment */</span></span></code></pre></div>
<p>Comments may appear almost anywhere in a program, either on separate
lines or on the same lines as other program text. Here’s what
<code>pun.c</code> might look like with comments added at the
beginning:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c */</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* Purpose: Prints a bad pun. */</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* Author: K. N. King */</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Comments may extend over more than one line; once it has seen the
<code>/*</code> symbol, the compiler reads (and ignores) whatever
follows until it encounters the <code>*/</code> symbol. If we like, we
can combine a series of short comments into one long comment:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">   Purpose: Prints a bad pun.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">   Author: K. N. King */</span></span></code></pre></div>
<p>A comment like this can be hard to read, though, because it’s not
easy to see where the comment ends. Putting <code>*/</code> on a line by
itself helps:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">   Purpose: Prints a bad pun.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">   Author: K. N. King </span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span></code></pre></div>
<p>Even better, we can form a “box” around the comment to make it stand
out:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">/************************************************************ </span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">* Name: pun.c                                               *</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">* Purpose: Prints a bad pun.                                *</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">* Author: K. N. King                                        *</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">************************************************************/</span></span></code></pre></div>
<p>Programmers often simplify boxed comments by omitting three of the
sides:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Name: pun.c</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a bad pun.</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span></code></pre></div>
<p>A short comment can go on the same line with other program code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span>    <span class="co">/* Beginning of main program */</span></span></code></pre></div>
<p>A comment like this is sometimes called a “winged comment”.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Forgetting to terminate a comment may cause the compiler to ignore
part of your program. Consider the following example:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;My &quot;</span><span class="op">);</span>    <span class="co">/* forgot to close this comment...</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">printf(&quot;cat &quot;);</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">printf(&quot;has &quot;);    /* so it ends here */</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;fleas&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Because we have neglected to terminate the first comment, the
compiler ignores the middle two statements, and the example prints
<code>My fleas</code>.</p>
</div>
<p><span class="C99Symbol"></span></p>
<p>C99 provides a second kind of comment, which begins with
<code>//</code> (two adjacent slashes):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a comment</span></span></code></pre></div>
<p>This style of comment ends automatically at the end of a line. To
create a commet that’s more than one line long, we can either use the
older comment style (<code>/* ... */</code>) or else put <code>//</code>
at the beginning of each comment line:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Name: pun.c</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Purpose: Prints a bad pun.</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Author: K. N. King</span></span></code></pre></div>
<p>The newer comment style has a couple of important advantages. First,
because a comment automatically ends at the end of a line, there’s no
chance that an unterminated comment will accidentally consume part of a
program. Second, multiline comments stand out better, thanks to the
<code>//</code> that’s required at the beginning of each line.</p>
<h2 id="variables-and-assignment">2.4 Variables and Assignment</h2>
<p>Few programs are as simple as the one in Section 2.1. Most programs
need to perform a series of calculations before producing output, and
thus need a way to store data temporarily during program execution. In
C, as in most programming languages, these storage locations are called
<strong>variables</strong>.</p>
<h3 id="types">2.4.1 Types</h3>
<p>Every variable must have a <strong><em>type</em></strong>, which
specifies what kind of data it will hold. C has a wide variety of types.
For now, we’ll limit ourselves to just two: <code>int</code> and
<code>float</code>. Choosing the proper type is critical, since the type
affects how the variable is stored and what operations can be performed
on the variable. The type of a numeric variable determines the largest
and smallest numbers that the variable can store; it also determines
whether or not digits are allowed after the decimal point.</p>
<p>A variable of type <code>int</code> (short for <em>integer</em>) can
store a whole number such as 0, 1, 392, or -2553. The range of possible
values is limited, though. The largest <code>int</code> value is
typically 2,147,483,647 but can be as small as 32,767.</p>
<p><span class="QandA"></span></p>
<p>A variable of type <code>float</code> (short for
<em>floating-point</em>) can store much larger numbers than an
<code>int</code> variable. Furthermore, a <code>float</code> variable
can store numbers with digits after the decimal point, like 379.125.
<code>float</code> variables have drawbacks, however. Arithmetic on
<code>float</code> numbers may be slower than arithmetic on
<code>int</code> numbers. Most significantly, the value of a
<code>float</code> variable is often just an approximation of the number
that was stored in it. If we store 0.1 in a <code>float</code> variable,
we may later find that the variable has a value such as
0.09999999999999987, thanks to rounding error.</p>
<h3 id="declarations">2.4.2 Declarations</h3>
<p>Variables must be <strong>declared</strong>–described for the benefit
of the compiler–before they can be used. To declare a variable, we first
specify the <em>type</em> of the variable, then its <em>name</em>.
(Variable names are chosen by the programmer, subject to the rules
described in Section 2.7.) For example, we might declare variables
<code>height</code> and <code>profit</code> as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> profit<span class="op">;</span></span></code></pre></div>
<p>The first declaration states that <code>height</code> is a variable
of type <code>int</code>, meaning that <code>height</code> can store an
integer value. The second declaration says that <code>profit</code> is a
variable of type <code>float</code>.</p>
<p>If several variables have the same type, their declarations can be
combined:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> profit<span class="op">,</span> loss<span class="op">;</span></span></code></pre></div>
<p>Notice that each complete declaration ends with a semicolon. Ou Our
first template for <code>main</code> didn’t include declarations. When
<code>main</code> contains declarations, these must precede
statements:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    declarations</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    statements</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As we’ll see in Chapter 9, this is true of functions in general, as
well as blocks (statements that contain embedded declarations). As a
matter of style, it’s a good idea to leave a blank line between the
declarations and the statements.</p>
<p><span class="C99Symbol"></span></p>
<p>In C99, declarations don’t have to come before statements. For,
example, <code>main</code> might contain a declaration, then a
statement, and then another declaration. For compatibility with older
compilers, the programs in this book don’t take advantage of this rule.
However, it’s common in C++ and Java programs not to declare variables
until they’re first needed, so this practice can be expected to become
popular in C99 programs as well.</p>
<h3 id="assignment">2.4.3 Assignment</h3>
<p>A variable can be given a value by means of
<strong><em>assignment</em></strong>. For example, the statements</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<p>assign values to <code>height</code>, <code>length</code>, and
<code>width</code>. The numbers 8, 12, and 10 are said to be
<strong><em>constants</em></strong>.</p>
<p>Before a variable can be assigned a value–or used in any other way,
for that matter–it must first be declared. Thus, we could write</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span></code></pre></div>
<p>but not</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span></code></pre></div>
<p>A constant assigned to a <code>float</code> variable usually contains
a decimal point. For example, if <code>profit</code> is a
<code>float</code> variable, we might write</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>profit <span class="op">=</span> <span class="fl">2150.48</span><span class="op">;</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>It’s best to append the letter <code>f</code> (for “float”) to a
constant that contains a decimal point if the number is assigned to a
<code>float</code> variable:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>profit <span class="op">=</span> <span class="fl">2150.48</span><span class="bu">f</span><span class="op">;</span></span></code></pre></div>
<p>Failing to include the <code>f</code> may cause a warning from the
compiler.</p>
<p>An <code>int</code> variable is normally assigned a value of type
<code>int</code>, and a <code>float</code> variable is normally assigned
a value of type <code>float</code>. Mixing types (such as assigning an
<code>int</code> value to a <code>float</code> variable or assigning a
<code>float</code> value to an <code>int</code> variable) is possible
but not always safe, as we’ll see in Section 4.2.</p>
<p>Once a variable has been assigned a value, it can be used to help
compute the value of another variable:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span>    <span class="co">/* volume is now 960 */</span></span></code></pre></div>
<p>In C, <code>*</code> represents the multiplication operator, so this
statement multiplies the values stored in <code>height</code>,
<code>length</code>, and <code>width</code>, then assigns the result to
the variable <code>volume</code>. In general, the right side of an
assignment can be a formula (or <strong><em>expression</em></strong>, in
C terminology) involving constants, variables, and operators.</p>
<h3 id="printing-the-value-of-a-variable">2.4.4 Printing the Value of a
Variable</h3>
<p>We can use <code>printf</code> to display the current value of a
variable. For example, to write the message</p>
<pre class="shell"><code>Height: h</code></pre>
<p>where <code>h</code> is the current value of the <code>height</code>
variable, we’d use the following call of <code>printf</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">);</span></span></code></pre></div>
<p><code>%d</code> is a placeholder indicating where the value of
<code>height</code> is to be filled in during printing. Note the
placement of <code>\n</code> just after <code>%d</code>, so that
<code>printf</code> will advance to the next line after printing the
value of <code>height</code>.</p>
<p><code>%d</code> works only for <code>int</code> variables; to print a
<code>float</code> variable, we’d use <code>%f</code> instead. By
default, <code>%f</code> displays a number with six digits after the
decimal point. To force <code>%f</code> to display <code>p</code> digits
after the decimal point, we can put <code>.p</code> between
<code>%</code> and <code>f</code>. For example, to print the line</p>
<pre class="shell"><code>Profit: $2150.48</code></pre>
<p>we’d call <code>printf</code> as follows:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Profit: $%.2f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> profit<span class="op">);</span></span></code></pre></div>
<p>There’s no limit to the number of variables that can be printed a
single call of <code>printf</code>. To display the values of both the
<code>height</code> and <code>length</code> variables, we could use the
following call of <code>printf</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d  Length: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">,</span> length<span class="op">);</span></span></code></pre></div>
<h3 id="program-computing-the-dimensional-weight-of-a-box">2.4.5
(PROGRAM) Computing the Dimensional Weight of a Box</h3>
<p>Shipping companies don’e especially like boxes that are larger but
very light, since they take up valuable space in a truck or airplane. In
fact, companies often charge extra for such a box, basing the fee on its
volume instead of its weight. In the United States, the usual method is
to divide the volume by 166 (the allowable number of cubic inches per
pound). If this number–the box’s “dimensional” or “volumetric”
weight–exceeds its actual weight, the shipping fee is based on the
dimensional weight. (The 166 divisor is for international shipments; the
dimensional weight of a domestic shipment is typically calculated using
194 instead).</p>
<p>Let’s say that you’ve been hired by a shipping company to write a
program that computes the dimensional weight of a box. Since you’re new
to C, you decide to start off by writing a program that calculates the
dimensional weight of a particular box that’s
<code>12" x 10" x 8"</code>. Division is represented by <code>/</code>
in C, so the obvious way to compute the dimensional weight would be</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> volume <span class="op">/</span> <span class="dv">166</span></span></code></pre></div>
<p>where <code>weight</code> and <code>volume</code> are integer
variables representing the box’s weight and volume. Unfortunately, this
formula isn’t quite what we need. In C, when one integer is divided by
another, the answer is “truncated”: all digits after the decimal point
are lost. The volume of a <code>12" x 10" x 8"</code> box will be 960
cubic inches. Dividing by 166 gives the answer 5 instead of 5.783, so we
have in effect rounded <em>down</em> to the next lowest pound; the
shipping company expects us to round <em>up</em>. One solution is to add
165 to the volume before dividing by 166:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span></code></pre></div>
<p>A volume of 166 would give a weight of 331/166, or 1, while a volume
of 167 would yield 332/166, or 2. Calculating the weight in this fashion
gives us the following program.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: dweight.c */</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* Computes the dimensional weight of a 12&quot; x 10&quot; x 8&quot; box */</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">,</span> weight<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Dimensions: %dx%dx%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> height<span class="op">);</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Volume (cubic inches): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    printd<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> weight<span class="op">);</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The output of the program is</p>
<pre class="shell"><code>Dimensions: 12x10x8
Volume (cubic inches): 960
Dimensional weight (pounds): 6</code></pre>
<h3 id="initialization">2.4.6 Initialization</h3>
<p>Some variables are automatically set to zero when a program begins to
execute, but most are not. A variable that doesn’t have a default value
and hasn’t yet been assigned a value by the program is said to be
<strong><em>uninitialized</em></strong>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Attempting to access the value of an uninitialized variable (for
example, by displaying the variable using <code>printf</code> or using
it in an expression) may yield an unpredictable result such as 2568,
-30891, or some equally strange number. With some compilers, worse
behavior–even a program crash–may occur.</p>
</div>
<p>We can always give a variable an initial value by using assignment,
of course. But there’s an easier way: put the initial value of the
variable in its declaration. For example, we can declare the
<code>height</code> variable and initialize it in one step:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span></code></pre></div>
<p>In C jargon, the value <code>8</code> is said to be an
<strong><em>initializer</em></strong>.</p>
<p>Any number o variables can be initialized in the same
declaration:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height <span class="op">=</span> <span class="dv">8</span><span class="op">,</span> length <span class="op">=</span> <span class="dv">12</span><span class="op">,</span> width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<p>Notice that each variable requires its own initializer. In the
ollowing example, the initializer <code>10</code> is good only or the
variable <code>width</code>, not for <code>height</code> or
<code>length</code> (which remain uninitialized):</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<h3 id="printing-expressions">2.4.7 Printing Expressions</h3>
<p><code>printf</code> isn’t limited to displaying numbers stored in
variables; it can display the value of <em>any</em> numeric expression.
Taking advantage of this property can simplify a program and reduce the
number of variables. For instance, the statements</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span></code></pre></div>
<p>could be replaced by</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">);</span></span></code></pre></div>
<p><code>printf</code>’s ability to print expressions illustrates one of
C’s general principles: <em>Wherever a value is needed, any expression
of the same type will do</em>.</p>
<h2 id="reading-input">2.5 Reading Input</h2>
<p>Because the <code>dweight.c</code> program calculates the dimensional
weight of just one box, it isn’t especially useful. To improve the
program, we’ll need to allow the user to enter the dimensions.</p>
<p>To obtain input, we’ll use the <code>scanf</code> function, the C
library’s counterpart to <code>printf</code>. The <code>f</code> in
<code>scanf</code>, like the <code>f</code> in <code>printf</code>,
stands for “formatted”; both <code>scanf</code> and <code>printf</code>
require the use of a <strong><em>format string</em></strong> to specify
the appearance of the input or output data. <code>scanf</code> needs to
know what form the input data will take, just as <code>printf</code>
needs to know how to display output data.</p>
<p>To read an <code>int</code> value, we’d use <code>scanf</code> as
follows:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span>    <span class="co">/* reads an integer; stores into i */</span></span></code></pre></div>
<p>The <code>"%d"</code> string tells <code>scanf</code> to read input
that represents an integer; <code>i</code> is an <code>int</code>
variable into which we want <code>scanf</code> to store the input. The
<code>&amp;</code> symbol is hard to explain at this point; for now,
I’ll just note that it is usually (but not always) required when using
<code>scanf</code>.</p>
<p>Reading a <code>float</code> value requires a slightly different call
of <code>scanf</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>x<span class="op">);</span>    <span class="co">/* reads a float value; stores into x */</span></span></code></pre></div>
<p><code>%f</code> works only with variables of type <code>float</code>,
so I’m assuming that <code>x</code> is a <code>float</code> variable.
The <code>"%f"</code> string tells <code>scanf</code> to look for an
input value in <code>float</code> format (the number may contain a
decimal point, but doesn’t have to).</p>
<h3
id="program-computing-the-dimensional-weight-of-a-box-revisited">2.5.1
(PROGRAM) Computing the Dimensional Weight of a Box (Revisited)</h3>
<p>Here’s an improved version of the dimensional weight program in which
the user enters the dimensions. Note that each call of
<code>scanf</code> is immediately preceeded by a call of
<code>printf</code>. That way, the user will know when to enter input
and what input to enter.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: dweight2.c</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co">   purpose: Computes the dimensional weight of a </span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co">   box from input provided by the user */</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">,</span> weight<span class="op">;</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter height of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>height<span class="op">);</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter length of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>length<span class="op">);</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter width of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>width<span class="op">);</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Volume (cubic inches): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> weight<span class="op">);</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The output of the program has the following appearance</p>
<pre class="shell"><code>Enter height of box: 8
Enter length of box: 12
Enter width of box: 10
Volume (cubic inches): 960
Dimensional weight (pounds): 6</code></pre>
<p>A message that asks the user to enter input (a
<strong><em>prompt</em></strong>) normally shouldn’t end with a new-line
character, because we want the user to enter input on the same line as
the prompt itself. When the user presses the Enter key, the cursor
automatically moves to the next line–the program doesn’t need to display
a new-line character to terminate the current line.</p>
<p>The <code>dweight2.c</code> program suffers from one problem: it
doesn’t work correctly if the user enters nonnumeric input. Section 3.2
discusses this issue in more detail.</p>
<h2 id="defining-names-for-constants">2.6 Defining Names for
Constants</h2>
<p>When a program contains constants, it’s often a good idea to give
them names. The <code>dweight.c</code> and <code>dweight2.c</code>
programs rely on constant 166, whose meaning may not be at all clear to
someone reading the program later. Using feature know as
<strong><em>macro definition</em></strong>, we can name this
constant:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INCHES_PER_POUND 166</span></span></code></pre></div>
<p><code>#define</code> is a preprocessing directive, just as
<code>#include</code> is, so there’s no semicolon at the end of the
line.</p>
<p>When a program is compiled, the preprocessor replaces each macro by
the value that it represents. For example, the statement</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> INCHES_PER_POUND <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">/</span> INCHES_PER_POUND<span class="op">;</span></span></code></pre></div>
<p>will become</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">166</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span></code></pre></div>
<p>giving the same effect as if we’d written the latter statement in the
first place.</p>
<p>The value of a macro can be an expression:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define RECIPROCAL_OF_PI (1.0f / 3.14159f)</span></span></code></pre></div>
<p>If it contains operators; the expression should be enclosed ina
prantheses.</p>
<p>Notice that we’ve used only upper-case letters in macros names. This
a convention that most C programmers follow, not a requirement of the
language. (Still, C programmers have been doing this for decades; you
wouldn’t want to be the first to deviate.)</p>
<h3 id="program-converting-from-fahrenheit-to-celsius">2.6.1 (PROGRAM)
Converting from Fahrenheit to Celsius</h3>
<p>The following program prompts the user to enter a Fahrenheit
temperature; it then prints the equivalent Celsius temperature. The
output of the program will have the following appearance:</p>
<pre class="shell"><code>Enter Fahrenheit temperature: 212
Celsius equivalent: 100.0</code></pre>
<p>The program will allow temperatures that aren’t integers; that’s why
the Celsius temperature is displayed as 100.0 instead of 100. Let’s look
first at the entire program, then see how it’s put together.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * File: celsius.c</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Converts a Fahrenheit temperature to Celsius</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FREEZING_PT 32.0f</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCALE_FACTOR (5.0f /9.0f)</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fahrenheit<span class="op">,</span> celsius<span class="op">;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>fahrenheit<span class="op">);</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The statement</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span></code></pre></div>
<p>converts the Fahrenheit temperature to Celsius. Since
<code>FREEZING_PT</code> stands for <code>32.0f</code> and
<code>SCALE_FACTOR</code> stands for <code>(5.0f /9.0f)</code>, the
compiler sees this statement as</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> <span class="fl">32.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fl">5.0</span><span class="bu">f</span> <span class="op">/</span> <span class="fl">9.0</span><span class="bu">f</span><span class="op">);</span></span></code></pre></div>
<p>Defining <code>SCALE_FACTOR</code> to be <code>(5.0f / 9.0f)</code>
instead of <code>(5 / 9)</code> is important, becasuse C truncates the
result when two integers are divided. The value of <code>(5 / 9)</code>
would be <code>0</code>, which definitely isn’t what we want.</p>
<p>The call of <code>printf</code> writes the Celsius temperature:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span></code></pre></div>
<p>Notice the use of <code>%.1f</code> to display <code>celsius</code>
with just one digit after the decimal point.</p>
<h2 id="identifiers">Identifiers</h2>
<p>As we’re writing a program, we’ll have to choose names for variables,
functions, macros, and other entities. These names are called
<strong><em>identifiers</em></strong>. In C, an identifier may contain
letters, digits, and underscores, but must begin with a letter or
underscore.</p>
<p><span class="C99Symbol"></span></p>
<p>(In C99, identifiers may contain certain “universal character names”
as well.)</p>
<p>Here are some examples of legal identifers:</p>
<pre><code>times10
get_next_char
_done</code></pre>
<p>The following are <em>not</em> legal identifiers:</p>
<pre><code>10times
get-next-char</code></pre>
<p>The symbol <code>10times</code> begins with a digit, not a letter or
underscore. <code>get-next-char</code> contains minus signs, not
underscores.</p>
<p>C is <strong><em>case-sensitive</em></strong>: it distinguishes
between upper-case and lower-case letters in identifiers. For example,
the following identifiers are all different:</p>
<pre><code>job
joB
jOb
jOB
Job
JoB
JOb
JOB</code></pre>
<p>These eight identifiers could all be used simultaneously, each for a
completely different purpose. (Talk about obfuscation!) Sensible
programmers try to make identifiers look different unless they’re
somehow related.</p>
<p>Since case matters in C, many programmers follow the convention of
using only lower-case letters in identifiers (other than macros), with
underscores inserted when necessary for legibility:</p>
<pre><code>symbol_table
current_page
name_and_address</code></pre>
<p>Other programmers avoid underscores, instead using an upper-case
letter to begin each word within an identifier:</p>
<pre><code>symbolTable
currentPage
nameAndAddress</code></pre>
<p>(The first letter is sometimes capitalized as well.) Although the
former style is common in traditional C, the latter style is becoming
more popular thanks to its widespread use in Java and C# (and, to a
lesser extent, C++). Other reasonable conventions exist; just be sure to
capitalize an identifier the same way each time it appears in a
program.</p>
<p><span class="QandA"></span></p>
<p>C places no limit on the maximum length of an identifier, so don’t be
afraid to use long, descriptive names. A name such as
<code>current_page</code> is a lot easier to understand than a name like
<code>cp</code>.</p>
<h3 id="keywords">2.7.1 Keywords</h3>
<p><span class="C99Symbol"></span></p>
<p>The <strong><em>keywords</em></strong> in Table 2.1 have special
significance to C compilers and therefore can’t be used as identifiers.
Note that five keywords were added in C99.</p>
<p><strong>Table 2.1</strong><br>Keywords</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<tbody>
<tr class="odd">
<td><code>auto</code></td>
<td><code>enum</code></td>
<td><code>restrict</code><span class="staffOfHermis"></span></td>
<td><code>unsigned</code></td>
</tr>
<tr class="even">
<td><code>break</code></td>
<td><code>extern</code></td>
<td><code>return</code></td>
<td><code>void</code></td>
</tr>
<tr class="odd">
<td><code>case</code></td>
<td><code>float</code></td>
<td><code>short</code></td>
<td><code>volatile</code></td>
</tr>
<tr class="even">
<td><code>char</code></td>
<td><code>for</code></td>
<td><code>signed</code></td>
<td><code>while</code></td>
</tr>
<tr class="odd">
<td><code>const</code></td>
<td><code>goto</code></td>
<td><code>sizeof</code></td>
<td><code>_Bool</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="even">
<td><code>continue</code></td>
<td><code>if</code></td>
<td><code>static</code></td>
<td><code>_Complex</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="odd">
<td><code>default</code></td>
<td><code>inline</code><span class="staffOfHermis"></span></td>
<td><code>struct</code></td>
<td><code>_Imaginary</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="even">
<td><code>do</code></td>
<td><code>int</code></td>
<td><code>switch</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>double</code></td>
<td><code>long</code></td>
<td><code>typedef</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>else</code></td>
<td><code>register</code></td>
<td><code>union</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="staffOfHermis"></span>C99 only</p>
<p>Because of C’s case-sensitivity, keywords must appear in programs
exactly as shown in Table 2.1, with all letters in lower case. Names of
functions in the standard library (such as <code>printf</code>) contain
only lower-case letters also. Avoid the plight of the unfortunate
programmer who enters an entire program in upper case, only to find that
the compiler can’t recognize keywords and calls of library
functions.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Watch out for other restrictions on identifiers. Some compilers treat
certain identifiers (<code>asm</code>, for example) as additional
keywords. Identifiers that belong to the standard library are restricted
as well. Accidentally using one of these names can cause an error during
compilation or linking. Identifiers that begin with an underscore are
also restricted.</p>
</div>
<h2 id="layout-of-a-c-program">2.8 Layout of a C Program</h2>
<p>We think of a C program as a series of
<strong><em>tokens</em></strong>: groups of characters that can’t be
split up without changing their meaning. Identifiers and keywords are
tokens. So are operators like <code>+</code> and <code>-</code>,
punctuation marks such as the comma and semicolon, and string literals.
For example, the statement</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">);</span></span></code></pre></div>
<p>consists of seven tokens:</p>
<table>
<tbody>
<tr class="odd">
<td><code>printf</code></td>
<td><span class="circled1"></span></td>
</tr>
<tr class="even">
<td><code>(</code></td>
<td><span class="circled2"></span></td>
</tr>
<tr class="odd">
<td><code>"Height: %d\n"</code></td>
<td><span class="circled3"></span></td>
</tr>
<tr class="even">
<td><code>,</code></td>
<td><span class="circled4"></span></td>
</tr>
<tr class="odd">
<td><code>height</code></td>
<td><span class="circled5"></span></td>
</tr>
<tr class="even">
<td><code>)</code></td>
<td><span class="circled6"></span></td>
</tr>
<tr class="odd">
<td><code>;</code></td>
<td><span class="circled7"></span></td>
</tr>
</tbody>
</table>
<p>Tokens <span class="circled1"></span> and <span
class="circled5"></span> are identifiers, token <span
class="circled3"></span> is a string literal, and tokens <span
class="circled2"></span>, <span class="circled4"></span>, <span
class="circled6"></span>, and <span class="circled7"></span> are
punctuation.</p>
<p>The amount of space between tokens in a program isn’t critical in
most cases. At one extreme, tokens can be crammed together with no space
between them at all, except where this would cause two tokens to merge
into a third token. For example, we could delete most of the space in
the <code>celsius.c</code> program of Section 2.6, provided that we
leave space between tokens such as <code>int</code> and
<code>main</code> and between <code>float</code> and
<code>fahrenheit</code>:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Converts a Fahrenheit temperature to Celsius */</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FREEZING_PT 32.0f</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCALE_FACTOR (5.0f/9.0f)</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">){</span><span class="dt">float</span> fahrenheit<span class="op">,</span>celsius<span class="op">;</span>printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span>scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,&amp;</span>fahrenheit<span class="op">);</span>celsius<span class="op">=(</span>fahrenheit<span class="op">-</span>FREEZING_PT<span class="op">)*</span>SCALE_FACTOR<span class="op">;</span>printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>celsius<span class="op">);</span><span class="cf">return</span> <span class="dv">0</span><span class="op">;}</span></span></code></pre></div>
<p>In fact, if the page were wider, we could put the entire
<code>main</code> function on a single line. We can’t put the whole
<em>program</em> on one line, though, because each preprocessing
directive requires a separate line.</p>
<p>Compressing programs in this fashion isn’t good idea. In fact, adding
spaces and blank lines to a program can make it easier to read and
understand. Fortunately, C allows us to insert any amouont of
space–blanks, tabs, and new-line characters–between tokens. This rule
has several important consequences for program layout:</p>
<!-- Ordered list Start here -->
<ul>
<li>
<p><em>Statements can be divided</em> over any number of lines. The
following statement, for example, is so long that it would be hard to
sqeeze it onto a single line:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span>volume <span class="op">+</span> INCHES_PER_POUND <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> INCHES_PER_POUND<span class="op">);</span></span></code></pre></div>
</li>
<li>
<p><em>Space between tokens</em> makes it easier for the eye to separate
them. For this reason, I usually put a space before and after each
operator:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span></code></pre></div>
<p>I also put a space after each comma. Some programmers go even
further, putting spaces around parentheses and other punctuation.</p>
</li>
<p><span class="QandA"></span></p>
<li>
<p><em>Indentation</em> can make nesting easier to spot. For example, we
should indent declarations and statements to make it clear that they’re
nested inside <code>main</code>.</p>
</li>
<li>
<p><em>Blank lines</em> can divide a program into logical units, making
it easier for the reader to discern the program’s structure. A program
with no blank lines is as hard to read as a book with no chapters.</p>
</li>
</ul>
<!-- Un ordered list end here -->
<p>The <code>celsius.c</code> program of Section 2.6 illustrates several
of these guidelines. Let’s take a closer look at the <code>main</code>
function in that program:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fahrenheit<span class="op">,</span> celsius<span class="op">;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>fahrenheit<span class="op">);</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>First, observe how the space around <code>=</code>, <code>-</code>,
and <code>*</code> makes these operators stand out. Second, notice how
the indentation of declarations and statements makes it obvious that
they all belong to <code>main</code>. Finally, note how blank lines
divide <code>main</code> into five parts: (1) declaring the
<code>fahrenheit</code> and <code>celsius</code> variables; (2)
obtaining the Fahrenheit temperature; (3) calculating the value of
<code>celsius</code>; (4) printing the Celsius temperature; and (5)
returning to the operating system.</p>
<p>While we’re on the subject of program layout, notice how I’ve placed
the <code>{</code> token underneath <code>main()</code> and put the
matching <code>}</code> on a separate line, aligned with <code>{</code>.
Putting <code>}</code> on a separate line lets us insert or delete
statements at the end of the function; aligning it with <code>{</code>
makes it easy to spot the end of <code>main</code>.</p>
<p>A final note: Although extra spaces can be added <em>between</em>
tokens, it’s not possible to add space <em>within</em> a token without
changing the meaning of the program or causing an error. Writing</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>fl oat fahrenheit<span class="op">,</span> celsius<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>fl</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>oat fahrenheit<span class="op">,</span> celsius<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>produces an error when the program is compiled. Putting a space
inside a string literal is allowed, although it changes the meaning of
the string. However, putting a new-line character in a string (in other
words, splitting the string over two lines) is illegal:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C:</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>that is the question<span class="op">.</span>\n<span class="st">&quot;);    /*** WRONG ***/</span></span></code></pre></div>
<p>Continuing a string from one line to the next requires a special
technique that we’ll learn in a later chapter.</p>
<hr />
<h2 id="q-a">Q &amp; A</h2>
<div class="QandA_question">
<p>Q: What does GCC stand for? [p. 11]</p>
</div>
<div class="QandA_answer">
<p>A: GCC originally stood for “<u>G</u>NU <u>C</u> <u>C</u>ompiler.” It
now stands for “<u>G</u>NU <u>C</u>ompiler <u>C</u>ollection,” because
the current version of GCC compiles programs written in a variety of
languages, including Ada, C, C++, Fortran, Java, and Objective-C.</p>
</div>
<div class="QandA_question">
<p>Q: OK, so what does GNU stand for?</p>
</div>
<div class="QandA_answer">
<p>A: GNU stands for “<u>G</u>NU’s <u>N</u>ot <u>U</u>nix!” (and is
pronounced <em>guh-NEW</em>, by the way). GNU is a project of the Free
Software Foundation, an organization set up by <strong>Ritchard M.
Stallman</strong> as a protest against the restrictions of licensed UNIX
software. According to its web site, the Free Software Foundation
believes that the users should be free to “run, copy, distribute, study,
change and improve” software. The GNU Project has rewritten much
traditional UNIX software from scratch and made it publicly available at
no charge.</p>
<p>GCC and other GNU software are crucial to Linux. Linux itself is only
the “kernel” of an operating system (the part that handles program
scheduling and basic I/O services); the GNU software is necessary to
have a fully functional operating system.</p>
<p>For more information on the GNU Project, visit <a
href="https://www.gnu.org/">www.gnu.org</a>.</p>
</div>
<div class="QandA_question">
<p>Q: What’s the big deal about the GCC anyway?</p>
</div>
<div class="QandA_answer">
<p>A: GCC is significant for many reasons, not least the fact that it’s
free and capable of compiling a number of languages. It runs under many
operating systems and generates code for many different CPUs, including
all the widely used ones. GCC is the primary compiler for many
UNIX-based operating systems, including Linux, BSD, and Mac OS X, and
it’s used extensively for commercial software development. For more
information about GCC, visit <a
href="https://gcc.gnu.org">gcc.gnu.org</a></p>
</div>
<div class="QandA_question">
<p>Q: How good is GCC at finding errors in programs?</p>
</div>
<div class="QandA_answer">
<p>A: GCC has various command-line options that control how thoroughly
it checks programs. When these options are used, GCC is quite good at
finding potential trouble spots in a program. Here are some of the more
popular options:</p>
<ul>
<li>
<p><code>-Wall</code></p>
<p>Causes the compiler to produce warning messages when it detects
possible errors. (<code>-W</code> can be followed by codes for specific
warnings; <code>-Wall</code> means “all <code>-W</code> options.”)
Should be used in conjunction with <code>-O</code> for maximum
effect.</p>
</li>
<li>
<p><code>-W</code></p>
<p>Issues additional warning messages beyond those produced by
<code>-Wall</code>.</p>
</li>
<li>
<p><code>-pedantic</code></p>
<p>Issues all warnings required by the C standard. Causes programs that
use non-standard features to be rejected.</p>
</li>
<li>
<p><code>-ansi</code></p>
<p>Turns off features of GCC that aren’t standard C and enables a few
standard features that are normally disabled.</p>
</li>
<li>
<pre><code>-std=c89
-std=c99</code></pre>
<p>Specifies which version of C the compiler should use to check the
program.</p>
</li>
</ul>
<p>These options are often used in combination:</p>
<pre class="shell"><code>gcc -O -Wall -W -pedantic -ansi -std=c99 -o pun pun.c</code></pre>
</div>
<div class="QandA_question">
<p>Q: Why is C so terse? It seems as though programs would be more
readable if C used <code>begin</code> and <code>end</code> instead of
<code>{</code> and <code>}</code>, <code>integer</code> instead of
<code>int</code>, and so forth. [p. 12]</p>
</div>
<div class="QandA_answer">
<p>A: Legend has it that the brevity of C programs is due to the
environment that existed in Bell Labs at the time the language was
developed. The first C compiler ran on a DEC PDP-11 (an early
minicomputer); programmers used a teletype–essentially a typewriter
connected to a computer–to enter programs and print listings. Because
teletypes were very slow (they could print only 10 characters per
second), minimizing the number of characters in a program was clearly
advantageous.</p>
</div>
<div class="QandA_question">
<p>Q: In some C books, the <code>main</code> function ends with
<code>exit(0)</code> instead of <code>return 0</code>. Are these the
same? [p. 14]</p>
</div>
<div class="QandA_answer">
<p>A: When they appear inside <code>main</code>, these statements are
indeed equivalent: both terminate the program, returning the value
<code>0</code> to the operating system. Which one to use is mostly a
matter of taste.</p>
</div>
<div class="QandA_question">
<p>Q: What happens if a program reaches the end of the <code>main</code>
function without executing a <code>return</code> statement? [p. 14]</p>
</div>
<div class="QandA_answer">
<p><span class="C99Symbol"></span></p>
<p>A: The <code>return</code> statement isn’t mandatory; if it’s
missing, the program will still terminate. In C89, the value returned to
the operating system is undefined. In C99, if <code>main</code> is
declared to return an <code>int</code> (as in our examples), the program
returns <code>0</code> to the operating system; otherwise, the program
returns an unspecified value.</p>
</div>
<div class="QandA_question">
<p>Q: Does the compiler remove a comment entirely or replace it with
blank space?</p>
</div>
<div class="QandA_answer">
<p>A: Some old C compilers deleted all the characters in each comment,
making it possible to write</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>a<span class="co">/**/</span>b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>and have the compiler interpret it as</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>ab <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>According to the C standard, however, the compiler must replace each
comment by a single space character, so this trick doesn’t work.
Instead, we’d end up with the following (illegal) statement:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>a b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
</div>
<div class="QandA_question">
<p>Q: How can I tell if my program has an unterminated comment?</p>
</div>
<div class="QandA_answer">
<p>A: If you’re lucky, the program won’t compile because the comment has
rendered the program illegal. If the program does compile, there are
several techniques that you can use. Stepping through the program line
by line with a debugger will reveal if any lines are being skipped. Some
IDEs display comments in a distinctive color to distinuish them from
sorrounding code. If you’re using such an environment, you can easily
spot unterminated comments, since program text will have different color
of it’s accidentally included in a comment. A program such as
<code>lint</code> can also help.</p>
</div>
<div class="QandA_question">
<p>Q: Is it legal to nest one comment inside another?</p>
</div>
<div class="QandA_answer">
<p>A: Old-style comments (<code>/* ... */</code>) can’t be nested. For
instance, the following code is illegal:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="co">    /*** WRONG ***/</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="op">*/</span></span></code></pre></div>
<p>The <code>*/</code> symbol on the second line matches the
<code>/*</code> symbol on the first line, so the compiler will flag the
<code>*/</code> symbol on the third line as an error.</p>
<p><span class="C99Symbol"></span></p>
<p>C’s prohibition against nested comments can sometimes be a problem.
Suppose we’ve written a long program containing many short comments. To
disable a portion of the program temporarily (during testing, say), our
first impulse is to “comment out” the offending lines with
<code>/*</code> and <code>*/</code>. Unfortunately, this method won’t
work if the lines contain old-style comments. C99 comments (those
beginning with <code>//</code>) can be nested inside old-style comments,
however–another advantage to using this kind of comment.</p>
<p>In any event, there’s a better way to disable portions of a program,
as we’ll see later.</p>
</div>
<div class="QandA_question">
<p>Q: Where does the <code>float</code> type get its name? [p. 17]</p>
</div>
<div class="QandA_answer">
<p>A: <code>float</code> is short for “floating-point”, a technique for
storing numbers in which the decimal point “floats”. A float value is
usually stored in two parts: the fraction (or mantissa) and the
exponent. The number 12.0 might be stored as <span
class="displayInlineMath"><span
class="math display">1.5 × 2<sup>3</sup></span></span>, for example,
where 1.5 is the fraction and 3 is the exponent. Some programming
languages call this type <code>real</code> instead of
<code>float</code>.</p>
</div>
<div class="QandA_question">
<p>Q: Why do floating-point constants need to end with letter
<code>f</code>? [p. 19]</p>
</div>
<div class="QandA_answer">
<p>A: For the full explanation, see Chapter 7. Here’s the short answer:
a constant that contains a decimal point but doesn’t end with
<code>f</code> has type <code>double</code> (short for
“double-precision”). <code>double</code> values are stored more
accurately than <code>float</code> values. Moreover, <code>double</code>
values can be larger than <code>float</code> values, which is why we
need to add the letter <code>f</code> when assigning to a
<code>float</code> variable. Without the <code>f</code>, a warning may
be generated about the possibility of a number being stored into a
<code>float</code> variable that exceeds the capacity of the
variable.</p>
</div>
<div class="QandA_question">
<p>*Q: Is it really true that there’s no limit on the length of an
identifier? [p. 26]</p>
</div>
<div class="QandA_answer">
<p>A:</p>
<p><span class="C99Symbol"></span></p>
<p>Yes and no. The C89 standard says that identifiers may be arbitrarily
long. However, compilers are only required to remember the first 31
characters (63 characters in C99). Thus, if two names begin with the
same 31 characters, a compiler might be unable to distinguish between
them.</p>
<p><span class="C99Symbol"></span></p>
<p>To make matters even more complicated, there are special rules for
identifiers with external linkage; most function names fall into this
category. Since these names must be made available to the linker, and
since some older linkers can handle only short names, only the first six
characters are significant in C89. Moreover, the case of letters may not
matter. As a result, <code>ABCDEFG</code> and <code>abcdefg</code> might
be treated as the same name. (In C99, the first 31 characters are
significant, and the case of letters is taken into account.)</p>
<p>Most compilers and linkers are more generous than the standard, so
these rules aren’t a problem in practice. Don’t worry about making
identifiers too long–worry about making them too short.</p>
</div>
<div class="QandA_question">
<p>Q: How many spaces should I use for indentation? [p. 28]</p>
</div>
<div class="QandA_answer">
<p>A: That’s a tough question. Leave too little space, and the eye has
trouble detecting indentation. Leave too much, and the lines run off the
screen (or page). Many C programmers indent nested statements eight
spaces (one tab stop), which is probably too much. Studies have shown
that the optimum amount of indentation is three spaces, but many
programmers feel uncomfortable with numbers that aren’t a power of two.
Although I normally prefer to indent three or four spaces. I’ll use two
spaces in this book so that my programs will fit within the margins.</p>
</div>
<h2 id="examples">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh02/cknkCh02Exmp/">./cknkCh02/cknkCh02Exmp/</a></li>
</ul>
<h2 id="exercises">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh02/cknkCh02Exrc/README.md">./cknkCh02/cknkCh02Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh02/cknkCh02Exrc/cknkCh02ExrcReadme.html">./cknkCh02/cknkCh02Exrc/cknkCh02ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh02/cknkCh02Exrc/">./cknkCh02/cknkCh02Exrc/</a></li>
</ul>
<h2 id="programming-projects">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh02/cknkCh02Prj/README.md">./cknkCh02/cknkCh02Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh02/cknkCh02Prj/cknkCh02PrjReadme.html">./cknkCh02/cknkCh02Prj/cknkCh02PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh02/cknkCh02Prj/">./cknkCh02/cknkCh02Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="formatted-inputoutput">3 Formatted Input/Output</h1>
<div class="theQuote">
In seeking the unattainable, simplicity only gets in the way.
</div>
<p><code>scanf</code> and <code>printf</code>, which support formatted
reading and writing, are two of the most frequently used functions in C.
As this chapter shows, both are powerful but tricky to use properly.
Section 3.1 describes <code>printf</code>, and Sectioon 3.2 covers
<code>scanf</code>. Neither section gives complete details, which will
have to wait until Chapter 22.</p>
<h2 id="the-printf-function">3.1 The <code>printf</code> Function</h2>
<p>The <code>printf</code> function is designed to display the contents
of a string, known as the <strong><em>format string</em></strong>, with
values possibly inserted at specified points in the string. When it’s
called, <code>printf</code> must be supplied with the format string,
followed by any values that are to be inserted into the string during
printing:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span>string<span class="op">,</span> expr1<span class="op">,</span> expr2<span class="op">,</span> <span class="op">...);</span></span></code></pre></div>
<p>The values displayed can be constants, variables, or more complicated
expressions. There’s no limit on the number of values that can be
printed by a single call of <code>printf</code>.</p>
<p>The format string may contain both ordinary characters and
<strong><em>conversion specifications</em></strong>, which begin with
the <code>%</code> character. A conversion specification is a place
holder representing a value to be filled in during printing. The
information that follows the % character <em>specifies</em> how the
value is <em>converted</em> from its internal form (binary) to printed
form (characters)–that’s where the term “conversion specification” comes
from. For example, the conversion specification <code>%d</code>
specifies that <code>printf</code> is to convert an <code>int</code>
value from binary to a string of decimal digits, while <code>%f</code>
does the same for a <code>float</code> value.</p>
<p>Ordinary characters in a format string are printed exactly as they
appear in the string; conversion specifications are replaced by the
values to be printed. Consider the following example:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">43.2892</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fl">5527.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i = %d, j = %d, x = %f, y = %f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span></code></pre></div>
<p>This call of <code>printf</code> produces the following output:</p>
<pre class="shell"><code>i = 10, j = 20, x = 43.289200, y = 5527.000000</code></pre>
<p>The ordinary characters in the format string are simply copied to the
output line. The four conversion specifications are replaced by the
values of the variables <code>i</code>, <code>j</code>, <code>x</code>,
and <code>y</code>, in that order.</p>
<div class="infoBox">
<p><span class="warningEmoji"><span></p>
<p>C compilers aren’t required to check that the number of conversion
specifications in a format string matches the number of output items.
The following call of <code>printf</code> has more conversion
specifications than values to be printed:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p><code>printf</code> will print the value of <code>i</code> correctly,
then print a second (meaningless) integer value. A call with too few
conversion specifications has similar problems:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>In this case, <code>printf</code> prints the value of <code>i</code>
but doesn’t show the value of <code>j</code>.</p>
<p>Furthermore, compilers aren’t required to check that a conversion
specification is appropriate for the type of item being printed. If the
programmer uses an incorrect specification, the program will simply
produce meaningless output. Consider the following call of
<code>printf</code>, in which the <code>int</code> variable
<code>i</code> and the <code>float</code> variable <code>x</code> are in
the wrong order:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%f %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> x<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>Since <code>printf</code> must obey the format string, it will
dutifully display a <code>float</code> value, followed by an
<code>int</code> value. Unfortunately, both will be meaningless.</p>
</div>
<h3 id="conversion-specifications">3.1.1 Conversion Specifications</h3>
<p>Conversion specifications give the programmer a great deal of control
over the appearance of output. On the other hand, they can be
complicated and hard to read. In fact, describing conversion
specifications in complete detail is too arduous a task to tackle this
early in the book. Instead, we’ll just take a brief look at some of
their more important capabilities.</p>
<p>In chapter 2 , we saw that a conversion specification can include
formatting information. In particular, we used <code>%.1f</code> to
display a <code>float</code> value with one digit after the decimal
point. More generally, a conversion specification can have the form
<code>%m.pX</code> or <code>%-m.pX</code>, where <code>m</code> and
<code>p</code> are integer constants and <code>X</code> is a letter.
Both <code>m</code> and <code>p</code> are optional; if <code>p</code>
is omitted, the period that separates <code>m</code> and <code>p</code>
is also dropped. In the conversion specification <code>%10.2f</code>,
<code>m</code> is <code>10</code>, <code>p</code> is <code>2</code>, and
<code>X</code> is <code>f</code>. In the specification
<code>%.2f</code>, <code>p</code> is <code>2</code> and <code>m</code>
is missing.</p>
<p>The <strong><em>minimum field width</em></strong>, <code>m</code>,
specifies the minimum number of characters to print. If the value to be
printed requires fewer than <code>m</code> characters, the values is
right justified within the field. (in other words, extra spaces precede
the value.) For example, the specification <code>%4d</code> would
display the number 123 as <code>123</code>. (Please notice the
preceeding space). If the value to be porinted requires more than
<code>m</code> characters, the field width automatically expands to the
necessary size. Thus, the specification <code>%4d</code> would display
the number 12345 as <code>12345</code>–no digits are lost. Putting a
minus sign in front of <code>m</code> causes left justification; the
specification <code>%-4d</code> would display 123 as
<code>123</code>.</p>
<p>The meaning of the <strong><em>precision</em></strong>,
<code>p</code> isn’t as easily described, since it depends on the choice
of <code>X</code>, the <strong><em>conversion specifier</em></strong>.
<code>X</code> indicates which conversion should be applied to the value
before it’s printed. The most common conversion specifiers for numbers
are:</p>
<ul>
<li>
<p><span class="QandA"></span></p>
<p><code>d</code> – Displays an integer in decimal (base 10) form.
<code>p</code> indicates the minimum number of digits to display (extra
zeros are added to the beginning of the number if necessary); if
<code>p</code> is omitted, it is assumed to have the value 1. (In other
words, <code>%d</code> is the same as <code>%.1d</code>.)</p>
</li>
<li>
<p><code>e</code> – Displays a floating-point number in exponential
format (scientific notation). <code>p</code> indicates how many digits
should appear after the decimal point (the default is 6). If
<code>p</code> is 0, the decimal point is not displayed.</p>
</li>
<li>
<p><code>f</code> – Displays a floating-point number in “fixed decimal”
format, without an exponent. <code>p</code> has the same meaning as for
the <code>e</code> specifier.</p>
</li>
<li>
<p><code>g</code> – Displays a floating-point number in either
exponential format or fixed decimal format, depending on the number’s
size. <code>p</code> indicates the maximum number of significant digits
(<em>not</em> digits after the decimal point) to be displayed. Unlike
the <code>f</code> conversion, the <code>g</code> conversion won’t show
trailing zeros. Furthermore, if the value to be printed has no digits
after the decimal point, <code>g</code> doesn’t display the decimal
point.</p>
</li>
</ul>
<p>The <code>g</code> specifier is especially useful for displaying
numbers whose size can’t be predicted when the program is written or
that tend to vary widely in size. When used to print a moderately large
or moderately small number, the <code>g</code> specifier uses fixed
decimal format. But when used to print a very large or very small
number, the <code>g</code> specifier switches to exponential format so
that the number will require fewer characters.</p>
<p>There are many other specifiers besides <code>%d</code>,
<code>%e</code>, <code>%f</code>, and <code>%g</code>. I’ll gradually
introduce many of them in subsequent chapters. For the full list, and
for a complete explanation of the other capabilities of conversion
specifications, consult Section 22.3.</p>
<h3 id="using-printf-to-format-numbers">3.1.2 Using <code>printf</code>
to Format Numbers</h3>
<p>The following program illustrates the use of <code>printf</code> to
print integers and floating-point numbers in various formats.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">/** </span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co">  * file: tprintf.c</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co">  * Purpose: Prints int and float values in various formats</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="co">  * Author: K. N. King</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="co">  */</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x<span class="op">;</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">40</span><span class="op">;</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="fl">839.21</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;|%d|%5d|%-5d|%5.3d|</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> i<span class="op">,</span> i<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;|%10.3f|%10.3e|%-10g|</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> x<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The character <code>|</code> in the <code>printf</code> format
strings are there merely to help show how much space each number
occupies when printed; unlike <code>%</code> or <code>\</code>, the
<code>|</code> character has no special significance to
<code>printf</code>. The output of this program is:</p>
<pre class="shell"><code>|40|   40|40   |  040|
|   839.210| 8.392e+02|839.21    |</code></pre>
<p>Let’s take a closer look at the conversion specifications used in
this program:</p>
<ul>
<li>
<p><code>%d</code> – Displays <code>i</code> in decimal form, using a
minimum amount of space.</p>
</li>
<li>
<p><code>%5d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters. Since <code>i</code> requires only two
characters,three spaces were added.</p>
</li>
<li>
<p><code>%-5d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters; since the value of <code>i</code> doesn’t
require five characters, the spaces are added afterward (that is,
<code>i</code> is left-justified in a field of length five).</p>
</li>
<li>
<p><code>%5.3d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters overall and a minimum of three digits. Since
<code>i</code> is only two digits long, an extra zero was added to
guarantee three digits. The resulting number is only three characters
long, so two spaces were added, for a total of five characters
(<code>i</code> is right-justified).</p>
</li>
<li>
<p><code>%10.3f</code> – Display <code>x</code> in fixed decimal form,
using 10 characters overall with three digits after the decimal point.
Since <code>x</code> requires only seven charcaters (three before the
decimal point, three after the decimal point, and one for the decimal
point itself), three spaces precede <code>x</code>.</p>
</li>
<li>
<p><code>%10.3e</code> – Displays <code>x</code> in exponential form,
using 10 characters overall, with three digits after the decimal point.
<code>x</code> requires nine characters altogether (including the
exponent), so one space precedes <code>x</code>.</p>
</li>
<li>
<p><code>%-10g</code> – Display <code>x</code> in either fixed decimal
form or exponential form, using 10 characters overall. In this case,
<code>printf</code> chose to display <code>x</code> in fixed decimal
form. The presence of the minus sign forces left justification, so
<code>x</code> is followed by spaces.</p>
</li>
</ul>
<h3 id="escape-sequences">3.1.3 Escape Sequences</h3>
<p>The <code>\n</code> code that we often use in format strings is
called an <strong><em>escape sequence</em></strong>. Escape sequences
enable strings to contain characters that would otherwise cause problems
for the compiler, including nonprinting (control) characters and
characters that have special meaning to the compiler (such as
<code>"</code>). We’ll provide a complete list of escape sequences
later; for now, here’s a sample:</p>
<table>
<tbody>
<tr class="odd">
<td>Alert (bell)</td>
<td><code>\a</code></td>
</tr>
<tr class="even">
<td>Backspace</td>
<td><code>\b</code></td>
</tr>
<tr class="odd">
<td>New line</td>
<td><code>\n</code></td>
</tr>
<tr class="even">
<td>Horizontal tab</td>
<td><code>\t</code></td>
</tr>
</tbody>
</table>
<p><span class="QandA"><span></p>
<p>When they appear in <code>printf</code> format strings, these escape
sequences represent actions to perform upon printing. printing
<code>\a</code> causes an audible beep on most machines. Printing
<code>\b</code> moves the cursor back one position. Printing
<code>\n</code> advances the cursor to the beginning of the next line.
printing <code>\t</code> moves the cursor to the next tab stop.</p>
<p>A string may contain any number of escape sequences. consider the
following <code>printf</code> example, in which the format string
contains six escape sequences:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Item</span><span class="sc">\t</span><span class="st">Unit</span><span class="sc">\t</span><span class="st">Purchase</span><span class="sc">\n\t</span><span class="st">Price</span><span class="sc">\t</span><span class="st">Date</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Executing this statement prints a two-line heading:</p>
<pre class="shell"><code>Item    Unit    Purchase
        Price   Date</code></pre>
<p>Another common escape sequence is <code>\"</code>, which represents
the <code>"</code> character. Since the <code>"</code> charcater marks
the beginning of this sequence. here’s and example:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">Hello!</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>This statement produces the following output:</p>
<pre class="shell"><code>&quot;Hello!&quot;</code></pre>
<p>Incidentally, you can’t just put a single <code>\</code> character in
a string; the compiler will assume that it’s the beginning of an escape
sequence. To print a single <code>\</code> character, put two
<code>\</code> characters in the string:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\\</span><span class="st">&quot;</span><span class="op">);</span>    <span class="co">/* prints one \ character */</span></span></code></pre></div>
<h2 id="the-scanf-function">3.2 The <code>scanf</code> Function</h2>
<p>Just as <code>printf</code> prints output in a specified format,
<code>scanf</code> reads input according to a particular format. A
<code>scanf</code> format string, like a <code>printf</code> format
string, may contain both ordinary characers and conversion
specifications. The conversions allowed with <code>scanf</code> are
essentially the same as those used with <code>printf</code>.</p>
<p>In many cases, a <code>scanf</code> format string will contain only
conversion specifications, as in the following example:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f, &amp;i, &amp;j, &amp;x, &amp;y);</span></span></code></pre></div>
<p>Suppose that the user enters the following input line:</p>
<pre class="shell"><code>1 -20 .3 -4.0e3</code></pre>
<p><code>scanf</code> will read the line, converting its characters to
the numbers they represent, and then assign 1, -20, 0.3, and -4000.0 to
<code>i</code>, <code>j</code>, <code>x</code>, and <code>y</code>,
respectively. “tightly packed” format strings like
<code>"%d%d%f%f</code> are common in <code>scanf</code> calls.
<code>printf</code> format strings are less likely to have adjacent
conversion specifications.</p>
<p><code>scanf</code>, like <code>printf</code>, contains several traps
for the unwary. When using <code>scanf</code>, the programmer must check
that the number of conversion specifications matches the number of input
variables and that each conversion is appropriate for the corresponding
variable–as with <code>printf</code>, the compiler isn’t required to
check for a possible mismatch. Another trap involves the
<code>&amp;</code> symbol, which normally precedes each variable in a
<code>scanf</code> call. The <code>&amp;</code> is usually (but not
always) required, and it’s the programmer’s responsibility to remember
to use it.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Forgetting to put the <code>&amp;</code> symbol in front of variable
in a call of <code>scanf</code> will have unpredictable–and possibly
disastrous–results. A program crash is a common outcome. At the very
least, the value that is read from the input won’t be stored in the
variable; instead, the variable will retain its old value (which may be
meaningles if the variable wasn’t given an initial value). Omitting the
<code>&amp;</code> is an extremely common error–be careful! Some
compilers can spot this error and produce a warning message such as
<em>“format argument is not a pointer”</em>. (The term <em>pointer</em>
is defined in Chapter 11; the <code>&amp;</code> symbol is used to
create a pointer to a variable.) If you get a warning, check for a
missing <code>&amp;</code>.</p>
</div>
<p>Calling <code>scanf</code> is a powerful but unforgiving way to read
data. Many professional C programmers avoid <code>scanf</code>, instead
reading all data in character form and converting it to numeric form
later. We’ll use <code>scanf</code> quite a bit, especially in the early
chapters of this book, because it provides a simple way to read numbers.
Be aware, however, that many of our programs won’t behave properly if
the user enters unexpected input. As we’ll see later, it’s possible to
have a program test whether <code>scanf</code> successfully read the
requested data (and attempt to recover if it didn’t). Such tests are
impractical for the programs in this book–they would add too many
statements and obscure the point of the examples.</p>
<h3 id="how-scanf-works">3.2.1 How <code>scanf</code> Works</h3>
<p><code>scanf</code> can actually do much more than I’ve indicated so
far. It is essentially a “pattern-matching” function that tries to match
up groups of input characters with conversion specifications.</p>
<p>Like the <code>printf</code> function, <code>scanf</code> is
controlled by the format string. When it is called, <code>scanf</code>
begins processing the information in the string, starting at the left.
For each conversion specification in the format string,
<code>scanf</code> tries to locate an item of the appropriate type in
the input data, skipping blank space if necessary. <code>scanf</code>
then reads the item, stopping when it encounters a character that can’t
possibly belong to the item. If the item was read sucessfully,
<code>scanf</code> continues processing the rest of the format string.
If any item is not read successfully, <code>scanf</code> returns
immediately without looking at the rest of the format string (or the
remaining input data).</p>
<p>As it searches for the beginning of a number, <code>scanf</code>
ignores <strong><em>white-space characters</em></strong> (the space,
horizontal and vertical tab, form-feed, and new-line characters). As a
result, numbers can be put on a single line or spread out over several
lines. Consider the following call of <code>scanf</code>:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span></code></pre></div>
<p>Suppose the user enters three lines of input:</p>
<pre class="shell"><code>  1
-20   .3
   -4.0e3</code></pre>
<p><code>scanf</code> sees one continuous stream of characters:</p>
<pre><code>&lt;space&gt;&lt;space&gt;1&lt;newLine&gt;-20&lt;space&gt;&lt;space&gt;&lt;space&gt;.3&lt;newLine&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;-4.0e3&lt;newLine&gt;</code></pre>
<p>(I’m using <code>&lt;space&gt;</code> to represent the space
character and <code>&lt;newLine&gt;</code> to represent the new-line
character.) Since it skips over white-space characters as it looks for
the beginning of each number, <code>scanf</code> will be able to read
the numbers successfully.</p>
<p><code>scanf</code> “peeks” at the final new-line character without
actually reading it. This new-line will be the first character read by
the next call of <code>scanf</code>.</p>
<p>What rules does <code>scanf</code> follow to recognize an integer or
a floating-point number? When asked to read an integer,
<code>scanf</code> first searches for a digit, a plus sign, or a minus
sign; it then reads digits until it reaches a nondigit. when asked to
read a floating-point number, <code>scanf</code> looks for<br />
- a plus or minus sign (optional), followed by<br />
- a series of digits (possibly containing a decimal point), followed
by<br />
- an exponent (optional). An exponent consists of the letter
<code>e</code> (or <code>E</code>), an optional sign, and one or more
digits.</p>
<p>The <code>%e</code>, <code>%f</code>, and <code>%g</code> conversions
are interchangeable when used with <code>scanf</code>; all three follow
the same rules for recognizing a floating-point number.</p>
<p><span class="QandA"><span></p>
<p>When <code>scanf</code> encounters a character that can’t be part of
the current item, the character is “put back” to be read again during
the scanning of the next input item or during the next call of
<code>scanf</code>. Consider the following (admittedly pathological)
arrangement of our four numbers:</p>
<pre class="shell"><code>1-20.3-4.0e3
</code></pre>
<p>Let’s use the same call of <code>scanf</code> as before:</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span></code></pre></div>
<p>Here’s how <code>scanf</code> would process the new input:</p>
<ul>
<li>Conversion specification: <code>%d</code>. The first nonblank input
character is <code>1</code>; since integers can begin with 1,
<code>scanf</code> then reads the next character, <code>-</code>.
Recognizing that <code>-</code> can’t appear inside an integer,
<code>scanf</code> stores <code>1</code> into <code>i</code> and puts
the <code>-</code> character back.<br />
</li>
<li>Conversion specification: <code>%d</code>. <code>scanf</code> then
reads the characters <code>-</code>, <code>2</code>, <code>0</code>, and
<code>.</code> (period). Since an integer can’t contain a decimal point,
<code>scanf</code> stores <code>-20</code> into <code>j</code> and puts
the <code>.</code> character back.<br />
</li>
<li>Conversion specification: <code>%f</code>. <code>scanf</code> reads
the characters <code>.</code>, <code>3</code>, and <code>-</code>. Since
a floating-point number can’t contain a minus sign after a digit,
<code>scanf</code> stores <code>0.3</code> into <code>x</code> and puts
the <code>-</code> character back.<br />
</li>
<li>conversion specification <code>%f</code>. Lastly, <code>scanf</code>
reads the characters <code>-</code>, <code>4</code>, <code>.</code>,
<code>0</code>, <code>e</code>, <code>3</code>, and a new line. Since a
floating-point number can’t contain a new-line character,
<code>scanf</code> stores <span class="displayInlineMath"><span
class="math display">−4.0 × 10<sup>3</sup></span></span> into
<code>y</code> and puts the new-line character back.</li>
</ul>
<p>In this example, <code>scanf</code> was able to match every
conversion specification in the format string with an input item. Since
the new-line character wasn’t read, it will be left for the next call of
<code>scanf</code>.</p>
<h3 id="ordinary-characters-in-format-strings">3.2.2 Ordinary Characters
in Format Strings</h3>
<p>The concept of pattern-matching can be taken one step further by
writing format strings that contain ordinary characters in addition to
conversion specifications. The action that <code>scanf</code> takes when
it processes an ordinary character in a format string depends on whether
or not it’s a white-space character.</p>
<ul>
<li>
<p><strong><em>White-space characters.</em></strong> When it encounters
one or more consecutive white-space characters in a format string,
<code>scanf</code> repeatedly reads white-space characters from the
input until it reaches a non-white-space character (which is “put
back”). The number of white-space characters in the format string is
irrelevant; one white-space character in the format string will match
any number of white-space characters in the input. (Incidentally,
putting a white-space character in a format string doesn’t force the
input to contain white-space characters. A white-space character in a
format string matches <em>any</em> number of white-space characters in
the input, including none.)</p>
</li>
<li>
<p><strong><em>Other characters.</em></strong> When it encounters a
non-white-space character in a format string, <code>scanf</code>
compares it with the next input character. if the two characters match,
<code>scanf</code> discards the input character and continues processing
the format string. If the characters don’t match, <code>scanf</code>
puts the offencing character back into the input, then aborts without
further processing the format string or reading characters from the
input.</p>
<p>For example, suppose that the format string is <code>"%d/%d"</code>.
If the input is <code>&lt;space&gt;5/&lt;space&gt;96</code>,
<code>scanf</code> skips the first space while looking for an integer,
matches <code>%d</code> with <code>5</code>, matches <code>/</code> with
<code>/</code>, skips a space while looking for another integer, and
matches <code>%d</code> with <code>96</code>. On the other hand, if the
input is <code>&lt;space&gt;5&lt;space&gt;/&lt;space&gt;96</code>,
<code>scanf</code> skips one space, matches <code>%d</code> with
<code>5</code>, then attempts to match the <code>/</code> in the format
string with a space in the input. There’s no match, so
<code>scanf</code> puts the space back; the
<code>&lt;space&gt;/&lt;space&gt;96</code> characters remain to be read
by the next call of <code>scanf</code>. To allow spaces after the first
number, we should use the format string <code>"%d /%d"</code>
instead.</p>
</li>
</ul>
<h3 id="confusing-printf-with-scanf">3.2.3 Confusing <code>printf</code>
with <code>scanf</code></h3>
<p>Although calls of <code>scanf</code> and <code>printf</code> may
appear similar, there are significant differences between the two
functions; ignoring these differences can be hazardous to the health of
your program.</p>
<p>One common mistake is to put <code>&amp;</code> in front of variables
in a call of <code>printf</code>:</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>Fortunately, this mistake is fairly easy to spot: <code>printf</code>
will display a couple of odd-looking numbers instead of the values of
<code>i</code> and <code>j</code>.</p>
<p>Since <code>scanf</code> normally skips white-space characters when
looking for data items, there’s often no need for a format string to
include characters other than conversion specifications. Incorrectly
assuming that <code>scanf</code> format strings should resemble
<code>printf</code> format strings–another common error–may cause
<code>scanf</code> to behave in unexpected ways. Let’s see what happens
when the following call of <code>scanf</code> is executed:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d, %d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
<p><code>scanf</code> will first look for an integer in the input, which
it stores in the variables <code>i</code>. <code>scanf</code> will then
try to match a comma with the next input character. If the next input
character is a space, not a comma, <code>scanf</code> will terminate
without reading a value for <code>j</code>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Although <code>printf</code> format strings often end with
<code>\n</code>, putting a new-line character at the end of a
<code>scanf</code> format string is usually a bad idea. To
<code>scanf</code>, a new-line character in a format string is
equivalent to a space; both cause <code>scanf</code> to advance to the
next non-white-space character. For example, if the format string is
<code>" %d\n"</code>, <code>scanf</code> will skip white space, read an
integer, then skip to the next non-white-space character. A format
string like this can cause an interactive program to “hang” until user
enters a nonblank character.</p>
</div>
<h3 id="program-adding-fractions">3.2.4 (PROGRAM) Adding Fractions</h3>
<p>To illustrate <code>scanf</code>’s ability to match patterns,
consider the problem of reading a fraction entered by the user.
Fractions are customarily written in the form
<em>numerator/denominator</em>. Instead of having the user enter the
numerator and denominator of a fraction as separate integers,
<code>scanf</code> makes it possible to read the entire fraction. The
following program, which adds two fractions, illustartes this
technique.</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: addfrac.c</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Adds two fractions</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num1<span class="op">,</span> denom1<span class="op">,</span> num2<span class="op">,</span> denom2<span class="op">,</span> result_num<span class="op">,</span> result_denom<span class="op">;</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter first fraction: &quot;</span><span class="op">);</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d/%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num1<span class="op">,</span> <span class="op">&amp;</span>denom1<span class="op">);</span></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter second fraction: &quot;</span><span class="op">);</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d/%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num2<span class="op">,</span> <span class="op">&amp;</span>denom2<span class="op">);</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>    result_num <span class="op">=</span> num1 <span class="op">*</span> denom2 <span class="op">+</span> num2 <span class="op">*</span> denom1<span class="op">;</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>    result_denom <span class="op">=</span> denom1 <span class="op">*</span> denom2<span class="op">;</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;The sum is %d/%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> result_num<span class="op">,</span> result_denom<span class="op">);</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A session with this program might have the following appearance:</p>
<pre class="shell"><code>Enter first fraction: 5/6
Enter second fraction: 3/4
The sum is 38/24</code></pre>
<p>Note that the resulting fraction isn’t reduced to lowest terms.</p>
<hr />
<h2 id="q-a-1">Q &amp; A</h2>
<div class="QandA_question">
<p>*Q: I’ve seen the <code>%i</code> conversion used to read and write
integers. What’s the difference between <code>%i</code> and
<code>%d</code>? [p. 39]</p>
</div>
<div class="QandA_answer">
<p>A: In a <code>printf</code> format string, there’s no difference
between the two. In a <code>scanf</code> format string, however,
<code>%d</code> can only match an integer written in decimal (base 10)
form, while <code>%i</code> can match an integer expressed in octal
(base 8), decimal, or hexadecimal (base 16). If an input number has a
<code>0</code> prefix (as in <code>056</code>), <code>%i</code> treats
it as an octal number, if it has a <code>0x</code> or <code>0X</code>
prefix (as in <code>0x56</code>), <code>%i</code> treats it as a hex
number. Using <code>%i</code> instead of <code>%d</code> to read a
number can have surprising results if the user should accidentally put
<code>0</code> at the beginning of the number. Because of this trap, I
recommend sticking with <code>%d</code>.</p>
</div>
<div class="QandA_question">
<p>Q: If <code>printf</code> treats <code>%</code> as the beginning of a
conversion specification, how can I print the <code>%</code>
character?</p>
</div>
<div class="QandA_answer">
<p>A: If <code>printf</code> encounters two consecutive <code>%</code>
characters in a format strring, it prints a single <code>%</code>
character. For example, the statement</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Net profit: %d%%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> profit<span class="op">);</span></span></code></pre></div>
<p>might print</p>
<pre class="shell"><code>Net profit: 10%</code></pre>
</div>
<div class="QandA_question">
<p>Q: The <code>\t</code> escape is supposed to cause
<code>printf</code> to advance to the next tab stop. How do I know how
far apart tab stops are? [p. 41]</p>
</div>
<div class="QandA_answer">
<p>A: You don’t. The effect of printing <code>\t</code> isn’t defined in
C; it depends on what your operating system does when asked to print a
tab character. Tab stops are typically eight characters apart, but C
makes no guarantee.</p>
</div>
<div class="QandA_question">
<p>Q: What does <code>scanf</code> do if it’s asked to read a number but
the user enters nonnumeric input?</p>
</div>
<div class="QandA_answer">
<p>A: Let’s look at the following example:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter a number: &quot;</span><span class="op">);</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span></code></pre></div>
<p>Suppose that the user enters a valid number, followed by nonnumeric
characters:</p>
<pre class="shell"><code>Enter a number: 23foo</code></pre>
<p>In this case, <code>scanf</code> reads the <code>2</code> and the
<code>3</code>, storing <code>23</code> in <code>i</code>. The remaining
characters (<code>foo</code>) are left to be read by the next call of
<code>scanf</code> (or some other input function). On the other hand,
suppose that the input is invalid from the beginning:</p>
<pre class="shell"><code>Enter a number: foo</code></pre>
<p>In this case, the value of <code>i</code> is undefined and
<code>foo</code> is left for the next <code>scanf</code>.</p>
<p>What can we do about this sad state of affairs? Later, we’ll see how
to test whether a call of <code>scanf</code> has succeeded. If the call
fails, we can have the program either terminate or try to recover,
perhaps by discarding the offending input and asking the user to try
again. (Ways to discard bad input are discussed in the Q&amp;A section
at the end of chapter 22.)</p>
</div>
<div class="QandA_question">
<p>Q: I don’t understand how <code>scanf</code> can “put back”
characters and read them again later. [p. 44]</p>
</div>
<div class="QandA_answer">
<p>A: As it turns out, programs don’t read user input as it is typed.
Instead input is stored in a hidden buffer, to which <code>scanf</code>
has access. It’s easy for <code>scanf</code> to put characters back into
the buffer for subsequent reading. Chapter 22 discusses input buffering
in more detail.</p>
</div>
<div class="QandA_question">
<p>Q: What does <code>scanf</code> do if the user puts punctuation marks
(commas, for example) between numbers?</p>
</div>
<div class="QandA_answer">
<p>A: Let’s look at a simple example. Suppose that we try to read a pair
of integers using <code>scanf</code>:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter two numbers: &quot;</span><span class="op">);</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
<p>If the user enters</p>
<pre class="shell"><code>4,28</code></pre>
<p><code>scanf</code> will read <code>4</code> and store it in
<code>i</code>, As it searches for the beginning of the second number,
<code>scanf</code> encounters the comma. Since numbers can’t begin with
a comma, <code>scanf</code> returns immediately. The comma and the
second number are left for the next call of <code>scanf</code>.</p>
<p>Of course, we can easily solve the problem by adding a comma to the
format string if we’re sure that the numbers will <em>always</em> be
separated by a comma:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter two numbers, separated by a comma: &quot;</span><span class="op">);</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d,%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
</div>
<h2 id="examples-1">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh03/cknkCh03Exmp/">./cknkCh03/cknkCh03Exmp/</a></li>
</ul>
<h2 id="exercises-1">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh03/cknkCh03Exrc/README.md">./cknkCh03/cknkCh03Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh03/cknkCh03Exrc/cknkCh03ExrcReadme.html">./cknkCh03/cknkCh03Exrc/cknkCh03ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh03/cknkCh03Exrc/">./cknkCh03/cknkCh03Exrc/</a></li>
</ul>
<h2 id="programming-projects-1">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh03/cknkCh03Prj/README.md">./cknkCh03/cknkCh03Prj/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh03/cknkCh03Prj/cknkCh03PrjReadme.html">./cknkCh03/cknkCh03Prj/cknkCh03PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh03/cknkCh03Prj/">./cknkCh03/cknkCh03Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="expressions">4 Expressions</h1>
<div class="theQuote">
<p>One does not learn computing by using a hand calculator, but one can
forget arithmetic.</p>
</div>
<p>One of C’s distinguishing characteristics is its emphasis on
expressions–formulas that show how to compute a value–rather than
statements. The simplest expressions are variables and constants. A
variable represents a value to be computed as the program runs; a
constant represents a value that doesn’t change. More complicated
expressions apply operators to operands (which are themselves
expressions). In the expression <code>a + (b * c)</code>, the
<code>+</code> operator is applied to the operands <code>a</code> and
<code>(b * c)</code>, both of which are expressions in their own
right.</p>
<p>Operators are the basic tools for building expressions, and C has an
unusually rich collection of them. To start off, C provides the
rudimentary operators that are found in most programming
languages:<br />
- Arithmetic operators, including addition, subtraction, multiplication,
and division.<br />
- Relational operators to perform comparisons such as “<code>i</code> is
<em>greater than</em> 0.”<br />
- Logical operators to build conditions such as “<code>i</code> is
greater than 0 <em>and</em> <code>i</code> is less than 10.”</p>
<p>But C doesn’t stop here; it goes on to provide dozens of other
operators. There are so many operators, in fact, that we’ll need to
introduce them gradually over the first twenty chapters of this book.
Mastering so many operators can be a chore, but it’s essential to
becoming proficient at C.</p>
<p>In this chapter, we’ll cover some of C’s most fundamental operators:
the arithmetic operators (Section 4.1), the assignment operators
(Section 4.2), and the increment and decrement operators (Section 4.3).
Section 4.1 also explains operator precedence and associativity, which
are important for expressions that contain more than one operator.
Section 4.4 describes how C expressions are evaluated. Finally, Section
4.5 introduces the expression statement, an unusual feature that allows
any expression to serve as a statement.</p>
<h2 id="arithmetic-operators">4.1 Arithmetic Operators</h2>
<p>The <strong><em>arithmetic operators</em></strong>–operators that
perform addition, subtraction, multiplication, and division–are the
workhorses of many programming languages, including C. Table 4.1 shows
C’s arithmetic operators.</p>
<p><strong>Table 4.1:</strong> Arithmetic Operators</p>
<table>
<thead>
<tr>
<th rowspan="2" style="text-align: center">
<p><strong><em>Unary</em></strong></p>
</th>
<th colspan="2" style="text-align: center">
<p><strong><em>Binary</em></strong></p>
</th>
</tr>
<tr>
<th style="text-align: center">
<p><strong><em>Additive</em></strong></p>
</th>
<th style="text-align: center">
<p><strong><em>Multiplicative</em></strong></p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><code>+</code> unary plus</p>
</td>
<td>
<p><code>+</code> addition</p>
</td>
<td>
<p><code>*</code> multiplication</p>
</td>
</tr>
<tr>
<td>
<p><code>-</code> unary minus</p>
</td>
<td>
<p><code>-</code> subtraction</p>
</td>
<td>
<p><code>/</code> division</p>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
<p><code>%</code> remainder</p>
</td>
</tr>
</tbody>
</table>
<p>The additive and multiplicative operators are said to be
<strong><em>binary</em></strong> because they require <em>two</em>
operands. The <strong><em>unary</em></strong> operators require
<em>one</em> operand:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">+</span><span class="dv">1</span><span class="op">;</span>    <span class="co">/* + used as a unary operator */</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span>    <span class="co">/* - used as a unary operator */</span></span></code></pre></div>
<p>The unary <code>+</code> operator does nothing; in fact, it didn’t
even exist in K &amp; R C. It’s used primarily to emphasize that a
numeric constant is positive.</p>
<p>The binary operators probably look familiar. The only one that might
not is <code>%</code>, the remainder operator. The value of
<code>i % j</code> is the remainder when <code>i</code> is divided by
<code>j</code>. For example, the value of <code>10 % 3</code> is 1, and
the value of <code>12 % 4</code> is 0.</p>
<p><span class="QandA"></span></p>
<p>The binary operators in Table 4.1–with the exception of
<code>%</code>–allow either integer or floating-point operands, with
mixing allowed. When <code>int</code> and <code>float</code> operands
are mixed, the result has type <code>float</code>. Thus,
<code>9 + 2.5f</code> has the value <code>11.5</code>, and
<code>6.7f / 2</code> has the value <code>3.35</code>.</p>
<p>The <code>/</code> and <code>%</code> operators require special
care:</p>
<ul>
<li>
<p>The <code>/</code> operator can produce surprising results. When both
of its operands are integers, the <code>/</code> operator “truncates”
the result by dropping the fractional part. Thus, the value of
<code>1 / 2</code> is 0, not <code>0.5</code>.</p>
</li>
<li>
<p>The <code>%</code> operator requires integer operands; if either
operand is not an integer, the program won’t compile.</p>
</li>
<li>
<p>Using zero as the right operand of either <code>/</code> or
<code>%</code> causes undefined behavior.</p>
</li>
<li>
<p><span class="QandA"></span></p>
<p><span class="C99Symbol"></span></p>
<p>Describing the result when <code>/</code> and <code>%</code> are used
with negative operands is tricky. The C89 standard states that if either
operand is negative, the result of a division can be rounded either up
or down. (For example, the value of <code>-9 / 7</code> could be either
-1 or -2). If <code>i</code> or <code>j</code> is negative, the sign of
<code>i % j</code> in C89 depends on the implementation. (For example,
the value of <code>-9 % 7</code> could be either -2 or 5). In C99, on
the other hand, the result of a division is always truncated toward zero
(so <code>-9 / 7</code> has the value -1) and the value of
<code>i % j</code> has the same sign as <code>i</code> (hence the value
of <code>-9 % 7</code> is -2).</p>
</li>
</ul>
<section id="implementation-defined-behaviour" class="infoBox">
<h3>Implementation-Defined Behaviour</h3>
<p>The term <strong><em>Implementation-defined</em></strong> will arise
often enough that it’s worth taking a moment to discuss it. The C
standard deliberately leaves parts of the language unspecified, with the
understanding that an “implementation”–the software needed to compile,
link, and execute programs on a particular platform–will fill in the
details. As a result, the behavior of the program may vary somewhat from
one implementation to another. The behavior of the <code>/</code> and
<code>%</code> operators for negative operands in C89 is an example of
implementation-defined behavior.</p>
<p>Leaving parts of the language unspecified may seem odd or even
dangerous, but it reflects C’s philosophy. One of the language’s goals
is efficiency, which often means matching the way that hardware behaves.
Some CPUs yield -1 when -9 is divided by 7, while others produce -2; the
C89 standard simply reflects this fact of life.</p>
<p>It’s best to avoid writing programs that depend on
implementation-defined behavior. If that’s not possible, at least check
the manual carefully–the C standard requires that implementation-defined
behaior be documented.</p>
</section>
<h3 id="operator-precedence-and-associativity">4.1.1 Operator Precedence
and Associativity</h3>
<p>When an expression contains more than one operator, its
interpretation may not be immediately clear. For example, does
<code>i + j * k</code> mean “add <code>i</code> and <code>j</code>, then
multiply the result by <code>k</code>,” or does it mean “multiply
<code>j</code> and <code>k</code>, then add <code>i</code>”? One
solution to this problem is to add parentheses, writing either
<code>(i + j) * k</code> or <code>i + (j * K)</code>. As a general rule,
C allows the use of parentheses for grouping in all expressions.</p>
<p>What if we don’t use parentheses, though? Will the compiler interpret
<code>i + j * k</code> as <code>(i + j) * k</code> or
<code>i + (j * k)</code>? Like many other languages, C user
<strong><em>operator precedence</em></strong> rules to resolve this
potential ambiguity. The arithmetic operators have the following
relative precedence:</p>
<table>
<tbody>
<tr class="odd">
<td>Highest:</td>
<td><code>+</code></td>
<td><code>-</code></td>
<td>(unary)</td>
</tr>
<tr class="even">
<td></td>
<td><code>*</code></td>
<td><code>/</code></td>
<td><code>%</code></td>
</tr>
<tr class="odd">
<td>Lowest:</td>
<td><code>+</code></td>
<td><code>-</code></td>
<td>(binary)</td>
</tr>
</tbody>
</table>
<p>Operators listed on the same line (such as <code>+</code> and
<code>-</code>) have equal precedence.</p>
<p>When two or more operators appear in the same expression, we can
determine how the compiler will interpret the expression by repeatedly
putting parentheses around subexpressions, starting with high-precedence
operators and working down to low-precedence operators. The following
examples illustrate the result:</p>
<table>
<tbody>
<tr class="odd">
<td><code>i + j * k</code></td>
<td>is equivalent to</td>
<td><code>i + (j * k)</code></td>
</tr>
<tr class="even">
<td><code>-i * -j</code></td>
<td>is equivalent to</td>
<td><code>(-i) * (-j)</code></td>
</tr>
<tr class="odd">
<td><code>+i + j / k</code></td>
<td>is equivalent to</td>
<td><code>(+i) + (j / k)</code></td>
</tr>
</tbody>
</table>
<p>Operator precedence rules alone aren’t enough when an expression
contains two or more operators at the same level of precedence. In this
situation, the <strong><em>associativity</em></strong> of the operators
comes into play. An operator is said to be <strong><em>left
associative</em></strong> if it groups from left to right. The binary
arithmetic operators (<code>*</code>, <code>/</code>, <code>%</code>,
<code>+</code>, and <code>-</code>) are all left associative, so</p>
<table>
<tbody>
<tr class="odd">
<td><code>i - j - k</code></td>
<td>is equivalent to</td>
<td><code>(i - j) - k</code></td>
</tr>
<tr class="even">
<td><code>i * j / k</code></td>
<td>is equivalent to</td>
<td><code>(i * j) / k</code></td>
</tr>
</tbody>
</table>
<p>An operator is <strong><em>right associative</em></strong> if it
groups from right to left. The unary arithmetic operators
(<code>+</code> and <code>-</code>) are both right associative, so</p>
<table>
<tbody>
<tr class="odd">
<td><code>- + i</code></td>
<td>is equivalent to</td>
<td><code>-(+i)</code></td>
</tr>
</tbody>
</table>
<p>Precedence and associativity rules are important in many laguages,
but especially so in C. However, C has so many operators (almost fifty!)
that few programmers bother to memorize the precedence and associativity
rules. Instead, they consult a table of operators when in doubt or just
use plenty of parentheses.</p>
<h3 id="program-computing-a-upc-check-digit">4.1.2 (PROGRAM) Computing a
UPC Check Digit</h3>
<p>For a number of years, manufacturers of goods sold in U.S. and
Canadian stores have put a bar code on each product. This code, known as
a Universal Product Code (UPC), identifies both the manufacturer and the
product. Each bar code represents a twelve-digit number, which is
usually printed underneath the bars. For example, the following bar code
comes from a package of Stouffer’s French Bread Pepperoni Pizza:</p>
<p><img src="./images/cknkCh04_barcode.jpg" style="width:200px; position: relative; left: 50%; right: 50%"/></p>
<p>The digits <code>0  13800 15173  5</code> appear underneath the bar
code. The first digit identifies the type of item (0 or 7 for most
items, 2 for items that must be weighed, 3 for drugs and health-related
merchandise, and 5 for coupons). The first group of five digits
identifies the manufacturer (13800 is the code for Nestlé USA’s Frozen
Food Division). The second group of five digits identifies the product
(including package size). The final digit is a “check digit,” whose only
purpose is to help identify an error in the preceding digits. If the UPC
is scanned incorrectly, the first 11 digits probably won’t be consistent
with the last digit, and the store’s scanner will reject the entire
code.</p>
<p>Here’s one method of computing the check digit:</p>
<blockquote>
<p>Add the first, third, fifth, seventh, ninth, and eleventh
digits.<br />
Add the second, fourth, sixth, eighth, and tenth digits.<br />
Multiply the first sum by 3 and add it to the second sum.<br />
Subtract 1 from the total.<br />
Compute the remainder when the adjusted total is divided by 10.<br />
Subtract the remainder fom 9.</p>
</blockquote>
<p>Using the Stouffer’s example, we get <span
class="displayInlineMath"><span
class="math display">0 + 3 + 0 + 1 + 1 + 3 = 8</span></span> for the
first sum and <span class="displayInlineMath"><span
class="math display">1 + 8 + 0 + 5 + 7 = 21</span></span> for the second
sum. Multiplying the first sum by 3 and adding the second yields 45.
Subtracting 1 gives 44. The remainder upon dividing by 10 is 4. When the
remainder is subtracted from 9, the result is 5. Here are a couple of
other UPCs, in case you want to try your hand at computing the check
digit (raiding the kitchen cabinet for the answer is <em>not</em>
allowed):</p>
<p>Jif Creamy Peanut Butter (18 oz.):
<code>0   51500 24128   ?</code><br />
Ocean Spray Jellied Cranberry Sauce (8 oz.):
<code>0   31200 01005   ?</code></p>
<p>The answers: 8 for Jif and 6 for Ocean Spray.</p>
<p>Let’s write a program that calculates the check digit for an
arbitrary UPC. We’ll ask the user to enter the first 11 digits of the
UPC, then we’ll display the corresponding check digit. To avoid
confusion, we’ll ask the user to enter the number in three parts: the
single digit at the left, the first group of five digits, and the second
group of five digits. Here’s what a session with the program will look
like:</p>
<pre class="shell"><code>Enter the first (single) digit: 0
Enter first group of five digits: 138000
Enter second group of five digits: 15173
Check digit: 5</code></pre>
<p>Instead of reading each digit group as a <em>five</em>-digit number,
we’ll read it as five <em>one</em>-digit numbers. Reading the numbers as
single digits is more convenient; also, we won’t have to worry that one
of the five-digit numbers is too large to store in an <code>int</code>
variable. (Some older compilers limit the maximum value of an
<code>int</code> variable to 32,767.) To read single digits, we’ll use
<code>scanf</code> with the <code>%1d</code> conversion specification,
which matches a one-digit integer.</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: upc.c</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Computes a Universal Product Code check digit</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d<span class="op">,</span> i1<span class="op">,</span> i2<span class="op">,</span> i3<span class="op">,</span> i4<span class="op">,</span> i5<span class="op">,</span> j1<span class="op">,</span> j2<span class="op">,</span> j3<span class="op">,</span> j4<span class="op">,</span> j5<span class="op">,</span> first_sum<span class="op">,</span> second_sum<span class="op">,</span> total<span class="op">;</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter the first (single) digit: &quot;</span><span class="op">);</span></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>d<span class="op">);</span></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter first group of five digits: &quot;</span><span class="op">);</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d%1d%1d%1d%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i1<span class="op">,</span> <span class="op">&amp;</span>i2<span class="op">,</span> <span class="op">&amp;</span>i3<span class="op">,</span> <span class="op">&amp;</span>i4<span class="op">,</span> <span class="op">&amp;</span>i5<span class="op">);</span></span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter second group of five digits: &quot;</span><span class="op">);</span></span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d%1d%1d%1d%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>j1<span class="op">,</span> <span class="op">&amp;</span>j2<span class="op">,</span> <span class="op">&amp;</span>j3<span class="op">,</span> <span class="op">&amp;</span>j4<span class="op">,</span> <span class="op">&amp;</span>j5<span class="op">);</span></span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>    first_sum <span class="op">=</span> d <span class="op">+</span> i2 <span class="op">+</span> i4 <span class="op">+</span> j1 <span class="op">+</span> j3 <span class="op">+</span> j5<span class="op">;</span></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>    second_sum <span class="op">=</span> i1 <span class="op">+</span> i3 <span class="op">+</span> i5 <span class="op">+</span> j2 <span class="op">+</span> j4<span class="op">;</span></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> first_sum <span class="op">+</span> second_sum<span class="op">;</span></span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Check digit: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">9</span> <span class="op">-</span> <span class="op">((</span>total <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="dv">10</span><span class="op">));</span></span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the expression <code>9 - ((total - 1) % 10)</code> could
have been written as <code>9 - (total - 1) % 10</code>, but the extra
set of parentheses makes it easier to understand.</p>
<h2 id="assignment-operators">4.2 Assignment Operators</h2>
<p>Once the value of an expression has been computed, we’ll often need
to store it in a variable for later use. C’s <code>=</code>
(<strong><em>simple assignment</em></strong>) operator is used for that
purpose. For updating a value already stored in a variable, C provides
an assortment of compound assignment operators.</p>
<h3 id="simple-assignment">4.2.1 Simple Assignment</h3>
<p>The effect of the assignment <span class="displayInlineMath"><span
class="math display"><em>v</em> = <em>e</em></span></span> is to
evaluate the expression <code>e</code> and copy its value into
<code>v</code>. As the following examples show, <code>e</code> can be a
constant, a variable, or a more complicated expression:</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>    <span class="co">/* i is now 5 */</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> i<span class="op">;</span>    <span class="co">/* j is now 5 */</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> i <span class="op">+</span> j<span class="op">;</span>    <span class="co">/* k is now 55 */</span></span></code></pre></div>
<p>If <code>v</code> and <code>e</code> don’t have the same type, then
the value of <code>e</code> is converted to the type of <code>v</code>
as the assignment takes place:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="fl">72.99</span><span class="bu">f</span><span class="op">;</span>    <span class="co">/* i is now 72 */</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="dv">136</span><span class="op">;</span>    <span class="co">/* f is now 136.0 */</span></span></code></pre></div>
<p>We’ll return to the topic of type conversion later.</p>
<p>In many programming languages, assignment is a <em>statement</em>; in
C, however, assignment is an <em>operator</em>, just like
<code>+</code>. In other words, the act of assignment produces a result,
just as adding two numbers produces a result. The value of an assignment
<span class="displayInlineMath"><span
class="math display"><em>v</em> = <em>e</em></span></span> is the value
of <code>v</code> after the assignment. Thus, the value of
<code>i = 72.99f</code> is 72 (not 72.99).</p>
<section id="side-effects" class="infoBox">
<h3>Side effects</h3>
<p>We don’t normally expect operators to modify their operands, since
operators in mathematics don’t. Writing <code>i + j</code> doesn’t
modify either <code>i</code> or <code>j</code>; it simply computes the
result of adding <code>i</code> and <code>j</code>.</p>
<p>Most C operators don’t modify their operands, but some do. We say
that these operators have <strong><em>side effects</em></strong>, since
they do more than just compute a value. The simple assignment operator
is the first operator we’ve seen that has side effects; it modifies its
left operand. Evaluating the expression <code>i = 0</code> produces the
result 0 and–as a side effect–assigns 0 to <code>i</code>.</p>
</section>
<p>Since assignment is an operator, several assignments can be chained
together:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> j <span class="op">=</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>The <code>=</code> operator is right associative, so this assignment
is equivalent to</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">(</span>j <span class="op">=</span> <span class="op">(</span>k <span class="op">=</span> <span class="dv">0</span><span class="op">));</span></span></code></pre></div>
<p>The effect is to assign 0 first to <code>k</code>, then to
<code>j</code>, and finally to <code>i</code>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Watch out for unexpected results in chained assignments as a result
of type conversion:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> i <span class="op">=</span> <span class="fl">33.3</span><span class="bu">f</span><span class="op">;</span></span></code></pre></div>
<p><code>i</code> is assigned the value 33, then <code>f</code> is
assigned 33.0 (not 33.3, as you might think).</p>
</div>
<p>In general, an assignment of the form <code>v = e</code> is allowed
wherever a value of type <code>v</code> would be permitted. In the
following example, the expression <code>j = i</code> copies
<code>i</code> to <code>j</code>; the new value of <code>j</code> is
then added to 1, producing the new value of <code>k</code>:</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="op">(</span>j <span class="op">=</span> i<span class="op">);</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">);</span>    <span class="co">/*prints &quot;1 1 2&quot; */</span></span></code></pre></div>
<p>Using the assignment operator in this fashion usually isn’t a good
idea. For one thing, “embedded assignments” can make programs hard to
read. They can also be a source of subtle bugs, as we’ll see in Section
4.4.</p>
<h3 id="lvalues">4.2.2 Lvalues</h3>
<p>Most C operators allow their operands to be variables, constants, or
expressions containing other operators. The assignment operator,
however, requires an <strong><em>lvalue</em></strong> as its left
operand. An lvalue (pronounced “L-value”) represents an object stored in
computer memory, not a constant or the result of a computation.
Variables are lvalues; expressions such as <code>10</code> or
<code>2 * i</code> are not. At this point, variables are the only
lvalues that we know about; other kinds of lvalues will appear in later
chapters.</p>
<p>Since the assignment operator requires an lvalue as its left operand,
it’s illegal to put any other kind of expression on the left side of an
assignment expression:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span> <span class="op">=</span> i<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">+</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="op">-</span>i <span class="op">=</span> j<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>The compiler will detect errors of this nature, and you’ll get an
error message such as “<em>invalid lvalue in assignment</em>.”</p>
<h3 id="compound-assignment">3.2.3 Compound Assignment</h3>
<p>Assignments that use the old value of a variable to compute its new
value are common in C programs. The following statement, for example,
adds 2 to the value stored in <code>i</code>:</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>C’s <strong><em>compound assignment</em></strong> operators allow us
to shorten this statement and others like it. Using the <code>+=</code>
operator, we simply write:</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span>    <span class="co">/* same as i = i + 2; */</span></span></code></pre></div>
<p>The <code>+=</code> operator adds the value of the right operand to
the variable on the left.</p>
<p>There are nine other compound assignment operators, including the
following:</p>
<p><code>-=   *=   /=   %=</code></p>
<p>(We’ll cover the remaining compound assignment operators in a later
chapter.) All compound assignment operators work in much the same
way:</p>
<blockquote>
<p><code>v += e</code> adds <code>v</code> to <code>e</code>, storing
the result in <code>v</code><br />
<code>v -= e</code> subtracts <code>e</code> from <code>v</code>,
storing the result in <code>v</code><br />
<code>v *= e</code> multiplies <code>v</code> by <code>e</code>, storing
the result in <code>v</code><br />
<code>v /= e</code> divides <code>v</code> by <code>e</code>, storing
the result in <code>v</code><br />
<code>v %= e</code> computes the remainder when <code>v</code> is
divided by <code>e</code>, storing the result in <code>v</code>.</p>
</blockquote>
<p><span class="QandA"></span></p>
<p>Note that I’ve been careful not to say that <code>v += e</code> is
“equivalent” to <code>v = v + e</code>. One problem is operator
precedence: <code>i *= j + k</code> isn’t the same as
<code>i = i * j + k</code>. There are also rare cases in which
<code>v += e</code> differs from <code>v = v + e</code> because
<code>v</code> itself has a side effect. Similar remarks apply to the
other compound assignment operators.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>When using the compound assignment operators, be carefull not to
switch the two characters that make up the operator. Switching the
characters may yield an expression that is acceptable to the compiler
but that doesn’t have the intended meaning. For example, if you meant to
write <code>i += j</code> but you typed <code>i =+ j</code> instead, the
program will still compile. Unfortunately, the latter expression is
equivalent to <code>i = (+j)</code>, which merely copies the value of
<code>j</code> into <code>i</code>.</p>
</div>
<p>The compound assignment operators have the same properties as the
<code>=</code> operator. In particular, they’re right associative, so
the statement</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> j <span class="op">+=</span> k<span class="op">;</span></span></code></pre></div>
<p>means</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="op">(</span>j <span class="op">+=</span> k<span class="op">);</span></span></code></pre></div>
<h2 id="incremet-and-decrement-operators">4.3 Incremet and Decrement
Operators</h2>
<p>Two of the most common operations on a variable are “incrementing”
(adding 1) and “decrementing” (subtracting 1). We can, of course,
accomplish these tasks by writing</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> j <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>The compound assignment operators allow us to condense these
statements a bit:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>But C allows increments and decrements to be shortened even further,
using the <code>++</code> (<strong><em>increment</em></strong>) and
<code>--</code> (<strong><em>decrement</em></strong>) operators.</p>
<p>At first glance, the increment and decrement operators are simplicity
itself: <code>++</code> adds 1 to its operand, whereas <code>--</code>
subtracts 1. Unfortunately, this simplicity is misleading–the increment
and decrement operators can be tricky to use. One complication is that
<code>++</code> and <code>--</code> can be used as
<strong><em>prefix</em></strong> operators (<code>++i</code> and
<code>--i</code>, for example) or <strong><em>postfix</em></strong>
operators (<code>i++</code> and <code>i--</code>). The correctness of a
program may hinge on picking the proper version.</p>
<p>Another complication is that, like the assignment operators,
<code>++</code> and <code>--</code> have side effects: they modify the
values of their operands. Evaluating the expression <code>++i</code> (a
“pre-increment”) yields <code>i + 1</code> and–as a side
effect–increments <code>i</code>:</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">++</span>i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span></code></pre></div>
<p>Evaluating th expression <code>i++</code> (a “post-increment”)
produces the result <code>i</code>, but causes <code>i</code> to be
incremented afterwards:</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">++);</span>    <span class="co">/* prints &quot;i is 1&quot; */</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>The first <code>printf</code> shows the original value of
<code>i</code>, before it is incremented. The second <code>printf</code>
shows the new value. As these examples illustrate, <code>++i</code>
means “increment <code>i</code> immediately,” while <code>i++</code>
means “use the old value of <code>i</code> for now, but increment
<code>i</code> later.” How much later? The C standard doesn’t specify a
precise time, but it’s safe to assume that <code>i</code> will be
incremented before the next statement is executed.</p>
<p>The <code>--</code> operator has similar properties:</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">--</span>i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span></code></pre></div>
<div class="sourceCode" id="cb132"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span>    <span class="co">/* prints &quot;i is 1&quot; */</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span></code></pre></div>
<p>When <code>++</code> or <code>--</code> is used more than once in the
same expression, the result can often be hard to understand. Consider
the following statements:</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="op">++</span>i <span class="op">+</span> j<span class="op">++;</span></span></code></pre></div>
<p>What are the values of <code>i</code>, <code>j</code> and
<code>k</code> after these statements are executed? Since <code>i</code>
is incremented <em>before</em> its value is used, but <code>j</code> is
incremented <em>after</em> it is used, the last statement is equivalent
to</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> i <span class="op">+</span> j<span class="op">;</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>so the final values of <code>i</code>, <code>j</code>, and
<code>k</code> are 2, 3, and 4, respectively. In contrast, executing the
statements</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> i<span class="op">++</span> <span class="op">+</span> j<span class="op">++;</span></span></code></pre></div>
<p>will give <code>i</code>, <code>j</code>, and <code>k</code> the
values 2, 3, and 3, respectively.</p>
<p>For the record, the postfix versions of <code>++</code> and
<code>--</code> have higher precedence than unary plus and minus and are
left associative. The prefix versions have the same precedence as unary
plus and minus and are right associative.</p>
<h2 id="expression-evaluation">4.4 Expression Evaluation</h2>
<p>Table 4.2 summarizes the operators we’ve seen so far. (Appendix A has
a similar table that shows <em>all</em> operators.) The first column
shows the precedence of each operator relative to the other operators in
the table (the highest precedence is 1: the lowest is 5). The last
column shows the associativity of each operator.</p>
<p><strong>Table 4.2:</strong> A Partial list of C Operators</p>
<table>
<thead>
<tr class="header">
<th>Precedence</th>
<th>Name</th>
<th>Symbol(s)</th>
<th>Associativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>increment (postfix)</td>
<td><code>++</code></td>
<td>left</td>
</tr>
<tr class="even">
<td>1</td>
<td>decrement (postfix)</td>
<td><code>--</code></td>
<td>left</td>
</tr>
<tr class="odd">
<td>2</td>
<td>increment (prefix)</td>
<td><code>++</code></td>
<td>right</td>
</tr>
<tr class="even">
<td>2</td>
<td>decrement (prefix)</td>
<td><code>--</code></td>
<td>right</td>
</tr>
<tr class="odd">
<td>2</td>
<td>unary plus</td>
<td><code>+</code></td>
<td>right</td>
</tr>
<tr class="even">
<td>2</td>
<td>unary minus</td>
<td><code>-</code></td>
<td>right</td>
</tr>
<tr class="odd">
<td>3</td>
<td>multiplicative</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>left</td>
</tr>
<tr class="even">
<td>4</td>
<td>additive</td>
<td><code>+</code> <code>-</code></td>
<td>left</td>
</tr>
<tr class="odd">
<td>5</td>
<td>assignment</td>
<td><code>=</code> <code>*=</code> <code>/=</code> <code>%=</code>
<code>+=</code> <code>-=</code></td>
<td>right</td>
</tr>
</tbody>
</table>
<p>Table 4.2 (or its larger cousin in Appendix A) has a variety of uses.
Let’s look at one of these. Suppose that we run across a complicated
expression such as</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> c<span class="op">++</span> <span class="op">-</span> d <span class="op">+</span> <span class="op">--</span>e <span class="op">/</span> <span class="op">-</span>f</span></code></pre></div>
<p>as we’re reading someone’s program. This expression would be easier
to understand if there were parentheses to show how the expression is
constructed from subexpressions. With the help of Table 4.2, adding
parentheses to an expression is easy: after examining the expression to
find the operator with highest precedence, we put parentheses around the
operator and its operands, indicating that it should be treated as a
single operand from that point onwards. We then repeat the process until
the expression is fully parenthesized.</p>
<p>In our example, the operator with highest precedence is
<code>++</code>, used here as a postfix operator, so we put parentheses
around <code>++</code> and its operand:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> <span class="op">(</span>c<span class="op">++)</span> <span class="op">-</span> d <span class="op">+</span> <span class="op">--</span>e <span class="op">/</span> <span class="op">-</span>f</span></code></pre></div>
<p>We now spot a prefix <code>--</code> operator and a unary minus
operator (both precedence 2) in the expression:</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> <span class="op">(</span>c<span class="op">++)</span> <span class="op">-</span> d <span class="op">+</span> <span class="op">(--</span>e<span class="op">)</span> <span class="op">/</span> <span class="op">(-</span>f<span class="op">)</span></span></code></pre></div>
<p>Note that the other minus sign has an operand to its immediate left,
so it must be a subtraction operator, not a unary minus operator.</p>
<p>Next, we notice the <code>/</code> operator (precedence 3):</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> <span class="op">(</span>c<span class="op">++)</span> <span class="op">-</span> d <span class="op">+</span> <span class="op">((--</span>e<span class="op">)</span> <span class="op">/</span> <span class="op">(-</span>f<span class="op">))</span></span></code></pre></div>
<p>The expression contains two operators with precedence 4, subtraction
and addition. Whenever two operators with the same precedence are
adjacent to an operand, we’ve got to be careful about associativity. In
our example, <code>-</code> and <code>+</code> are both adjacent to
<code>d</code>, so associativity rules apply. The <code>-</code> and
<code>+</code> operators group from left to right, so parentheses go
around the subtraction first, then the addition:</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> <span class="op">((</span>c<span class="op">++)</span> <span class="op">-</span> d<span class="op">)</span> <span class="op">+</span> <span class="op">((--</span>e<span class="op">)</span> <span class="op">/</span> <span class="op">(-</span>f<span class="op">))</span></span></code></pre></div>
<p>The only remaining operators are <code>=</code> and <code>+=</code>.
Both operators are adjacent to b, so we must take associativity into
account. Assignment operators group from right to left, so parentheses
go around the <code>+=</code> expression first, then the <code>=</code>
expression:</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>a <span class="op">=</span> <span class="op">(</span>b <span class="op">+=</span> <span class="op">(((</span>c<span class="op">++)</span> <span class="op">-</span> d<span class="op">)</span> <span class="op">+</span> <span class="op">((--</span>e<span class="op">)</span> <span class="op">/</span> <span class="op">(-</span>f<span class="op">)))))</span></span></code></pre></div>
<p>The expression is now fully parenthesized.</p>
<h3 id="order-of-subexpression-evaluation">4.4.1 Order of Subexpression
Evaluation</h3>
<p>The rules of operator precedence and associativity allow us to break
any C expression into subexpressions—to determine uniquely where the
parentheses would go if the expression were fully parenthesized.
Paradoxically, these rules don’t always allow us to determine the value
of the expression, which may depend on the order in which its
subexpressions are evaluated.</p>
<p>C doesn’t define the order in which subexpressions are evaluated
(with the exception of subexpressions involving the logical
<em>and</em>, logical <em>or</em>, conditional, and comma operators).
Thus, in the expression <code>(a + b) * (c - d)</code> we don’t know
whether (a + b) will be evaluated before <code>(c - d)</code>.</p>
<p>Most expressions have the same value regardless of the order in which
their subexpressions are evaluated. However, this may not be true when a
subexpression modifies one of its operands. Consider the following
example:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="op">(</span>b <span class="op">=</span> a <span class="op">+</span> <span class="dv">2</span><span class="op">)</span> <span class="op">-</span> <span class="op">(</span>a <span class="op">=</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>The effect of executing the second statement is undefined: the C
standard doesn’t say what will happen. With most compilers, the value of
<code>c</code> will be either 6 or 2. If the subexpression
<code>(b = a + 2)</code> is evaluated first, <code>b</code> is assigned
the value 7 and <code>c</code> is assigned 6. But if
<code>(a = 1)</code> is evaluated first, <code>b</code> is assigned 3
and <code>c</code> is assigned 2.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Avoid writing expressions that access the value of a variable and
also modify the variable elsewhere in the expression. The expression
<code>(b =a + 2) - (a = 1)</code> accesses the value of <code>a</code>
(in order to compute <code>a + 2</code>) and also modifies the value of
<code>a</code> (by assigning it 1). Some compilers may produce a warning
message such as “<em>operation on ‘a’ may be undefined</em>” when they
encounter such an expression.</p>
</div>
<!-- END: div -->
<p>To prevent problems, it’s a good idea to avoid using the assignment
operators in subexpressions; instead, use a series of separate
assignments. For example, the statements above could be rewritten as</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> b <span class="op">-</span> a<span class="op">;</span></span></code></pre></div>
<p>The value of <code>c</code> will always be 6 after these statements
are executed.</p>
<p>Besides the assignment operators, the only operators that modify
their operands are increment and decrement. When using these operators,
be careful that your expressions don’t depend on a particular order of
evaluation. In the following example, <code>j</code> may be assigned one
of two values:</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> i <span class="op">*</span> i<span class="op">++;</span></span></code></pre></div>
<p>It’s natural to assume that <code>j</code> is assigned the value 4.
However, the effect of executing the statement is undefined, and
<code>j</code> could just as well be assigned 6 instead. Here’s the
scenario: (1) The second operand (the original value of 1) is fetched,
then 1 is incremented. (2) The first operand (the new value of 1) is
fetched. (3) The new and old values of <code>i</code> are multiplied,
yielding 6. “Fetching” a variable means to retrieve the value of the
variable from memory. A later change to the variable won’t affect the
fetched value, which is typically stored in a special location (known as
a register) inside the CPU.</p>
<!-- START: div -->
<div class="infoBox">
<p>Undefined Behavior</p>
<p>According to the C standard, statements such as
<code>c = (b = a + 2) - (a = 1);</code> and <code>j = i * i++;</code>
cause undefined behavior, which is different from implementation-defined
behavior (see Section 4.1). When a program ventures into the realm of
undefined behavior, all bets are off. The program may behave differently
when compiled with different compilers. But that’s not the only thing
that can happen. The program may not compile in the first place, if it
compiles it may not run, and if it does run, it may crash, behave
erratically, or produce meaningless results. In other words, undefined
behavior should be avoided like the plague.</p>
</div>
<!-- END: div -->
<h2 id="expression-statements">4.5 Expression Statements</h2>
<p>C has the unusual rule that any expression can be used as a
statement. That is, any expression—regardless of its type or what it
computes—can be turned into a statement by appending a semicolon. For
example, we could turn the expression <code>++i</code> into a
statement:</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="op">++</span>i<span class="op">;</span></span></code></pre></div>
<p>When this statement is executed, <code>i</code> is first incremented,
then the new value of <code>i</code> is fetched (as though it were to be
used in an enclosing expression). However, since <code>++i</code> isn’t
part of a larger expression, its value is discarded and the next
statement executed. (The change to 1 is permanent, of course.)</p>
<p>Since its value is discarded, there’s little point in using an
expression as a statement unless the expression has a side effect. Let’s
look at three examples. In the first example, 1 is stored into
<code>i</code>, then the new value of <code>i</code> is fetched but not
used:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>In the second example, the value of <code>i</code> is fetched but not
used; however, <code>i</code> is decremented afterwards:</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>i<span class="op">--;</span></span></code></pre></div>
<p>In the third example, the value of the expression
<code>i * j - 1</code> is computed and then discarded:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">*</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>Since <code>i</code> and <code>j</code> aren’t changed, this
statement has no effect and therefore serves no purpose.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>A slip of the finger can easily create a “do-nothing™ expression
statement. For example, instead of entering</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>we might accidentally type</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+</span> j<span class="op">;</span></span></code></pre></div>
<p>(This kind of error is more common than you might expect, since the
<code>=</code> and <code>+</code> characters usually occupy the same
key.) Some compilers can detect meaningless expression statements;
you’ll get a warning such as “<em>statement with no effect</em>.”</p>
</div>
<!-- END: div -->
<hr />
<h2 id="q-a-2">Q &amp; A</h2>
<!-- START: div -->
<div class="QandA_question">
<p>Q: I notice that C has no exponentiation operator. How can I raise a
number to a power?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Raising an integer to a small positive integer power is best done
by repeated multiplication (<code>i * i * i</code> is <code>i</code>
cubed). To raise a number to a noninteger power, call the
<code>pow</code> function.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: I want to apply the <code>%</code> operator to a floating-point
operand, but my program won’t compile. What can I do? [p. 54]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The <code>%</code> operator requires integer operands. Try the
<code>fmod</code> function instead.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: Why are the rules for using the <code>/</code> and <code>%</code>
operators with negative operands so complicated? [p. 54]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="C99Symbol"></span></p>
<p>A: The rules aren’t as complicated as they may first appear. In both
C89 and C99, the goal is to ensure that the value of
<code>(a / b) * b + a % b</code> will always be equal to <code>a</code>
(and indeed, both standards guarantee that this is the case, provided
that the value of <code>a / b</code> is “representable”). The problem is
that there are two ways for <code>a / b</code> and <code>a % b</code> to
satisfy this equality if either <code>a</code> or <code>b</code> is
negative, as seen in C89, where either <code>-9 / 7</code> is -1 and
<code>-9 % 7</code> is -2, or <code>-9 / 7</code> is -2 and
<code>-9 % 7</code> is 5. In the first case,
<code>(-9 / 7) * 7 + -9 % 7</code> has the value
<code>-1 x 7 + -2 = -9</code>, and in the second case,
<code>(-9 / 7) * 7 + -9 % 7</code> has the value
<code>-2 x 7 + 5 = -9</code>. By the time C99 rolled around, most CPUs
were designed to truncate the result of division toward zero, so this
was written into the standard as the only allowable outcome.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>If C has lvalues, does it also have rvalues? [p. 59]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>Yes, indeed. An <em>l</em>value is an expression that can appear on
the <em>left</em> side of an assignment; an <em>r</em>value is an
expression that can appear on the <em>right</em> side. Thus, an rvalue
could be a variable, constant, or more complex expression. In this book,
as in the C standard, we’ll use the term “expression™ instead of
“rvalue.”</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>You said that <code>v += e</code> isn’t equivalent to
<code>v = v + e</code> if <code>v</code> has a side effect. Can you
explain? [p. 60]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>Evaluating <code>v += e</code> causes <code>v</code> to be evaluated
only once; evaluating <code>v = v + e</code> causes <code>v</code> to be
evaluated twice. Any side effect caused by evaluating <code>v</code>
will occur twice in the latter case. In the following example,
<code>i</code> is incremented once:</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">[</span>i<span class="op">++]</span> <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>If we use <code>=</code> instead of <code>+=</code>, here’s what the
statement will look like:</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">[</span>i<span class="op">++]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">++]</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>The value of <code>i</code> is modified as well as used elsewhere in
the statement, so the effect of executing the statement is undefined.
It’s likely that <code>i</code> will be incremented twice, but we can’t
say with certainty what will happen.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Why does C provide the <code>++</code> and <code>--</code> operators?
Are they faster than other ways of incrementing and decrementing, or
they are just more convenient? [p. 61]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>C inherited <code>++</code> and <code>--</code> from <strong>Ken
Thompson</strong>’s earlier B language. Thompson apparently created
these operators because his B compiler could generate a more compact
translation for <code>++i</code> than for <code>i = i + 1</code>. These
operators have become a deeply ingrained part of C (in fact, many of C’s
most famous idioms rely on them). With modern compilers, using
<code>++</code> and won’t make a compiled program any smaller or faster;
the continued popularity of these operators stems mostly from their
brevity and convenience.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Do <code>++</code> and <code>--</code> work with <code>float</code>
variables?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>Yes; the increment and decrement operations can be applied to
floating-point numbers as well as integers. In practice, however, it’s
fairly rare to increment or decrement a <code>float</code> variable.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>When I use the postfix version of <code>++</code> or <code>--</code>,
just when is the increment or decrement performed? [p. 62]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>That’s an excellent question. Unfortunately, it’s also a difficult
one to answer. The C standard introduces the concept of “sequence point”
and says that “updating the stored value of the operand shall occur
between the previous and the next sequence point.” There are various
kinds of sequence points in C: the end of an expression statement is one
example. By the end of an expression statement, all increments and
decrements within the statement must have been performed; the next
statement can’t begin to execute until this condition has been met.</p>
<p>Certain operators that we’ll encounter in later chapters (logical
and. logical or, conditional, and comma) also impose sequence points. So
do function calls: the arguments in a function call must be fully
evaluated before the call can be performed. If an argument happens to be
an expression containing a <code>++</code> or <code>--</code> operator,
the increment or decrement must occur before the call can take
place.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: What do you mean when you say that the value of an expression
statement is discarded? [p. 65]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>By definition, an expression represents a value. If <code>i</code>
has the value 5, for example, then evaluating <code>i + 1</code>
produces the value 6. Let’s turn <code>i + 1</code> into a statement by
putting a semicolon after it:</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>When this statement is executed, the value of <code>i + 1</code> is
computed. Since we have failed to save this value—or at least use it in
some way—it is lost.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: But what about statements like <code>i = 1;</code>? I don’t see
what is being discarded.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>Don’t forget that <code>=</code> is an operator in C and produces a
value just like any other operator. The assignment</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>assigns 1 to <code>i</code>. The value of the entire expression is 1,
which is discarded. Discarding the expression’s value is no great loss,
since the reason for writing the statement in the first place was to
modify <code>i</code>.</p>
</div>
<!-- END: div -->
<hr />
<h2 id="examples-2">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh04/cknkCh04Exmp/">./cknkCh04/cknkCh04Exmp/</a></li>
</ul>
<h2 id="exercises-2">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh04/cknkCh04Exrc/README.md">./cknkCh04/cknkCh04Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh04/cknkCh04Exrc/cknkCh04ExrcReadme.html">./cknkCh04/cknkCh04Exrc/cknkCh04ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh04/cknkCh04Exrc/">./cknkCh04/cknkCh04Exrc/</a></li>
</ul>
<h2 id="programming-projects-2">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh04/cknkCh04Prj/README.md">./cknkCh04/cknkCh04Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh04/cknkCh04Prj/cknkCh04PrjReadme.html">./cknkCh04/cknkCh04Prj/cknkCh04PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh04/cknkCh04Prj/">./cknkCh04/cknkCh04Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="selection-statements">5 Selection Statements</h1>
<!-- START: div -->
<div class="theQuote">
<p>Programmers are not to be measured by their ingenuity and their logic
but by the completeness of their case analysis.</p>
</div>
<!-- END: div -->
<p>Although C has many operators, it has relatively few statements.
We’ve encountered just two so far: the <code>return</code> statement and
the expression statement. Most of C’s remaining statements fall into
three categories, depending on how they affect the order in which
statements are executed:</p>
<ul>
<li><strong><em>Selection statements</em></strong>, The <code>if</code>
and <code>switch</code> statements allow a program to select a
particular execution path from a set of alternatives.<br />
</li>
<li><strong><em>Iteration statements</em></strong>. The
<code>while</code>, <code>do</code>, and <code>for</code> statements
support iteration (looping).<br />
</li>
<li>*<strong>Jump statements</strong>. The <code>break</code>,
<code>continue</code>, and <code>goto</code> statements cause an
unconditional jump to some other place in the program. (The return
statement belongs in this category, as well.)</li>
</ul>
<p>The only other statements in C are the compound statement, which
groups several statements into a single statement, and the null
statement, which performs no action.</p>
<p>This chapter discusses the selection statements and the compound
statement. (Chapter 6 covers the iteration statements, the jump
statements, and the null statement.) Before we can write <code>if</code>
statements, we’ll need logical expressions: conditions that
<code>if</code> statements can test. Section 5.1 explains how logical
expressions are built from the relational operators (<code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>), the
equality operators (<code>==</code> and <code>!=</code>), and the
logical operators (<code>&amp;&amp;</code>, <code>||</code>, and
<code>!</code>). Section 5.2 covers the <code>if</code> statement and
compound statement, as well as introducing the conditional operator
(<code>?:</code>), which can test a condition within an expression.
Section 5.3 describes the <code>switch</code> statement.</p>
<h2 id="logical-expressions">5.1 Logical Expressions</h2>
<p>Several of C’s statements, including the <code>if</code> statement,
must test the value of an expression to see if it is “true™ or “false.”
For example, an <code>if</code> statement might need to test the
expression <code>i &lt; j;</code> a true value would indicate that
<code>i</code> is less than <code>j</code>. In many programming
languages, an expression such as <code>i &lt; j</code> would have a
special “Boolean” or “logical” type. Such a type would have only two
values, <code>false</code> and <code>frue</code>. In C, however, a
comparison such as <code>i &lt; j</code> yields an integer: either 0
(false) or 1 (true). With this in mind, let’s look at the operators that
are used to build logical expressions.</p>
<h3 id="relational-operators">5.1.1 Relational Operators</h3>
<p>C’s <strong><em>relational operators</em></strong> (Table 5.1)
correspond to the <code>&lt;</code>, <code>&gt;</code>, <code>≤</code>,
and <code>≥</code> operators of mathematics, except that they produce 0
(false) or 1 (true) when used in expressions. For example, the value of
<code>10 &lt; 11</code> is 1; the value of <code>11 &lt; 10</code> is
0.</p>
<p><strong>Table 5.1</strong>: Relational Operators</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;</code></td>
<td>less than</td>
</tr>
<tr class="even">
<td><code>&gt;</code></td>
<td>greater than</td>
</tr>
<tr class="odd">
<td><code>≤</code></td>
<td>less than or equal to</td>
</tr>
<tr class="even">
<td><code>≥</code></td>
<td>greater than or equal to</td>
</tr>
</tbody>
</table>
<p>The relational operators can be used to compare integers and
floating-point numbers, with operands of mixed types allowed. Thus,
<code>1 &lt; 2.5</code> has the value 1, while <code>5.6 &lt; 4</code>
has the value 0.</p>
<p>The precedence of the relational operators is lower than that of the
arithmetic operators; for example, <code>i + j &lt; k - 1</code> means
<code>(i + j) &lt; (k - 1)</code>. The relational operators are left
associative.</p>
<!-- START: div -->
<div class="infoBox">
<p>The expression <code>i &lt; j &lt; k</code> is legal in C, but
doesn’t have the meaning that you might expect. Since the
<code>&lt;</code> operator is left associative, this expression is
equivalent to <code>(i &lt; j) &lt; k</code>.</p>
<p>In other words, the expression first tests whether <code>i</code> is
less than <code>j</code>; the 1 or 0 produced by this comparison is then
compared to <code>k</code>. The expression does not test whether
<code>j</code> lies between <code>i</code> and <code>k</code>. (We’ll
see later in this section that the correct expression would be
<code>i &lt; j &amp;&amp; j &lt; k</code>.)</p>
</div>
<!-- END: div -->
<h3 id="equality-operators">5.1.2 Equality Operators</h3>
<p>Although the relational operators are denoted by the same symbols as
in many other programming languages, the <strong><em>equality
operators</em></strong> have a unique appearance (Table 5.2). The “equal
to” operator is two adjacent <code>=</code> characters, not one, since a
single <code>=</code> character represents the assignment operator. The
“not equal to” operator is also two characters: <code>!</code> and
<code>=</code>.</p>
<p><strong>Table 5.2</strong>: Equality Operators</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>==</code></td>
<td>equal to</td>
</tr>
<tr class="even">
<td><code>!=</code></td>
<td>not equal to</td>
</tr>
</tbody>
</table>
<p>Like the relational operators, the equality operators are left
associative and produce either O (false) or 1 (true) as their result.
However, the equality operators have <em>lower</em> precedence than the
relational operators. For example, the expression
<code>i &lt; j == j &lt; k</code> is equivalent to
<code>(i &lt; j) == (j &lt; k)</code> which is true if
<code>i &lt; j</code> and <code>j &lt; k</code> are both true or both
false.</p>
<p>Clever programmers sometimes exploit the fact that the relational and
equality operators return integer values. For example, the value of the
expression <code>(i &gt;= j) + (i == j)</code> is either 0, 1, or 2,
depending on whether <code>i</code> is less than, greater than, or equal
to <code>j</code>, respectively. Tricky coding like this generally isn’t
a good idea, however; it makes programs hard to understand.</p>
<h3 id="logical-operators">5.1.3 Logical Operators</h3>
<p>More complicated logical expressions can be built from simpler ones
by using the <strong><em>logical operators</em></strong>: <em>and</em>,
<em>or</em>, and <em>not</em> (Table 5.3). The <code>!</code> operator
is unary, while <code>&amp;&amp;</code> and <code>||</code> are
binary.</p>
<p><strong>Table 5.3</strong>: Logical Operators</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>!</code></td>
<td>logical negation</td>
</tr>
<tr class="even">
<td><code>&amp;&amp;</code></td>
<td>logical <em>and</em></td>
</tr>
<tr class="odd">
<td><code>||</code></td>
<td>logical <em>or</em></td>
</tr>
</tbody>
</table>
<p>The logical operators produce either 0 or 1 as their result. Often,
the operands will have values of 0 or 1, but this isn’t a requirement;
the logical operators treat any nonzero operand as a true value and any
zero operand as a false value.</p>
<p>The logical operators behave as follows:</p>
<ul>
<li><code>!expr</code> has the value 1 if <code>expr</code> has the
value 0.<br />
</li>
<li><code>exprl &amp;&amp; expr2</code> has the value 1 if the values of
<code>expr1</code> and <code>expr2</code> are both non Zero.<br />
</li>
<li><code>exprl || expr2</code> has the value 1 if either
<code>expr1</code> or <code>expr2</code> (or both) has a nonzero
value.</li>
</ul>
<p>In all other cases, these operators produce the value 0.</p>
<p>Both <code>&amp;&amp;</code> and <code>||</code> perform
“short-circuit” evaluation of their operands. That is, these operators
first evaluate the left operand, then the right operand. If the value of
the expression can be deduced from the value of the left operand alone,
then the right operand isn’t evaluated. Consider the following
expression:</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>i <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>j <span class="op">/</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>To find the value of this expression, we must first evaluate
<code>(i != 0)</code>. If <code>i</code> isn’t equal to 0, then we’ll
need to evaluate <code>(j / 1 &gt; 0)</code> to determine whether the
entire expression is true or false. However, if <code>i</code> is equal
to 0, then the entire expression must be false, so there’s no need to
evaluate <code>(j / i &gt; 0)</code>. The advantage of short circuit
evaluation is apparent—without it, evaluating the expression would have
caused a division by zero.</p>
..md<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Be wary of side effects in logical expressions. Thanks to the
short-circuit nature of the <code>&amp;&amp;</code> and <code>||</code>
operators, side effects in operands may not always occur. Consider the
following expression:</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="op">++</span>j <span class="op">&gt;</span> <span class="dv">0</span></span></code></pre></div>
<p>Although <code>j</code> is apparently incremented as a side effect of
evaluating the expression, that isn’t always the case. If
<code>i &gt; 0</code> is false, then <code>++j &gt; 0</code> is not
evaluated, so <code>j</code> isn’t incremented. The problem can be fixed
by changing the condition to <code>++j &gt; 0 &amp;&amp; i &gt; 0</code>
or, even better, by incrementing <code>j</code> separately.</p>
</div>
<!-- END: div -->
<p>The <code>!</code> operator has the same precedence as the unary plus
and minus operators. The precedence of <code>&amp;&amp;</code> and
<code>||</code> is lower than that of the relational and equality
operators; for example, <code>i &lt; j &amp;&amp; k == m</code> means
<code>(i &lt; j) &amp;&amp; (k == m)</code>. The ! operator is right
associative; <code>&amp;&amp;</code> and <code>||</code> are left
associative.</p>
<h2 id="the-if-statement">5.2 The <code>if</code> Statement</h2>
<p>The <code>if</code> statement allows a program to choose between two
alternatives by testing the value of an expression. In its simplest
form, the <code>if</code> statement has the form</p>
<pre><code>if(expression) statement</code></pre>
<p>Notice that the parentheses around the expression are mandatory;
they’re part of the <code>if</code> statement, not part of the
expression. Also note that the word then doesn’t come after the
parentheses, as it would in some programming languages.</p>
<p>When an <code>if</code> statement is executed. the expression in the
parentheses is evaluated: if the value of the expression is
nonzero—which C interprets as true—the statement after the parentheses
is executed. Here’s an example:</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX_LINES<span class="op">)</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>The statement <code>line_num = 0;</code> is executed if the condition
<code>line_num == MAX_LINES</code> is true (has a nonzero value).</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Don’t confuse <code>==</code> (equality) with <code>=</code>
(assignment). The statement <code>if(i == 0) ...</code> tests whether
<code>i</code> is equal to 0. However, the statement
<code>if (i = 0) ...</code> assigns 0 to <code>i</code>, then tests
whether the <em>result</em> is nonzero. In this case, the test always
fails.</p>
<p><span class="QandA"></span></p>
<p>Confusing <code>==</code> with <code>=</code> is perhaps the most
common C programming error, probably because <code>=</code> means “is
equal to” in mathematics (and in certain programming languages). Some
compilers issue a warning if they notice <code>=</code> where
<code>==</code> would normally appear.</p>
</div>
<!-- END: div -->
<p>Often the expression in an <code>if</code> statement will test
whether a variable falls within a range of values. To test whether
<code>0 ≤ i &lt; n</code>, for example, we’d write</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="dv">0</span> <span class="op">&lt;=</span> i <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> n<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>To test the opposite condition (<code>i</code> is outside the range),
we’d write</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> i <span class="op">&gt;=</span> n<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>Note the use of the <code>||</code> operator instead of the
<code>&amp;&amp;</code> operator.</p>
<h3 id="compound-statements">5.2.1 Compound Statements</h3>
<p>In our <code>if</code> statement template, notice that statement is
singular, not plural:</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span> statement</span></code></pre></div>
<p>What if we want an <code>if</code> statement to control fwo or more
statements? That’s where the <strong><em>compound
statement</em></strong> comes in. A compound statement has the form</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> statements <span class="op">}</span></span></code></pre></div>
<p>By putting braces around a group of statements, we can force the
compiler to treat it as a single statement.</p>
<p>Here’s an example of a compound statement:</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> page num<span class="op">++;</span> <span class="op">}</span></span></code></pre></div>
<p>For clarity, I’ll usually put a compound statement on several lines,
with one statement per line:</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>    line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that each inner statement still ends with a semicolon, but the
compound statement itself does not.</p>
<p>Here’s what a compound statement would look like when used inside an
<code>if</code> statement:</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX LINES<span class="op">)</span> <span class="op">{</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>    line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Compound statements are also common in loops and other places where
the syntax of C requires a single statement, but we want more than
one.</p>
<h3 id="the-else-clause">5.2.2 The <code>else</code> Clause</h3>
<p>An <code>if</code> statement may have an <code>else</code>
clause:</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span> statement <span class="cf">else</span> statement</span></code></pre></div>
<p>The statement that follows the word <code>else</code> is executed if
the expression in parentheses has the value 0.</p>
<p>Here’s an example of an <code>if</code> statement with an
<code>else</code> clause:</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>    max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>    max <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>Notice that both “inner” statements end with a semicolon.</p>
<p>When an <code>if</code> statement contains an <code>else</code>
clause, a layout issue arises: where should the else be placed? Many C
programmers align it with the <code>if</code> at the beginning of the
statement, as in the previous example. The inner statements are usually
indented, but if they’re short they can be put on the same line as the
<code>if</code> and <code>else</code>:</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> max <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>There are no restrictions on what kind of statements can appear
inside an <code>if</code> statement. In fact, it’s not unusual for
<code>if</code> stalements to be nested inside other <code>if</code>
statements. Consider the following <code>if</code> statement, which
finds the largest of the numbers stored in <code>i</code>,
<code>j</code>, and <code>k</code> and stores that value in
<code>max</code>:</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> k<span class="op">)</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> k<span class="op">)</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-12"><a href="#cb169-12" aria-hidden="true" tabindex="-1"></a>`if` statements can be nested to any depth<span class="op">.</span> Notice how aligning each `e1se` with the matching `if` makes the nesting easier to see<span class="op">.</span> If you still find the nesting confusing<span class="op">,</span> don’t hesitate to add braces<span class="op">:</span></span>
<span id="cb169-13"><a href="#cb169-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-14"><a href="#cb169-14" aria-hidden="true" tabindex="-1"></a>```C</span>
<span id="cb169-15"><a href="#cb169-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb169-16"><a href="#cb169-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb169-17"><a href="#cb169-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> K<span class="op">)</span></span>
<span id="cb169-18"><a href="#cb169-18" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb169-19"><a href="#cb169-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb169-20"><a href="#cb169-20" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb169-21"><a href="#cb169-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb169-22"><a href="#cb169-22" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb169-23"><a href="#cb169-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb169-24"><a href="#cb169-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> k<span class="op">)</span></span>
<span id="cb169-25"><a href="#cb169-25" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb169-26"><a href="#cb169-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb169-27"><a href="#cb169-27" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb169-28"><a href="#cb169-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Adding braces to statements—even when they’re not necessary—is like
using parentheses in expressions: both techniques help make a progrum
more readable while at the same time avoiding the possibility that the
compiler won’t understand the program the way we thought it did.</p>
<p>Some programimers use as many braces as possible inside
<code>if</code> statements (and iteration statements as well). A
programmer who adopts this convention would include a pair of braces for
every <code>if</code> clause and every <code>else</code> clause:</p>
<div class="sourceCode" id="cb170"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> K<span class="op">)</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb170-13"><a href="#cb170-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb170-14"><a href="#cb170-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> k<span class="op">)</span></span>
<span id="cb170-15"><a href="#cb170-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb170-16"><a href="#cb170-16" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb170-17"><a href="#cb170-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-18"><a href="#cb170-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb170-19"><a href="#cb170-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb170-20"><a href="#cb170-20" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb170-21"><a href="#cb170-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-22"><a href="#cb170-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Using braces even when they’re not required has two advantages.
First, the program becomes easier to modify, because more statements can
easily be added to any <code>if</code> or <code>else</code> clause.
Second, it helps avoid errors that can result from forgetting to use
braces when adding statements to an <code>if</code> or <code>else</code>
clause.</p>
<h3 id="cascaded-i-f-statements">5.2.3 Cascaded i f Statements</h3>
<p>We’ll often need to test a series of conditions, stopping as soon as
one of them is true. A “cascaded” <code>if</code> statement is often the
best way to write such a series of tests. For example, the following
cascaded <code>if</code> statement tests whether <code>n</code> is less
than 0, equal to 0, or greater than 0:</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;n is less than 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;n is equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;n is greater than 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Although the second <code>if</code> statement is nested inside the
first, C programmers don’t usually indent it. Instead, they align each
else with the original <code>if</code>:</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;n is less than 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;n is equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;n is greater than 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>This arrangement gives the cascaded <code>if</code> a distinctive
appearance:</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>    statement</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>    statement</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>    statement</span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>    statement</span></code></pre></div>
<p>The last two lines (<code>else</code> <em>statement</em>) aren’t
always present, of course. This way of indenting the cascaded
<code>if</code> statement avoids the problem of excessive indentation
when the number of tests is large. Moreover, it assures the reader that
the statement is nothing more than a series of tests.</p>
<p>Keep in mind that a cascaded <code>if</code> statement isn’t some new
kind of statement; it’s just an ordinary <code>if</code> statement that
happens to have another <code>if</code> statement as its
<code>else</code> clause (and <em>that</em> <code>if</code> statement
has another <code>if</code> statement as its <code>else</code> clause,
<em>ad infinitum</em>).</p>
<h3 id="program-calculating-a-brokers-commission">5.2.4 (PROGRAM)
Calculating a Broker’s Commission</h3>
<p>When stocks are sold or purchased through a broker, the broker’s
commission is often computed using a sliding scale that depends upon the
value of the stocks traded. Let’s say that a broker charges the amounts
shown in the following table:</p>
<table>
<thead>
<tr class="header">
<th>Transaction size</th>
<th>Commission rate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Under $2,500</td>
<td>$30 + 1.7%</td>
</tr>
<tr class="even">
<td>$2,500-$6,250</td>
<td>$56 + 0.66%</td>
</tr>
<tr class="odd">
<td>$6,250-$20,000</td>
<td>$76 + 0.34%</td>
</tr>
<tr class="even">
<td>$20,000-$50,000</td>
<td>$100 + 0.22%</td>
</tr>
<tr class="odd">
<td>$50,000-$500,000</td>
<td>$155 + 0.11%</td>
</tr>
<tr class="even">
<td>Over $500,000</td>
<td>$255 + 0.09%</td>
</tr>
</tbody>
</table>
<p>The minimum charge is $39. Our next program asks the user to enter
the amount of the trade, then displays the amount of the commission:</p>
<pre class="shell"><code>Enter value of trade: 30000
Commission: $166.00</code></pre>
<p>The heart of the program is a cascaded <code>if</code> statement that
determines which range the trade falls into.</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: broker.c</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Calculates a broker&#39;s commission </span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> commission<span class="op">,</span> value<span class="op">;</span></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter value of trade: &quot;</span><span class="op">);</span></span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>value<span class="op">);</span></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">2500.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">30.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.017</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">6250.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">56.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0066</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-24"><a href="#cb175-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">20000.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-25"><a href="#cb175-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-26"><a href="#cb175-26" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">76.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0034</span><span class="bu">f</span> <span class="op">+</span> value<span class="op">);</span></span>
<span id="cb175-27"><a href="#cb175-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-28"><a href="#cb175-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">50000.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-29"><a href="#cb175-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-30"><a href="#cb175-30" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">100.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0022</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-31"><a href="#cb175-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-32"><a href="#cb175-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">500000.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-33"><a href="#cb175-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-34"><a href="#cb175-34" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">155.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0011</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-35"><a href="#cb175-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-36"><a href="#cb175-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb175-37"><a href="#cb175-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-38"><a href="#cb175-38" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">255.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0009</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-39"><a href="#cb175-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-40"><a href="#cb175-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-41"><a href="#cb175-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>commission <span class="op">&lt;</span> <span class="fl">39.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-42"><a href="#cb175-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-43"><a href="#cb175-43" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">39.00</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb175-44"><a href="#cb175-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-45"><a href="#cb175-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-46"><a href="#cb175-46" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Commission: $%.2f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> commission<span class="op">);</span></span>
<span id="cb175-47"><a href="#cb175-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-48"><a href="#cb175-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb175-49"><a href="#cb175-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The cascaded <code>if</code> statement could have been written this
way instead:</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">2500.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>    commission <span class="op">=</span> <span class="fl">30.00</span><span class="bu">f</span> <span class="op">+</span> <span class="fl">.017</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">;</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;=</span> <span class="fl">2500.00</span><span class="bu">f</span> <span class="op">&amp;&amp;</span> value <span class="op">&lt;</span> <span class="fl">6250.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    commission <span class="op">=</span> <span class="fl">56.00</span><span class="bu">f</span> <span class="op">+</span> <span class="fl">.0066</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">;</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;=</span> <span class="fl">6250.00</span><span class="bu">f</span> <span class="op">&amp;&amp;</span> value <span class="op">&lt;</span> <span class="fl">20000.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>    commission <span class="op">=</span> <span class="fl">76.00</span><span class="bu">f</span> <span class="op">+</span> <span class="fl">.0034</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">;</span></span></code></pre></div>
<p>Although the program will still work, the added conditions aren’t
necessary. For example, the first <code>if</code> clause tests whether
value is less than 2500 and, if so, computes the commission. When we
reach the second <code>if</code> test
(<code>value &gt;= 2500.00f &amp;&amp; value &lt; 6250.00f</code>), we
know that value can’t be less than 2500 and therefore must be greater
than or equal to 2500. The condition <code>value &gt;= 2500.00f</code>
will always be true, so there’s no point in checking it.</p>
<h3 id="the-dangling-e1se-problem">5.2.5 The “Dangling e1se”
Problem</h3>
<p>When <code>if</code> statements are nested, we’ve got to watch out
for the notorious “dangling <code>else</code>” problem. Consider the
following example:</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>y <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> x <span class="op">/</span> y<span class="op">;</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Error: y ic equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>To which <code>if</code> statement does the <code>else</code> clause
belong? The indentation suggests that it belongs to the outer
<code>if</code> statement. However, C follows the rule that an
<code>else</code> clause belongs to the nearest <code>if</code>
statement that hasn’t already been paired with an <code>else</code>. In
this example, the <code>else</code> clause actually belongs to the inner
<code>if</code> statement, so a correctly indented version would look
like this:</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>y <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> x <span class="op">/</span> y<span class="op">;</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Error: y ic equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>To make the <code>else</code> clause part of the outer
<code>if</code> statement, we can enclose the inner <code>if</code>
statement in braces:</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>y <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> x <span class="op">/</span> y<span class="op">;</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Error: y ic equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>This example illustrates the value of braces; <code>if</code> we’d
used them in the original <code>if</code> statement, we wouldn’t have
gotten into this situation in the first place.</p>
<h3 id="conditional-expressions">5.2.6 Conditional Expressions</h3>
<p>C’s <code>if</code> statement allows a program to perform one of two
actions depending on the value of a condition, C also provides an
<em>operator</em> that allows an expression to produce one of two
<em>values</em> depending on the value of a condition.</p>
<p>The <strong><em>conditional operator</em></strong> consists of two
symbols (<code>?</code> and <code>:</code>), which must be used together
in the following way:</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>exprl <span class="op">?</span> expr2 <span class="op">:</span> expr3</span></code></pre></div>
<p><code>exprl</code>, <code>expr2</code>, and <code>expr3</code> can be
expressions of any type. The resulting expression is said to be a
<strong><em>conditional expression</em></strong>. The conditional
operator is unique among C operators in that it requires three operands
instead of one or two. For this reason, it is often referred to as a
*<strong>ternary</strong> operator.</p>
<p>The conditional expression <code>exprl</code> ? <code>expr2</code> :
<code>expr3</code> should be read “if <code>exprl</code> then
<code>expr2</code> else <code>expr3</code>.” The expression is evaluated
in stages: <code>expr1</code> is evaluated first; if its value isn’t
zero, then <code>expr2</code> is evaluated, and its value is the value
of the entire conditional expression. If the value of <code>expr1</code>
is zero, then the value of <code>expr3</code> is the value of the
conditional.</p>
<p>The following example illustrates the conditional operator:</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">;</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> i <span class="op">&gt;</span> j <span class="op">?</span> i <span class="op">:</span> j<span class="op">;</span>    <span class="co">/* k is now 2 */</span></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">?</span> i <span class="op">:</span> <span class="dv">0</span><span class="op">)</span> <span class="op">+</span> j<span class="op">;</span>    <span class="co">/* k is now 3 */</span></span></code></pre></div>
<p>The conditional expression <code>i &gt; j ? i : j</code> in the first
assignment to <code>k</code> returns the value of either <code>i</code>
or <code>j</code>, depending on which one is larger. Since
<code>i</code> has the value 1 and <code>j</code> has the value 2, the
<code>i &gt; j</code> comparison fails, and the value of the conditional
is 2, which is assigned to <code>k</code>. In the second assignment to
<code>k</code>, the <code>i &gt;= 0</code> comparison succeeds; the
conditional expression (<code>i &gt;= 0 ? i : 0</code>) has the value 1,
which is then added to <code>j</code> to produce 3. The parentheses are
necessary, by the way; the precedence of the conditional operator is
less than that of the other operators we’ve discussed so far, with the
exception of the assignment operators.</p>
<p>Conditional expressions tend to make programs shorter but harder to
understand, so it’s probably best to avoid them. There are, however, a
few places in which they’re tempting; one is the return statement.
Instead of writing</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> j<span class="op">;</span></span></code></pre></div>
<p>many programmers would write</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> i <span class="op">&gt;</span> j <span class="op">?</span> i <span class="op">:</span> j<span class="op">;</span></span></code></pre></div>
<p>Calls of <code>printf</code> can sometimes benefit from condition
expressions. Instead of</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;&amp;d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> j<span class="op">);</span></span></code></pre></div>
<p>we could simply write</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i <span class="op">&gt;</span> j <span class="op">?</span> i <span class="op">:</span> j<span class="op">);</span></span></code></pre></div>
<p>Conditional expressions are also common in certain kinds of macro
definitions,</p>
<h3 id="boolean-values-in-c89">5.2.7 Boolean Values in C89</h3>
<p>For many years, the C language lacked a proper Boolean type, and
there is none defined in the C89 standard. This omission is a minor
annoyance, since many programs need variables that can store either
<code>false</code> or <code>true</code>. One way to work around this
limitation of C89 is to declare an <code>int</code> variable and then
assign it either 0 or 1;</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> flag<span class="op">;</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>Although this scheme works, it doesn’t contribute much to program
readability, It’s not obvious that <code>flag</code> is to be assigned
only Boolean values and that 0 and 1 represent <code>false</code> and
<code>true</code>.</p>
<p>To make programs more understandable, C89 programmers often define
macros with names such as <code>TRUE</code> and <code>FALSE</code>:</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TRUE 1</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FALSE 0</span></span></code></pre></div>
<p>Assignments to <code>flag</code> now have a more natural
appearance:</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> FALSE<span class="op">;</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> TRUE<span class="op">;</span></span></code></pre></div>
<p>To test whether <code>flag</code> is true, we can write</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>flag <span class="op">==</span> TRUE<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>or just</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>flag<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>The latter form is better, not only because it’s more concise, but
also because it will still work correctly if <code>flag</code> has a
value other than 0 or 1.</p>
<p>To test whether <code>flag</code> is false, we can write</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>flag <span class="op">==</span> FALSE<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!</span>flag<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>Carrying this idea one step further, we might even define a macro
that can be used as a type:</p>
<div class="sourceCode" id="cb193"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BOOL int</span></span></code></pre></div>
<p><code>BOOL</code> can take the place of <code>int</code> when
declaring Boolean variables:</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>BOOL flag<span class="op">;</span></span></code></pre></div>
<p>It’s now clear that <code>flag</code> isn’t an ordinary integer
variable, but instead represents a Boolean condition, (The compiler
still treats <code>flag</code> as an <code>int</code> variable, of
course.) In later chapters, we’ll discover better ways to set up a
Boolean type in C89 by using type definitions and enumerations.</p>
<p><span class="C99Symbol"></span></p>
<h3 id="boolean-values-in-c99">5.2.8 Boolean Values in C99</h3>
<p><span class="QandA"></span></p>
<p>The longstanding lack of a Boolean type has been remedied in C99,
which provides the <code>_Bool</code> type. In this version of C, a
Boolean variable can be declared by writing</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="dt">_Bool</span> flag<span class="op">;</span></span></code></pre></div>
<p><code>_Bool</code> is an integer type (more precisely, an
<em>unsigned</em> integer type), so a <code>_Bool</code> variable is
really just an integer variable in disguise. Unlike an ordinary integer
variable, however, a <code>_Bool</code> variable can only be assigned 0
or 1. In general, attempting to store a nonzero value into a
<code>_Bool</code> variable will cause the variable to be assigned
1:</p>
<div class="sourceCode" id="cb196"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">/* flag ie assigned 1 */</span></span></code></pre></div>
<p>iI’s legal (although not advisable) to perform arithmetic on
<code>_Bool</code> variables; it’s also legal to print a
<code>_Bool</code> variable (either 0 or 1 will be displayed). And, of
course, a <code>_Bool</code> variable can be tested in an
<code>if</code> statement:</p>
<div class="sourceCode" id="cb197"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>flag<span class="op">)</span> <span class="co">/* tests whether flag is 1 */</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>In addition to defining the <code>_Bool</code> type, C99 also
provides a new header, <code>&lt;stdbool.h&gt;</code>, that makes it
easier to work with Boolean values. This header provides a macro,
<code>bool</code>, that stands for <code>_Bool</code>. If
<code>&lt;stdbool.h&gt;</code> is included, we can write</p>
<div class="sourceCode" id="cb198"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> flag<span class="op">;</span> <span class="co">/* same as _Bool flag; */</span></span></code></pre></div>
<p>The <code>&lt;stdbool.h&gt;</code> header also supplies macros named
<code>true</code> and <code>false</code>, which stand for 1 and 0,
respectively, making it possible to write</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> true<span class="op">;</span></span></code></pre></div>
<p>Because the <code>&lt;stdbool.h&gt;</code> header is so handy, I’ll
use it in subsequent programs whenever Boolean variables are needed.</p>
<h2 id="the-switch-statement">5.3 The switch Statement</h2>
<p>In everyday programming, we’ll often need to compare an expression
against a series of values to see which one it currently matches. We saw
in Section 5.2 that a cascaded <code>if</code> statement can be used for
this purpose. For example, the following cascaded <code>if</code>
statement prints the English word that corresponds to a numerical
grade:</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">4</span><span class="op">)</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Excellent&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Good&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Average&quot;</span><span class="op">);</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Poor&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Illegal grade&#39;&quot;</span><span class="op">);</span></span></code></pre></div>
<p>As an alternative to this kind of cascaded <code>if</code> statement,
C provides the switch statement. The following switch is equivalent to
our cascaded <code>if</code>:</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Excellent&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Good&quot;</span><span class="op">);</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Average&quot;</span><span class="op">);</span></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Poor&quot;</span><span class="op">);</span></span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a><span class="cf">default</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Illegal grade&quot;</span><span class="op">);</span></span>
<span id="cb201-14"><a href="#cb201-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-15"><a href="#cb201-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When this statement is executed, the value of the variable grade is
tested against 4, 3, 2, 1, and 0. If it matches 4, for example, the
message <code>Excellent</code> is printed, then the <code>break</code>
statement transfers control to the statement following the
<code>switch</code>. If the value of grade doesn’t match any of the
choices listed, the <code>default</code> case applies, and the message
<code>Illegal grade</code> is printed.</p>
<p>A <code>switch</code> statement is often easier to read than a
cascaded <code>if</code> statement. Moreover, <code>switch</code>
statements are often faster than <code>if</code> statements, especially
when there are more than a handful of cases.</p>
<p><span class="QandA"></span></p>
<p>In its most common form, the <code>switch</code> statement has the
form</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span> expression <span class="op">)</span> <span class="op">{</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> constant<span class="op">-</span>expression <span class="op">:</span> statements</span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> constant<span class="op">-</span>expression <span class="op">:</span> statements</span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span> <span class="op">:</span> statements</span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>switch</code> statement is fairly complex; let’s look at
its components one by one:</p>
<ul>
<li><strong><em>Controlling expression</em></strong>. The word switch
must be followed by an integer expression in parentheses. Characters are
treated as integers in C and thus can be tested in <code>switch</code>
statements. Floating-point numbers and strings don’t qualify,
however.<br />
</li>
<li><strong><em>Case labels</em></strong>. Each case begins with a label
of the form <code>case constant-expression:</code> A
<strong><em>constant expression</em></strong> is much like an ordinary
expression except that it can’t contain variables or function calls.
Thus, 5 is a constant expression, and <code>5 + 10</code> is a constant
expression, but <code>n + 10</code> isn’t a constant expression (unless
<code>n</code> is a macro that represents a constant). The constant
expression in a case label must evaluate to an integer (characters are
also acceptable).<br />
</li>
<li><strong><em>Statements</em></strong>. After each case label comes
any number of statements. No braces are required around the statements.
(Enjoy it—this is one of the few places in C where braces aren’t
required.) The last statement in each group is normally
<code>break</code>.</li>
</ul>
<p>Duplicate case labels aren’t allowed. The order of the cases doesn’t
matter; in particular, the default case doesn’t need to come last.</p>
<p>Only one constant expression may follow the word <code>case</code>;
however, several <code>case</code> labels may precede the same group of
statements:</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span></span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Passing&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Illegal grade&quot;</span><span class="op">);</span></span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb203-12"><a href="#cb203-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To save space, programmers sometimes put several case labels on the
same line:</p>
<div class="sourceCode" id="cb204"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> </span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Passing&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Illegal grade&quot;</span><span class="op">);</span></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unfortunately, there’s no way to write a case label that specifies a
range of values, as there is in some programming languages.</p>
<p>A <code>switch</code> statement isn’t required to have a
<code>default</code> case. If <code>default</code> is missing and the
value of the controlling expression doesn’t match any of the case
labels, control simply passes to the next statement after the
<code>switch</code>.</p>
<h3 id="the-role-of-the-break-statement">5.3.1 The Role of the break
Statement</h3>
<p>Now, let’s take a closer look at the mysterious <code>break</code>
statement. As we’ve seen, executing a <code>break</code> statement
causes the program to “break™ out of the <code>switch</code> statement;
execution continues at the next statement after the
<code>switch</code>.</p>
<p>The reason that we need break has to do with the fact that the
<code>switch</code> statement is really a form of “computed jump.” When
the controlling expression is evaluated, control jumps to the case label
matching the value of the <code>switch</code> expression. A case label
is nothing more than a marker indicating a position within the
<code>switch</code>, When the last statement in the case has been
executed, control “falls through” to the first statement in the
following case; the case label for the next case is ignored. Without
<code>break</code> (or some other jump statement), control will flow
from one case into the next. Consider the following switch
statement:</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Excellent&quot;</span><span class="op">);</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Good&quot;</span><span class="op">);</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Average&quot;</span><span class="op">);</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Poor&quot;</span><span class="op">);</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Illegal grade&quot;</span><span class="op">);</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If the value of grade is 3, the message printed is</p>
<pre class="shell"><code>GoodAveragePoorFailingIllegal grade</code></pre>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Forgetting to use <code>break</code> is a common error. Although
omitting <code>break</code> is sometimes done intentionally to allow
several cases to share code, it’s usually just an oversight.</p>
</div>
<!-- END: div -->
<p>Since deliberately falling through from one case into the next is
rare, it’s a good idea to point out any deliberate omission of
<code>break</code>:</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>        num_passings<span class="op">++;</span></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* FALL THROUGH */</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> total grades<span class="op">++;</span></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Without the comment, someone might later fix the “error” by adding an
unwanted <code>break</code> statement.</p>
<p>Although the last case in a <code>switch</code> statement never needs
a <code>break</code> statement, it’s common practice to put one there
anyway to guard against a “missing <code>break</code>” problem if cases
should later be added.</p>
<h3 id="program-printing-a-date-in-legal-form">5.3.2 (PROGRAM) Printing
a Date in Legal Form</h3>
<p>Contracts and other legal documents are often dated in the following
way:</p>
<pre><code>Dated this __________ day of __________ . 20 __ .</code></pre>
<p>Let’s write a program that displays dates in this form. We’ll have
the user enter the date in month/day/year form, then we’ll display the
date in “legal” form:</p>
<pre class="shell"><code>Enter date (mm/dd/yy): 7/19/14
Dated this 19th day of July, 2014.</code></pre>
<p>We can get <code>printf</code> to do most of the formatting. However.
we’re left with two problems: how to add “th” (or “st” or “nd” ar “rd”)
to the day. and how to print the month as a word instead of a number.
Fortunately, the <code>switch</code> statement is ideal for both
situations; we’ll have one switch print the day suffix and another print
the month name.</p>
<div class="sourceCode" id="cb210"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: date.c</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a date in legal form</span></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb210-11"><a href="#cb210-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> month<span class="op">,</span> day<span class="op">,</span> year<span class="op">;</span></span>
<span id="cb210-12"><a href="#cb210-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-13"><a href="#cb210-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter date (mm/dd/yy): &quot;</span><span class="op">);</span></span>
<span id="cb210-14"><a href="#cb210-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d / %d /%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>month<span class="op">,</span> <span class="op">&amp;</span>day<span class="op">,</span> <span class="op">&amp;</span>year<span class="op">);</span></span>
<span id="cb210-15"><a href="#cb210-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-16"><a href="#cb210-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Dated this %d&quot;</span><span class="op">,</span> day<span class="op">);</span></span>
<span id="cb210-17"><a href="#cb210-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span><span class="op">(</span>day<span class="op">)</span></span>
<span id="cb210-18"><a href="#cb210-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb210-19"><a href="#cb210-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">21</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">31</span><span class="op">:</span></span>
<span id="cb210-20"><a href="#cb210-20" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;st&quot;</span><span class="op">);</span></span>
<span id="cb210-21"><a href="#cb210-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-22"><a href="#cb210-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">22</span><span class="op">:</span></span>
<span id="cb210-23"><a href="#cb210-23" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;nd&quot;</span><span class="op">);</span></span>
<span id="cb210-24"><a href="#cb210-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-25"><a href="#cb210-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">23</span><span class="op">:</span></span>
<span id="cb210-26"><a href="#cb210-26" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;rd&quot;</span><span class="op">);</span></span>
<span id="cb210-27"><a href="#cb210-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-28"><a href="#cb210-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb210-29"><a href="#cb210-29" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;th&quot;</span><span class="op">);</span></span>
<span id="cb210-30"><a href="#cb210-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-31"><a href="#cb210-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb210-32"><a href="#cb210-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot; day of &quot;</span><span class="op">);</span></span>
<span id="cb210-33"><a href="#cb210-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-34"><a href="#cb210-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>month<span class="op">)</span></span>
<span id="cb210-35"><a href="#cb210-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb210-36"><a href="#cb210-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;January&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-37"><a href="#cb210-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;February&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-38"><a href="#cb210-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;March&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-39"><a href="#cb210-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;April&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-40"><a href="#cb210-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;May&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-41"><a href="#cb210-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">6</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;June&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-42"><a href="#cb210-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">7</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;July&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-43"><a href="#cb210-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">8</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;August&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-44"><a href="#cb210-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">9</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;September&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-45"><a href="#cb210-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">10</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;October&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-46"><a href="#cb210-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">11</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;November&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-47"><a href="#cb210-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">12</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;December&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-48"><a href="#cb210-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb210-49"><a href="#cb210-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-50"><a href="#cb210-50" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;, 20%.2d.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> year<span class="op">);</span></span>
<span id="cb210-51"><a href="#cb210-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-52"><a href="#cb210-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb210-53"><a href="#cb210-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note the use of <code>%.2d</code> to display the last two digits of
the year. If we had used <code>%d</code> instead, single-digit years
would be displayed incorrectly (2005 would be printed as 205).</p>
<hr />
<h2 id="q-a-3">Q &amp; A</h2>
<!-- START: div -->
<div class="QandA_question">
<p>Q: My compiler doesn’t give a warning when I use <code>=</code>
instead of <code>==</code>. Is there some way to force the compiler to
notice the problem? [p. 77]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Here’s a trick that some programmers use: instead of writing</p>
<div class="sourceCode" id="cb211"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>they habitually write</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="dv">0</span> <span class="op">==</span> i<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>Now suppose that the <code>==</code> operator is accidentally written
as <code>=</code>:</p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span><span class="dv">0</span> <span class="op">=</span> i<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>The compiler will produce an error message, since it’s not possible
to assign a value to 0. I don’t use this trick, because I think it makes
programs look unnatural. Also, it can be used only when one of the
operands in the test condition isn’t an lvalue.</p>
<p>Fortunately, many compilers are capable of checking for suspect uses
of the <code>=</code> operator in <code>if</code> conditions. The GCC
compiler, for example, will perform this check if the
<code>-Wparentheses</code> option is used or if <code>-Wall</code> (all
warnings) is selected. GCC allows the programmer to suppress the warning
in a particular case by enclosing the if condition in a second set of
parentheses:</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">((</span>i <span class="op">=</span> j<span class="op">))</span> <span class="op">...</span></span></code></pre></div>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: C books seem to use several different styles of indentation and
brace placement for compound statements. Which style is best?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>According to The <em>New Hacker’s Dictionary</em> (Cambridge, Mass.:
MIT Press, 1996), there are four common styles of indentation and brace
placement:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>The <em>K&amp;R</em> style, used in Kernighan and Ritchie’s <em>The C
Programming Language</em>, is the one I’ve chosen for the programs in
this book. In the K&amp;R style, the left brace appears at the end of a
line:</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX LINES<span class="op">)</span> <span class="op">{</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>    line num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The K&amp;R style keeps programs compact by not putting the left
brace on a line by itself. A disadvantage: the left brace can be hard to
find. (I don’t consider this a problem, since the indentation of the
inner statements makes it clear where the left brace should be.) The
K&amp;R style is the one most often used in Java, by the way.</p>
</li>
<li>
<p>The <em>Allman style</em>, named after <strong>Eric Allman</strong>
(the author of <code>sendmail</code> and other UNIX utilities), puts the
left brace on a separate line:</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX_ LINES<span class="op">)</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>    line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This style makes it easy to check that braces come in matching
pairs.</p>
</li>
<li>
<p>The <em>Whitesmiths style</em>, popularized by the Whitesmiths C
compiler, dictates that braces be indented:</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX LINES<span class="op">)</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>    line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
</li>
<li>
<p>m The GNU style, used in software developed by the GNU Project,
indents the braces, then further indents the inner statements:</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX LINES<span class="op">)</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>        line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a>        page_num<span class="op">++;</span></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
</li>
</ul>
<!-- END: unordered-list -->
<p>Which style you use is mainly a matter of taste; there’s no proof
that one style is clearly better than the others. In any event, choosing
the right style is less important than applying it consistently.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: If <code>i</code> is an <code>int</code> variable and
<code>f</code> is a <code>float</code> variable, what is the type of the
conditional expression <code>(i &gt; 0 ? i : f)</code>?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: When <code>int</code> and <code>float</code> values are mixed in a
conditional expression, as they are here, the expression has type
<code>float</code>. If <code>i &gt; 0</code> is <code>true</code>, the
value of the expression will be the value of <code>i</code> after
conversion to <code>float</code> type.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: Why doesn’t C99 have a better name for its Boolean type?
[p. 85]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="C99Symbol"></span></p>
<p>A: <code>_Bool</code> isn’t a very elegant name, is it? More common
names, such as <code>bool</code> or <code>boolean</code>, weren’t chosen
because existing C programs might already define these names, causing
older code not to compile.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: OK, so why wouldn’t the name <code>_Bool</code> break older
programs as well?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The C89 standard specifies that names beginning with an underscore
followed by an uppercase letter are reserved for future use and should
not be used by programmers.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: The template given for the <code>switch</code> statement described
it as the “most common form.” Are there other forms? [p. 87]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The <code>switch</code> statement is a bit more general than
described in this chapter, although the description given here is
general enough for virtually all programs. For example, a
<code>switch</code> statement can contain labels that aren’t preceded by
the word <code>case</code>, which leads to an amusing (?) trap. Suppose
that we accidentally misspell the word <code>default</code>:</p>
<div class="sourceCode" id="cb219"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>    defualt<span class="op">:</span> <span class="op">...</span></span></code></pre></div>
<p>The compiler may not detect the error, since it assumes that
<code>defualt</code> is an ordinary label.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: I’ve seen several methods of indenting the <code>switch</code>
statement. Which way is best?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: There are at least two common methods. One is to put the
statements in each case <em>after</em> the <code>case</code> label:</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>coin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Cent&quot;</span><span class="op">);</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Nickel&quot;</span><span class="op">);</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">10</span><span class="op">:</span> printf <span class="op">(</span><span class="st">&quot;Dime&quot;</span><span class="op">);</span></span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">25</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Quarter&quot;</span><span class="op">);</span></span>
<span id="cb220-9"><a href="#cb220-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb220-10"><a href="#cb220-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If each case consists of a single action (a call of
<code>printf</code>, in this example), the <code>break</code> statement
could even go on the same line as the action:</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>coin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Cent&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Nickel&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">10</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Dime&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">25</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Quarter&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The other method is to put the statements <em>under</em> the case
label, indenting the statements to make the case label stand out:</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>coin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Cent&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Nickel&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">10</span><span class="op">:</span></span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Dime&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">25</span><span class="op">:</span></span>
<span id="cb222-12"><a href="#cb222-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Quarter&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb222-13"><a href="#cb222-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb222-14"><a href="#cb222-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In one variation of this scheme, each case label is aligned under the
word <code>switch</code>.</p>
<p>The first method is fine when the statements in each case are short
and there are relatively few of them. The second method is better for
large switch statements in which the statements in each case are complex
and/or numerous.</p>
</div>
<!-- END: div -->
<hr />
<h2 id="examples-3">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh05/cknkCh05Exmp/">./cknkCh05/cknkCh05Exmp/</a></li>
</ul>
<h2 id="exercises-3">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh05/cknkCh05Exrc/README.md">./cknkCh05/cknkCh05Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh05/cknkCh05Exrc/cknkCh05ExrcReadme.html">./cknkCh05/cknkCh05Exrc/cknkCh05ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh05/cknkCh05Exrc/">./cknkCh05/cknkCh05Exrc/</a></li>
</ul>
<h2 id="programming-projects-3">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh05/cknkCh05Prj/README.md">./cknkCh05/cknkCh05Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh05/cknkCh05Prj/cknkCh05PrjReadme.html">./cknkCh05/cknkCh05Prj/cknkCh05PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh05/cknkCh05Prj/">./cknkCh05/cknkCh05Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="loops">6 Loops</h1>
<!-- START: div -->
<div class="theQuote">
<p>A program without a loop and a structured variable isn’t worth
writing.</p>
</div>
<!-- END: div -->
<p>Chapter 5 covered C’s selection statements, <code>if</code> and
<code>switch</code>. This chapter introduces C’s iteration statements,
which allow us to set up loops.</p>
<p>A <strong><em>loop</em></strong> is a statement whose job is to
repeatedly execute some other statement (the <strong><em>loop
body</em></strong>). In C, every loop has a <strong><em>controlling
expression</em></strong>. Each time the loop body is executed (an
iteration of the loop), the controlling expression is evaluated; if the
expression is true—has a value that’s not zero—the loop continues to
execute.</p>
<p>C provides three iteration statements: <code>while</code>,
<code>do</code>, and <code>for</code>, which are covered in Sections
6.1, 6.2, and 6.3, respectively. The <code>while</code> statement is
used for loops whose controlling expression is tested <em>before</em>
the loop body is executed. The <em>do</em> statement is used if the
expression is tested <em>after</em> the loop body is executed. The
<code>for</code> statement is convenient for loops that increment or
decrement a counting variable. Section 6.3 also introduces the comma
operator, which is used primarily in <code>for</code> statements.</p>
<p>The last two sections of this chapter are devoted to C features that
are used in conjunction with loops. Section 6.4 describes the
<code>break</code>, <code>continue</code>, and <code>goto</code>
statements. <code>break</code> jumps out of a loop and transfers control
to the next statement after the loop, <code>continue</code> skips the
rest of a loop iteration, and goto jumps to any statement within a
function. Section 6.5 covers the null statement, which can be used to
create loops with empty bodies.</p>
<h2 id="the-while-statement">6.1 The <code>while</code> Statement</h2>
<p>Of all the ways to set up loops in C, the <code>while</code>
statement is the simplest and most fundamental. The <code>while</code>
statement has the form</p>
<div class="sourceCode" id="cb223"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span> expression <span class="op">)</span> statement</span></code></pre></div>
<p>The expression inside the parentheses is the controlling expression;
the statement after the parentheses is the loop body. Here’s an
example:</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> n<span class="op">)</span> <span class="co">/* controlling expression */</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> i <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="co">/* loop body */</span></span></code></pre></div>
<p>Note that the parentheses are mandatory and that nothing goes between
the right parenthesis and the loop body. (Some languages require the
word <code>do</code>.)</p>
<p>When a <code>while</code> statement is executed, the controlling
expression is evaluated first. If its value is nonzero (true), the loop
body is executed and the expression is tested again. The process
continues in this fashion—first testing the controlling expression, then
executing the loop body—until the controlling expression eventually has
the value zero.</p>
<p>The following example uses a <code>while</code> statement to compute
the smallest power of 2 that is greater than or equal to a number
<code>n</code>:</p>
<div class="sourceCode" id="cb225"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> n<span class="op">)</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> i <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>Suppose that <code>n</code> has the value 10. The following trace
shows what happens when the <code>while</code> statement is
executed:</p>
<table>
<tbody>
<tr class="odd">
<td><code>i = 1;</code></td>
<td><code>i</code> is now 1.</td>
</tr>
<tr class="even">
<td>Is <code>i &lt; n</code>?</td>
<td>Yes; continue.</td>
</tr>
<tr class="odd">
<td><code>i = i * 2;</code></td>
<td><code>i</code> is now 2.</td>
</tr>
<tr class="even">
<td>Is <code>i &lt; n</code>?</td>
<td>Yes; continue.</td>
</tr>
<tr class="odd">
<td><code>i = i * 2;</code></td>
<td><code>i</code> is now 4.</td>
</tr>
<tr class="even">
<td>Is <code>i &lt; n</code>?</td>
<td>Yes: continue.</td>
</tr>
<tr class="odd">
<td><code>i = i * 2;</code></td>
<td><code>i</code> is now 8.</td>
</tr>
<tr class="even">
<td>Is <code>i &lt; n</code>? Yes:; continue.</td>
<td></td>
</tr>
<tr class="odd">
<td><code>i = i * 2;</code></td>
<td><code>i</code> is now l6.</td>
</tr>
<tr class="even">
<td>Is <code>i &lt; n</code>? No; exit from loop.</td>
<td></td>
</tr>
</tbody>
</table>
<p>Notice how the loop keeps going as long as the controlling expression
<code>(i &lt; n)</code> is true. When the expression is false, the loop
terminates, and <code>i</code> is greater than or equal to
<code>n</code>, as desired.</p>
<p>Although the loop body must be a single statement, that’s merely a
technicality. If we want more than one statement, we can just use braces
to create a single compound statement:</p>
<div class="sourceCode" id="cb226"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>    i<span class="op">--;</span></span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Some programmers always use braces, even when they’re not strictly
necessary:</p>
<div class="sourceCode" id="cb227"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> n<span class="op">)</span> <span class="op">{</span> <span class="co">/* braces allowed, but not reguired */</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> i <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As a second example, let’s trace the execution of the following
statements, which display a series of “countdown” messages:</p>
<div class="sourceCode" id="cb228"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a>    i<span class="op">--;</span></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<p>Before the <code>while</code> statement is executed, the variable
<code>i</code> is assigned the value 10. Since 10 is greater than 0, the
loop body is executed, causing the message
<code>T minus 10 and counting</code> to be printed and <code>i</code> to
be decremented. The condition <code>i &gt; 0</code> is then tested
again. Since 9 is greater than 0, the loop body is executed once more.
This process continues until the message
<code>T minus 1 and counting</code> is printed and <code>i</code>
becomes 0. The test <code>i &gt; 0</code> then fails, causing the loop
to terminate.</p>
<p>The countdown example leads us to make several observations about the
<code>while</code> statement:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>The controlling expression is false when a <code>while</code> loop
terminates. Thus, when a loop controlled by the expression
<code>1 &gt; 0</code> terminates. <code>i</code> must be less than or
equal to 0. (Otherwise, we’d still be executing the loop!)</p>
</li>
<li>
<p>The body of a <code>while</code> loop may not be executed at all.
Since the controlling expression is tested <em>before</em> the loop body
is executed, it’s possible that the body isn’t executed even once. If
<code>i</code> has a negative or zero value when the countdown loop is
first entered, the loop will do nothing.</p>
</li>
<li>
<p>A <code>while</code> statement can often be written in a variety of
ways. For example, we could make the countdown loop more concise by
decrementing <code>i</code> inside the call of <code>printf</code>;</p>
<p><span class="QandA"></span></p>
<div class="sourceCode" id="cb229"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span></span></code></pre></div>
</li>
</ul>
<!-- END: unordered-list -->
<h3 id="infinite-loops">6.1.1 Infinite Loops</h3>
<p>A <code>while</code> satement won’t terminate if the controlling
expression always has a nonzero value. In fact, C programmers sometimes
deliberately create an <strong><em>infinite loop</em></strong> by using
a nonzero constant as the controlling expression:</p>
<div class="sourceCode" id="cb230"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>A <code>while</code> statement of this form will execute forever
unless its body contains a statement that transfers control out of the
loop (<code>break</code>, <code>goto</code>, <code>return</code>) or
calls a function that causes the program to terminate.</p>
<h3 id="program-printing-a-table-of-squares">6.1.2 (PROGRAM) Printing a
Table of Squares</h3>
<p>Let’s write a program that prints a table of squares. The program
will first prompt the user to enter a number <code>n</code>. It will
then print <code>n</code> lines of output, with each line containing a
number between 1 and <code>n</code> together with its square:</p>
<pre class="shell"><code>This program prints a table of squares.
Enter number of entries in table: 5
         1         1
         2         4
         3         9
         4        16
         5        25</code></pre>
<p>Let’s have the program store the desired number of squares in a
variable named <code>n</code>. We’ll need a loop that repeatedly prints
a number <code>i</code> and its square, starting with <code>i</code>
equal to 1. The loop will repeat as long as <code>i</code> is less than
or equal to <code>n</code>. We’ll have to make sure to add 1 to
<code>i</code> each time through the loop.</p>
<p>We’ll write the loop as a <code>while</code> statement. (Frankly, we
haven’t got much choice, since the <code>while</code> statement is the
only kind of loop we’ve covered so far.) Here’s the finished
program:</p>
<div class="sourceCode" id="cb232"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: square.c</span></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a table of squares using a while statement</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> n<span class="op">;</span></span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-13"><a href="#cb232-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This program prints a table of squares.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb232-14"><a href="#cb232-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter number of entries in table: &quot;</span><span class="op">);</span></span>
<span id="cb232-15"><a href="#cb232-15" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb232-16"><a href="#cb232-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-17"><a href="#cb232-17" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb232-18"><a href="#cb232-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>i <span class="op">&lt;=</span> n<span class="op">)</span></span>
<span id="cb232-19"><a href="#cb232-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb232-20"><a href="#cb232-20" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%10d%10d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> i <span class="op">*</span> i<span class="op">);</span></span>
<span id="cb232-21"><a href="#cb232-21" aria-hidden="true" tabindex="-1"></a>        i<span class="op">++;</span></span>
<span id="cb232-22"><a href="#cb232-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb232-23"><a href="#cb232-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-24"><a href="#cb232-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb232-25"><a href="#cb232-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note how <code>square.c</code> displays numbers in neatly aligned
columns. The trick is to use a conversion specification like
<code>%10d</code> instead of just <code>%d</code>, taking advantage of
the fact that printf right-justifies numbers when a field width is
specified.</p>
<h3 id="summing-a-series-of-numbers">6.1.3 Summing a Series of
Numbers</h3>
<p>As a second example of the <code>while</code> statement, let’s write
a program that sums a series of integers entered by the user, Here’s
what the user will see:</p>
<pre class="shell"><code>This program sums a series of integers.
Enter integers (0 to terminate): 8 23 71 5 0
The sum is: 107</code></pre>
<p>Clearly we’ll need a loop that uses <code>scanf</code> to read a
number and then adds the number to a running total.</p>
<p>Letting <code>n</code> represent the number just read and sum the
total of all numbers previously read, we end up with the following
program:</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: sum.c</span></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Sums a series of numbers</span></span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb234-12"><a href="#cb234-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-13"><a href="#cb234-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This program sums a series of integers.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb234-14"><a href="#cb234-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter integers (0 to terminate): &quot;</span><span class="op">);</span></span>
<span id="cb234-15"><a href="#cb234-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-16"><a href="#cb234-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb234-17"><a href="#cb234-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>n <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb234-18"><a href="#cb234-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb234-19"><a href="#cb234-19" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> n<span class="op">;</span></span>
<span id="cb234-20"><a href="#cb234-20" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb234-21"><a href="#cb234-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb234-22"><a href="#cb234-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;The sum is: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> sum<span class="op">);</span></span>
<span id="cb234-23"><a href="#cb234-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-24"><a href="#cb234-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb234-25"><a href="#cb234-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the condition <code>n != 0</code> is tested just after a
number is read, allowing the loop to terminate as soon as possible. Also
note that there are two identical calls of <code>scanf</code>, which is
often hard to avoid when using <code>while</code> loops.</p>
<h2 id="the-do-statement">The do Statement</h2>
<p>The <code>do</code> statement is closely related to the
<code>while</code> statement, in fact, the do statement is essentially
just a <code>while</code> statement whose controlling expression is
tested <em>after</em> each execution of the loop body. The
<code>do</code> statement has the form</p>
<div class="sourceCode" id="cb235"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> statement <span class="cf">while</span> <span class="op">(</span> expression <span class="op">)</span> <span class="op">;</span></span></code></pre></div>
<p>As with the <code>while</code> statement, the body of a
<code>do</code> statement must be one statement (possibly compound, of
course) and the controlling expression must be enclosed within
parentheses.</p>
<p>When a <code>do</code> statement is executed, the loop body is
executed first, then the controlling expression is evaluated. If the
value of the expression is nonzero, the loop body is executed again and
then the expression is evaluated once more. Execution of the
<code>do</code> statement terminates when the controlling expression has
the value 0 after the loop body has been executed.</p>
<p>Let’s rewrite the countdown example of Section 6.1, using a
<code>do</code> statement this time:</p>
<div class="sourceCode" id="cb236"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span><span class="op">{</span></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">--</span>i<span class="op">;</span></span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span><span class="cf">while</span><span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>When the <code>do</code> statement is executed, the loop body is
first executed, causing the message <code>T minus 10 and counting</code>
to be printed and <code>i</code> to be decremented. The condition
<code>i &gt; 0</code> is now tested. Since 9 is greater than 0, the loop
body is executed a second time. This process continues until the message
<code>T minus 1 and counting</code> is printed and <code>i</code>
becomes 0. The test <code>i &gt; 0</code> now fails, causing the loop to
terminate. As this example shows, the <code>do</code> statement is often
indistinguishable from the <code>while</code> statement. The difference
between the two is that the body of a <code>do</code> statement is
always executed at least once; the body of a <code>while</code>
statement is skipped entirely if the controlling expression is 0
initially.</p>
<p>Incidentally, it’s a good idea to use braces in <em>all</em> do
statements, whether or not they’re needed, because a <code>do</code>
statement without braces can easily be mistaken fora <code>while</code>
statement:</p>
<div class="sourceCode" id="cb237"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>A careless reader might think that the word <code>while</code> was
the beginning of a <code>while</code> statement.</p>
<h3 id="calculating-the-number-of-digits-in-an-integer">6.2.1
Calculating the Number of Digits in an Integer</h3>
<p>Although the <code>while</code> statement appears in C programs much
more often than the <code>do</code> statement, the latter is handy for
loops that must execute at least once. To illustrate this point, let’s
write a program that calculates the number of digits in an integer
entered by the user:</p>
<pre class="shell"><code>Enter a nonnegative integer: 60
The number has 2 digit(s).</code></pre>
<p>Our strategy will be to divide the user’s input by 10 repeatedly
until it becomes 0; the number of divisions performed is the number of
digits. Clearly we’ll need some kind of loop, since we don’t know how
many divisions it will take to reach 0. But should we use a
<code>while</code> statement or a <code>do</code> statement? The
<code>do</code> statement turns out to be more attractive, because every
integer—even 0—has at least one digit. Here’s the program:</p>
<div class="sourceCode" id="cb239"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: numdigits.c</span></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Calculates the number of digits in an integer</span></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb239-11"><a href="#cb239-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> digits <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> n<span class="op">;</span></span>
<span id="cb239-12"><a href="#cb239-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-13"><a href="#cb239-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter a nonnegative integer: &quot;</span><span class="op">);</span></span>
<span id="cb239-14"><a href="#cb239-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb239-15"><a href="#cb239-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-16"><a href="#cb239-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span></span>
<span id="cb239-17"><a href="#cb239-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb239-18"><a href="#cb239-18" aria-hidden="true" tabindex="-1"></a>        n <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb239-19"><a href="#cb239-19" aria-hidden="true" tabindex="-1"></a>        digits<span class="op">++;</span></span>
<span id="cb239-20"><a href="#cb239-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span><span class="cf">while</span><span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb239-21"><a href="#cb239-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-22"><a href="#cb239-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;The number has %d digit(s).</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> digits<span class="op">);</span></span>
<span id="cb239-23"><a href="#cb239-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-24"><a href="#cb239-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb239-25"><a href="#cb239-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To see why the <code>do</code> statement is the right choice, let’s
see what would happen if we were to replace the <code>do</code> loop by
a similar while loop:</p>
<div class="sourceCode" id="cb240"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a>    digits<span class="op">++;</span></span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If <code>n</code> is 0 initially, this loop won’t execute at all, and
the program would print</p>
<pre class="shell"><code>The number has 0 digit(s).</code></pre>
<h2 id="the-for-statement">6.3 The <code>for</code> Statement</h2>
<p>We now come to the last of C’s loops: the <code>for</code> statement.
Don’t be discouraged by the <code>for</code> statement’s apparent
complexity; it’s actually the best way to write many loops. The
<code>for</code> statement is ideal for loops that have a “counting”
variable, but it’s versatile enough to be used for other kinds of loops
as well.</p>
<p>The <code>for</code> statement has the form</p>
<div class="sourceCode" id="cb242"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span> exprl <span class="op">;</span> expr2 <span class="op">;</span> expr3 <span class="op">)</span> statement</span></code></pre></div>
<p>where <code>exprl</code>, <code>expr2</code>, and <code>expr3</code>
are expressions. Here’s an example:</p>
<div class="sourceCode" id="cb243"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span></code></pre></div>
<p>When this <code>for</code> statement is executed, the variable
<code>i</code> is initialized to 10, then <code>i</code> is tested to
see if it’s greater than 0. Since it is, the message
<code>T minus 10 and counting</code> is printed, then <code>i</code> is
decremented. The condition <code>i &gt; 0</code> is then tested again.
The loop body will be executed 10 times in all, with <code>i</code>
varying from 10 down to 1.</p>
<p><span class="QandA"></span></p>
<p>The <code>for</code> statement is closely related to the
<code>while</code> statement. In fact, except in a few rare cases, a
<code>for</code> loop can always be replaced by an equivalent
<code>while</code> loop:</p>
<div class="sourceCode" id="cb244"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a>exprl<span class="op">;</span></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span> expr2 <span class="op">)</span> <span class="op">{</span></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a>    Statement</span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>    expr3<span class="op">;</span></span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As this pattern shows, <code>exprl</code> is an initialization step
that’s performed only once, before the loop begins to execute,
<code>expr2</code> controls loop termination (the loop continues
executing as long as the value of <code>expr2</code> is nonzero), and
<code>expr3</code> is an operation to be performed at the end of each
loop iteration. Applying this pattern to our previous <code>for</code>
loop example, we arrive at the following:</p>
<div class="sourceCode" id="cb245"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>i<span class="op">=</span><span class="dv">10</span><span class="op">;</span></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a>    i<span class="op">--;</span></span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Studying the equivalent <code>while</code> statement can help us
understand the fine points of a <code>for</code> statement. For example,
suppose that we replace <code>i--</code> by <code>--i</code> in our
<code>for</code> loop example:</p>
<div class="sourceCode" id="cb246"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span></code></pre></div>
<p>How does this change affect the loop? Looking at the equivalent
<code>while</code> loop, we see that it has no effect:</p>
<div class="sourceCode" id="cb247"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb247-4"><a href="#cb247-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">--</span>i<span class="op">;</span></span>
<span id="cb247-5"><a href="#cb247-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Since the first and third expressions in a <code>for</code> statement
are executed as statements, their values are irrelevant—they’re useful
only for their side effects. Consequently, these two expressions are
usually assignments or increment/decrement expressions.</p>
<h3 id="for-statement-idioms">6.3.1 <code>for</code> statement
Idioms</h3>
<p>The <code>for</code> statement is usually the best choice for loops
that “count up” (increment a variable) or “count down™ (decrement a
variable). A <code>for</code> statement that counts up or down a total
of <code>n</code> times will usually have one of the following
forms:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>Counting up from 0 to <code>n-1</code>:</p>
<div class="sourceCode" id="cb248"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">...</span></span></code></pre></div>
</li>
<li>
<p>Counting up from 1 to <code>n</code>:</p>
<div class="sourceCode" id="cb249"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">....</span></span></code></pre></div>
</li>
<li>
<p>Counting down from <code>n-1</code> to <code>0</code>:</p>
<div class="sourceCode" id="cb250"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> n<span class="op">-</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">...</span></span></code></pre></div>
</li>
<li>
<p>Counting down from <code>n</code> to 1:</p>
<div class="sourceCode" id="cb251"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> n<span class="op">;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">...</span></span></code></pre></div>
</li>
</ul>
<!-- END: unordered-list -->
<p>Imitating these patterns will help you avoid some of the following
errors, which beginning C programmers often make:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>Using <code>&lt;</code> instead of <code>&gt;</code> (or vice versa)
in the controlling expression. Notice that “counting up” loops use the
<code>&lt;</code> or <code>&lt;=</code> operator, while “counting down™
loops rely on <code>&gt;</code> or <code>&gt;=</code>.</p>
</li>
<li>
<p>Using <code>==</code> in the controlling expression instead of
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or
<code>&gt;=</code>. A controlling expression needs to be true at the
beginning of the loop, then later become false so that the loop can
terminate. A test such as <code>i == n</code> doesn’t make much sense,
because it won’t be true initially.</p>
</li>
<li>
<p>“Off-by-one” errors such as writing the controlling expression as
<code>i &lt;= n</code> instead of <code>i &lt; n</code>.</p>
</li>
</ul>
<!-- END: unordered-list -->
<h3 id="omitting-expressions-in-a-for-statement">6.3.2 Omitting
Expressions in a <code>for</code> statement</h3>
<p>The <code>for</code> statement is even more flexible than we’ve seen
so far. Some <code>for</code> loops may not need all three of the
expressions that normally control the loop. so C allows us to omit any
or all of the expressions.</p>
<p>If the first expression is omitted, no initialization is performed
before the loop is exccuted:</p>
<div class="sourceCode" id="cb252"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span></code></pre></div>
<p>In this example, <code>i</code> has been initialized by a separate
assignment, so we’ve omitted the first expression in the
<code>for</code> statement. (Notice that the semicolon between the first
and second expressions remains. The two semicolons must always be
present, even when we’ve omitted some of the expressions.)</p>
<p>If we omit the <em>third</em> expression in a <code>for</code>
statement, the loop body is responsible for ensuring that the value of
the second expression eventually becomes false. Our <code>for</code>
statement example could be written like this:</p>
<div class="sourceCode" id="cb253"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;)</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span></span></code></pre></div>
<p>To compensate for omitting the third expression, we’ve arranged for
<code>i</code> to be decremented inside the loop body.</p>
<p>When the <em>first</em> and <em>third</em> expressions are both
omitted, the resulting loop is nothing more than a <code>while</code>
statement in disguise. For example, the loop</p>
<div class="sourceCode" id="cb254"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;)</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span></span></code></pre></div>
<p>is the same as</p>
<div class="sourceCode" id="cb255"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span></span></code></pre></div>
<p>The <code>while</code> version is clearer and therefore
preferable.</p>
<p><span class="QandA"></span></p>
<p>If the second expression is missing, it defaults to a true value, so
the for statement doesn’t terminate (unless stopped in some other
fashion). For example, some programmers use the following
<code>for</code> statement to establish an infinite loop:</p>
<div class="sourceCode" id="cb256"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;;)</span> <span class="op">...</span></span></code></pre></div>
<h3 id="for-statements-in-c99">6.3.3 <code>for</code> statements in
C99</h3>
<p>In C99, the first expression in a <code>for</code> statement can be
replaced by a declaration. “This teature allows the programmer to
declare a variable for use by the loop:</p>
<div class="sourceCode" id="cb257"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p>The variable <code>i</code> need not have been declared prior to this
statement. (In fact, if a declaration of <code>i</code> already exists,
this statement creates a <em>new</em> version of <code>i</code> that
will be used solely within the loop.)</p>
<p>A variable declared by a <code>for</code> statement can’t be accessed
outside the body of the loop (we say that it’s not
<strong><em>visible</em></strong> outside the loop):</p>
<div class="sourceCode" id="cb258"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span><span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> i<span class="op">);</span> <span class="co">/* legal; i is visible inside loop */</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> i<span class="op">);</span> <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>Having a <code>for</code> statement declare its own control variable
is usually a good idea: it’s convenient and it can make programs easier
to understand. However, if the program needs to access the variable
afler loop termination, it’s necessary to use the older form of the
<code>for</code> statement.</p>
<p>Incidentally, a <code>for</code> statement may declare more than one
variable, provided that all variables have the same type:</p>
<div class="sourceCode" id="cb259"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<h3 id="the-comma-operator">6.3.4 The Comma Operator</h3>
<p>On occasion, we might like to write a <code>for</code> statement with
two (or more) initialization expressions or one that increments several
variables each time through the loop. We can do this by using a
<strong><em>comma expression</em></strong> as the first or third
expression in the <code>for</code> statement.</p>
<p>A comma expression has the form</p>
<div class="sourceCode" id="cb260"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a>exprl <span class="op">,</span> expr2</span></code></pre></div>
<p>where <code>exprl</code> and <code>expr2</code> are any two
expressions. A comma expression is evaluated in two steps: First,
<code>expr1</code> is evaluated and its valve discarded. Second,
<code>expr2</code> is evaluated: its value is the value of the entire
expression. Evaluating <code>expr1</code> should always have a side
effect; if it doesn’t. then <code>exprl</code> serves no purpose.</p>
<p>For example, suppose that <code>i</code> and <code>j</code> have the
values 1 and 5, respectively. When the comma expression
<code>++i</code>, <code>i + j</code> is evaluated, <code>i</code> is
first incremented, then <code>i + j</code> is evaluated, so the value of
the expression is 7. (And, of course, 1 now has the value 2.) The
precedence of the comma operator is less than that of all other
operators, by the way, so there’s no need to put parentheses around
<code>++i</code> and <code>i + j</code>.</p>
<p>Occasionally, we’ll need to chain together a series of comma
expressions, just as we sometimes chain assignments together. The comma
operator is left associative, so the compiler interprets</p>
<div class="sourceCode" id="cb261"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> j <span class="op">=</span> <span class="dv">2</span><span class="op">,</span> k <span class="op">=</span> i <span class="op">+</span> j</span></code></pre></div>
<p>as</p>
<div class="sourceCode" id="cb262"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="op">((</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">),</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">2</span><span class="op">)),</span> <span class="op">(</span>k <span class="op">=</span> <span class="op">(</span>i <span class="op">+</span> j<span class="op">))</span></span></code></pre></div>
<p>Since the left operand in a comma expression is evaluated before the
right operand, the assignments <code>i = 1</code>, <code>j = 2</code>
and <code>k = i + j</code> will be performed from left to right.</p>
<p>The comma operator is provided for situations where C requires a
single expression, but we’d like to have two or more expressions. In
other words, the comma operator allows us to “glue” two expressions
together to form a single expression. (Note the similarity to the
compound statement, which allows us to treat a group of statements us a
single statement.)</p>
<p>The need to glue expressions together doesn’t arise that often.
Certain macro definitions can benefit from the comma operator, as we’ll
sce in a later chapter. The <code>for</code> statement is the only other
place where the comma operator is likely to be found. For example,
suppose that we want to initialize two variables when entering a
<code>for</code> statement. Instead of writing</p>
<div class="sourceCode" id="cb263"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a>sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> i<span class="op">;</span></span></code></pre></div>
<p>we can write</p>
<div class="sourceCode" id="cb264"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>sum <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> i<span class="op">;</span></span></code></pre></div>
<p>The expression <code>sum = 0</code>, <code>i = 1</code> first assigns
0 to sum, then assigns 1 to <code>i</code>. With additional commas, the
<code>for</code> statement could initialize more than two variables.</p>
<h3 id="program-printing-a-table-of-squares-revisited">6.3.5 (PROGRAM)
Printing a Table of Squares (Revisited)</h3>
<p>The <code>square.c</code> program (Section 6.1) can be improved by
converting its <code>while</code> loop to a <code>for</code> loop:</p>
<div class="sourceCode" id="cb265"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: square2.c</span></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a table of squares using a for statement</span></span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb265-6"><a href="#cb265-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-7"><a href="#cb265-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb265-8"><a href="#cb265-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-9"><a href="#cb265-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb265-10"><a href="#cb265-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb265-11"><a href="#cb265-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> n<span class="op">;</span></span>
<span id="cb265-12"><a href="#cb265-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-13"><a href="#cb265-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This program prints a table of squares.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb265-14"><a href="#cb265-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter number of entries in table: &quot;</span><span class="op">);</span></span>
<span id="cb265-15"><a href="#cb265-15" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb265-16"><a href="#cb265-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-17"><a href="#cb265-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb265-18"><a href="#cb265-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb265-19"><a href="#cb265-19" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%10d%10d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> i <span class="op">*</span> i<span class="op">);</span></span>
<span id="cb265-20"><a href="#cb265-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb265-21"><a href="#cb265-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-22"><a href="#cb265-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb265-23"><a href="#cb265-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can use this program to illustrate an important point about the
<code>for</code> statement: C places no restrictions on the three
expressions that control its behavior. Although these expressions
usually initialize. test, and update the same variable, there’s no
requirement that they be related in any way. Consider the following
version of the same program:</p>
<div class="sourceCode" id="cb266"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: square3.c</span></span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a table of squares using an odd method</span></span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-7"><a href="#cb266-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb266-8"><a href="#cb266-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-9"><a href="#cb266-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb266-10"><a href="#cb266-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb266-11"><a href="#cb266-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> n<span class="op">,</span> odd<span class="op">,</span> square<span class="op">;</span></span>
<span id="cb266-12"><a href="#cb266-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-13"><a href="#cb266-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This program prints a table of squares.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb266-14"><a href="#cb266-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter number of entries in table: &quot;</span><span class="op">);</span></span>
<span id="cb266-15"><a href="#cb266-15" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb266-16"><a href="#cb266-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-17"><a href="#cb266-17" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb266-18"><a href="#cb266-18" aria-hidden="true" tabindex="-1"></a>    odd <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb266-19"><a href="#cb266-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>square <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> odd <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb266-20"><a href="#cb266-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb266-21"><a href="#cb266-21" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%10d%10d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> square<span class="op">);</span></span>
<span id="cb266-22"><a href="#cb266-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>i<span class="op">;</span></span>
<span id="cb266-23"><a href="#cb266-23" aria-hidden="true" tabindex="-1"></a>        square <span class="op">+=</span> odd<span class="op">;</span></span>
<span id="cb266-24"><a href="#cb266-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-25"><a href="#cb266-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-26"><a href="#cb266-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb266-27"><a href="#cb266-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>for</code> statement in this program initializes one
variable (<code>square</code>), tests another (<code>i</code>), and
increments a third (<code>odd</code>). <code>i</code> is the number to
be squared, square is the square of <code>i</code>, and <code>odd</code>
is the odd number that must be added to the current square to get the
mext square (allowing the program to compute consecutive squares without
performing any multiplications).</p>
<p>The tremendous flexibility of the <code>for</code> statement can
sometimes be useful; we’ll find it to be a great help when working with
linked lists. The <code>for</code> statement can easily be misused,
though, so don’t go overboard. The <code>for</code> loop in
<code>square3.c</code> would be a lot clearer if we rearranged its
pieces so that the loop is clearly controlled by <code>i</code>.</p>
<h2 id="exiting-from-a-loop">6.4 Exiting from a Loop</h2>
<p>We’ve seen how to write loops that have an exit point before the loop
body (using <code>while</code> and <code>for</code> statements) or after
it (using <code>do</code> statements). Occasionally, however, we’ll need
a loop with an exit point in the middle. We may even want a loop to have
more than one exit point. The <code>break</code> statement makes it
possible to write either kind of loop.</p>
<p>After we’ve examined the <code>break</code> statement, we’ll look at
a couple of related slatements: <code>continue</code> and
<code>goto</code>. The <code>continue</code> statement makes it possible
to skip part of a loop iteration without jumping out of the loop. The
<code>goto</code> statement allows a program to jump from one statement
to another. Thanks to the availability of statements such as
<code>break</code> and <code>continue</code>, the <code>goto</code>
statement is rarely used.</p>
<h3 id="the-break-statement">6.4.1 The break Statement</h3>
<p>We’ve already discussed how a <code>break</code> statement can
transfer control out of a <code>switch</code> statement. The
<code>break</code> statement can also be used to jump out of a
<code>while</code>, <code>do</code>, or <code>for</code> loop.</p>
<p>Suppose that we’re writing a program that checks whether a number
<code>n</code> is prime. Our plan is to write a <code>for</code>
statement that divides <code>n</code> by the numbers between 2 and
<code>n — 1</code>. We should break out of the loop as soon as any
divisor is found; there’s no need to try the remaining possibilities.
After the loop has terminated, we can use an <code>if</code> statement
to determine whether termination was premature (hence <code>n</code>
isn’t prime) or normal (<code>n</code> is prime):</p>
<div class="sourceCode" id="cb267"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>d <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> d <span class="op">&lt;</span> n<span class="op">;</span> d<span class="op">++)</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">%</span> d <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>d <span class="op">&lt;</span> n<span class="op">)</span></span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d is divisible by %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d is prime</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">);</span></span></code></pre></div>
<p>The <code>break</code> statement is particularly useful for writing
loops in which the exit point is in the middle of the body rather than
at the beginning or end. Loops that read user input, terminating when a
particular value is entered, often fall into this category:</p>
<div class="sourceCode" id="cb268"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter a number (enter 0 to stop): &quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a>    scanf <span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d cubed is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">,</span> n <span class="op">*</span> n <span class="op">*</span> n<span class="op">);</span></span>
<span id="cb268-7"><a href="#cb268-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A <code>break</code> statement transfers control out of the
<em>innermost</em> enclosing <code>while</code>, <code>do</code>,
<code>for</code>, or <code>switch</code> statement. Thus, when these
statements are nested, the <code>break</code> statement can escape only
one level of nesting. Consider the case of a <code>switch</code>
statement nested inside a <code>while</code> statement:</p>
<div class="sourceCode" id="cb269"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb269-4"><a href="#cb269-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb269-5"><a href="#cb269-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb269-6"><a href="#cb269-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb269-7"><a href="#cb269-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>break</code> statement transfers control out of the
<code>switch</code> statement, but not out of the <code>while</code>
loop. I’ll <code>return</code> to this point later.</p>
<h3 id="the-continue-statement">6.4.2 The continue Statement</h3>
<p>The <code>continue</code> statement doesn’t really belong here,
because it doesn’t exit from a loop. It’s similar to <code>break</code>,
though, so its inclusion in this section isn’t completely arbitrary.
<code>break</code> transfers control just past the end of a loop, while
continue transfers control to a point just before the end of the loop
body. With <code>break</code>, control leaves the loop; with
<code>continue</code>, control remains inside the loop. There’s another
difference between <code>break</code> and <code>continue</code>:
<code>break</code> can be used in <code>switch</code> statements and
loops (<code>while</code>, <code>do</code>, and <code>for</code>),
whereas <code>continue</code> is limited to loops.</p>
<p>The following example, which reads a series of numbers and computes
their sum, illustrates a simple use of <code>continue</code>. The loop
terminates when 10 nonzero numbers have been read. Whenever the number 0
is read, the <code>continue</code> statement is executed, skipping the
rest of the loop body (the statements <code>sum += 1;</code> and
<code>n++;</code>) but remaining inside the loop.</p>
<div class="sourceCode" id="cb270"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a>sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a>    scanf <span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb270-6"><a href="#cb270-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb270-7"><a href="#cb270-7" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> i<span class="op">;</span></span>
<span id="cb270-8"><a href="#cb270-8" aria-hidden="true" tabindex="-1"></a>    n<span class="op">++;</span></span>
<span id="cb270-9"><a href="#cb270-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* continue jumps to here */</span></span>
<span id="cb270-10"><a href="#cb270-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If <code>continue</code> were not available, we could have written
the example as follows:</p>
<div class="sourceCode" id="cb271"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a>sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a>    scanf <span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> i<span class="op">;</span></span>
<span id="cb271-7"><a href="#cb271-7" aria-hidden="true" tabindex="-1"></a>        n<span class="op">++;</span></span>
<span id="cb271-8"><a href="#cb271-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb271-9"><a href="#cb271-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="the-goto-statement">6.4.3 The <code>goto</code> Statement</h3>
<p><span class="C99Symbol"></span></p>
<p><code>break</code> and <code>continue</code> are jump statements that
transfer control from one point in the program to another. Both are
restricted: the target of a <code>break</code> is a point just beyond
the end of the enclosing loop, while the target of a
<code>continue</code> is a point just before the end of the loop. The
<code>goto</code> statement, on the other hand, is capable of jumping to
any statement in a function, provided that the statement has a
<strong><em>label</em></strong>. (C99 places an additional restriction
on the <code>goto</code> statement: it can’t be used to bypass the
declaration of a variable-length array.)</p>
<p>A label is just an identificr placed at the beginning of a
statement:</p>
<div class="sourceCode" id="cb272"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a>identifier <span class="op">:</span> starement</span></code></pre></div>
<p>A statement may have more than one label. The <code>goto</code>
statement itself has the form</p>
<div class="sourceCode" id="cb273"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="cf">goto</span> identifier <span class="op">;</span></span></code></pre></div>
<p>Executing the statement <code>goto L;</code> transfers control to the
statement that follows the label <code>L</code>, which must be in the
same function as the <code>goto</code> statement itself.</p>
<p>If C didn’t have a <code>break</code> statement, here’s how we might
use a goto statement 1o exit prematurely from a loop:</p>
<div class="sourceCode" id="cb274"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>d <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> d <span class="op">&lt;</span> n<span class="op">;</span> d<span class="op">++)</span></span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">%</span> d <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> done<span class="op">;</span></span>
<span id="cb274-4"><a href="#cb274-4" aria-hidden="true" tabindex="-1"></a>    done<span class="op">:</span></span>
<span id="cb274-5"><a href="#cb274-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>d <span class="op">&lt;</span> n<span class="op">)</span></span>
<span id="cb274-6"><a href="#cb274-6" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%d is divisible by %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb274-7"><a href="#cb274-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb274-8"><a href="#cb274-8" aria-hidden="true" tabindex="-1"></a>        printf <span class="op">(</span><span class="st">&quot;%d is prime</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">);</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>The <code>goto</code> statement, a staple of older programming
languages, is rarely needed in everyday C programming. The
<code>break</code>, <code>continue</code>, and <code>return</code>
statements which are essentially restricted <code>goto</code>
statements—and the <code>exit</code> function are sufficient to handle
most situations that might require a <code>goto</code> in other
languages.</p>
<p>Nonetheless, the <code>goto</code> statement can be helpful once in a
while. Consider the problem of exiting a loop from within a switch
statement. As we saw earlier, the <code>break</code> statement doesn’t
quite have the desired effect: it exits from the switch, but not from
the loop. A <code>goto</code> statement solves the problem:</p>
<div class="sourceCode" id="cb275"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">goto</span> loop_done<span class="op">;</span> <span class="co">/* break won&#39;t work here */</span></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a>loop_done<span class="op">:</span> <span class="op">...</span></span></code></pre></div>
<p>The <code>goto</code> statement is also useful for exiting from
nested loops.</p>
<h3 id="balancing-a-checkbook">6.4.4 Balancing a Checkbook</h3>
<p>Many simple interactive programs are menu-based: they present the
user with a list of commands to choose from. Once the user has selected
a command, the program performs the desired action, then prompts the
user for another command. This process continues until the user selects
an “exit” or “quit” command.</p>
<p>The heart of such a program will obviously be a loop. Inside the loop
will be statements that prompt the user for a command, read the command,
then decide what action to take:</p>
<div class="sourceCode" id="cb276"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a>    prompt user to enter command <span class="op">;</span></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a>    read command <span class="op">;</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a>    execute command <span class="op">;</span></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Executing the command will require a <code>switch</code> statement
(or cascaded <code>if</code> statement):</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a>    prompt user to enter command <span class="op">;</span></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a>    read command <span class="op">;</span></span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>command<span class="op">)</span> <span class="op">{</span></span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> command₁<span class="op">:</span> perform operation₁<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> command₂<span class="op">:</span> perform operation₂<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span></span>
<span id="cb277-8"><a href="#cb277-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span></span>
<span id="cb277-9"><a href="#cb277-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span></span>
<span id="cb277-10"><a href="#cb277-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> commandₙ<span class="op">:</span> perform operationₙ<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb277-11"><a href="#cb277-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span> print error message<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb277-12"><a href="#cb277-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb277-13"><a href="#cb277-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To illustrate this arrangement, let’s develop a program that
maintains a checkbook balance. The program will offer the user a menu of
choices: clear the account balance, credit money to the account, debit
money from the account, display the current balance, and exit the
program. The choices are represented by the integers 0, 1, 2, 3, and 4,
respectively. Here’s what a session with the program will look like:</p>
<pre class="shell"><code>*** ACME checkbook-balancing program ***
Commands: O=clear, l=credit, 2=debit, 3=balance, 4=exit

Enter command: 1
Enter amount of credit: 1042.56
Enter command: 2
Enter amount of debit: 133.79
Enter command: 1
Enter amount of credit: 1754.32
Enter command: 2
Enter amount of debit: 1400
Enter command: 2
Enter amount of debit: 68
Enter comwand: 2
Enter amount of debit: 50
Enter command: 3
Current balance: $1145.09
Enter command: 4</code></pre>
<p>When the user enters the command 4 (exit), the program needs to exit
from the <code>switch</code> statement <em>and</em> the surrounding
loop. The <code>break</code> statement won’t help, and we’d prefer not
to use a <code>goto</code> statement. Instead, we’ll have the program
execute a <code>return</code> statement, which will cause the main
function to return to the operating system.</p>
<div class="sourceCode" id="cb279"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: checking.c</span></span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Balances a checkbook</span></span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb279-5"><a href="#cb279-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb279-6"><a href="#cb279-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-7"><a href="#cb279-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb279-8"><a href="#cb279-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-9"><a href="#cb279-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb279-10"><a href="#cb279-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb279-11"><a href="#cb279-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cmd<span class="op">;</span></span>
<span id="cb279-12"><a href="#cb279-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> balance <span class="op">=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> credit<span class="op">,</span> debit<span class="op">;</span></span>
<span id="cb279-13"><a href="#cb279-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-14"><a href="#cb279-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;*** ACME checkbook-balancing program ***</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb279-15"><a href="#cb279-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Commands: 0=clear, 1=credit, 2=debit, &quot;</span><span class="op">);</span></span>
<span id="cb279-16"><a href="#cb279-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;3=balance, 4=exit</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb279-17"><a href="#cb279-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-18"><a href="#cb279-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(;;)</span></span>
<span id="cb279-19"><a href="#cb279-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb279-20"><a href="#cb279-20" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Enter command: &quot;</span><span class="op">);</span></span>
<span id="cb279-21"><a href="#cb279-21" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>cmd<span class="op">);</span></span>
<span id="cb279-22"><a href="#cb279-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span><span class="op">(</span>cmd<span class="op">)</span></span>
<span id="cb279-23"><a href="#cb279-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb279-24"><a href="#cb279-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb279-25"><a href="#cb279-25" aria-hidden="true" tabindex="-1"></a>                balance <span class="op">=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb279-26"><a href="#cb279-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb279-27"><a href="#cb279-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb279-28"><a href="#cb279-28" aria-hidden="true" tabindex="-1"></a>                printf<span class="op">(</span><span class="st">&quot;Enter amount of credit: &quot;</span><span class="op">);</span></span>
<span id="cb279-29"><a href="#cb279-29" aria-hidden="true" tabindex="-1"></a>                scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>credit<span class="op">);</span></span>
<span id="cb279-30"><a href="#cb279-30" aria-hidden="true" tabindex="-1"></a>                balance <span class="op">+=</span> credit<span class="op">;</span></span>
<span id="cb279-31"><a href="#cb279-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb279-32"><a href="#cb279-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb279-33"><a href="#cb279-33" aria-hidden="true" tabindex="-1"></a>                printf<span class="op">(</span><span class="st">&quot;Enter amount of debit: &quot;</span><span class="op">);</span></span>
<span id="cb279-34"><a href="#cb279-34" aria-hidden="true" tabindex="-1"></a>                scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>debit<span class="op">);</span></span>
<span id="cb279-35"><a href="#cb279-35" aria-hidden="true" tabindex="-1"></a>                balance <span class="op">-=</span> debit<span class="op">;</span></span>
<span id="cb279-36"><a href="#cb279-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb279-37"><a href="#cb279-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span></span>
<span id="cb279-38"><a href="#cb279-38" aria-hidden="true" tabindex="-1"></a>                printf<span class="op">(</span><span class="st">&quot;Current balance: $%.2f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> balance<span class="op">);</span></span>
<span id="cb279-39"><a href="#cb279-39" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb279-40"><a href="#cb279-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span></span>
<span id="cb279-41"><a href="#cb279-41" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb279-42"><a href="#cb279-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">default</span><span class="op">:</span></span>
<span id="cb279-43"><a href="#cb279-43" aria-hidden="true" tabindex="-1"></a>                printf<span class="op">(</span><span class="st">&quot;Commands: 0=clear, 1=credit, 2=debit, &quot;</span><span class="op">);</span></span>
<span id="cb279-44"><a href="#cb279-44" aria-hidden="true" tabindex="-1"></a>                printf<span class="op">(</span><span class="st">&quot;3=balance, 4=exit</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb279-45"><a href="#cb279-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb279-46"><a href="#cb279-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-47"><a href="#cb279-47" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb279-48"><a href="#cb279-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb279-49"><a href="#cb279-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the <code>return</code> statement is not followed by a
<code>break</code> statement. A <code>break</code> immediately following
a <code>return</code> can never be executed, and many compilers will
issue a warning message.</p>
<h2 id="the-null-statement">6.5 The Null Statement</h2>
<p>A statement can be <strong><em>null</em></strong>—devoid of symbols
except for the semicolon at the end.</p>
<p>Here’s an example:</p>
<div class="sourceCode" id="cb280"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">;</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>This line contains three statements: an assignment to <code>i</code>,
a null statement, and an assignment to 5.</p>
<p><span class="QandA"></span></p>
<p>The null statement is primarily good for one thing: writing loops
whose bodies are empty. As an example, recall the prime-finding loop of
Section 6.4:</p>
<div class="sourceCode" id="cb281"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>d <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> d <span class="op">&lt;</span> n<span class="op">;</span> d<span class="op">++)</span></span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">%</span> d <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span></code></pre></div>
<p>If we move the <code>n % d == 0</code> condition into the loop’s
controlling expression, the body of the loop becomes empty:</p>
<div class="sourceCode" id="cb282"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>d <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> d <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> n <span class="op">%</span> d <span class="op">!=</span> <span class="dv">0</span><span class="op">;</span> d<span class="op">++)</span></span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* empty loop body */</span> <span class="op">;</span></span></code></pre></div>
<p>Each time through the loop, the condition <code>d &lt; n</code> is
tested first: if it’s false, the loop terminates. Otherwise, the
condition <code>n % d ! = 0</code> is tested, and if that’s false, the
loop terminates. (In the latter case, <code>n % d == 0</code> must be
true: in other words. we’ve found a divisor of <code>n</code>.)</p>
<p>Note how we’ve put the null statement on a line by itself, instead of
writing</p>
<p>for (d - 2; d&lt;n&amp;&amp;n %dl=0; dt+);</p>
<p>C programmers customarily put the null statement on a line by itself.
Otherwise, someone reading the program might get confused about whether
the statement after the <code>for</code> was actually its body:</p>
<div class="sourceCode" id="cb283"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>d <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> d <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> n <span class="op">%</span> d <span class="op">!=</span> <span class="dv">0</span><span class="op">;</span> d<span class="op">++);</span></span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>d <span class="op">&lt;</span> n<span class="op">)</span></span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d is divisible by %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">,</span> d<span class="op">);</span></span></code></pre></div>
<p>Converting an ordinary loop into one with an empty body doesn’t buy
much: the new loop is often more concise but usually no more efficient.
In a few cases, though. a loop with an empty body is clearly superior to
the alternatives. For example, we’ll find these loops to be handy for
reading character data.</p>
<!-- START: div -->
<div class="infoBox">
<p>Accidentally putting a semicolon after the parentheses in an
<code>if</code>, <code>while</code>, or <code>for</code> statement
creates a null statement, thus ending the <code>if</code>,
<code>while</code>, or <code>for</code> prematurely.</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>In an <code>if</code> statement, putting a semicolon after the
parentheses creates an <code>if</code> statement that apparently
performs the same action regardless of the value of its controlling
expression:</p>
<div class="sourceCode" id="cb284"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a>it <span class="op">(</span>d <span class="op">==</span> <span class="dv">0</span><span class="op">);</span> <span class="co">/*** WRONG ***/</span></span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Error: Division by zero</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>The call of <code>printf</code> isn’t inside the <code>if</code>
statement, so it’s performed regardless of whether <code>d</code> is
equal to 0.</p>
</li>
<li>
<p>In a <code>while</code> statement, putting a semicolon after the
parentheses may create an infinite loop:</p>
<div class="sourceCode" id="cb285"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span> <span class="co">/*** WRONG ***/</span></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">--</span>i<span class="op">;</span></span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Another possibility is that the loop terminates, but the statement
that should be the loop body is executed only once, after the loop has
terminated:</p>
<div class="sourceCode" id="cb286"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">11</span><span class="op">;</span></span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(--</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span> <span class="co">/*** WRONG ***/</span></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;T minus 3d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span></code></pre></div>
<p>This example prints the message</p>
<pre class="shell"><code>T minus 0 and counting</code></pre>
</li>
<li>
<p>In a <code>for</code> statement, putting a semicolon after the
parentheses causes the statement that should be the loop body to be
executed only once:</p>
<div class="sourceCode" id="cb288"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span></code></pre></div>
<p>This example also prints the message</p>
<pre class="shell"><code>T minus 0 and counting</code></pre>
</li>
</ul>
<!-- END: unordered-list -->
</div>
<!-- END: div -->
<hr />
<h2 id="qa">Q&amp;A</h2>
<!-- START: div -->
<div class="QandA_question">
<p>Q: The following loop appears in Section 6.1</p>
<div class="sourceCode" id="cb290"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span></span></code></pre></div>
<p>Why not shorten the loop even more by removing the “&gt; 0” test?</p>
<div class="sourceCode" id="cb291"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i<span class="op">)</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;T minus %d and counting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span></span></code></pre></div>
<p>This version will stop when <code>i</code> reaches 0, so it should be
just as good as the original. [p. 101]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The new version is certainly more concise, and many C programmers
would write the loop in just this way. It does have drawbacks,
though.</p>
<p>First, the new loop is not as easy to read as the original. It’s
clear that the loop will terminate when <code>i</code> reaches 0, but
it’s not obvious whether we’re counting up or down. In the original
loop, that information can be deduced from the controlling expression,
<code>i &gt; 0</code>.</p>
<p>Second, the new loop behaves differently than the original if
<code>i</code> should happen to have a negative value when the loop
begins to execute. The original loop terminates immediately, but the new
loop doesn’t.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Section 6.3 says that, except in rare cases, <code>for</code>
loops can be converted to <code>while</code> loops using a standard
pattern. Can you give an example of such a case? [p. 106]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: When the body of a <code>for</code> loop contains a
<code>continue</code> statement, the <code>while</code> pattern shown in
Section 6.3 is no longer valid. Consider the following example from
Section 6.4:</p>
<div class="sourceCode" id="cb292"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a>sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a>    scanf <span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> i<span class="op">;</span></span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a>    n<span class="op">++;</span></span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>At first glance, it looks as though we could convert the
<code>while</code> loop into a for loop:</p>
<div class="sourceCode" id="cb293"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> n <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> n<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>    scanf <span class="op">(</span><span class="st">&quot;&amp;d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> i<span class="op">;</span></span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unfortunately, this loop isn’t equivalent to the original. When
<code>i</code> is equal to 0, the original loop doesn’t increment
<code>n</code>, but the new loop does.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Which form of infinite loop is preferable, <code>while(1)</code>
or <code>for(;;)</code>? [p. 108]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: C programmers have traditionally preferred <code>for(;;)</code>
for reasons of efficiency: older compilers would often force programs to
test the 1 condition cach time through the <code>while</code> loop. With
modern compilers, however, there should be no difference in
performance.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: I’ve heard that programmers should never use the
<code>continue</code> statement. Is this true?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: It’s true that <code>continue</code> statements are rare. Still,
<code>continue</code> is handy once in a while. Suppose we’re writing a
loop that reads some input data, checks that it’s valid, and, if so,
processes the input in some way. If there are a number of validity
tests, or if they’re complex, <code>continue</code> can be helpful. The
loop would look something like this:</p>
<div class="sourceCode" id="cb294"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a>    read data<span class="op">;</span></span>
<span id="cb294-3"><a href="#cb294-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>data fails first test<span class="op">)</span></span>
<span id="cb294-4"><a href="#cb294-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb294-5"><a href="#cb294-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>data fails second test<span class="op">)</span></span>
<span id="cb294-6"><a href="#cb294-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb294-7"><a href="#cb294-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span></span>
<span id="cb294-8"><a href="#cb294-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span></span>
<span id="cb294-9"><a href="#cb294-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span></span>
<span id="cb294-10"><a href="#cb294-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>data fails last test<span class="op">)</span></span>
<span id="cb294-11"><a href="#cb294-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb294-12"><a href="#cb294-12" aria-hidden="true" tabindex="-1"></a>    process data <span class="op">;</span></span>
<span id="cb294-13"><a href="#cb294-13" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: What’s so bad about the <code>goto</code> statement? [p. 114]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>The <code>goto</code> statement isn’t inherently evil; it’s just that
we usually have better alternatives. Programs that use more than a few
<code>goto</code> statements can quickly degenerate into “spaghetti
code.” with control blithely jumping from here to there. Spaghetti code
is hard to understand and hard to modify.</p>
<p><code>goto</code> statements make programs hard to read because they
can jump either forward or backward. (In contrast, <code>break</code>
and <code>continue</code> only jump forward.) A program that contains
<code>goto</code> statements often requires the reader to jump back and
forth in an attempt to follow the flow of control.</p>
<p><code>goto</code> statements can make programs hard to modify, since
they make it possible for a section of code to serve more than one
purpose. For example, a statement that is preceded by a label might be
reachable either by “falling through™ from the previous statement or by
executing one of several <code>goto</code> statements.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Does the null statement have any uses besides indicating that the
body of a loop is empty? [p. 116]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Very few. Since the null statement can appear wherever a statement
is allowed, there are many potential uses for the null statement. In
practice, however, there’s only one other use of the null statement, and
it’s rare.</p>
<p>Suppose that we need to put a label at the end of a compound
statement. A label can’t stand alone: it must always be followed by a
statement. Putting a null statement after the label solves the
problem:</p>
<div class="sourceCode" id="cb295"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">goto</span> end_of_stmt<span class="op">;</span></span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a>    end_of_stmt<span class="op">:</span> <span class="op">;</span></span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Are there any other ways to make an empty loop body stand out
besides putting the null statement on a line by itself? [p. 117]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Some programmers use a dummy <code>continue</code> statement:</p>
<div class="sourceCode" id="cb296"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>d <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> d <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> n <span class="op">%</span> d <span class="op">!=</span> <span class="dv">0</span><span class="op">;</span> d<span class="op">++)</span></span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">continue</span><span class="op">;</span></span></code></pre></div>
<p>Others use an empty compound statement:</p>
<div class="sourceCode" id="cb297"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>d <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> d <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> n <span class="op">%</span> d <span class="op">!=</span><span class="dv">0</span><span class="op">;</span> d<span class="op">++)</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a><span class="op">{}</span></span></code></pre></div>
</div>
<!-- END: div -->
<hr />
<h2 id="examples-4">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh06/cknkCh06Exmp/">./cknkCh06/cknkCh06Exmp/</a></li>
</ul>
<h2 id="exercises-4">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh06/cknkCh06Exrc/README.md">./cknkCh06/cknkCh06Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh06/cknkCh06Exrc/cknkCh06ExrcReadme.html">./cknkCh06/cknkCh06Exrc/cknkCh06ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh06/cknkCh06Exrc/">./cknkCh06/cknkCh06Exrc/</a></li>
</ul>
<h2 id="programming-projects-4">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh06/cknkCh06Prj/README.md">./cknkCh06/cknkCh06Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh06/cknkCh06Prj/cknkCh06PrjReadme.html">./cknkCh06/cknkCh06Prj/cknkCh06PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh06/cknkCh06Prj/">./cknkCh06/cknkCh06Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="basic-types">7 Basic Types</h1>
<!-- START: div -->
<div class="theQuote">
<p>Make no mistake about it: Computers process numbers—not symbols. We
measure our understanding (and control) by the extent to which we can
arithmetize an activity.</p>
</div>
<!-- END: div -->
<p>So far, we’ve used only two of C’s <strong><em>basic</em></strong>
(built-in) <strong><em>types</em></strong>: <code>int</code> and
<code>float</code>. (We’ve also seen <code>_Bool</code>, which is a
basic type in C99.) This chapter describes the rest of the basic types
and dist s important issues about types in general. Section 7.1 reveals
the full range of integer types. which include long integers, short
integers, and unsigned integers. Section 7.2 introduces the
<code>double</code> and <code>long double</code> types, which provide a
larger range of values and greater precision than <code>float</code>.
Section 7.3 covers the <code>char</code> type, which we’ll need in order
to work with character data. Section 7.4 tackles the thorny topic of
converting a value of one type to an equivalent value of another.
Section 7.5 shows how to use <code>typedef</code> to define new type
names. Finally, Section 7.6 describes the <code>sizeof</code> operator,
which measures the amount of storage required for a type.</p>
<h2 id="integer-types">7.1 Integer Types</h2>
<p>C supports two fundamentally different kinds of numeric types:
integer types and floating types. Values of an integer type are whole
numbers, while values of a floating type can have a fractional part as
well. The integer types, in turn, are divided into two categories:
<code>signed</code> and <code>unsigned</code>.</p>
<!-- START: div -->
<section id="signed-and-unsigned-integers" class="infoBox">
<h2>Signed and Unsigned Integers</h2>
<p>The leftmost bit of a <strong><em>signed</em></strong> integer (known
as the sign bit) is 0 if the number is positive or zero, 1 if it’s
negative. Thus, the largest 16-bit integer has the binary
representation</p>
<p>0111111111111111</p>
<p>which has the value 32,767 (2<sup>15</sup> — 1). The largest 32-bit
integer is</p>
<p>01111111111111111111111111111111</p>
<p>which has the value 2,147,483,647 (2<sup>31</sup> — 1). An integer
with no sign bit (the leftmost bit is considered part of the number’s
magnitude) is said to be <strong><em>unsigned</em></strong>. The largest
16-bit unsigned integer is 65,535 (2<sup>16</sup> - 1), and the largest
32-bit unsigned integer is 4,294,967,295 (2<sup>32</sup> - 1).</p>
<p>By default, integer variables are signed in C—the leftmost bit is
reserved for the sign. To tell the compiler that a variable has no sign
bit, we declare it to be unsigned. Unsigned numbers are primarily useful
for systems programming and low-level, machine-dependent applications.
We’ll discuss typical applications for unsigned numbers in Chapter 20;
until then, we’ll generally avoid them.</p>
</section>
<!-- END: div -->
<p>C’s integer types come in different sizes. The <code>int</code> type
is usually 32 bits, but may be 16 bits on older CPUs. Since some
programs require numbers that are too large to store in <code>int</code>
form, C also provides <code>long</code> integers. At times, we may need
to conserve memory by instructing the compiler to store a number in less
space than normal; such a number is called a
<strong><em>short</em></strong> integer.</p>
<p>To construct an integer type that exactly meets our needs, we can
specify that a variable is <code>long</code> or <code>short</code>,
<code>signed</code> or <code>unsigned</code>. We can even combine
specifiers (e.g., <code>long unsigned int</code>). However, only the
following six combinations actually produce different types:</p>
<div class="sourceCode" id="cb298"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> <span class="dt">int</span></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">short</span> <span class="dt">int</span></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb298-5"><a href="#cb298-5" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">int</span></span>
<span id="cb298-6"><a href="#cb298-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-7"><a href="#cb298-7" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">int</span></span>
<span id="cb298-8"><a href="#cb298-8" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span></span></code></pre></div>
<p>Other combinations are synonyms for one of these six types. (For
example, <code>long signed int</code> is the same as
<code>long int</code>, since integers are always signed unless otherwise
specified.) Incidentally, the order of the specifiers doesn’t matter;
<code>unsigned short int</code> is the same as
<code>short unsigned int</code>.</p>
<p>C allows us to abbreviate the names of integer types by dropping the
word <code>int</code>. For example, <code>unsigned short int</code> may
be abbreviated to <code>unsigned short</code>, and <code>long int</code>
may be abbreviated to just <code>long</code>. Omitting <code>int</code>
is a widespread practice among C programmers, and some newer C-based
languages (including Java) actually require the programmer to write
<code>short</code> or <code>long</code> rather than
<code>short int</code> or <code>long int</code>. For these reasons, I’ll
often omit the word <code>int</code> when it’s not strictly
necessary.</p>
<p>The range of values represented by each of the six integer types
varies from one machine to another. However, there are a couple of rules
that all compilers must obey. First, the C standard requires that
<code>short int</code>, <code>int</code>, and <code>long int</code> each
cover a certain minimum range of values (see Section 23.2 for details).
Second, the standard requires that <code>int</code> not be shorter than
<code>short int</code>, and <code>long int</code> not be shorter than
<code>int</code>. However, it’s possible that <code>short int</code>
represents the same range of values as <code>int</code>; also,
<code>int</code> may have the same range as <code>long int</code>.</p>
<p>Table 7.1 shows the usual range of values for the integer types on a
16-bit machine; note that <code>short int</code> and <code>int</code>
have identical ranges.</p>
<p><strong>Table 7.1</strong>: Integer Types on a 16-bit Machine</p>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th>Smallest Value</th>
<th>Largest Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>short int</code></td>
<td>32,768</td>
<td>32,767</td>
</tr>
<tr class="even">
<td><code>unsigned short int</code></td>
<td>0</td>
<td>65,535</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td>-32,768</td>
<td>32,767</td>
</tr>
<tr class="even">
<td><code>unsigned int</code></td>
<td>0</td>
<td>65,535</td>
</tr>
<tr class="odd">
<td><code>long int</code></td>
<td>-2,147,483,648</td>
<td>2,147 483,647</td>
</tr>
<tr class="even">
<td><code>unsigned long int</code></td>
<td>0</td>
<td>4.294.967.295</td>
</tr>
</tbody>
</table>
<p>Table 7.2 shows the usual ranges on a 32-bit machine; here
<code>int</code> and <code>long int</code> have identical ranges.</p>
<p><strong>Table 7.2</strong>: Integer Types on a 32-bit Machine</p>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th>Smallest Value</th>
<th>Largest Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>short int</code></td>
<td>32,768</td>
<td>32,767</td>
</tr>
<tr class="even">
<td><code>unsigned short int</code></td>
<td>0</td>
<td>65,535</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr class="even">
<td><code>unsigned int</code></td>
<td>0</td>
<td>4,294.967,295</td>
</tr>
<tr class="odd">
<td><code>long int</code></td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr class="even">
<td><code>unsigned long int</code></td>
<td>0</td>
<td>4,294,967,295</td>
</tr>
</tbody>
</table>
<p>In recent years, 64-bit CPUs have become more common. Table 7.3 shows
typical ranges for the integer types on a 64-bit machine (especially
under UNIX).</p>
<p><strong>Table 7.3</strong>: Integer Types on a 64-bit Machine</p>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th>Smallest Value</th>
<th>Largest Value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>short int</code></td>
<td>32,768</td>
<td>32,767</td>
</tr>
<tr class="even">
<td><code>unsigned short int</code></td>
<td>0</td>
<td>65,535</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td>-2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr class="even">
<td><code>unsigned int</code></td>
<td>0</td>
<td>4,294,967,295</td>
</tr>
<tr class="odd">
<td><code>long int</code></td>
<td>-9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr class="even">
<td><code>unsigned long int</code></td>
<td>0</td>
<td>18,446,744,073,709,551,615</td>
</tr>
</tbody>
</table>
<p>Once more, let me emphasize that the ranges shown in Tables 7.1, 7.2,
and 7.3 aren’t mandated by the C standard and may vary from one compiler
to another. One way to determine the ranges of the integer types for a
particular implementation is to check the <code>&lt;1imits.h&gt;</code>
header, which is part of the standard library. This header defines
macros that represent the smallest and largest values of each integer
type.</p>
<p><span class="C99Symbol"></span></p>
<h3 id="integer-types-in-c99">7.1.1 Integer Types in C99</h3>
<p>C99 provides two additional standard integer types,
<code>long long int</code> and <code>unsigned long long int</code>.
These types were added because of the growing need for very large
integers and the ability of newer processors to support 64-bit
arithmetic. Both <code>long long</code> types are required to be at
least 64 bits wide, so the range of <code>long long int</code> values is
typically -2<sup>63</sup> (-9,223,372,036,854,775,808) to 2<sup>63</sup>
- 1 (9,223,372,036,854,775,807), and range of
<code>unsigned long long int</code> values is usually 0 to
2<sup>64</sup> — 1 (18,446,744,073,709,551,615).</p>
<p>The <code>short int</code>, <code>int</code>, <code>long int</code>,
and <code>long long int</code> types (along with the
<code>signed char</code> type) are called <strong><em>standard signed
integer types</em></strong> in C99. The <code>unsigned short int</code>,
<code>unsigned int</code>, <code>unsigned long int</code>, and
<code>unsigned long long int</code> types (along with the
<code>unsigned char</code> type and the <code>_Bool</code> type) are
called <strong><em>standard unsigned integer types</em></strong>.</p>
<p>In addition to the standard integer types, the C99 standard allows
implementation-defined <strong><em>extended integer types</em></strong>,
both signed and unsigned. For example, a compiler might provide signed
and unsigned 128-bit integer types.</p>
<h3 id="integer-constants">7.1.2 Integer Constants</h3>
<p>Let’s turn our attention to
<strong><em>constants</em></strong>—numbers that appear in the text of a
program, not numbers that are read, written, or computed. C allows
integer constants to be written in decimal (base 10), octal (base 8), or
hexadecimal (base 16).</p>
<!-- START: div -->
<section id="octal-and-hexadecimal-numbers" class="infoBox">
<h2>Octal and Hexadecimal Numbers</h2>
<p>An octal number is written using only the digits 0 through 7. Each
position in an octal number represents a power of 8 (just as each
position in a decimal number represents a power of 10). Thus, the octal
number 237 represents the decimal number <span
class="displayInlineMath"><span
class="math display">2 × 8<sup>2</sup> + 3 × 8<sup>1</sup> + 7 × 8<sup>0</sup> = 128 + 24 + 7 = 159</span></span>.</p>
<p>A hexadecimal (or hex) number is written using the digits 0 through 9
plus the letters A through F, which stand for 10 through 15,
respectively. Each pasition in a hex number represents a power of 16;
the hex number <code>1AF</code> has the decimal value <span
class="displayInlineMath"><span
class="math display">1 × 16<sup>2</sup> + 10 × 16<sup>1</sup> + 15 × 16<sup>0</sup> = 256 + 160 + 15 = 431</span></span>.</p>
</section>
<!-- END: div -->
<!-- START: unordered-list -->
<ul>
<li>
<p><strong><em>Decimal</em></strong> constants contain digits between 0
and 9, but must not begin with a Zero:</p>
<div class="sourceCode" id="cb299"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span> <span class="dv">255</span> <span class="dv">32767</span></span></code></pre></div>
</li>
<li>
<p><strong><em>Octal</em></strong> constants contain only digits between
0 and 7, and <em>must</em> begin with a zero:</p>
<div class="sourceCode" id="cb300"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a><span class="bn">017</span> <span class="bn">0377</span> <span class="bn">077777</span></span></code></pre></div>
</li>
<li>
<p><strong>Hexadecimal</strong> constants contain digits between 0 and 9
and letters between <code>a</code> and <code>f</code>, and always begin
with <code>0x</code>:</p>
<div class="sourceCode" id="cb301"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="bn">0xf</span> Oxff Ox7fff</span></code></pre></div>
<p>The letters in a hexadecimal constant may be either upper or lower
case:</p>
<div class="sourceCode" id="cb302"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a>Oxff OxfF OxFf OxFF OXff OXEF OXFf OXFF</span></code></pre></div>
</li>
</ul>
<!-- END: unordered-list -->
<p>Keep in mind that octal and hexadecimal are nothing more than an
alternative way of writing numbers; they have no effect on how the
numbers are actually stored. (Integers are always stored in binary,
regardless of what notation we’ve used to express them.) We can switch
from one notation to another at any time, and even mix them:
<code>10 + 015 + 0x20</code> has the value 55 (decimal). Octal and hex
are most convenient for writing low-level programs; we won’t use these
notations much until Chapter 20.</p>
<p>The type of a decimal integer constant is normally <code>int</code>.
However, if the value of the constant is too large to store as an
<code>int</code>, the constant has type <code>long int</code> instead.
In the unlikely case that the constant is too large to store as a
<code>long int</code>, the compiler will try
<code>unsigned long int</code> as a last resort. The rules for
determining the type of an <em>octal</em> or <em>hexadecimal</em>
constant are slightly different: the compiler will go through the types
<code>int</code>, <code>unsigned int</code>, <code>long int</code>, and
<code>unsigned long int</code> until it finds one capable of
representing the constant.</p>
<p>To force the compiler to treat a constant as a long integer, just
follow it with the letter <code>L</code> (or <code>l</code>):</p>
<div class="sourceCode" id="cb303"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span><span class="bu">L</span> <span class="bn">0377</span><span class="bu">L</span> Ox7fffL</span></code></pre></div>
<p>To indicate that a constant is unsigned, put the letter
<code>U</code> (or <code>u</code>) after it:</p>
<div class="sourceCode" id="cb304"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span><span class="bu">U</span> <span class="bn">03770</span> Ox7fffU</span></code></pre></div>
<p><code>L</code> and <code>U</code> may be used in combination to show
that a constant is both long <em>and</em> unsigned:
<code>OxffffffffUL</code>. (The order of the <code>L</code> and
<code>U</code> doesn’t matter, nor does their case.)</p>
<p><span class="C99Symbol"></span></p>
<h3 id="integer-constants-in-c99">Integer Constants in C99</h3>
<p>In C99, integer constants that end with either <code>LL</code> or
<code>ll</code> (the case of the two letters must match) have type
<code>long long int</code>. Adding the letter <code>U</code> (or
<code>u</code>) before or after the <code>LL</code> or <code>ll</code>
denotes a constant of type <code>unsigned long long int</code>.</p>
<p>C99’s general rules for determining the type of an integer constant
are a bit different from those in C89, The type of a decimal constant
with no suffix (<code>U</code>, <code>u</code>, <code>L</code>,
<code>l</code>, <code>LL</code>, or <code>ll</code>) is the “smallest”
of the types <code>int</code>, <code>long int</code>, or
<code>long long int</code> that can represent the value of that
constant. For an octal or hexadecimal constant, however, the list of
possible types is <code>int</code>, <code>unsigned int</code>,
<code>long int</code>, <code>unsigned long int</code>,
<code>long long int</code>, and <code>unsigned long long int</code>, in
that order. Any suffix at the end of a constant changes the list of
possible types. For example, a constant that ends with <code>U</code>
(or <code>u</code>) must have one of the types
<code>unsigned int</code>, <code>unsigned long int</code>, or
<code>unsigned long long int</code>. A decimal constant that ends with
<code>L</code> (or <code>l</code>) must have one of the types
<code>long int</code> or <code>long long int</code>. There’s also a
provision for a constant to have an extended integer type if it’s too
large to represent using one of the standard integer types.</p>
<h3 id="integer-overflow">7.1.4 Integer Overflow</h3>
<p>When arithmetic operations are performed on integers, it’s possible
that the result will be too large to represent. For example, when an
arithmetic operation is performed on two <code>int</code> values, the
result must be able to be represented as an <code>int</code>. If the
result can’t be represented as an <code>int</code> (because it requires
too many bits), we say that <strong><em>overflow</em></strong> has
occurred.</p>
<p>The behavior when integer overflow occurs depends on whether the
operands were <em>signed</em> or <em>unsigned</em>. When overflow occurs
during an operation on signed integers, the program’s behavior is
undefined. Recall from Section 4.4 that the consequences of undefined
behavior may vary. Most likely the result of the operation will simply
be wrong, but the program could crash or exhibit other undesirable
behavior.</p>
<p>When overflow occurs during an operation on unsigned integers,
though, the result is defined: we get the correct answer modulo
2<sup>n</sup>, where <code>n</code> is the number of bits used to store
the result. For example, if we add 1 to the unsigned 16-bit number
65,533, the result is guaranteed to be 0.</p>
<h3 id="reading-and-writing-integers">7.1.5 Reading and Writing
Integers</h3>
<p>Suppose that a program isn’t working because one of its
<code>int</code> variables is overflowing. Our first thought is to
change the type of the variable from <code>int</code> to
<code>long int</code>. But we’re not done yet; we need to see how the
change will affect the rest of the program. In particular, we must check
whether the variable is used in a call of <code>printf</code> or
<code>scanf</code>. If so, the format string in the call will need to be
changed, since the %d conversion works only for the <code>int</code>
type.</p>
<p>Reading and writing unsigned, short, and long integers requires
several new conversion specifiers:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p><span class="QandA"></span></p>
<p>When reading or writing an <em>unsigned</em> integer, use the letter
<code>u</code>, <code>o</code>, or <code>x</code> instead of
<code>d</code> in the conversion specification. If the <code>u</code>
specifier is present, the number is read (or written) in decimal
notation; <code>o</code> indicates octal notation, and <code>x</code>
indicates hexadecimal notation.</p>
<div class="sourceCode" id="cb305"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">int</span> u<span class="op">;</span></span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%u&quot;</span><span class="op">,</span> <span class="op">&amp;</span>u<span class="op">);</span> <span class="co">/* reads u in base 10 */</span></span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;%u&quot;</span><span class="op">,</span> u<span class="op">);</span> <span class="co">/* writes u in base 10 */</span></span>
<span id="cb305-5"><a href="#cb305-5" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%o&quot;</span><span class="op">,</span> <span class="op">&amp;</span>u<span class="op">);</span> <span class="co">/* reads u in base 8 */</span></span>
<span id="cb305-6"><a href="#cb305-6" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;%o&quot;</span><span class="op">,</span> u<span class="op">);</span> <span class="co">/* writes u in base 8 */</span></span>
<span id="cb305-7"><a href="#cb305-7" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%x&quot;</span><span class="op">,</span> <span class="op">&amp;</span>u<span class="op">);</span> <span class="co">/* reads u in base 16 */</span></span>
<span id="cb305-8"><a href="#cb305-8" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%x&quot;</span><span class="op">,</span> u<span class="op">);</span> <span class="co">/* writes u in base 16 */</span></span></code></pre></div>
</li>
<li>
<p>When reading or writing a <em>short</em> integer. put the letter
<code>h</code> in front of <code>d</code>, <code>o</code>,
<code>u</code>, or <code>x</code></p>
<div class="sourceCode" id="cb306"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> s<span class="op">;</span></span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%hd&quot;</span><span class="op">,</span> <span class="op">&amp;</span>s<span class="op">);</span></span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;%hd&quot;</span><span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
</li>
<li>
<p>When reading or writing a <em>long</em> integer, put the letter
<code>l</code> (“ell,” not “one”) in front of <code>d</code>,
<code>o</code>, <code>u</code>, or <code>x</code>:</p>
<div class="sourceCode" id="cb307"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> l<span class="op">;</span></span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%ld&quot;</span><span class="op">,</span> <span class="op">&amp;</span>l<span class="op">);</span></span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%ld&quot;</span><span class="op">,</span> l<span class="op">);</span></span></code></pre></div>
</li>
<li>
<p><span class="C99Symbol"></span></p>
<p>When reading or writing a <em>long long</em> integer (C99 only), put
the letters <code>ll</code> in front of <code>d</code>, <code>o</code>,
<code>u</code>, or <code>x</code>:</p>
<div class="sourceCode" id="cb308"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> ll<span class="op">;</span></span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%lld&quot;</span><span class="op">,</span> <span class="op">&amp;</span>ll<span class="op">);</span></span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;%lld&quot;</span><span class="op">,</span> ll<span class="op">);</span></span></code></pre></div>
</li>
</ul>
<!-- END: unordered-list -->
<h3 id="program-summing-a-series-of-numbers-revisited">7.1.6 (PROGRAM)
Summing a Series of Numbers (Revisited)</h3>
<p>In Section 6.1, we wrote a program that sums a series of integers
entered by the user. One problem with this program is that the sum (or
one of the input numbers) might exceed the largest value allowed for an
<code>int</code> variable. Here’s what might happen if the program is
run on a machine whose integers are 16 bits long:</p>
<pre class="shell"><code>This program sums a series of integers.
Enter integers (0 to terminate): 10000 20000 30000 0
The sum is: -5536</code></pre>
<p>The sum was 60,000, which wouldn’t fit in an <code>int</code>
variable, so overflow occurred. When overflow occurs with signed
numbers, the outcome is undefined. In this case, we got an apparently
meaningless number. To improve the program, let’s switch to
<code>Long</code> variables.</p>
<div class="sourceCode" id="cb310"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: sum2.c</span></span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Sums a series of numbers (using long variables)</span></span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb310-11"><a href="#cb310-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> n<span class="op">,</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb310-12"><a href="#cb310-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-13"><a href="#cb310-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;This program sums a series of integers.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb310-14"><a href="#cb310-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter integers (0 to terminate): &quot;</span><span class="op">);</span></span>
<span id="cb310-15"><a href="#cb310-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-16"><a href="#cb310-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%ld&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb310-17"><a href="#cb310-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>n <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb310-18"><a href="#cb310-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb310-19"><a href="#cb310-19" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> n<span class="op">;</span></span>
<span id="cb310-20"><a href="#cb310-20" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&quot;%ld&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb310-21"><a href="#cb310-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb310-22"><a href="#cb310-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;The sum is: %ld</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> sum<span class="op">);</span></span>
<span id="cb310-23"><a href="#cb310-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-24"><a href="#cb310-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb310-25"><a href="#cb310-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The change was fairly simple: we declared <code>n</code> and
<code>sum</code> to be <code>long</code> variables instead of
<code>int</code> variables, then we changed the conversion
specifications in <code>scanf</code> and <code>printf</code> to
<code>%l1d</code> instead of <code>%d</code>.</p>
<h2 id="floating-types">7.2 Floating Types</h2>
<p>The integer types aren’t suitable for all applications. Sometimes
we’ll need variables that can store numbers with digits after the
decimal point, or numbers that are exceedingly large or small. Numbers
like these are stored in floating-point format (so called because the
decimal point “floats”). C provides three floating types, corresponding
to different floating-point formats:</p>
<ul>
<li><code>float</code> Single-precision floating-point<br />
</li>
<li><code>double</code> Double-precision floating-point<br />
</li>
<li><code>long double</code> Extended-precision floating-point</li>
</ul>
<p><code>float</code> is suitable when the amount of precision isn’t
critical (calculating temperatures to one decimal point, for example).
<code>double</code> provides greater precision enough for most programs.
<code>long double</code>, which supplies the ultimate in precision, is
rarely used.</p>
<p>The C standard doesn’t state how much precision the
<code>float</code>, <code>double</code>, and <code>long double</code>
types provide, since different computers may store floating-point
numbers in different ways. Most modern computers follow the
specifications in IEEE Standard 754 (also known as IEC 60559), so we’ll
use it as an example.</p>
<!-- START: div -->
<section id="the-ieee-floating-point-standard" class="infoBox">
<h2>The IEEE Floating-Point Standard</h2>
<p>IEEE Standard 754, developed by the Institute of Electrical and
Electronics Engineers, provides two primary formats for floating-point
numbers: single precision (32 bits) and double precision (64 bits).
Numbers are stored in a form of scientific notation, with each number
having three parts: a <strong><em>sign</em></strong>, an
<strong><em>exponent</em></strong>, and a
<strong><em>fraction</em></strong>. The number of bits reserved for the
exponent determines how large (or small) numbers can be, while the
number of bits in the fraction determines the precision. In
single-precision format, the exponent is 8 bits long, while the fraction
occupies 23 bits. As a result, a single-precision number has a maximum
value of approximately 3.40 x 10<sup>38</sup>, with a precision of about
6 decimal digits.</p>
<p>The IEEE standard also describes two other formats, single extended
precision and double extended precision. The standard doesn’t specify
the number of bits in these formats, although it requires that the
single extended type occupy at least 43 bits and the double extended
type at least 79 bits. For more information about the IEEE standard and
floating-point arithmetic in general, see “What every computer scientist
should know about floating-point arithmetic” by David Goldberg (<em>ACM
Computing Surveys</em>, vol. 23, no. 1 (March 1991): 5-48).</p>
</section>
<!-- END: div -->
<p>Table 7.4 shows the characteristics of the floating types when
implemented according to the IEEE standard. (The table shows the
smallest positive <em>normalized</em> values. Subnormal numbers can be
smaller.) The <code>long double</code> type isn’t shown in the table,
since its length varies from one machine to another, with 80 bits and
128 bits being the most common sizes.</p>
<p><strong>Table 7.4</strong>: Floating Type Characteristics (IEEE
Standard)</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Smallest Positive Value</th>
<th>Largest Value</th>
<th>Precision</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>float</td>
<td>1.17549 x 10<sup>-38</sup></td>
<td>3.40282 x 10<sup>38</sup></td>
<td>6 digits</td>
</tr>
<tr class="even">
<td>double</td>
<td>2.22507 x 10<sup>-308</sup></td>
<td>1.79769 x 10<sup>308</sup></td>
<td>15 digits</td>
</tr>
</tbody>
</table>
<p>On computers that don’t follow the IEEE standard, Table 7.4 won’t be
valid. In fact, on some machines, <code>float</code> may have the same
set of values as <code>double</code>, or <code>double</code> may have
the same values as <code>long double</code>. Macros that define the
characteristics of the floating types can be found in the
<code>&lt;float.h&gt;</code> header.</p>
<p>In C99, the floating types are divided into two categories. The
<code>float</code>, <code>double</code>, and <code>long double</code>
types fall into one category, called the <strong><em>real floating
types</em></strong>. Floating types also include the complex types
(<code>float _Complex</code>, <code>double _Complex</code>, and
<code>long double _Complex</code>), which are new in C99.</p>
<h3 id="floating-constants">7.2.1 Floating Constants</h3>
<p>Floating constants can be written in a variety of ways. The following
constants, for example, are all valid ways of writing the number
57.0:</p>
<div class="sourceCode" id="cb311"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a><span class="fl">57.0</span> <span class="fl">57.</span> <span class="fl">57.0e0</span> <span class="fl">57E0</span> <span class="fl">5.7e1</span> <span class="fl">5.7e+1</span> <span class="fl">.57e2</span> <span class="fl">570.e-1</span></span></code></pre></div>
<p>A floating constant must contain a decimal point and/or an exponent;
the exponent indicates the power of 10 by which the number is to be
scaled. If an exponent is present, it must be preceded by the letter
<code>E</code> (or <code>e</code>). An optional <code>+</code> or
<code>-</code> sign may appear after the <code>E</code> (or
<code>e</code>).</p>
<p>By default, floating constants are stored as double-precision
numbers. In other words, when a C compiler finds the constant 57.0 in a
program, it arranges for the number to be stored in memory in the same
format as a <code>double</code> variable. This rule generally causes no
problems, since <code>double</code> values are converted automatically
to <code>float</code> when necessary.</p>
<p>On occasion, it may be necessary to force the compiler to store a
floating constant in <code>float</code> or <code>long double</code>
format. To indicate that only single precision is desired, put the
letter <code>F</code> (or <code>f</code>) at the end of the constant
(for example, <code>57.0F</code>). To indicate that a constant should be
stored in <code>long double</code> format, put the letter <code>L</code>
(or <code>l</code>) at the end (<code>57.OL</code>).</p>
<p><span class="C99Symbol"></span> <span class="QandA"></span></p>
<p>C99 has a provision for writing floating constants in hexadecimal.
Such a constant begins with <code>0x</code> or <code>0X</code> (like a
hexadecimal integer constant). This feature is rarely used.</p>
<h3 id="reading-and-writing-floating-point-numbers">7.2.2 Reading and
Writing Floating-Point Numbers</h3>
<p>As we’ve discussed, the conversion specifications <code>%e</code>,
<code>%f</code>, and <code>%g</code> are used for reading and writing
single-precision floating-point numbers. Values of types
<code>double</code> and <code>long double</code> require slightly
different conversions:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>When <em>reading</em> a value of type <code>double</code>, put the
letter <code>l</code> in front of <code>e</code>, <code>f</code>, or
<code>g</code>:</p>
<div class="sourceCode" id="cb312"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> d<span class="op">;</span></span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%lf&quot;</span><span class="op">,</span> <span class="op">&amp;</span>d<span class="op">);</span></span></code></pre></div>
<p><span class="QandA"></span> <span class="C99Symbol"></span></p>
<p><em>Note</em>: Use <code>l</code> only in a <code>scanf</code> format
string, not a <code>printf</code> string. In a <code>printf</code>
format string, the <code>e</code>, <code>f</code>, and <code>g</code>
conversions can be used to write either <code>float</code> or
<code>double</code> values. (C99 legalizes the use of <code>%le</code>,
<code>%lf</code>, and <code>%lg</code> in calls of <code>printf</code>,
although the <code>l</code> has no effect.)</p>
</li>
<li>
<p>When reading or writing a value of type <code>long double</code>, put
the letter <code>L</code> in front of <code>e</code>, <code>£</code>, or
<code>g</code>:</p>
<div class="sourceCode" id="cb313"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">double</span> ld<span class="op">;</span></span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%Lf&quot;</span><span class="op">,</span> <span class="op">&amp;</span>ld<span class="op">);</span></span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;%Lf&quot;</span><span class="op">,</span> ld<span class="op">);</span></span></code></pre></div>
</li>
</ul>
<!-- END: unordered-list -->
<h2 id="character-types">7.3 Character Types</h2>
<p><span class="QandA"></span></p>
<p>The only remaining basic type is <code>char</code>, the character
type. The values of type <code>char</code> can vary from one computer to
another, because different machines may have different underlying
character sets.</p>
<!-- START: div -->
<section id="character-sets" class="infoBox">
<h2>Character Sets</h2>
<p>Today’s most popular character set is ASCII (American Standard Code
for Information Interchange), a 7-bit code capable of representing 128
characters. In ASCII, the digits 0 to 9 are represented by the codes
0110000-0111001, and the uppercase letters A to Z are represented by
1000001-1011010. ASCII is often extended to a 256-character code known
as <strong>Latin-1</strong> that provides the characters necessary for
Western European and many African languages.</p>
</section>
<!-- END: div -->
<p>A variable of type <code>char</code> can be assigned any single
character:</p>
<div class="sourceCode" id="cb314"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> ch<span class="op">;</span></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> <span class="ch">&#39;a&#39;</span><span class="op">;</span> <span class="co">/* lower-case a */</span></span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span> <span class="co">/* upper-case A */</span></span>
<span id="cb314-4"><a href="#cb314-4" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> <span class="ch">&#39;0&#39;</span><span class="op">;</span> <span class="co">/* zero */</span></span>
<span id="cb314-5"><a href="#cb314-5" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> <span class="ch">&#39; &#39;</span><span class="op">;</span> <span class="co">/* space */</span></span></code></pre></div>
<p>Notice that character constants are enclosed in single quotes, not
double quotes.</p>
<h3 id="operations-on-characters">7.3.1 Operations on Characters</h3>
<p>Working with characters in C is simple, because of one fact: <em>C
treats characters as small integers</em>. After all, characters are
encoded in binary, and it doesn’t take much imagination to view these
binary codes as integers. In ASCII, for example, character codes range
from 0000000 to 1111111, which we can think of as the integers from 0 to
127. The character <code>'a'</code> has the value 97. <code>'A'</code>
has the value 65. <code>'0'</code> has the value 48, and
<code>' '</code> has the value 32. The connection between characters and
integers in C is so strong that character constants actually have
<code>int</code> type rather than <code>char</code> type (an interesting
fact, but not one that will often matter to us).</p>
<p>When a character appears in a computation, C simply uses its integer
value. Consider the following examples, which assume the ASCII character
set:</p>
<div class="sourceCode" id="cb315"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> ch<span class="op">;</span></span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a>i<span class="op">=</span><span class="ch">&#39;a&#39;</span><span class="op">;</span> <span class="co">/* i is now 97 */</span></span>
<span id="cb315-5"><a href="#cb315-5" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> <span class="dv">65</span><span class="op">;</span> <span class="co">/* ch is mow &#39;A&#39; */</span></span>
<span id="cb315-6"><a href="#cb315-6" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> ch <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">/* ch is now &#39;B&#39; */</span></span>
<span id="cb315-7"><a href="#cb315-7" aria-hidden="true" tabindex="-1"></a>ch<span class="op">++;</span> <span class="co">/* ch is now &#39;c&#39; */</span></span></code></pre></div>
<p>Characters can be compared, just as numbers can. The following
<code>if</code> statement checks whether <code>ch</code> contains a
lower-case letter; if so, it converts <code>ch</code> to upper case.</p>
<div class="sourceCode" id="cb316"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span><span class="ch">&#39;a&#39;</span> <span class="op">&lt;=</span> ch <span class="op">&amp;&amp;</span> ch <span class="op">&lt;=</span> <span class="ch">&#39;z&#39;</span><span class="op">)</span></span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a>    ch <span class="op">=</span> ch <span class="op">-</span> <span class="ch">&#39;a&#39;</span> <span class="op">+</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span></span></code></pre></div>
<p>Comparisons such as <code>'a' &lt;= ch</code> are done using the
integer values of the characters involved. These values depend on the
character set in use, so programs that use <code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> to compare
characters may not be portable.</p>
<p>The fact that characters have the same properties as numbers has some
advantages. For example, we can easily write a <code>for</code>
statement whose control variable steps through all the upper-case
letters:</p>
<div class="sourceCode" id="cb317"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>ch <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span> ch <span class="op">&lt;=</span> <span class="ch">&#39;Z&#39;</span><span class="op">;</span> ch<span class="op">++)</span> <span class="op">...</span></span></code></pre></div>
<p>On the other hand, treating characters as numbers can lead to various
programming errors that won’t be caught by the compiler, and lets us
write meaningless expressions such as ‘a’ * ‘b’ / ‘c’. It can also
hamper portability, since our programs may be based on assumptions about
the underlying character set. (Our <code>for</code> loop, for example,
assumes that the letters from A to Z have consecutive codes.)</p>
<h3 id="signed-and-unsigned-characters">7.3.2 Signed and Unsigned
Characters</h3>
<p>Since C allows characters to be used as integers, it shouldn’t be
surprising that the <code>char</code> type—like the integer types—exists
in both <code>signed</code> and <code>unsigned</code> versions. Signed
characters normally have values between —128 and 127, while unsigned
characters have values between 0 and 255.</p>
<p>The C standard doesn’t specify whether ordinary <code>char</code> is
a signed or an unsigned type: some compilers treat it as a signed type.
while others treat it as an unsigned type. (Some even allow the
programmer to select, via a compiler option, whether <code>char</code>
should be signed or unsigned.)</p>
<p><span class="QandA"></span></p>
<p>Most of the time, we don’t really care whether <code>char</code> is
signed or unsigned. Once in a while, though, we do, especially if we’re
using a character variable to store a small integer. For this reason, C
allows the use of the words <code>signed</code> and
<code>unsigned</code> to modify <code>char</code>:</p>
<div class="sourceCode" id="cb318"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a><span class="dt">signed</span> <span class="dt">char</span> sch<span class="op">;</span></span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> uch<span class="op">;</span></span></code></pre></div>
<p><em>Don’t assume that <code>char</code> is either signed or unsigned
by defauli. If it marters, use <code>signed char</code> or
<code>unsigned char</code> instead of <code>char</code>.</em></p>
<p>In light of the close relationship between characters and integers,
C89 uses the term integral types to refer to both the integer types and
the character types. Enumerated types are also integral types.</p>
<p><span class="C99Symbol"></span></p>
<p>C99 doesn’t use the term “integral types.” Instead, it expands the
meaning of “integer types” to include the character types and the
enumerated types. C99’s <code>_Bool</code> type is considered to be an
unsigned integer type.</p>
<h3 id="arithmetic-types">7.3.3 Arithmetic Types</h3>
<p>The integer types and floating types are collectively known as
<strong><em>arithmetic types</em></strong>. Here’s a summary of the
arithmetic types in C89, divided into categories and subcategories:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>Integral types</p>
<ul>
<li><code>char</code><br />
</li>
<li>Signed integer types (<code>signed char</code>,
<code>short int</code>, <code>int</code>, <code>long int</code>)<br />
</li>
<li>Unsigned integer types (<code>unsigned char</code>,
<code>unsigned short int</code>, <code>unsigned int</code>,
<code>unsigned long int</code>)<br />
</li>
<li>Enumerated types</li>
</ul>
</li>
<li>
<p>Floating types (<code>float</code>, <code>double</code>,
<code>long double</code>)</p>
</li>
</ul>
<!-- END: unordered-list -->
<p><span class="C99Symbol"></span></p>
<p>C99 has a more complicated hierarchy for its arithmetic types:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>Integer types</p>
<ul>
<li><code>char</code><br />
</li>
<li>Signed integer types, both standard (<code>signed char</code>,
<code>short int</code>, <code>int</code>, <code>long int</code>,
<code>long long int</code>) and extended<br />
</li>
<li>Unsigned integer types, both standard (<code>unsigned char</code>,
<code>unsigned short int</code>, <code>unsigned int</code>,
<code>unsigned long int</code>, <code>unsigned long long int</code>,
<code>_Bool</code>) and extended<br />
</li>
<li>Enumerated types</li>
</ul>
</li>
<li>
<p>Floating types</p>
<ul>
<li>Real floating types (<code>float</code>, <code>double</code>,
<code>long double</code>)<br />
</li>
<li>Complex types (<code>float _Complex</code>,
<code>double _Complex</code>, <code>long double _Complex</code>)</li>
</ul>
</li>
</ul>
<!-- END: unordered-list -->
<h3 id="escape-sequences-1">7.3.4 Escape Sequences</h3>
<p>A character constant is usually one character enclosed in single
quotes, as we’ve seen in previous examples. However, certain special
characters—including the new-line character—can’t be written in this
way, because they’re invisible (non-printing) or because they can’t be
entered from the keyboard. So that programs can deal with every
character in the underlying character set, C provides a special
notation, the escape sequence.</p>
<p>There are two kinds of escape sequences: <strong><em>character
escapes</em></strong> and <strong><em>numeric escapes</em></strong>. We
saw a partial list of character escapes in Section 3.1; Table 7.5 gives
the complete set.</p>
<p><strong>Table 7.5</strong>: Character Escapes</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Escape Sequence</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alert (bell)</td>
<td><code>\a</code></td>
</tr>
<tr class="even">
<td>Backspace</td>
<td><code>\b</code></td>
</tr>
<tr class="odd">
<td>Form feed</td>
<td><code>\f</code></td>
</tr>
<tr class="even">
<td>New line</td>
<td><code>\n</code></td>
</tr>
<tr class="odd">
<td>Carriage return</td>
<td><code>\r</code></td>
</tr>
<tr class="even">
<td>Horizontal tab</td>
<td><code>\t</code></td>
</tr>
<tr class="odd">
<td>Vertical tab</td>
<td><code>\v</code></td>
</tr>
<tr class="even">
<td>Backslash</td>
<td><code>\\</code></td>
</tr>
<tr class="odd">
<td>Question mark</td>
<td><code>\?</code></td>
</tr>
<tr class="even">
<td>Single quote</td>
<td><code>\'</code></td>
</tr>
<tr class="odd">
<td>Double quote</td>
<td><code>\"</code></td>
</tr>
</tbody>
</table>
<p><span class="QandA"></span></p>
<p>The <code>\a</code>, <code>\b</code>, <code>\f</code>,
<code>\r</code>, <code>\t</code>, and <code>\v</code> escapes represent
common ASCII control characters. The <code>\n</code> escape represents
the ASCII line-feed character. The <code>\\</code> escape allows a
character constant or string to contain the <code>\</code> character.
The <code>\'</code> escape allows a character constant to contain the
<code>'</code> character, while the <code>\"</code> escape allows a
string to contain the <code>"</code> character. The <code>\?</code>
escape is rarely used.</p>
<p>Character escapes are handy, but they have a problem: the list of
character escapes doesn’t include all the nonprinting ASCII characters,
just the most common. Character escapes are also useless for
representing characters beyond the basic 128 ASCII characters. Numeric
escapes, which can represent any character, are the solution to this
problem.</p>
<p>To write a numeric escape for a particular character, first look up
the character’s octal or hexadecimal value in a table like the one in
Appendix E. For example, the ASCII escape character (decimal value: 27)
has the value 33 in octal and 1B in hex. Either of these codes can be
used to write an escape sequence:</p>
<ul>
<li>An <strong><em>octal escape sequence</em></strong> consists of the
<code>\</code> character followed by an octal number with at most three
digits. (This number must be representable as an unsigned character, so
its maximum value is normally 377 octal.) For example, the escape
character could be written <code>\33</code> or <code>\033</code>, Octal
numbers in escape sequences—unlike octal constants—don’t have to begin
with 0.<br />
</li>
<li>A hexadecimal escape sequence consists of <code>\x</code> followed
by a hexadecimal number. Although C places no limit on the number of
digits in the hexadecimal number, it must be representable as an
unsigned character (hence it can’t exceed FF if characters are eight
bits long). Using this notation, the escape character would be written
<code>\x1b</code> or <code>\x1B</code>. The <code>x</code> must be in
lower case, but the hex digits (such as <code>b</code>) can be upper or
lower case.</li>
</ul>
<p>When used as a character constant, an escape sequence must be
enclosed in single quotes. For example, a constant representing the
escape character would be written <code>'\33'</code> (or
<code>'\x1b'</code>). Escape sequences tend to get a bit cryptic, so
it’s often a good idea to give them names using
<code>#define</code>:</p>
<div class="sourceCode" id="cb319"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ESC &#39;\33&#39; /* ASCII escape character */</span></span></code></pre></div>
<p>Escape sequences can be embedded in strings as well, as we saw in
Section 3.1.</p>
<p><span class="C99Symbol"></span></p>
<p>Escape sequences aren’t the only special notations for representing
characters. Trigraph sequences provide a way to represent the characters
<code>#</code>, <code>[</code>, <code>\</code>, <code>]</code>,
<code>^</code>, <code>{</code>, <code>|</code>. <code>}</code>, and
<code>~</code>, which may not be available on keyboards in some
countries. C99 adds universal character names, which resemble escape
sequences. Unlike escape sequences, however, universal character names
are allowed in identifiers.</p>
<h3 id="character-handling-functions">7.3.5 Character-Handling
Functions</h3>
<p>Earlier in this section, we saw how to write an <code>if</code>
statement that converts a lowercase letter to upper-case:</p>
<div class="sourceCode" id="cb320"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span><span class="ch">&#39;a&#39;</span> <span class="op">&lt;=</span> ch <span class="op">&amp;&amp;</span> ch <span class="op">&lt;=</span> <span class="ch">&#39;z&#39;</span><span class="op">)</span></span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a>    ch <span class="op">=</span> ch <span class="op">-</span> <span class="ch">&#39;a&#39;</span> <span class="op">+</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span></span></code></pre></div>
<p>This isn’t the best method, though. A faster—and more portable—way to
convert case is to call C’s <code>toupper</code> library function:</p>
<div class="sourceCode" id="cb321"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> toupper <span class="op">(</span>ch<span class="op">);</span> <span class="co">/* converts ch to upper case */</span></span></code></pre></div>
<p>When it’s called, <code>toupper</code> checks whether its argument
(<code>ch</code> in this case) is a lower-case letter. If so, it returns
the corresponding upper-case letter. Otherwise, <code>toupper</code>
returns the value of the argument. In our example, we’ve used the
assignment operator to store the return value of <code>toupper</code>
back into the <code>ch</code> variable, although we could just as easily
have done something else with it—stored it in another variable, say, or
tested it in an <code>if</code> statement:</p>
<div class="sourceCode" id="cb322"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>toupper<span class="op">(</span>ch<span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;A&#39;</span><span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>Programs that call <code>toupper</code> need to have the following
<code>#include</code> directive at the top:</p>
<div class="sourceCode" id="cb323"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ctype.h&gt;</span></span></code></pre></div>
<p><code>toupper</code> isn’t the only useful character-handling
function in the C library. Section 23.5 describes them all and gives
examples of their use.</p>
<h3 id="reading-and-writing-characters-using-scanf-and-printf">7.3.6
Reading and Writing Characters using <code>scanf</code> and
<code>printf</code></h3>
<p>The <code>%c</code> conversion specification allows
<code>scanf</code> and <code>printf</code> to read and write single
characters:</p>
<div class="sourceCode" id="cb324"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> ch<span class="op">;</span></span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%c&quot;</span><span class="op">,</span> <span class="op">&amp;</span>ch<span class="op">);</span> <span class="co">/* reads a single character */</span></span>
<span id="cb324-4"><a href="#cb324-4" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;%c&quot;</span><span class="op">,</span> ch<span class="op">);</span> <span class="co">/* writes a single character */</span></span></code></pre></div>
<p><code>scanf</code> doesn’t skip white-space characters before reading
a character. If the next unread character is a space. then the variable
<code>ch</code> in the previous example will contain a space after
<code>scanf</code> returns. To force <code>scanf</code> to skip white
space before reading a character, put a space in its format string just
before <code>%c</code>:</p>
<div class="sourceCode" id="cb325"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot; %c&quot;</span><span class="op">,</span> <span class="op">&amp;</span>ch<span class="op">);</span> <span class="co">/* skips white space, then reads ch */</span></span></code></pre></div>
<p>Recall from Section 3.2 that a blank in a <code>scanf</code> format
string means “skip zero or more white-space characters.”</p>
<p>Since <code>scanf</code> doesn’t normally skip white space, it’s easy
to detect the end of an input line: check to see if the character just
read is the new-line character. For example, the following loop will
read and ignore all remaining characters in the current input line:</p>
<div class="sourceCode" id="cb326"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span>    </span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true" tabindex="-1"></a>    scanf <span class="op">(</span><span class="st">&quot;%c&quot;</span><span class="op">,</span> <span class="op">&amp;</span>ch<span class="op">);</span></span>
<span id="cb326-3"><a href="#cb326-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>ch <span class="op">!=</span> <span class="ch">&#39;\n&#39;</span><span class="op">);</span></span></code></pre></div>
<p>When <code>scanf</code> is called the next time, it will read the
first character on the next input line.</p>
<h3
id="reading-and-writing-characters-using-getchar-and-putchar">Reading
and Writing Characters using <code>getchar</code> and
<code>putchar</code></h3>
<p><span class="QandA"></span></p>
<p>C provides other ways to read and write single characters. In
particular, we can use the <code>getchar</code> and <code>putchar</code>
functions instead of calling <code>scanf</code> and <code>printf</code>.
<code>putchar</code> writes a single character:</p>
<div class="sourceCode" id="cb327"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a>putchar<span class="op">(</span>ch<span class="op">)</span> <span class="op">;</span></span></code></pre></div>
<p>Each time <code>getchar</code> is called, it reads one character,
which it returns. In order to save this character, we must use
assignment to store it in a variable:</p>
<div class="sourceCode" id="cb328"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> getchar<span class="op">();</span> <span class="co">/* reads a character and stores it in ch */</span></span></code></pre></div>
<p><code>getchar</code> actually returns an <code>int</code> value
rather than a <code>char</code> value (the reason will be discussed in
later chapters). As a result, it’s not unusual for a variable to have
type <code>int</code> rather than <code>char</code> if it will be used
to store a character read by <code>getchar</code>. Like
<code>scanf</code>, <code>getchar</code> doesn’t skip white-space
characters as it reads.</p>
<p>Using <code>getchar</code> and <code>putchar</code> (rather than
<code>scanf</code> and <code>printf</code>) saves time when the program
is executed. <code>getchar</code> and <code>putchar</code> are fast for
two reasons. First, they’re much simpler than <code>scanf</code> and
<code>printf</code>, which are designed to read and write many kinds of
data in a variety of formats. Second, <code>getchar</code> and
<code>putchar</code> are usually implemented as macros for additional
speed.</p>
<p><code>getchar</code> has another advantage over <code>scanf</code>:
because it returns the character that it reads, <code>getchar</code>
lends itself to various C idioms, including loops that search for a
character or skip over all occurrences of a character. Consider the
<code>scanf</code> loop that we used to skip the rest of an input
line:</p>
<div class="sourceCode" id="cb329"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a>    scanf <span class="op">(</span><span class="st">&quot;%c&quot;</span><span class="op">,</span> <span class="op">&amp;</span>ch<span class="op">);</span></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>ch <span class="op">!=</span> <span class="ch">&#39;\n&#39;</span><span class="op">);</span></span></code></pre></div>
<p>Rewriting this loop using <code>getchar</code> gives us the
following:</p>
<div class="sourceCode" id="cb330"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a>    ch <span class="op">=</span> getchar<span class="op">();</span></span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>ch <span class="op">!=</span> <span class="ch">&#39;\n&#39;</span><span class="op">);</span></span></code></pre></div>
<p>Moving the call of <code>getchar</code> into the controlling
expression allows us to condense the loop:</p>
<div class="sourceCode" id="cb331"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">((</span>ch <span class="op">=</span> getchar<span class="op">())</span> <span class="op">!=</span> <span class="ch">&#39;\n&#39;</span><span class="op">)</span></span></code></pre></div>
<p>This loop reads a character, stores it into the variable
<code>ch</code>, then tests if <code>ch</code> is not equal to the
new-line character. If the test succeeds, the loop body (which is empty)
is executed, then the loop test is performed once more, causing a new
character to be read. Actually, we don’t even need the <code>ch</code>
variable; we can just compare the return value of <code>getchar</code>
with the new-line character:</p>
<div class="sourceCode" id="cb332"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>getchar<span class="op">()</span> <span class="op">!=</span> <span class="ch">&#39;\n&#39;</span><span class="op">)</span> <span class="co">/* skips rest of line */</span></span></code></pre></div>
<p>The resulting loop is a well-known C idiom that’s cryptic but worth
learning.</p>
<p><code>getchar</code> is useful in loops that skip characters as well
as loops that search for characters. Consider the following statement,
which uses <code>getchar</code> to skip an indefinite number of blank
characters:</p>
<div class="sourceCode" id="cb333"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">((</span>ch <span class="op">=</span> getchar<span class="op">())</span> <span class="op">==</span> <span class="ch">&#39; &#39;</span><span class="op">)</span> <span class="co">/* skips blanks */</span></span></code></pre></div>
<p>When the loop terminates, <code>ch</code> will contain the first
nonblank character that <code>getchar</code> encountered.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Be careful if you mix <code>getchar</code> and <code>scanf</code> in
the same program. <code>scanf</code> has a tendency to leave behind
characters that it has “peeked” at but not read, including the new-line
character. Consider what happens if we try to read a number first, then
a character:</p>
<div class="sourceCode" id="cb334"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;Enter an integer: &quot;</span><span class="op">);</span></span>
<span id="cb334-2"><a href="#cb334-2" aria-hidden="true" tabindex="-1"></a>scanf <span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span>
<span id="cb334-3"><a href="#cb334-3" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;Enter a command: &quot;</span><span class="op">);</span></span>
<span id="cb334-4"><a href="#cb334-4" aria-hidden="true" tabindex="-1"></a>command <span class="op">=</span> getchar<span class="op">();</span></span></code></pre></div>
<p>The call of <code>scanf</code> will leave behind any characters that
weren’t consumed during the reading of <code>i</code>, including (but
not limited to) the new-line character. <code>getchar</code> will fetch
the first leftover character, which wasn’t what we had in mind.</p>
</div>
<!-- END: div -->
<h3 id="program-determining-the-length-of-a-message">7.3.8 (PROGRAM)
Determining the Length of a Message</h3>
<p>To illustrate how characters are read, let’s write a program that
calculates the length of a message. After the user enters the message,
the program displays the length:</p>
<pre class="shell"><code>Enter a message: Brevity is the soul of wit.
Your message was 27 character(s) long.</code></pre>
<p>The length includes spaces and punctuation, but not the new-line
character at the end of the message.</p>
<p>We’ll need a loop whose body reads a character and increments a
counter. The loop will terminate as soon as a new-line character turns
up. We could use either <code>scanf</code> or <code>getchar</code> to
read characters; most C programmers would choose <code>getchar</code>.
Using a straightforward <code>while</code> loop, we might end up with
the following program.</p>
<div class="sourceCode" id="cb336"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb336-2"><a href="#cb336-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: length.c</span></span>
<span id="cb336-3"><a href="#cb336-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb336-4"><a href="#cb336-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Determines the length of a message </span></span>
<span id="cb336-5"><a href="#cb336-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb336-6"><a href="#cb336-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-7"><a href="#cb336-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb336-8"><a href="#cb336-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-9"><a href="#cb336-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb336-10"><a href="#cb336-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb336-11"><a href="#cb336-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> ch<span class="op">;</span></span>
<span id="cb336-12"><a href="#cb336-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb336-13"><a href="#cb336-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-14"><a href="#cb336-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter a message: &quot;</span><span class="op">);</span></span>
<span id="cb336-15"><a href="#cb336-15" aria-hidden="true" tabindex="-1"></a>    ch <span class="op">=</span> getchar<span class="op">();</span></span>
<span id="cb336-16"><a href="#cb336-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>ch <span class="op">!=</span> <span class="ch">&#39;\n&#39;</span><span class="op">)</span></span>
<span id="cb336-17"><a href="#cb336-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb336-18"><a href="#cb336-18" aria-hidden="true" tabindex="-1"></a>        len<span class="op">++;</span></span>
<span id="cb336-19"><a href="#cb336-19" aria-hidden="true" tabindex="-1"></a>        ch <span class="op">=</span> getchar<span class="op">();</span></span>
<span id="cb336-20"><a href="#cb336-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb336-21"><a href="#cb336-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Your message was %d character(s) long. </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> len<span class="op">);</span></span>
<span id="cb336-22"><a href="#cb336-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-23"><a href="#cb336-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb336-24"><a href="#cb336-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Recalling our discussion of idioms involving <code>while</code> loops
and <code>getchar</code>, we realize that the program can be
shortened:</p>
<div class="sourceCode" id="cb337"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb337-2"><a href="#cb337-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: length2.c</span></span>
<span id="cb337-3"><a href="#cb337-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb337-4"><a href="#cb337-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Determines the length of a message </span></span>
<span id="cb337-5"><a href="#cb337-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb337-6"><a href="#cb337-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-7"><a href="#cb337-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb337-8"><a href="#cb337-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-9"><a href="#cb337-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb337-10"><a href="#cb337-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb337-11"><a href="#cb337-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> ch<span class="op">;</span></span>
<span id="cb337-12"><a href="#cb337-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb337-13"><a href="#cb337-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-14"><a href="#cb337-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter a message: &quot;</span><span class="op">);</span></span>
<span id="cb337-15"><a href="#cb337-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>getchar<span class="op">()</span> <span class="op">!=</span> <span class="ch">&#39;\n&#39;</span><span class="op">)</span></span>
<span id="cb337-16"><a href="#cb337-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb337-17"><a href="#cb337-17" aria-hidden="true" tabindex="-1"></a>        len<span class="op">++;</span></span>
<span id="cb337-18"><a href="#cb337-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb337-19"><a href="#cb337-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Your message was %d character(s) long. </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> len<span class="op">);</span></span>
<span id="cb337-20"><a href="#cb337-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-21"><a href="#cb337-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb337-22"><a href="#cb337-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="type-conversion">7.4 Type Conversion</h2>
<p>Computers tend to be more restrictive than C when it comes to
arithmetic. For a computer to perform an arithmetic operation, the
operands must usually be of the same size (the same number of bits) and
be stored in the same way. A computer may be able to add two 16-bit
integers directly, but not a 16-bit integer and a 32-bit integer or a
32-bit integer and a 32-bit floating-point number.</p>
<p>C, on the other hand, allows the basic types to be mixed in
expressions. We can combine integers, floating-point numbers, and even
characters in a single expression. The C compiler may then have to
generate instructions that convert some operands to different types so
that the hardware will be able to evaluate the expression. If we add a
16-bit <code>short</code> and a 32-bit <code>int</code>, for example,
the compiler will arrange for the <code>short</code> value to be
converted to 32 bits. If we add an <code>int</code> and a
<code>float</code>, the compiler will arrange for the <code>int</code>
to be converted to <code>float</code> format. This conversion is a
little more complicated, since <code>int</code> and <code>float</code>
values are stored in different ways.</p>
<p>Because the compiler handles these conversions automatically, without
the programmer’s involvement, they’re known as <strong><em>implicit
conversions</em></strong>. C also allows the programmer to perform
<strong><em>explicit conversions</em></strong>, using the cast operator.
I’ll discuss implicit conversions first, postponing explicit conversions
until later in the section. Unfortunately, the rules for performing
implicit conversions are somewhat complex, primarily because C has so
many different arithmetic types.</p>
<p>Implicit conversions are performed in the following situations:</p>
<ul>
<li>When the operands in an arithmetic or logical expression don’t have
the same type. (C performs what are known as the <strong><em>usual
arithmetic</em></strong> conversions.)<br />
When the type of the expression on the right side of an assignment
doesn’t match the type of the variable on the left side.<br />
</li>
<li>When the type of an argument in a function call doesn’t match the
type of the corresponding parameter.<br />
</li>
<li>When the type of the expression in a <code>return</code> statement
doesn’t match the function’s return type.</li>
</ul>
<p>We’ll discuss the first two cases now and save the others for Chapter
9.</p>
<h3 id="the-usual-arithmetic-conversions">7.4.1 The Usual Arithmetic
Conversions</h3>
<p>The usual arithmetic conversions are applied to the operands of most
binary operators, including the arithmetic, relational, and equality
operators. For example, let’s say that <code>f</code> has type
<code>float</code> and <code>i</code> has type <code>int</code>. The
usual arithmetic conversions will be applied to the operands in the
expression <code>f + i</code>, because their types aren’t the same.
Clearly it’s safer to convert <code>i</code> to type <code>float</code>
(matching <code>f</code>’s type) rather than convert <code>f</code> to
type <code>int</code> (matching <code>i</code>’s type). An integer can
always be converted to <code>float</code>: the worst that can happen is
a minor loss of precision. Converting a floating-point number to
<code>int</code>, on the other hand, would cost us the fractional part
of the number. Worse still, we’d get a completely meaningless result if
the original number were larger than the largest possible integer or
smaller than the smallest integer.</p>
<p><span class="QandA"></span></p>
<p>The strategy behind the usual arithmetic conversions is to convert
operands to the “narrowest” type that will safely accommodate both
values. (Roughly speaking, one type is narrower than another if it
requires fewer bytes to store.) The types of the operands can often be
made to match by converting the operand of the narrower type to the type
of the other operand (this act is known as promotion). Among the most
common promotions are the integral promotions, which convert a character
or short integer to type <code>int</code> (or to
<code>unsigned int</code> in some cases).</p>
<p>We can divide the rules for performing the usual arithmetic
conversions into two cases:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p><strong><em>The type of either operand is a floating
type</em></strong>. Use the following diagram to promote the operand
whose type is narrower:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>long double</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="unicode_UPWARDS_ARROW"></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>double</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="unicode_UPWARDS_ARROW"></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>float</code></td>
</tr>
</tbody>
</table>
<p>That is, if one operand has type <code>long double</code>, then
convert the other operand to type <code>long double</code>. Otherwise,
if one operand has type <code>double</code>, convert the other operand
to type <code>double</code>. Otherwise, if one operand has type
<code>float</code>, convert the other operand to type
<code>float</code>. Note that these rules cover mixtures of integer and
floating types: if one operand has type <code>long int</code>, for
example, and the other has type <code>double</code>, the
<code>long int</code> operand is converted to <code>double</code>.</p>
</li>
<li>
<p><strong><em>Neither operand type is a floating type</em></strong>.
First perform integral promotion on both operands (guaranteeing that
neither operand will be a character or <code>short</code> integer). Then
use the following diagram to promote the operand whose type is
narrower:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>unsigned long int</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="unicode_UPWARDS_ARROW"></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>long int</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="unicode_UPWARDS_ARROW"></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>unsigned int</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="unicode_UPWARDS_ARROW"></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>int</code></td>
</tr>
</tbody>
</table>
<p>There’s one special case, but it occurs only when
<code>long int</code> and <code>unsigned int</code> have the same length
(32 bits, say). Under these circumstances, if one operand has type
<code>long int</code> and the other has type <code>unsigned int</code>,
both are converted to <code>unsigned long int</code>.</p>
</li>
</ul>
<!-- END: unordered-list -->
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>When a signed operand is combined with an unsigned operand, the
signed operand is converted to an unsigned value. The conversion
involves adding or subtracting a multiple of <code>n + 1</code>, where
<code>n</code> is the largest representable value of the unsigned type.
This rule can cause obscure programming errors.</p>
<p>Suppose that the <code>int</code> variable <code>i</code> has the
value -10 and the <code>unsigned int</code> variable <code>u</code> has
the value 10. If we compare <code>i</code> and <code>u</code> using the
<code>&lt;</code> operator, we might expect to get the result 1 (true).
Before the comparison, however, 1 is converted to
<code>unsigned int</code>. Since a negative number can’t be represented
as an unsigned integer, the converted value won’t be -10. Instead, the
value 4,294,967,296 is added (assuming that 4,294,967,295 is the largest
<code>unsigned int</code> value), giving a converted value of
4,294,967,286. The comparison <code>i &lt; u</code> will therefore
produce 0. Some compilers produce a warning message such as “comparison
between signed and unsigned” when a program attempts to compare a signed
number with an unsigned number.</p>
<p>Because of traps like this one, it’s best to use unsigned integers as
little as possible and, especially, never mix them with signed
integers.</p>
</div>
<!-- END: div -->
<p>The following example shows the usual arithmetic conversions in
action:</p>
<div class="sourceCode" id="cb338"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true" tabindex="-1"></a><span class="dt">short</span> <span class="dt">int</span> s<span class="op">;</span></span>
<span id="cb338-3"><a href="#cb338-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb338-4"><a href="#cb338-4" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">int</span> u<span class="op">;</span></span>
<span id="cb338-5"><a href="#cb338-5" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">int</span> l<span class="op">;</span></span>
<span id="cb338-6"><a href="#cb338-6" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> ul<span class="op">;</span></span>
<span id="cb338-7"><a href="#cb338-7" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb338-8"><a href="#cb338-8" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> d<span class="op">;</span></span>
<span id="cb338-9"><a href="#cb338-9" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">double</span> ld<span class="op">;</span></span>
<span id="cb338-10"><a href="#cb338-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb338-11"><a href="#cb338-11" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> c<span class="op">;</span> <span class="co">/* c is converted to int */</span></span>
<span id="cb338-12"><a href="#cb338-12" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> s<span class="op">;</span> <span class="co">/* s is converted to int */</span></span>
<span id="cb338-13"><a href="#cb338-13" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> u <span class="op">+</span> i<span class="op">;</span> <span class="co">/* i is converted to unsigned int */</span></span>
<span id="cb338-14"><a href="#cb338-14" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> l <span class="op">+</span> u<span class="op">;</span> <span class="co">/* u is converted to long int */</span></span>
<span id="cb338-15"><a href="#cb338-15" aria-hidden="true" tabindex="-1"></a>ul <span class="op">=</span> ul <span class="op">+</span> l<span class="op">;</span> <span class="co">/* l is converted to unsigned long int */</span></span>
<span id="cb338-16"><a href="#cb338-16" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> f <span class="op">+</span> ul<span class="op">;</span> <span class="co">/* ul is converted to float */</span></span>
<span id="cb338-17"><a href="#cb338-17" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> d <span class="op">+</span> f<span class="op">;</span> <span class="co">/* f is converted to double */</span></span>
<span id="cb338-18"><a href="#cb338-18" aria-hidden="true" tabindex="-1"></a>ld <span class="op">=</span> ld <span class="op">+</span> d<span class="op">;</span> <span class="co">/* d is converted to long double */</span></span></code></pre></div>
<h3 id="conversion-during-assignment">7.4.2 Conversion During
Assignment</h3>
<p>The usual arithmetic conversions don’t apply to assignment. Instead,
C follows the simple rule that the expression on the right side of the
assignment is converted to the type of the variable on the left side. If
the variable’s type is at least as “wide” as the expression’s, this will
work without a snag. For example:</p>
<div class="sourceCode" id="cb339"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb339-3"><a href="#cb339-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb339-4"><a href="#cb339-4" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> d<span class="op">;</span></span>
<span id="cb339-5"><a href="#cb339-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-6"><a href="#cb339-6" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> c<span class="op">;</span> <span class="co">/* c is converted to int */</span></span>
<span id="cb339-7"><a href="#cb339-7" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> i<span class="op">;</span> <span class="co">/* i is converted to float */</span></span>
<span id="cb339-8"><a href="#cb339-8" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> f<span class="op">;</span> <span class="co">/* f is converted to double */</span></span>
<span id="cb339-9"><a href="#cb339-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-10"><a href="#cb339-10" aria-hidden="true" tabindex="-1"></a>Other cases are problematic<span class="op">.</span> Assigning a floating<span class="op">-</span>point number to an integer variable drops the fractional part of the number<span class="op">:</span></span>
<span id="cb339-11"><a href="#cb339-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-12"><a href="#cb339-12" aria-hidden="true" tabindex="-1"></a>```C</span>
<span id="cb339-13"><a href="#cb339-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb339-14"><a href="#cb339-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-15"><a href="#cb339-15" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="fl">842.97</span><span class="op">;</span> <span class="co">/* i is now 842 */</span></span>
<span id="cb339-16"><a href="#cb339-16" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">-</span><span class="fl">842.97</span><span class="op">;</span> <span class="co">/* i is now -842 */</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>Moreover, assigning a value to a variable of a narrower type will
give a meaningless result (or worse) if the value is outside the range
of the variable’s type:</p>
<div class="sourceCode" id="cb340"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">10000</span><span class="op">;</span> <span class="co">/*** WRONG ***/</span></span>
<span id="cb340-2"><a href="#cb340-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="fl">1.0e20</span><span class="op">;</span> <span class="co">/*** WRONG ***/</span></span>
<span id="cb340-3"><a href="#cb340-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="fl">1.0e100</span><span class="op">;</span> <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>A “narrowing” assignment may elicit a warning from the compiler or
from tools such as <strong><em>lint</em></strong>.</p>
<p>It’s a good idea to append the <code>f</code> suffix to a
floating-point constant if it will be assigned to a <code>float</code>
variable, as we’ve been doing since Chapter 2:</p>
<div class="sourceCode" id="cb341"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="fl">3.14159</span><span class="bu">f</span><span class="op">;</span></span></code></pre></div>
<p>Without the suffix, the constant 3.14159 would have type
<code>double</code>, possibly causing a warning message.</p>
<p><span class="C99Symbol"></span></p>
<h3 id="implicit-conversions-in-c99">7.4.3 Implicit Conversions in
C99</h3>
<p>The rules for implicit conversions in C99 are somewhat different from
the rules in C89, primarily because C99 has additional types
(<code>_Bool</code>, <code>long long</code> types. extended integer
types, and complex types).</p>
<p>For the purpose of defining conversion rules, C99 gives each integer
type an “integer conversion rank.” Here are the ranks from highest to
lowest:</p>
<ol type="1">
<li><code>long long int</code>, <code>unsigned long long int</code></li>
<li><code>long int</code>, <code>unsigned long int</code></li>
<li><code>int</code>, <code>unsigned int</code></li>
<li><code>short int</code>, <code>unsigned short int</code></li>
<li><code>char</code>, <code>signed char</code>,
<code>unsigned char</code></li>
<li><code>_Bool</code></li>
</ol>
<p>For simplicity. I’m ignoring extended integer types and enumerated
types.</p>
<p>In place of C89’s integral promotions, C99 has “integer promotions,”
which involve converting any type whose rank is less than
<code>int</code> and <code>unsigned int</code> to <code>int</code>
(provided that all values of the type can be represented using
<code>int</code>) or else to <code>unsigned int</code>.</p>
<p>As in C89, the C99 rules for performing the usual arithmetic
conversions can be divided into two cases:</p>
<ul>
<li><strong><em>The type of either operand is a floating
type</em></strong>. As long as neither operand has a complex type, the
rules are the same as before. (The conversion rules for complex types
will be discussed in Section 27.3.)<br />
</li>
<li><strong><em>Neither operand type is a floating type</em></strong>.
First perform integer promotion on both operands. If the types of the
two operands are now the same, the process ends. Otherwise, use the
following rules, stopping at the first one that applies:
<ul>
<li>If both operands have signed types or both have unsigned types,
convert the operand whose type has lesser integer conversion rank to the
type of the operand with greater rank.<br />
</li>
<li>If the unsigned operand has rank greater or equal to the rank of the
type of the signed operand, convert the signed operand to the type of
the unsigned operand.<br />
</li>
<li>If the type of the signed operand can represent all of the values of
the type of the unsigned operand, convert the unsigned operand to the
type of the signed operand.<br />
</li>
<li>Otherwise, convert both operands to the unsigned type corresponding
to the type of the signed operand.</li>
</ul></li>
</ul>
<p>Incidentally, all arithmetic types can be converted to
<code>_Bool</code> type. The result of the conversion is 0 if the
original value is 0: otherwise, the result is 1.</p>
<h3 id="casting">7.4.4 Casting</h3>
<p>Although C’s implicit conversions are convenient, we sometimes need a
greater degree of control over type conversion. For this reason, C
provides <strong><em>casts</em></strong>. A cast expression has the
form</p>
<div class="sourceCode" id="cb342"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span> type<span class="op">-</span>name <span class="op">)</span> expression</span></code></pre></div>
<p><em>type-name</em> specifies the type to which the expression should
be converted.</p>
<p>The following example shows how to use a cast expression to compute
the fractional part of a <code>float</code> value:</p>
<div class="sourceCode" id="cb343"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">,</span> frac_part<span class="op">;</span></span>
<span id="cb343-2"><a href="#cb343-2" aria-hidden="true" tabindex="-1"></a>frac_part <span class="op">=</span> f <span class="op">-</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> f<span class="op">;</span></span></code></pre></div>
<p>The cast expression <code>(int) f</code> represents the result of
converting the value of <code>f</code> to type <code>int</code>. C’s
usual arithmetic conversions then require that <code>(int) f</code> be
converted back to type <code>float</code> before the subtraction can be
performed. The difference hetween <code>f</code> and
<code>(int) f</code> is the fractional part of <code>f</code>, which was
dropped during the cast.</p>
<p>Cast expressions enable us to document type conversions that would
take place anyway:</p>
<div class="sourceCode" id="cb344"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> f<span class="op">;</span> <span class="co">/* f is converted to int */</span></span></code></pre></div>
<p>They also enable us to overrule the compiler and force it to do
conversions that we want. Consider the following example:</p>
<div class="sourceCode" id="cb345"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> quotient<span class="op">;</span></span>
<span id="cb345-2"><a href="#cb345-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dividend<span class="op">,</span> divisor<span class="op">;</span></span>
<span id="cb345-3"><a href="#cb345-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb345-4"><a href="#cb345-4" aria-hidden="true" tabindex="-1"></a>quotient <span class="op">=</span> dividend <span class="op">/</span> divisor<span class="op">;</span></span></code></pre></div>
<p>As it’s now written, the result of the division—an integer—will be
converted to <code>float</code> form before being stored in quotient. We
probably want dividend and divisor converted to `float before the
division, though, so that we get a more exact answer. A cast expression
will do the trick:</p>
<div class="sourceCode" id="cb346"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true" tabindex="-1"></a>quotient <span class="op">=</span> <span class="op">(</span><span class="dt">float</span><span class="op">)</span> dividend <span class="op">/</span> divisor<span class="op">;</span></span></code></pre></div>
<p><code>divisor</code> doesn’t need a cast, since casting
<code>dividend</code> to <code>float</code> forces the compiler to
convert <code>divisor</code> to <code>float</code> also.</p>
<p>Incidentally, C regards ( <em>type-name</em> ) as a unary operator.
Unary operators have higher precedence than binary operators, so the
compiler interprets</p>
<div class="sourceCode" id="cb347"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="dt">float</span><span class="op">)</span> dividend <span class="op">/</span> divisor</span></code></pre></div>
<p>as</p>
<div class="sourceCode" id="cb348"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true" tabindex="-1"></a><span class="op">((</span><span class="dt">float</span><span class="op">)</span> dividend<span class="op">)</span> <span class="op">/</span> divisor</span></code></pre></div>
<p>If you find this confusing, note that there are other ways to
accomplish the same effect:</p>
<div class="sourceCode" id="cb349"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a>quotient <span class="op">=</span> dividend <span class="op">/</span> <span class="op">(</span><span class="dt">float</span><span class="op">)</span> divisor<span class="op">;</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb350"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true" tabindex="-1"></a>quotient <span class="op">=</span> <span class="op">(</span><span class="dt">float</span><span class="op">)</span> dividend <span class="op">/</span> <span class="op">(</span><span class="dt">float</span><span class="op">)</span> divisor<span class="op">;</span></span></code></pre></div>
<p>Casts are sometimes necessary to avoid overflow. Consider the
following example:</p>
<div class="sourceCode" id="cb351"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> i<span class="op">;</span></span>
<span id="cb351-2"><a href="#cb351-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1000</span><span class="op">;</span></span>
<span id="cb351-3"><a href="#cb351-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb351-4"><a href="#cb351-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> j <span class="op">*</span> j<span class="op">;</span> <span class="co">/* overflow may occur */</span></span></code></pre></div>
<p>At first glance, this statement looks fine. The value of
<code>j * j</code> is 1,000,000, and <code>i</code> is a
<code>long</code>, so it can easily store values of this size. right?
The problem is that when two <code>int</code> values are multiplied, the
result will have <code>int</code> type. But <code>j * j</code> is too
large to represent as an <code>int</code> on some machines, causing an
overflow. Fortunately, using a cast avoids the problem:</p>
<div class="sourceCode" id="cb352"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span> j <span class="op">*</span> j<span class="op">;</span></span></code></pre></div>
<p>Since the cast operator takes precedence over <code>*</code>, the
first <code>j</code> is converted to <code>long</code> type, forcing the
second <code>j</code> to be converted as well. Note that the
statement</p>
<div class="sourceCode" id="cb353"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span> <span class="op">(</span>j <span class="op">*</span> j<span class="op">);</span> <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>wouldn’t work, since the overflow would already have occurred by the
time of the cast.</p>
<h2 id="type-definitions">7.5 Type Definitions</h2>
<p>In Section 5.2, we used the <code>#define</code> directive to create
a macro that could be used as a Boolean type:</p>
<div class="sourceCode" id="cb354"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BOOL int</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>There’s a better way to set up a Boolean type, though, using a
feature known as a <strong><em>type definition</em></strong>:</p>
<div class="sourceCode" id="cb355"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> Bool<span class="op">;</span></span></code></pre></div>
<p>Notice that the name of the type being defined comes <em>last</em>.
Note also that I’ve capitalized the word <code>Bool</code>. Capitalizing
the first letter of a type name isn’t required; it’s just a convention
that some C programmers employ.</p>
<p>Using <code>typedef</code> to define <code>Bool</code> causes the
compiler to add <code>Bool</code> to the list of type names that it
recognizes. <code>Bool</code> can now be used in the same way as the
built-in type names—in variable declarations, cast expressions, and
elsewhere. For example, we might use <code>Bool</code> to declare
variables:</p>
<div class="sourceCode" id="cb356"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb356-1"><a href="#cb356-1" aria-hidden="true" tabindex="-1"></a>Bool flag<span class="op">;</span> <span class="co">/* same as int flag; */</span></span></code></pre></div>
<p>The compiler treats <code>Bool</code> as a synonym for
<code>int</code>; thus, <code>flag</code> is really nothing more than an
ordinary <code>int</code> variable.</p>
<h3 id="advantages-of-type-definitions">7.5.1 Advantages of Type
Definitions</h3>
<p>Type definitions can make a program more understandable (assuming
that the programmer has been careful to choose meaningful type names).
For example, suppose that the variables <code>cash_in</code> and
<code>cash_out</code> will be used to store dollar amounts. Declaring
<code>Dollars</code> as</p>
<div class="sourceCode" id="cb357"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">float</span> Dollars<span class="op">;</span></span></code></pre></div>
<p>and then writing</p>
<div class="sourceCode" id="cb358"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb358-1"><a href="#cb358-1" aria-hidden="true" tabindex="-1"></a>Dollars cash_in<span class="op">,</span> cash out<span class="op">;</span></span></code></pre></div>
<p>is more informative than just writing</p>
<div class="sourceCode" id="cb359"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb359-1"><a href="#cb359-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> cash_in<span class="op">,</span> cash out<span class="op">;</span></span></code></pre></div>
<p>Type definitions can also make a program easier to modify. If we
later decide that Dollars should really be defined as
<code>double</code>, all we need do is change the type definition:</p>
<div class="sourceCode" id="cb360"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb360-1"><a href="#cb360-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">double</span> Dollars<span class="op">;</span></span></code></pre></div>
<p>The declarations of <code>Dollars</code> variables need not be
changed. Without the type definition, we would need to locate all
<code>float</code> variables that store dollar amounts (not necessarily
an easy task) and change their declarations.</p>
<h3 id="type-definitions-and-portability">7.5.2 Type Definitions and
Portability</h3>
<p>Type definitions are an important tool for writing portable programs.
One of the problems with moving a program from one computer to another
is that types may have different ranges on different machines, If
<code>i</code> is an <code>int</code> variable, an assignment like</p>
<div class="sourceCode" id="cb361"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb361-1"><a href="#cb361-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">100000</span><span class="op">;</span></span></code></pre></div>
<p>is fine on a machine with 32-bit integers, but will fail on a machine
with 16-bit integers.</p>
<p><em>For greater portability, consider using <code>typedef</code> to
define new names for integer types.</em></p>
<p>Suppose that we’re writing a program that needs variables capable of
storing product quantities in the range 0-50,000. We could use
<code>long</code> variables for this purpose (since they’re guaranteed
to be able to hold numbers up to at least 2,147,483,647), but we’d
rather use <code>int</code> variables, since arithmetic on
<code>int</code> values may be faster than operations on
<code>long</code> values; also, <code>int</code> variables may take up
less space.</p>
<p>Instead of using the <code>int</code> type to declare quantity
variables, we can define our own “quantity” type:</p>
<div class="sourceCode" id="cb362"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb362-1"><a href="#cb362-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> Quantity<span class="op">;</span></span></code></pre></div>
<p>and use this type to declare variables:</p>
<div class="sourceCode" id="cb363"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb363-1"><a href="#cb363-1" aria-hidden="true" tabindex="-1"></a>Quantity q<span class="op">;</span></span></code></pre></div>
<p>When we transport the program to a machine with shorter integers,
we’ll change the definition of Quantity:</p>
<div class="sourceCode" id="cb364"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb364-1"><a href="#cb364-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> Quantity<span class="op">;</span></span></code></pre></div>
<p>This technique doesn’t solve all our problems, unfortunately, since
changing the definition of <code>Quantity</code> may affect the way
<code>Quantity</code> variables are used. At the very least, calls of
<code>printf</code> and <code>scanf</code> that use
<code>Quantity</code> variables will need to be changed, with
<code>%d</code> conversion specifications replaced by
<code>%ld</code>.</p>
<p>The C library itself uses <code>typedef</code> to create names for
types that can vary from one C implementation to another; these types
often have names that end with <code>_t</code>, such as
<code>ptrdiff_t</code>, <code>size_t</code>, and
<code>wchar_t</code>.The exact definitions of these types will vary, but
here are some typical examples:</p>
<div class="sourceCode" id="cb365"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb365-1"><a href="#cb365-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">int</span> <span class="dt">ptrdiff_t</span><span class="op">;</span></span>
<span id="cb365-2"><a href="#cb365-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> <span class="dt">size_t</span><span class="op">;</span></span>
<span id="cb365-3"><a href="#cb365-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="dt">wchar_t</span><span class="op">;</span></span></code></pre></div>
<p><span class="C99Symbol"></span></p>
<p>In C99, the <code>&lt;stdint.h&gt;</code> header uses
<code>typedef</code> to define names for integer types with a particular
number of bits. For example, <code>int32_t</code> is a signed integer
type with exactly 32 bits. Using these types is an effective way to make
programs more portable.</p>
<h2 id="the-sizeof-operator">7.6 The sizeof Operator</h2>
<p>The sizeof operator allows a program to determine how much memory is
required to store values of a particular type. The value of the
expression</p>
<div class="sourceCode" id="cb366"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sizeof</span> <span class="op">(</span> type<span class="op">-</span>name <span class="op">)</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>is an unsigned integer representing the number of bytes required to
store a value belonging to type-name. <code>sizeof (char)</code> is
always 1, but the sizes of the other types may vary. On a 32-bit
machine, <code>sizeof (int)</code> is normally 4. Note that
<code>sizeof</code> is a rather unusual operator, since the compiler
itself can usually determine the value of a <code>sizeof</code>
expression.</p>
<p>The <code>sizeof</code> operator can also be applied to constants,
variables, and expressions in general. If <code>i</code> and
<code>j</code> are <code>int</code> variables, then
<code>sizeof (i)</code> is 4 on a 32-bit machine, as is
<code>sizeof (i + j)</code>. When applied to an expression—as opposed to
a type—<code>sizeof</code> doesn’t require parentheses; we could write
<code>sizeof i</code> instead of <code>sizeof (i)</code>. However,
parentheses may be needed anyway because of operator precedence. The
compiler would interpret <code>sizeof i + j</code> as
<code>(sizeof i) + j</code>, because sizeof—a unary operator—takes
precedence over the binary <code>+</code> operator. To avoid problems, I
always use parentheses in <code>sizeof</code> expressions.</p>
<p>Printing a <code>sizeof</code> value requires care, because the type
of a <code>sizeof</code> expression is an implementation-defined type
named <code>size_t</code>. In C89, it’s best to convert the value of the
expression to a known type before printing it. <code>size_t</code> is
guaranteed to be an unsigned integer type, so it’s safest to cast a
<code>sizeof</code> expression to unsigned <code>long</code> (the
largest of C89’s unsigned types) and then print it using the
<code>%lu</code> conversion:</p>
<div class="sourceCode" id="cb367"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;Size of int: %lu</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">)</span> <span class="kw">sizeof</span> <span class="op">(</span><span class="dt">int</span><span class="op">));</span></span></code></pre></div>
<p><span class="C99Symbol"></span></p>
<p>In C99, the <code>size_t</code> type can be larger than
<code>unsigned long</code>. However, the <code>printf</code> function in
C99 is capable of displaying <code>size_t</code> values directly,
without needing a cast. The trick is to use the letter <code>z</code> in
the conversion specification, followed by one of the usual integer codes
(typically <code>u</code>):</p>
<div class="sourceCode" id="cb368"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;Size of int: %zu</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">sizeof</span> <span class="op">(</span><span class="dt">int</span><span class="op">));</span> <span class="co">/* C99 only */</span></span></code></pre></div>
<hr />
<h2 id="qa-1">Q&amp;A</h2>
<!-- START: div -->
<div class="QandA_question">
<p>Q: Section 7.1 says that <code>%o</code> and <code>%x</code> are used
to write unsigned integers in octal and hex notation. How do I write
ordinary (signed) integers in octal or hex? [p- 130]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: You can use <code>%o</code> and <code>%x</code> to print a signed
integer as long as its value isn’t negative. These conversions cause
<code>printf</code> to treat a signed integer as though it were
unsigned: in other words, <code>printf</code> will assume that the sign
bit is part of the number’s magnitude. As long as the sign bit is 0,
there’s no problem. If the sign bit is 1, <code>printf</code> will print
an unexpectedly large number.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: But what if the number <em>is</em> negative? How can I write it in
octal or hex?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: There’s no direct way to print a negative number in octal or hex.
Fortunately, the need to do so is pretty rare. You can, of course, test
whether the number is negative and print a minus sign yourself:</p>
<div class="sourceCode" id="cb369"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb369-2"><a href="#cb369-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;-%x&quot;</span><span class="op">,</span> <span class="op">-</span>i<span class="op">);</span></span>
<span id="cb369-3"><a href="#cb369-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb369-4"><a href="#cb369-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%x&quot;</span><span class="op">,</span> i<span class="op">);</span></span></code></pre></div>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Why are floating constants stored in <code>double</code> form
rather than <code>float</code> form? [p- 133]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: For historical reasons, C gives preference to the
<code>double</code> type; <code>float</code> is treated as a
second-class citizen. Consider, for instance, the discussion of
<code>float</code> in Kernighan and Ritchie’s <em>The C Programming
Language</em>: “The main reason for using <code>float</code> is to save
storage in large arrays, or, less often, to save time on machines where
double-precision arithmetic is particularly expensive.” C originally
mandated that all floating-point arithmetic be done in double precision.
(C89 and C99 have no such requirement.)</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: What do hexadecimal floating constants look like, and what are
they good for? [p. 134]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: A hexadecimal floating constant begins with <code>0x</code> or
<code>0X</code> and must contain an exponent, which is preceded by the
letter <code>P</code> (or <code>p</code>). The exponent may have a sign,
and the constant may end with <code>f</code>, <code>F</code>,
<code>l</code>, or <code>L</code>. The exponent is expressed in decimal,
but represents a power of 2, not a power of 10. For example,
<code>0x1.Bp3</code> represents the number 1.6875 x 2<sup>3</sup> =
13.5. The hex digit <code>B</code> corresponds to the bit pattern 1011,
The <code>B</code> occurs to the right of the period, so each 1 bit
represents a negative power of 2. Summing these powers of 2
(2<sup>-1</sup> + 2<sup>-3</sup> + 2<sup>-4</sup>) yields .6875.</p>
<p>Hexadecimal floating constants are primarily useful for specifying
constants that require great precision (including mathematical constants
such as <code>e</code> and π). Hex numbers have a precise binary
representation, whereas a constant written in decimal may be subject to
a tiny rounding error when converted to binary, Hexadecimal numbers are
also useful for defining constants with extreme values, such as the
values of the macros in the <code>&lt;float.h&gt;</code> header. These
constants are easy to write in hex but difficult to write in
decimal.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Why do we use <code>%lf</code> to read a <code>double</code> value
but <code>%f</code> to print it? [p. 134]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: This is a tough question to answer. First, notice that
<code>scanf</code> and <code>printf</code> are unusual functions in that
they aren’t restricted to a fixed number of arguments. We say that
<code>scanf</code> and <code>printf</code> have variable-length argument
lists. When functions with variable-length argument lists are called,
the compiler arranges for <code>float</code> arguments to be converted
automatically to type <code>double</code>. As a result,
<code>printf</code> can’t distinguish between <code>float</code> and
<code>double</code> arguments. This explains why <code>%f</code> works
for both <code>float</code> and <code>double</code> arguments in calls
of <code>printf</code>.</p>
<p><code>scanf</code>, on the other hand, is passed a <em>pointer</em>
to a variable. <code>%f</code> tells <code>scanf</code> to store a
<code>float</code> value at the address passed to it, while
<code>%lf</code> tells <code>scanf</code> to store a double value at
that address. The distinction between <code>float</code> and
<code>double</code> is crucial here. If given the wrong conversion
specification, <code>scanf</code> will likely store the wrong number of
bytes (not to mention the fact that the bit pattern for a
<code>float</code> isn’t the same as that for a
<code>double</code>).</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: What’s the proper way to pronounce <code>char</code>? [p. 134]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: There’s no universally accepted pronunciation. Some people
pronounce <code>char</code> in the same way as the first syllable of
“character.” Others say “char.” as in</p>
<div class="sourceCode" id="cb370"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb370-1"><a href="#cb370-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> broiled<span class="op">;</span></span></code></pre></div>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: When does it matter whether a character variable is signed or
unsigned? [p. 136]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: If we store only 7-bit characters in the variable, it doesn’t
matter, since the sign bit will be zero. If we plan to store 8-bit
characters, however, we’ll probably want the variable to have
<code>unsigned char</code> type. Consider the following example:</p>
<div class="sourceCode" id="cb371"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> <span class="ch">&#39;\xdb&#39;</span><span class="op">;</span></span></code></pre></div>
<p>If <code>ch</code> has been declared to have type <code>char</code>,
the compiler may choose to treat it as a signed character (many
compilers do). As long as <code>ch</code> is used only as a character,
there won’t be any problem. But if <code>ch</code> is ever used in a
context that requires the compiler to convert its value to an integer,
we’re likely to have trouble: the resulting integer will be negative,
since <code>ch</code>’s sign bit is 1.</p>
<p>Here’s another situation: In some kinds of programs, it’s customary
to use <code>char</code> variables to store one-byte integers. If we’re
writing such a program, we’ll have to decide whether each variable
should be <code>signed char</code> or <code>unsigned char</code>, just
as we must decide whether ordinary integer variables should have type
<code>int</code> or <code>unsigned int</code>.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: I don’t understand how the new-line character can be the ASCII
line-feed character. When a user enters input and presses the Enter key,
doesn’t the program read this as a carriage-return character or a
carriage return plus a line feed? [p. 137]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Nope. As part of C’s UNIX heritage. it always regards the end of a
line as being marked by a single line-feed character. (In UNIX text
files, a single line-feed character—but no carriage return—appears at
the end of each line.) The C library takes care of translating the
user’s keypress into a line-feed character. When a program reads from a
file, the I/O library translates the file’s end-of-line marker (whatever
it may be) into a single line-feed character. The same transformations
occur—in reverse—when output is written to the screen or to a file. (See
Section 22.1 for details.)</p>
<p>Although these translations may seem confusing, they serve an
important purpose: insulating programs from details that may vary from
one operating system to another.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: What’s the purpose of the <code>\?</code> escape sequence?
[p. 138]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The <code>\?</code> escape is related to trigraph sequences, which
begin with <code>??</code>. If you should put <code>??</code> in a
string, there’s a possibility that the compiler will mistake it for the
beginning of a trigraph. Replacing the second <code>?</code> by
<code>\?</code> fixes the problem.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: If <code>getchar</code> is faster, why would we ever want to use
<code>scanf</code> to read individual characters? [p. 140]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Although it’s not as fast as <code>getchar</code>, the
<code>scanf</code> function is more flexible. As we saw previously, the
<code>"%c"</code> format string causes <code>scanf</code> to read the
next input character; <code>" %c"</code> causes it to read the next
non-white-space character. Also, <code>scanf</code> is good at reading
characters that are mixed in with other kinds of data. Let’s say that
our input data consists of an integer, then a single nonnumeric
character, then another integer. By using the format string
<code>"%d%c%d"</code>, we can get <code>scanf</code> to read all three
items.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Under what circumstances do the integral promotions convert a
character or short integer to <code>unsigned int</code>? [p. 143]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The integral promotions yield an <code>unsigned int</code> if the
<code>int</code> type isn’t large enough to include all possible values
of the original type. Since characters are usually eight bits long, they
are almost always converted to <code>int</code>, which is guaranteed to
be at least 16 bits long. Signed short integers can always be converted
to <code>int</code> as well. Unsigned short integers are problematic, If
short integers have the same length as ordinary integers (as they do on
a 16-bit machine), then <code>unsigned short</code> integers will have
to be converted to <code>unsigned int</code>, since the largest unsigned
short integer (65,535 on a 16-bit machine) is larger than the largest
<code>int</code> (32.767).</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Exactly what happens if I assign a value to a variable that’s not
large enough to hold it? [p. 146]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Roughly speaking, if the value is of an integral type and the
variable is of an <code>unsigned</code> type, the extra bits are thrown
aways if the variable has a <code>signed</code> type, the result is
implementation-defined. Assigning a floating-point number to a
variable—integer or floating—that’s too small to hold it produces
undefined behavior: anything can happen, including program
termination.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Why does C bother to provide type definitions? Isn’t defining a
<code>BOOL</code> macro just as good as defining a <code>Bool</code>
type using <code>typedef</code>? [p. 149]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: There are two important differences between type definitions and
macro definitions. First, type definitions are more powerful than macro
definitions. In particular, array and pointer types can’t be defined as
macros. Suppose that we try to use a macro to define a “pointer to
integer” type:</p>
<div class="sourceCode" id="cb372"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb372-1"><a href="#cb372-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define PTR_TO_INT int *</span></span></code></pre></div>
<p>The declaration</p>
<div class="sourceCode" id="cb373"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb373-1"><a href="#cb373-1" aria-hidden="true" tabindex="-1"></a>PTR_TO_INT p<span class="op">,</span> q<span class="op">,</span> r<span class="op">;</span></span></code></pre></div>
<p>will become</p>
<div class="sourceCode" id="cb374"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span> p<span class="op">,</span> g<span class="op">,</span> r<span class="op">;</span></span></code></pre></div>
<p>after preprocessing. Unfortunately, only <code>p</code> is a pointer:
<code>g</code> and <code>r</code> are ordinary integer variables. Type
definitions don’t have this problem.</p>
<p>Second, <code>typedef</code> names are subject to the same scope
rules as variables; a <code>typedef</code> name defined inside a
function body wouldn’t be recognized outside the function. Macro names,
on the other hand, are replaced by the preprocessor wherever they
appear.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: You said that compilers “can usually determine the value of a
<code>sizeof</code> expression.” Can’t a compiler always determine the
value of a <code>sizeof</code> expression? [p- 151]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: In C89, yes. In C99, however, there’s one exception. The compiler
can’t determine the size of a variable-length array, because the number
of elements in the array may change during the execution of the
program.</p>
</div>
<!-- END: div -->
<hr />
<h2 id="examples-5">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh07/cknkCh07Exmp/">./cknkCh07/cknkCh07Exmp/</a></li>
</ul>
<h2 id="exercises-5">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh07/cknkCh07Exrc/README.md">./cknkCh07/cknkCh07Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh07/cknkCh07Exrc/cknkCh07ExrcReadme.html">./cknkCh07/cknkCh07Exrc/cknkCh07ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh07/cknkCh07Exrc/">./cknkCh07/cknkCh07Exrc/</a></li>
</ul>
<h2 id="programming-projects-5">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh07/cknkCh07Prj/README.md">./cknkCh07/cknkCh07Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh07/cknkCh07Prj/cknkCh07PrjReadme.html">./cknkCh07/cknkCh07Prj/cknkCh07PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh07/cknkCh07Prj/">./cknkCh07/cknkCh07Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="arrays">8 Arrays</h1>
<!-- START: div -->
<div class="theQuote">
<p>If a program manipulates a large amount of data, it does so in a
small number of ways.</p>
</div>
<!-- END: div -->
<p>So far, the only variables we’ve seen are
<strong><em>scalar</em></strong>: capable of holding a single data item,
C also supports <strong><em>aggregate</em></strong> variables, which can
store collections of values. There are two kinds of aggregates in C:
arrays and structures. This chapter shows how to declare and use arrays,
both one-dimensional (Section 8.1) and multidimensional (Section 8.2).
Section 8.3 covers C99’s variable-length arrays. The focus of the
chapter is on one-dimensional arrays, which play a much bigger role in C
than do multidimensional arrays. Later chapters (Chapter 12 in
particular) provide additional information about arrays; Chapter 16
covers structures.</p>
<h2 id="one-dimensional-arrays">8.1 One-Dimensional Arrays</h2>
<p>An <strong><em>array</em></strong> is a data structure containing a
number of data values, all of which have the same type. These values,
known as <strong><em>elements</em></strong>, can be individually
selected by their position within the array.</p>
<p>The simplest kind of array has just one dimension. The elements of a
one dimensional array are conceptually arranged one after another in a
single row (or column, if you prefer). Here’s how we might visualize a
one-dimensional array named <code>a</code>:</p>
<figure>
<img src="images/dim1Array.jpg" alt="one dimensional array a" />
<figcaption aria-hidden="true">one dimensional array a</figcaption>
</figure>
<p>To declare an array, we must specify the type of the array’s elements
and the number of elements. For example, to declare that the array a has
10 elements of type <code>int</code>, we would write</p>
<div class="sourceCode" id="cb375"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span></code></pre></div>
<p>The elements of an array may be of any type; the length of the array
can be specified by any (integer) constant expression. Since array
lengths may need to be adjusted when the program is later changed, using
a macro to define the length of an array is an excellent practice:</p>
<div class="sourceCode" id="cb376"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N 10</span></span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb376-3"><a href="#cb376-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>N<span class="op">];</span></span></code></pre></div>
<h3 id="array-subscripting">8.1.1 Array Subscripting</h3>
<p><span class="QandA"></span></p>
<p>To access a particular element of an array, we write the array name
followed by an integer value in square brackets (this is referred to as
subscripting or indexing the array). Array elements are always numbered
starting from 0, so the elements of an array of length <code>n</code>
are indexed from 0 to <code>n - 1</code>. For example, if <code>a</code>
is an array with 10 elements, they’re designated by <code>a[0]</code>,
<code>a[1]</code>, …, <code>a[9]</code>, as the following figure
shows:</p>
<figure>
<img src="./images/arrSubscript.jpg" alt="Array subscripting" />
<figcaption aria-hidden="true">Array subscripting</figcaption>
</figure>
<p>Expressions of the form <code>a[i]</code> are lvalues, so they can be
used in the same way as ordinary variables:</p>
<div class="sourceCode" id="cb377"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb377-2"><a href="#cb377-2" aria-hidden="true" tabindex="-1"></a>printf <span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]);</span></span>
<span id="cb377-3"><a href="#cb377-3" aria-hidden="true" tabindex="-1"></a><span class="op">++</span>a<span class="op">[</span>i<span class="op">];</span></span></code></pre></div>
<p>In general, if an array contains elements of type <code>T</code>;
then each element of the array is treated as if it were a variable of
type <code>T</code>. In this example, the elements <code>a[0]</code>,
<code>a[5]</code>, and <code>a[i]</code> behave like <code>int</code>
variables.</p>
<p>Arrays and <code>for</code> loops go hand-in-hand. Many programs
contain <code>for</code> loops whose job is to perform some operation on
every element in an array. Here are a few examples of typical operations
on an array a of length <code>N</code>:</p>
<div class="sourceCode" id="cb378"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb378-1"><a href="#cb378-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb378-2"><a href="#cb378-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">/* clears a */</span></span></code></pre></div>
<div class="sourceCode" id="cb379"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb379-1"><a href="#cb379-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb379-2"><a href="#cb379-2" aria-hidden="true" tabindex="-1"></a>    scanf <span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>a<span class="op">[</span>i<span class="op">]);</span> <span class="co">/* reads data into a */</span></span></code></pre></div>
<div class="sourceCode" id="cb380"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb380-1"><a href="#cb380-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb380-2"><a href="#cb380-2" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">+=</span> a<span class="op">[</span>i<span class="op">];</span> <span class="co">/* sums the elements of a */</span></span></code></pre></div>
<p>Notice that we must use the <code>&amp;</code> symbol when calling
<code>scanf</code> to read an array element, just as we would with an
ordinary variable.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>C doesn’t require that subscript bounds be checked; if a subscript
goes out of range, the program’s behavior is undefined. One cause of a
subscript going out of bounds: forgetting that an array with
<code>n</code> elements is indexed from O to <code>n - 1</code>, not 1
to <code>n</code>. (As one of my professors liked to say, “In this
business, you’re always off by one.” He was right, of course.) The
following example illustrates a bizarre effect that can be caused by
this common blunder:</p>
<div class="sourceCode" id="cb381"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb381-1"><a href="#cb381-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">],</span> i<span class="op">;</span></span>
<span id="cb381-2"><a href="#cb381-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-3"><a href="#cb381-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb381-4"><a href="#cb381-4" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>With some compilers, this innocent-looking <code>for</code> statement
causes an infinite loop! When <code>i</code> reaches 10, the program
stores 0 into <code>a[10]</code>. But <code>a[10]</code> doesn’t exist,
so 0 goes into memory immediately after <code>a[9]</code>. If the
variable <code>i</code> happens to follow <code>a[9]</code> in memory—as
might be the case—then <code>i</code> will be reset to 0, causing the
loop to start over.</p>
</div>
<!-- END: div -->
<p>An array subscript may be any integer expression:</p>
<div class="sourceCode" id="cb382"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb382-1"><a href="#cb382-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">[</span>i <span class="op">+</span> j <span class="op">*</span> <span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>The expression can even have side effects:</p>
<div class="sourceCode" id="cb383"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb383-1"><a href="#cb383-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb383-2"><a href="#cb383-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> N<span class="op">)</span></span>
<span id="cb383-3"><a href="#cb383-3" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">++]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>Let’s trace this code. After <code>i</code> is set to 0, the
<code>while</code> statement checks whether <code>i</code> is less than
<code>N</code>. If it is, <code>O</code> is assigned to
<code>a[0]</code>, <code>i</code> is incremented, and the loop repeats.
Note that <code>a[++i]</code> wouldn’t be right, because 0 would be
assigned to <code>a[1]</code> during the first loop iteration.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Be careful when an array subscript has a side effect. For example,
the following loop—which is supposed to copy the elements of the array
<code>b</code> into the array <code>a</code> may not work properly:</p>
<div class="sourceCode" id="cb384"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb384-1"><a href="#cb384-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb384-2"><a href="#cb384-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> N<span class="op">)</span></span>
<span id="cb384-3"><a href="#cb384-3" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>i<span class="op">++];</span></span></code></pre></div>
<p>The expression <code>a[i] = b[i++]</code> accesses the value of
<code>i</code> and also modifies <code>i</code> elsewhere in the
expression, which—as we saw in Section 4.4—causes undefined behavior. Of
course, we can easily avoid the problem by removing the increment from
the subscript:</p>
<div class="sourceCode" id="cb385"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb385-1"><a href="#cb385-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb385-2"><a href="#cb385-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span></code></pre></div>
</div>
<!-- END: div -->
<h3 id="program-reversing-a-series-of-numbers">8.1.2 (PROGRAM) Reversing
a Series of Numbers</h3>
<p>Our first array program prompts the user to enter a series of
numbers, then writes the numbers in reverse order:</p>
<pre class="shell"><code>Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
In reverse order: 31 50 11 23 94 7 102 49 82 34</code></pre>
<p>Our strategy will be to store the numbers in an array as they’re
read, then go through the array backwards, printing the elements one by
one. In other words, we won’t actually reverse the elements in the
array, but we’ll make the user think we did.</p>
<div class="sourceCode" id="cb387"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb387-2"><a href="#cb387-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: reverse.c</span></span>
<span id="cb387-3"><a href="#cb387-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb387-4"><a href="#cb387-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Reverses a series of numbers */</span></span>
<span id="cb387-5"><a href="#cb387-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-6"><a href="#cb387-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb387-7"><a href="#cb387-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-8"><a href="#cb387-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N 10</span></span>
<span id="cb387-9"><a href="#cb387-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-10"><a href="#cb387-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb387-11"><a href="#cb387-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb387-12"><a href="#cb387-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span>N<span class="op">],</span> i<span class="op">;</span></span>
<span id="cb387-13"><a href="#cb387-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-14"><a href="#cb387-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter %d numbers: &quot;</span><span class="op">,</span> N<span class="op">);</span></span>
<span id="cb387-15"><a href="#cb387-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb387-16"><a href="#cb387-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb387-17"><a href="#cb387-17" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb387-18"><a href="#cb387-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb387-19"><a href="#cb387-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-20"><a href="#cb387-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;In reverse order:&quot;</span><span class="op">);</span></span>
<span id="cb387-21"><a href="#cb387-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> N <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="cb387-22"><a href="#cb387-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb387-23"><a href="#cb387-23" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot; %d&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb387-24"><a href="#cb387-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb387-25"><a href="#cb387-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb387-26"><a href="#cb387-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb387-27"><a href="#cb387-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb387-28"><a href="#cb387-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This program shows just how useful macros can be in conjunction with
arrays. The macro <code>N</code> is used four times in the program: in
the declaration of <code>a</code>, in the <code>printf</code> that
displays a prompt, and in both <code>for</code> loops. Should we later
decide to change the size of the array, we need only edit the definition
of <code>N</code> and recompile the program. Nothing else will need to
be altered; even the prompt will still be correct.</p>
<h3 id="array-initialization">8.1.3 Array Initialization</h3>
<p>An array, like any other variable, can be given an initial value at
the time it’s declared. The rules are somewhat tricky, though, so we’ll
cover some of them now and save others until later.</p>
<p>The most common form of array initializer is a list of constant
expressions enclosed in braces and separated by commas:</p>
<div class="sourceCode" id="cb388"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb388-1"><a href="#cb388-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">;</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">10</span><span class="op">};</span></span></code></pre></div>
<p>If the initializer is shorter than the array, the remaining elements
of the array are given the value 0:</p>
<div class="sourceCode" id="cb389"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb389-1"><a href="#cb389-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">={</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}</span> <span class="op">;</span></span>
<span id="cb389-2"><a href="#cb389-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* initial value of a is {1, 2, 3, 4, 5, 6, 0, 0, 0, 0} */</span></span></code></pre></div>
<p>Using this feature, we can easily initialize an array to all
zeros:</p>
<div class="sourceCode" id="cb390"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb390-1"><a href="#cb390-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">}:</span></span>
<span id="cb390-2"><a href="#cb390-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* initdal value of a is {0, 0, 0, 0, 0, 0, 0, O, 0, 0} */</span></span></code></pre></div>
<p>1t’s illegal for an initializer to be completely empty, so we’ve put
a single 0 inside the braces. It’s also illegal for an initializer to be
longer than the array it initializes.</p>
<p>If an initializer is present, the length of the array may be
omitted:</p>
<div class="sourceCode" id="cb391"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">10</span><span class="op">};</span></span></code></pre></div>
<p>The compiler uses the length of the initializer to determine how long
the array is. The array still has a fixed number of elements (10, in
this example), just as if we had specified the length explicitly.</p>
<p><span class="C99Symbol"></span></p>
<h3 id="designated-initializers">8.1.4 Designated Initializers</h3>
<p>It’s often the case that relatively few elements of an array need to
be initialized explicitly: the other elements can be given default
values. Consider the following example:</p>
<div class="sourceCode" id="cb392"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">15</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">29</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">48</span><span class="op">}:</span></span></code></pre></div>
<p>We want element 2 of the array to be 29, element 9 to be 7, and
element 14 to be 48, but the other values are just zero. For a large
array, writing an initializer in this fashion is tedious and error-prone
(what if there were 200 zeros between two of the nonzero values?).</p>
<p>C99’s <strong><em>designated initializers</em></strong> can be used
to solve this problem. Here’s how we could redo the previous example
using a designated initializer:</p>
<div class="sourceCode" id="cb393"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">15</span><span class="op">]</span> <span class="op">=</span> <span class="op">{[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">29</span><span class="op">,</span> <span class="op">[</span><span class="dv">9</span><span class="op">]</span> <span class="op">=</span> <span class="dv">7</span><span class="op">,</span> <span class="op">[</span><span class="dv">14</span><span class="op">]</span> <span class="op">=</span> <span class="dv">48</span><span class="op">};</span></span></code></pre></div>
<p>Each number in brackets is said to be a
<strong><em>designator</em></strong>.</p>
<p>Besides being shorter and easier to read (at least for some arrays),
designated initializers have another advantage: the order in which the
elements are listed no longer matters. Thus, our previous example could
also be written in the following way:</p>
<div class="sourceCode" id="cb394"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">15</span><span class="op">]</span> <span class="op">=</span> <span class="op">{[</span><span class="dv">14</span><span class="op">]</span> <span class="op">=</span> <span class="dv">48</span><span class="op">,</span> <span class="op">[</span><span class="dv">9</span><span class="op">]</span> <span class="op">=</span> <span class="dv">7</span><span class="op">,</span> <span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">29</span><span class="op">};</span></span></code></pre></div>
<p>Designators must be integer constant expressions. If the array being
initialized has length <code>n</code>, each designator must be between 0
and <code>n — 1</code>. However, if the length of the array is omitted,
a designator can be any nonnegative integer. In the latter case, the
compiler will deduce the length of the array from the largest
designator.</p>
<p>In the following example, the fact that 23 appears as a designator
will force the array to have length 24:</p>
<div class="sourceCode" id="cb395"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b<span class="op">[]</span> <span class="op">=</span> <span class="op">{[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> <span class="op">[</span><span class="dv">23</span><span class="op">]</span> <span class="op">=</span> <span class="dv">13</span><span class="op">,</span> <span class="op">[</span><span class="dv">11</span><span class="op">]</span> <span class="op">=</span> <span class="dv">36</span><span class="op">,</span> <span class="op">[</span><span class="dv">15</span><span class="op">]</span> <span class="op">=</span> <span class="dv">29</span><span class="op">};</span></span></code></pre></div>
<p>An initializer may use both the older (element-by-element) technique
and the newer (designated) technique:</p>
<div class="sourceCode" id="cb396"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb396-1"><a href="#cb396-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> c<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="op">[</span><span class="dv">8</span><span class="op">]</span> <span class="op">=</span> <span class="dv">6</span><span class="op">);</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>This initializer specifies that the array’s first three elements will
be 5, 1, and 9. Element 4 will have the value 3. The two elements after
element 4 will be 7 and 2. Finally, element 8 will have the value 6. All
elements for which no value is specified will default to zero.</p>
<h3 id="program-checking-a-number-for-repeated-digits">8.1.5 (PROGRAM)
Checking a Number for Repeated Digits</h3>
<p>Our next program checks whether any of the digits in a number appear
more than once. After the user enters a number, the program prints
either <code>Repeated digit</code> or
<code>No repeated digit</code>:</p>
<pre class="shell"><code>Enter a number: 28212
Repeated digit</code></pre>
<p>The number 28212 has a repeated digit (2); a number like 9357
doesn’t.</p>
<p>The program uses an array of Boolean values to keep track of which
digits appear in a number. The array, named <code>digit_seen</code>, is
indexed from 0 to 9 to correspond to the 10 possible digits. Initially,
every element of the array is false. (The initializer for
<code>digit_seen</code> is {<code>false</code>}, which only initializes
the first element of the array. However, the compiler will automatically
make the remaining elements zero, which is equivalent to false.)</p>
<p>When given a number <code>n</code>, the program examines
<code>n</code>’s digits one at a time, storing each into the
<code>digit</code> variable and then using it as an index into
<code>digit_seen</code>. If <code>digit_seen[digit]</code> is true, then
digit appears at least twice in <code>n</code>. On the other hand, if
<code>digit_seen[digit]</code> is false, then digit has not been seen
before, so the program sets <code>digit_seen[digit]</code> to
<code>true</code> and keeps going.</p>
<div class="sourceCode" id="cb398"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb398-2"><a href="#cb398-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file:repdigit.c</span></span>
<span id="cb398-3"><a href="#cb398-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb398-4"><a href="#cb398-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Checks numbers for repeated digits */</span></span>
<span id="cb398-5"><a href="#cb398-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-6"><a href="#cb398-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb398-7"><a href="#cb398-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb398-8"><a href="#cb398-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-9"><a href="#cb398-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb398-10"><a href="#cb398-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb398-11"><a href="#cb398-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> digit_seen<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span>false<span class="op">};</span></span>
<span id="cb398-12"><a href="#cb398-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> digit<span class="op">;</span></span>
<span id="cb398-13"><a href="#cb398-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> n<span class="op">;</span></span>
<span id="cb398-14"><a href="#cb398-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-15"><a href="#cb398-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter a number: &quot;</span><span class="op">);</span></span>
<span id="cb398-16"><a href="#cb398-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%ld&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb398-17"><a href="#cb398-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-18"><a href="#cb398-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb398-19"><a href="#cb398-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb398-20"><a href="#cb398-20" aria-hidden="true" tabindex="-1"></a>        digit <span class="op">=</span> n <span class="op">%</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb398-21"><a href="#cb398-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>digit_seen<span class="op">[</span>digit<span class="op">])</span></span>
<span id="cb398-22"><a href="#cb398-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb398-23"><a href="#cb398-23" aria-hidden="true" tabindex="-1"></a>        digit_seen<span class="op">[</span>digit<span class="op">]</span> <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb398-24"><a href="#cb398-24" aria-hidden="true" tabindex="-1"></a>        n <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb398-25"><a href="#cb398-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb398-26"><a href="#cb398-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-27"><a href="#cb398-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb398-28"><a href="#cb398-28" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Repeated digit</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb398-29"><a href="#cb398-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb398-30"><a href="#cb398-30" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;No repeated digit</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb398-31"><a href="#cb398-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-32"><a href="#cb398-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb398-33"><a href="#cb398-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><span class="C99Symbol"></span></p>
<p>This program uses the names <code>bool</code>, <code>true</code>, and
<code>false</code>, which are defined in C99’s
<code>&lt;stdbool.h&gt;</code> header. If your compiler doesn’t support
this header, you’ll need to define these names yourself. One way to do
so is to put the following lines above the <code>main</code>
function:</p>
<div class="sourceCode" id="cb399"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define true 1</span></span>
<span id="cb399-2"><a href="#cb399-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define false 0</span></span>
<span id="cb399-3"><a href="#cb399-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="dt">bool</span><span class="op">;</span></span></code></pre></div>
<p>Notice that <code>n</code> has type <code>long</code>, allowing the
user fo enter numbers up to 2,147,483,647 (or more, on some
machines).</p>
<h3 id="using-the-sizeof-operator-with-arrays">8.1.6 Using the sizeof
Operator with Arrays</h3>
<p>The <code>sizeof</code> operator can determine the size of an array
(in bytes). If <code>a</code> is an array of 10 integers, then
<code>sizeof (a)</code> is typically 40 (assuming that each integer
requires four bytes).</p>
<p>We can also use <code>sizeof</code> to measure the size of an array
element, such as <code>a[0]</code>. Dividing the array size by the
element size gives the length of the array:</p>
<div class="sourceCode" id="cb400"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true" tabindex="-1"></a><span class="kw">sizeof</span><span class="op">(</span>a<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">[</span>l0<span class="op">])</span></span></code></pre></div>
<p>Some programmers use this expression when the length of the array is
needed. To clear the array <code>a</code>, for example, we could
write</p>
<div class="sourceCode" id="cb401"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">[</span><span class="dv">0</span><span class="op">]);</span> i<span class="op">++)</span></span>
<span id="cb401-2"><a href="#cb401-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>With this technique, the loop doesn’t have to be modified if the
array length should change at a later date. Using a macro to represent
the array length has the same advantage, of course, but the
<code>sizeof</code> technique is slightly better, since there’s no macro
name to remember (and possibly get wrong).</p>
<p>One minor annoyance is that some compilers produce a warning message
for the expression <code>i &lt; sizeof (a) / sizeof (a[0])</code>. The
variable <code>i</code> probably has type <code>int</code> (a signed
type), whereas <code>sizeof</code> produces a value of type
<code>size_t</code> (an unsigned type). We know from Section 7.4 that
comparing a signed integer with an unsigned integer is a dangerous
practice, although in this case it’s safe because both <code>i</code>
and <code>sizeof (a) / sizeof (a[0])</code> have nonnegative values. To
avoid a warning, we can add a cast that converts
<code>sizeof (a) / sizeof (a[0])</code> to a signed integer:</p>
<div class="sourceCode" id="cb402"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>a<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">[</span><span class="dv">0</span><span class="op">]));</span> i<span class="op">++)</span></span>
<span id="cb402-2"><a href="#cb402-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>Writing <code>(int) (sizeof (a) / sizeof (a[0]))</code> is a bit
unwieldy; defining a macro that represents it is often helpful:</p>
<div class="sourceCode" id="cb403"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SIZE ((int) (sizeof(a) / sizeof(a[0])))</span></span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> SIZE<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb403-4"><a href="#cb403-4" aria-hidden="true" tabindex="-1"></a>a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>If we’re back to using a macro, though, what’s the advantage of
sizeof`? We’ll answer that question in a later chapter (the trick is to
add a parameter to the macro).</p>
<h3 id="program-computing-interest">8.1.7 (PROGRAM) Computing
Interest</h3>
<p>Our next program prints a table showing the value of $100 invested at
different rates of interest over a period of years. The user will enter
an interest rate and the number of years the money will be invested. The
table will show the value of the money at one-year intervals—at that
interest rate and the next four higher rates—assuming that interest is
compounded once a year. Here’s what a session with the program will look
like:</p>
<pre class="shell"><code>Enter interest rate: 6
Enter number of years: 5

Years     6%     7%     8%     9%    10%
  1     106.00 107.00 108.00 108.00 110.00
  2     112.36 114.49 116.64 118.81 121.00
  3     119.10 122.50 125.97 129.50 133.10
  4     126.25 131.08 136.05 141.16 146.41
  5     133.82 140.26 146.93 153.86 161.05</code></pre>
<p>Clearly, we can use a <code>for</code> statement to print the first
row. The second row is a little trickier, since its values depend on the
numbers in the first row. Our solution is to store the first row in an
array as it’s computed, then use the values in the array to compute the
second row. Of course, this process can be repeated for the third and
later rows. We’ll end up with two <code>for</code> statements, one
nested inside the other. The outer loop will count from 1 to the number
of years requested by the user. The inner loop will increment the
interest rate from its lowest value to its highest value.</p>
<div class="sourceCode" id="cb405"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb405-2"><a href="#cb405-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: interest.c</span></span>
<span id="cb405-3"><a href="#cb405-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb405-4"><a href="#cb405-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a tablet of compound interest */</span></span>
<span id="cb405-5"><a href="#cb405-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-6"><a href="#cb405-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb405-7"><a href="#cb405-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-8"><a href="#cb405-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NUM_RATES ((int) (sizeof(value) / sizeof(value[0])))</span></span>
<span id="cb405-9"><a href="#cb405-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INITIAL_BALANCE 100.00</span></span>
<span id="cb405-10"><a href="#cb405-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-11"><a href="#cb405-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb405-12"><a href="#cb405-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb405-13"><a href="#cb405-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> low_rate<span class="op">,</span> num_years<span class="op">,</span> year<span class="op">;</span></span>
<span id="cb405-14"><a href="#cb405-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> value<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb405-15"><a href="#cb405-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-16"><a href="#cb405-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter interest rate: &quot;</span><span class="op">);</span></span>
<span id="cb405-17"><a href="#cb405-17" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>low_rate<span class="op">);</span></span>
<span id="cb405-18"><a href="#cb405-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter number of years: &quot;</span><span class="op">);</span></span>
<span id="cb405-19"><a href="#cb405-19" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num_years<span class="op">);</span></span>
<span id="cb405-20"><a href="#cb405-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-21"><a href="#cb405-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Years&quot;</span><span class="op">);</span></span>
<span id="cb405-22"><a href="#cb405-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> NUM_RATES<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb405-23"><a href="#cb405-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb405-24"><a href="#cb405-24" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%6d%%&quot;</span><span class="op">,</span> low_rate <span class="op">+</span> i<span class="op">);</span></span>
<span id="cb405-25"><a href="#cb405-25" aria-hidden="true" tabindex="-1"></a>        value<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INITIAL_BALANCE<span class="op">;</span></span>
<span id="cb405-26"><a href="#cb405-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb405-27"><a href="#cb405-27" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb405-28"><a href="#cb405-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-29"><a href="#cb405-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>year <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> year <span class="op">&lt;=</span> num_years<span class="op">;</span> year<span class="op">++)</span></span>
<span id="cb405-30"><a href="#cb405-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb405-31"><a href="#cb405-31" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%3d    &quot;</span><span class="op">,</span> year<span class="op">);</span></span>
<span id="cb405-32"><a href="#cb405-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> NUM_RATES<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb405-33"><a href="#cb405-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb405-34"><a href="#cb405-34" aria-hidden="true" tabindex="-1"></a>            value<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> <span class="op">(</span>low_rate <span class="op">+</span> i<span class="op">)</span> <span class="op">/</span> <span class="fl">100.0</span> <span class="op">*</span> value<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb405-35"><a href="#cb405-35" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;%7.2f&quot;</span><span class="op">,</span> value<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb405-36"><a href="#cb405-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb405-37"><a href="#cb405-37" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb405-38"><a href="#cb405-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb405-39"><a href="#cb405-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-40"><a href="#cb405-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb405-41"><a href="#cb405-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note the use of <code>NUM_RATES</code> to control two of the
<code>for</code> loops. If we later change the size of the value array.
the loops will adjust automatically.</p>
<h2 id="multidimensional-arrays">8.2 Multidimensional Arrays</h2>
<p>An array may have any number of dimensions. For example, the
following declaration creates a two-dimensional array (a
<em>matrix</em>, in mathematical terminology):</p>
<div class="sourceCode" id="cb406"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> m<span class="op">[</span><span class="dv">5</span><span class="op">][</span><span class="dv">9</span><span class="op">];</span></span></code></pre></div>
<p>The array <code>m</code> has 5 rows and 9 columns. Both rows and
columns are indexed from 0, as the following figure shows:</p>
<figure>
<img src="./images/multidimeArr.jpg" alt="multi-dimensional array" />
<figcaption aria-hidden="true">multi-dimensional array</figcaption>
</figure>
<p>To access the element of <code>m</code> in row <code>i</code>, column
<code>j</code>, we must write <code>m[1][j]</code>. The expression
<code>m[i]</code> designates row <code>i</code> of <code>m</code>, and
<code>m[i][j]</code> then selects element <code>j</code> in this
row.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Resist the temptation to write <code>m[i, j]</code> instead of
<code>m[i][j]</code>. C treats the comma as an operator in this context,
so <code>m[i, j]</code> is the same as m[j].</p>
</div>
<!-- END: div -->
<p>Although we visualize two-dimensional arrays as tables, that’s not
the way they’re actually stored in computer memory. C stores arrays in
<strong><em>row-major order</em></strong>, with row 0 first, then row 1,
and so forth. For example, here’s how the <code>m</code> array is
stored:</p>
<figure>
<img src="./images/multiDimArr_row.jpg"
alt="multi-dimensional array: row-major order" />
<figcaption aria-hidden="true">multi-dimensional array: row-major
order</figcaption>
</figure>
<p>We’ll usually ignore this detail, but sometimes it will affect our
code.</p>
<p>Just as <code>for</code> loops go hand-in-hand with one-dimensional
arrays, nested for loops are ideal for processing multidimensional
arrays. Consider, for example, the problem of initializing an array for
use as an identity matrix. (In mathematics, an <em>identity matrix</em>
has 1’s on the main diagonal, where the row and column index are the
same, and 0’s everywhere else.) We’ll need to visit each element in the
array in some systematic fashion. A pair of nested <code>for</code>
loops—one that steps through every row index and one that steps through
each column index—is perfect for the job:</p>
<div class="sourceCode" id="cb407"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N 10</span></span>
<span id="cb407-2"><a href="#cb407-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-3"><a href="#cb407-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> ident<span class="op">[</span>N<span class="op">][</span>N<span class="op">];</span></span>
<span id="cb407-4"><a href="#cb407-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> row<span class="op">,</span> col<span class="op">;</span></span>
<span id="cb407-5"><a href="#cb407-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-6"><a href="#cb407-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>row <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> row <span class="op">&lt;</span> N<span class="op">;</span> row<span class="op">++)</span></span>
<span id="cb407-7"><a href="#cb407-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>col <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> col <span class="op">&lt;</span> N<span class="op">;</span> col<span class="op">++)</span></span>
<span id="cb407-8"><a href="#cb407-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>row <span class="op">==</span> col<span class="op">)</span></span>
<span id="cb407-9"><a href="#cb407-9" aria-hidden="true" tabindex="-1"></a>            ident<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb407-10"><a href="#cb407-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb407-11"><a href="#cb407-11" aria-hidden="true" tabindex="-1"></a>            ident<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span></code></pre></div>
<p>Multidimensional arrays play a lesser role in C than in many other
programming languages, primarily because C provides a more flexible way
to store multidimensional data: arrays of pointers.</p>
<h3 id="initializing-a-multidimensional-array">8.2.1 Initializing a
Multidimensional Array</h3>
<p>We can create an initializer for a two-dimensional array by nesting
one-dimensional initializers:</p>
<div class="sourceCode" id="cb408"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> m<span class="op">[</span><span class="dv">5</span><span class="op">][</span><span class="dv">9</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb408-2"><a href="#cb408-2" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb408-3"><a href="#cb408-3" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb408-4"><a href="#cb408-4" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb408-5"><a href="#cb408-5" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">}};</span></span></code></pre></div>
<p>Each inner initializer provides values for one row of the matrix.
Initializers for higher-dimensional arrays are constructed in a similar
fashion.</p>
<p>C provides a variety of ways to abbreviate initializers for
multidimensional arrays:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>If an initializer isn’t large enongh to fill a multidimensional
array, the remaining elements are given the value 0. For example, the
following initializer fills only the first three rows of <code>m</code>:
the last two rows will contain zeros:</p>
<div class="sourceCode" id="cb409"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> m<span class="op">[</span><span class="dv">5</span><span class="op">][</span><span class="dv">9</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb409-2"><a href="#cb409-2" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb409-3"><a href="#cb409-3" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">}};</span></span></code></pre></div>
</li>
<li>
<p>If an inner list isn’t long enough to fill a row, the remaining
elements in the row are initialized to 0:</p>
<div class="sourceCode" id="cb410"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> m<span class="op">[</span><span class="dv">5</span><span class="op">][</span><span class="dv">9</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb410-2"><a href="#cb410-2" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb410-3"><a href="#cb410-3" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb410-4"><a href="#cb410-4" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb410-5"><a href="#cb410-5" aria-hidden="true" tabindex="-1"></a>               <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">}};</span></span></code></pre></div>
</li>
<li>
<p>We can even omit the inner braces:</p>
<div class="sourceCode" id="cb411"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> m<span class="op">[</span><span class="dv">5</span><span class="op">][</span><span class="dv">9</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb411-2"><a href="#cb411-2" aria-hidden="true" tabindex="-1"></a>               <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb411-3"><a href="#cb411-3" aria-hidden="true" tabindex="-1"></a>               <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb411-4"><a href="#cb411-4" aria-hidden="true" tabindex="-1"></a>               <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb411-5"><a href="#cb411-5" aria-hidden="true" tabindex="-1"></a>               <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span></code></pre></div>
<p>Once the compiler has seen enough values to fill one row, it begins
filling the next.</p>
</li>
</ul>
<!-- END: unordered-list -->
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Omitting the inner braces in a multidimensional array initializer can
be risky, since an extra element (or even worse, a missing element) will
affect the rest of the initializer, Leaving out the braces causes some
compilers to produce a warning message such as “missing braces around
initializer.”</p>
</div>
<!-- END: div -->
<p><span class="C99"></span></p>
<p>C99’s designated initializers work with multidimensional arrays. For
example, we could create a 2 x 2 identity matrix as follows:</p>
<div class="sourceCode" id="cb412"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> ident<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span><span class="op">,</span> <span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span><span class="op">};</span></span></code></pre></div>
<p>As usual, all elements for which no value is specified will default
to zero.</p>
<h3 id="constant-arrays">8.2.2 Constant Arrays</h3>
<p>Any array, whether one-dimensional or multidimensional, can be made
“constant” by starting its declaration with the word
<code>const</code>:</p>
<div class="sourceCode" id="cb413"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">char</span> hex chars<span class="op">[]</span> <span class="op">=</span></span>
<span id="cb413-2"><a href="#cb413-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="ch">&#39;0&#39;</span><span class="op">,</span> <span class="ch">&#39;1&#39;</span><span class="op">,</span> <span class="ch">&#39;2&#39;</span><span class="op">,</span> <span class="ch">&#39;3&#39;</span><span class="op">,</span> <span class="ch">&#39;4&#39;</span><span class="op">,</span> <span class="ch">&#39;5&#39;</span><span class="op">,</span> <span class="ch">&#39;6&#39;</span><span class="op">,</span> <span class="ch">&#39;7&#39;</span><span class="op">,</span> <span class="ch">&#39;8&#39;</span><span class="op">,</span> <span class="ch">&#39;9&#39;</span><span class="op">,</span> <span class="ch">&#39;A&#39;</span><span class="op">,</span> <span class="ch">&#39;B&#39;</span><span class="op">,</span> <span class="ch">&#39;C&#39;</span><span class="op">,</span> <span class="ch">&#39;D&#39;</span><span class="op">,</span> <span class="ch">&#39;E&#39;</span><span class="op">,</span> <span class="ch">&#39;F&#39;</span><span class="op">};</span></span></code></pre></div>
<p>An array that’s been declared <code>const</code> should not be
modified by the program: the compiler will detect direct attempts to
modify an element.</p>
<p>Declaring an array to be <code>const</code> has a couple of primary
advantages. It documents that the program won’t change the array, which
can be valuable information for someone reading the code later. It also
helps the compiler catch errors, by informing it that we don’t intend to
modify the array.</p>
<p><code>const</code> isn’t limited to arrays; it works with any
variable, as we’ll see later. However, <code>const</code> is
particularly useful in array declarations, because arrays may contain
reference information that won’t change during program execution.</p>
<h3 id="program-dealing-a-hand-of-cards">8.2.3 (PROGRAM) Dealing a Hand
of Cards</h3>
<p>Our next program illustrates both two-dimensional arrays and constant
arrays. The program deals a random hand from a standard deck of playing
cards. (In case you haven’t had time to play games recently, each card
in a standard deck has a <em>suit</em>–clubs, diamonds, hearts, or
spades—and a <em>rank</em>—two, three, four, five, six, seven, eight,
nine, ten, jack. queen, king, or ace.) We’ll have the user specify how
many cards should be in the hand:</p>
<div class="sourceCode" id="cb414"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true" tabindex="-1"></a>Enter number of cards in hand<span class="op">:</span> <span class="dv">5</span></span>
<span id="cb414-2"><a href="#cb414-2" aria-hidden="true" tabindex="-1"></a>Your hand<span class="op">:</span> <span class="dv">7</span><span class="er">c</span> <span class="dv">2</span><span class="er">s</span> <span class="dv">5</span><span class="er">d</span> as <span class="dv">2</span><span class="er">h</span></span></code></pre></div>
<p>It’s not immediately obvious how we’d write such a program. How do we
pick cards randomly from the deck? And how do we avoid picking the same
card twice? Let’s tackle these problems separately.</p>
<p>To pick cards randomly, we’ll use several C library functions. The
<code>time</code> function (from <code>&lt;time.h&gt;</code>) returns
the current time, encoded in a single number. The <code>srand</code>
function (from <code>&lt;stdlib.h&gt;</code>) initializes C’s random
number generator. Passing the return value of time to <code>srand</code>
prevents the program from dealing the same cards every time we run it.
The <code>rand</code> function (also from <code>&lt;stdlib.h&gt;</code>)
produces an apparently random number each time it’s called. By using the
<code>%</code> operator, we can scale the return value from rand so that
it falls between 0 and 3 (for suits) or between 0 and 12 (for
ranks).</p>
<p>To avoid picking the same card twice, we’ll need to keep track of
which cards have already been chosen. For that purpose, we’ll use an
array named <code>in_hand</code> that has four rows (one for each suit)
and 13 columns (one for each rank). In other words, each element in the
array corresponds to one of the 52 cards in the deck. All elements of
the array will be false to start with. Each time we pick a card at
random, we’ll check whether the element of <code>in_hand</code>
corresponding to that card is true or false. If it’s true, we’ll have to
pick another card. If it’s false, we’ll store true in that card’s array
element to remind us later that this card has already been picked.</p>
<p>Once we’ve verified that a card is “new”—not already selected—we’ll
need to translate its numerical rank and suit into characters and then
display the card. To translate the rank and suit to character form,
we’ll set up two arrays of characters—one for the rank and one for the
suit—and then use the numbers to subscript the arrays. These arrays
won’t change during program execution, so we may as well declare them to
be <code>const</code>.</p>
<div class="sourceCode" id="cb415"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: deal.c</span></span>
<span id="cb415-3"><a href="#cb415-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb415-4"><a href="#cb415-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Deals a random hand of cards */</span></span>
<span id="cb415-5"><a href="#cb415-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-6"><a href="#cb415-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb415-7"><a href="#cb415-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb415-8"><a href="#cb415-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb415-9"><a href="#cb415-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;time.h&gt;</span></span>
<span id="cb415-10"><a href="#cb415-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-11"><a href="#cb415-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NUM_SUITS 4</span></span>
<span id="cb415-12"><a href="#cb415-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NUM_RANKS 13</span></span>
<span id="cb415-13"><a href="#cb415-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-14"><a href="#cb415-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb415-15"><a href="#cb415-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb415-16"><a href="#cb415-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> in_hand<span class="op">[</span>NUM_SUITS<span class="op">][</span>NUM_RANKS<span class="op">]</span> <span class="op">=</span> <span class="op">{</span>false<span class="op">};</span></span>
<span id="cb415-17"><a href="#cb415-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_cards<span class="op">,</span> rank<span class="op">,</span> suit<span class="op">;</span></span>
<span id="cb415-18"><a href="#cb415-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> rank_code<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;2&#39;</span><span class="op">,</span> <span class="ch">&#39;3&#39;</span><span class="op">,</span> <span class="ch">&#39;4&#39;</span><span class="op">,</span> <span class="ch">&#39;5&#39;</span><span class="op">,</span> <span class="ch">&#39;6&#39;</span><span class="op">,</span> <span class="ch">&#39;7&#39;</span><span class="op">,</span> <span class="ch">&#39;8&#39;</span><span class="op">,</span> <span class="ch">&#39;9&#39;</span><span class="op">,</span> <span class="ch">&#39;t&#39;</span><span class="op">,</span> <span class="ch">&#39;j&#39;</span><span class="op">,</span> <span class="ch">&#39;q&#39;</span><span class="op">,</span> <span class="ch">&#39;k&#39;</span><span class="op">,</span> <span class="ch">&#39;a&#39;</span><span class="op">};</span></span>
<span id="cb415-19"><a href="#cb415-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> suit_code<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;c&#39;</span><span class="op">,</span> <span class="ch">&#39;d&#39;</span><span class="op">,</span> <span class="ch">&#39;h&#39;</span><span class="op">,</span> <span class="ch">&#39;s&#39;</span><span class="op">};</span></span>
<span id="cb415-20"><a href="#cb415-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-21"><a href="#cb415-21" aria-hidden="true" tabindex="-1"></a>    srand<span class="op">((</span><span class="dt">unsigned</span><span class="op">)</span> time<span class="op">(</span>NULL<span class="op">));</span></span>
<span id="cb415-22"><a href="#cb415-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-23"><a href="#cb415-23" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter number of cards in hand: &quot;</span><span class="op">);</span></span>
<span id="cb415-24"><a href="#cb415-24" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num_cards<span class="op">);</span></span>
<span id="cb415-25"><a href="#cb415-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-26"><a href="#cb415-26" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Your hand: &quot;</span><span class="op">);</span></span>
<span id="cb415-27"><a href="#cb415-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>num_cards <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb415-28"><a href="#cb415-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb415-29"><a href="#cb415-29" aria-hidden="true" tabindex="-1"></a>        suit <span class="op">=</span> rand<span class="op">()</span> <span class="op">%</span> NUM_SUITS<span class="op">;</span>    <span class="co">/* picks a random suit */</span></span>
<span id="cb415-30"><a href="#cb415-30" aria-hidden="true" tabindex="-1"></a>        rank <span class="op">=</span> rand<span class="op">()</span> <span class="op">%</span> NUM_RANKS<span class="op">;</span>    <span class="co">/* picks a random rank */</span></span>
<span id="cb415-31"><a href="#cb415-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>in_hand<span class="op">[</span>suit<span class="op">][</span>rank<span class="op">])</span></span>
<span id="cb415-32"><a href="#cb415-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb415-33"><a href="#cb415-33" aria-hidden="true" tabindex="-1"></a>            in_hand<span class="op">[</span>suit<span class="op">][</span>rank<span class="op">]</span> <span class="op">=</span> true<span class="op">;</span></span>
<span id="cb415-34"><a href="#cb415-34" aria-hidden="true" tabindex="-1"></a>            num_cards<span class="op">--;</span></span>
<span id="cb415-35"><a href="#cb415-35" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot; %c%c&quot;</span><span class="op">,</span> rank_code<span class="op">[</span>rank<span class="op">],</span> suit_code<span class="op">[</span>suit<span class="op">]);</span></span>
<span id="cb415-36"><a href="#cb415-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb415-37"><a href="#cb415-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb415-38"><a href="#cb415-38" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb415-39"><a href="#cb415-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-40"><a href="#cb415-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb415-41"><a href="#cb415-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice the initializer for the <code>in_hand</code> array:</p>
<div class="sourceCode" id="cb416"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> in_hand<span class="op">[</span>NUM_SUITS<span class="op">][</span>NUM_RANKS<span class="op">]</span> <span class="op">=</span> <span class="op">{</span>false<span class="op">};</span></span></code></pre></div>
<p>Even though <code>in_hand</code> is a two-dimensional array, we can
use a single pair of braces (at the risk of possibly incurring a warning
from the compiler). Also, we’ve supplied only one value in the
initializer, knowing that the compiler will fill in 0 (false) for the
other elements.</p>
<h2 id="variable-length-arrays-c99">8.3 Variable-Length Arrays
(C99)</h2>
<p>Section 8.1 stated that the length of an array variable must be
specified by a constant expression. In C99, however. it’s sometimes
possible to use an expression that’s <em>not</em> constant. The
following modification of the <code>reverse.c</code> program (Section
8.1) illustrates this ability:</p>
<div class="sourceCode" id="cb417"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: reverse2.c</span></span>
<span id="cb417-3"><a href="#cb417-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb417-4"><a href="#cb417-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Reverses a series of numbers using variable-length array - C99 only */</span></span>
<span id="cb417-5"><a href="#cb417-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb417-6"><a href="#cb417-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb417-7"><a href="#cb417-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb417-8"><a href="#cb417-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb417-9"><a href="#cb417-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb417-10"><a href="#cb417-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> n<span class="op">;</span></span>
<span id="cb417-11"><a href="#cb417-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb417-12"><a href="#cb417-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;How many numbers do you want to reverse?: &quot;</span><span class="op">);</span></span>
<span id="cb417-13"><a href="#cb417-13" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb417-14"><a href="#cb417-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb417-15"><a href="#cb417-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span>n<span class="op">];</span>    <span class="co">/* C99 only - length of array depends on n */</span></span>
<span id="cb417-16"><a href="#cb417-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb417-17"><a href="#cb417-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter %d numbers: &quot;</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb417-18"><a href="#cb417-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb417-19"><a href="#cb417-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb417-20"><a href="#cb417-20" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb417-21"><a href="#cb417-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb417-22"><a href="#cb417-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb417-23"><a href="#cb417-23" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;In reverse order:&quot;</span><span class="op">);</span></span>
<span id="cb417-24"><a href="#cb417-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span></span>
<span id="cb417-25"><a href="#cb417-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb417-26"><a href="#cb417-26" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot; %d&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb417-27"><a href="#cb417-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb417-28"><a href="#cb417-28" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb417-29"><a href="#cb417-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb417-30"><a href="#cb417-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb417-31"><a href="#cb417-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The array <code>a</code> in this program is an example of a
variable-length array (or <strong><em>VLA</em></strong> for short). The
length of a VLA is computed when the program is executed, not when the
program is compiled. The chief advantage of a VLA is that the programmer
doesn’t have to pick an arbitrary length when declaring an array:
instead, the program itself can calculate exactly how many elements are
needed. If the programmer makes the choice, it’s likely that the array
will be too long (wasting memory) or too short (causing the program to
fail). In the <code>reverse2.c</code> program, the number entered by the
user determines the length of <code>a</code>: the programmer doesn’t
have to choose a fixed length, unlike in the original version of the
program.</p>
<p>The length of a VLA doesn’t have to be specified by a single
variable. Arbitrary expressions, possibly containing operators, are also
legal. For example:</p>
<div class="sourceCode" id="cb418"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">5</span><span class="op">];</span></span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b<span class="op">[</span>j <span class="op">+</span> k<span class="op">];</span></span></code></pre></div>
<p>Like other arrays, VLAs can be multidimensional:</p>
<div class="sourceCode" id="cb419"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> c<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span></code></pre></div>
<p>The primary restriction on VLAs is that they can’t have static
storage duration. (We haven’t yet seen any arrays with this property.)
Another restriction is that a VLA may not have an initializer.</p>
<p>Variable-length arrays are most often seen in functions other than
<code>main</code>. One big advantage of a VLA that belongs to a function
<code>f</code> is that it can have a different length each time
<code>f</code> is called. We’ll explore this feature in Section 9.3.</p>
<hr />
<h2 id="qa-2">Q&amp;A</h2>
<!-- START: div -->
<div class="QandA_question">
<p>Q: Why do array subscripts start at 0 instead of 12 [p. 162]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Having subscripts begin at 0 simplifies the compiler a bit. Also,
it can make array subscripting marginally faster.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: What if I want an array with subscripts that go from 1 to 10
instead of 0 to 9?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Here’s a common trick: declare the array to have 11 elements
instead of 10. The subscripts will go from 0 to 10, but you can just
ignore element 0.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Is it possible to use a character as an array subscript?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Yes, because C treats characters as integers. You’ll probably need
to “scale” the character before you use it as a subscript, though. Let’s
say that we want the letter count array to keep track of a count for
each letter in the alphabet. The array will need 26 elements, so we’d
declare it in the following way:</p>
<div class="sourceCode" id="cb420"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> letter_count<span class="op">[</span><span class="dv">26</span><span class="op">];</span></span></code></pre></div>
<p>However, we can’t use letters to subsctipt <code>letter_count</code>
directly, because their integer values don’t fall between 0 and 25. To
scale a lower-case letter to the proper range, we can simply subtract
<code>'a'</code>; to scale an upper-case letter, we’ll subtract
<code>'A'</code>. For example, if <code>ch</code> contains a lower-case
letter, we’d write</p>
<div class="sourceCode" id="cb421"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true" tabindex="-1"></a>letter_count<span class="op">[</span>ch<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>to clear the count that corresponds to <code>ch</code>. A minor
caveat: this technique isn’t completely portable, because it assumes
that letters have consecutive codes. However, it works with most
character sets. including ASCIL.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: It seems like a designated initializer could end up initializing
an array element more than once. Consider the following array
declaration:</p>
<div class="sourceCode" id="cb422"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="fl">1.</span> <span class="dv">8</span><span class="op">,</span> <span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span></code></pre></div>
<p>Is this declaration legal, and if so, what is the length of the
array? [p. 166]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Yes, the declaration is legal. Here’s how it works: as it
processes an initializer list, the compiler keeps track of which array
element is to be initialized next. Normally, the next element is the one
following the element that was last initialized. However, when a
designator appears in the list, it forces the next element be the one
represented by the designator, even if that element has already been
initialized.</p>
<p>Here’s a step-by-step look at how the compiler will process the
initializer for the array <code>a</code>:</p>
<blockquote>
<p>The 4 initializes element 0; the next element to be initialized is
element 1.<br />
The 9 initializes element 1; the next element to be initialized is
element 2.<br />
The 1 initializes element 2; the next element to be initialized is
element 3.<br />
The 8 initializes element 3; the next element to be initialized is
element 4.<br />
The [0] designator causes the next element to become 0, so the 5
initializes element 0 (replacing the 4 previously stored there). The
next element to be initialized is element 1.<br />
The 7 initializes element 1 (replacing the 9 previously stored there).
The next element to be initialized is element 2 (which is irrelevant
since we’re at the end of the list).</p>
</blockquote>
<p>The net effect is the same as if we had written</p>
<div class="sourceCode" id="cb423"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">8</span><span class="op">};</span></span></code></pre></div>
<p>Thus, the length of this array is four.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: The compiler gives me an error message if I try to copy one array
into another by using the assignment operator. What’s wrong?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Although it looks quite plausible, the assignment</p>
<div class="sourceCode" id="cb424"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb424-1"><a href="#cb424-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b<span class="op">;</span> <span class="co">/* a and b are arrays */</span></span></code></pre></div>
<p>is indeed illegal. The reason for its illegality isn’t obvious; it
has to do with the peculiar relationship between arrays and pointers in
C, a topic we’ll explore in Chapter 12.</p>
<p>The simplest way to copy one array into another is to use a loop that
copies the elements, one by one:</p>
<div class="sourceCode" id="cb425"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb425-1"><a href="#cb425-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb425-2"><a href="#cb425-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> b<span class="op">[</span>i<span class="op">];</span></span></code></pre></div>
<p>Another possibility is to use the <code>memcpy</code> (“memory copy”)
function from the <code>&lt;string.h&gt;</code> header.
<code>memcpy</code> is a low-level function that simply copies bytes
from one place to another. To copy the array <code>b</code> into the
array <code>a</code>, use <code>memcpy</code> as follows:</p>
<div class="sourceCode" id="cb426"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb426-1"><a href="#cb426-1" aria-hidden="true" tabindex="-1"></a>memcpy<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">));</span></span></code></pre></div>
<p>Many programmers prefer <code>memcpy</code>, especially for large
arrays, because it’s potentially faster than an ordinary loop.</p>
</div>
<!-- END: div -->
<hr />
<!-- START: div -->
<div class="QandA_question">
<p>Q: Section 6.4 mentioned that C99 doesn’t allow a <code>goto</code>
statement to bypass the declaration of a variable-length array. What’s
the reason for this restriction?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The memory used to store a variable-length array is usually
allocated when the declaration of the array is reached during program
execution. Bypassing the declaration using a <code>goto</code> statement
could result in a program accessing the elements of an array that was
never allocated.</p>
</div>
<!-- END: div -->
<hr />
<h2 id="examples-6">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh08/cknkCh08Exmp/">./cknkCh08/cknkCh08Exmp/</a></li>
</ul>
<h2 id="exercises-6">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh08/cknkCh08Exrc/README.md">./cknkCh08/cknkCh08Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh08/cknkCh08Exrc/cknkCh08ExrcReadme.html">./cknkCh08/cknkCh08Exrc/cknkCh08ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh08/cknkCh08Exrc/">./cknkCh08/cknkCh08Exrc/</a></li>
</ul>
<h2 id="programming-projects-6">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh08/cknkCh08Prj/README.md">./cknkCh08/cknkCh08Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh08/cknkCh08Prj/cknkCh08PrjReadme.html">./cknkCh08/cknkCh08Prj/cknkCh08PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh08/cknkCh08Prj/">./cknkCh08/cknkCh08Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<hr />
<h2 id="examples-7">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh09/cknkCh09Exmp/">./cknkCh09/cknkCh09Exmp/</a></li>
</ul>
<h2 id="exercises-7">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh09/cknkCh09Exrc/README.md">./cknkCh09/cknkCh09Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh09/cknkCh09Exrc/cknkCh09ExrcReadme.html">./cknkCh09/cknkCh09Exrc/cknkCh09ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh09/cknkCh09Exrc/">./cknkCh09/cknkCh09Exrc/</a></li>
</ul>
<h2 id="programming-projects-7">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh09/cknkCh09Prj/README.md">./cknkCh09/cknkCh09Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh09/cknkCh09Prj/cknkCh09PrjReadme.html">./cknkCh09/cknkCh09Prj/cknkCh09PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh09/cknkCh09Prj/">./cknkCh09/cknkCh09Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
</body>
</html>
