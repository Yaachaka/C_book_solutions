<html>
<head>
<title>
C Programming
</title>
<meta charset="utf-8">
<link rel="stylesheet" href="./myStyle.css">
</head>
<body>
<h1 id="title-of-the-book-c-programming-a-modern-approach">Title of the
Book: C Programming A Modern Approach</h1>
<h2 id="edition-second-edition-2008">Edition: Second Edition (2008)</h2>
<h3 id="author-k.n.king">Author: K.N.King</h3>
<p><i>A clear, complete, and engaging presentation of the C programming
language – now with coverage of both C89 and C99.</i></p>
<div class="theQuote">
In computing, turning the obvious into the useful is a living definition
of the word “frustration.”
</div>
<hr class="chapterDivider"/>
<h1 id="introducing-c">1 Introducing C</h1>
<div class="theQuote">
When someone says “I want a programming language in which I need only
say what I wish done,” give him a lollipop.
</div>
<p><strong>Few points on C:</strong><br />
- Developed in the early 1970s at Bell Laboratories by <strong>Ken
Thompson</strong>, <strong>Dennis Ritchie</strong>, and others.<br />
- <em>The C Programming Language</em>, written by <strong>Brian
Kernighan</strong> and <strong>Dennis Ritchie</strong> published in
1978.<br />
- In December 1989, standardisation of C under <em>ANSI (American
National Standards Institute)</em> was approved as <em>ANSI standard
X3.159-1989</em>.<br />
- In 1990, it was approved by the <em>International Organization for
Standardization (ISO)</em> as <em>internation standard ISO/IEC
9899:1990</em>.</p>
<hr class="chapterDivider"/>
<h1 id="c-fundamentals">2 C Fundamentals</h1>
<div class="theQuote">
One man’s constant is another man’s variable
</div>
<p>This chapter introduces several basic concepts, including
preprocessing directives, functions, variables, and statements, that
we’ll need in order to write even the simplest programs. Later chapters
will cover these topics in much greater detail.</p>
<p>To start off, Section 2.1 presents a small C program and describes
how to compile and link it. Section 2.2 then discusses how to generalize
the program, and Section 2.3 shows how to add explantory remarks, known
as comments. Section 2.4 introduces variables, which store data that may
change during the execution of a program, and Section 2.5 shows how to
use the <code>scanf</code> function to read data into variables.
Constants – data that won’t change during program execution – can be
given names, as Section 2.6 shows. Finally, Section 2.7 explains C’s
rules for creating names (identifiers) and Section 2.8 gives the rules
for laying out a program.</p>
<h2 id="writing-a-simple-program">2.1 Writing a Simple Program</h2>
<p>In contrast to programs written in some languages, C programs require
little “boilerplate” – a complete program can be as short as a few
lines.</p>
<h3 id="program-printing-a-pun">2.1.1 (PROGRAM) Printing a Pun</h3>
<p>The first program which we will name <code>pun.c</code>, is expected
to display the following message each time it is run.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">To</span> C, or not to C: that is the question.</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: pun.c */</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Section 2.2 explains the form of this program in some detail. For
now, I’ll just make a few brief observations. The line</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span></code></pre></div>
<p>is necessary to “include” information about C’s standard I/O
(input/output) library. The program’s executable code goes inside
<code>main</code>, which represents the “main” program. The only line
inside <code>main</code> is a command to display the desired message.
<code>printf</code> is a function from the standard I/O library that can
produce nicely formatted output. The <code>\n</code> code tells
<code>printf</code> to advance to the next line after printing the
message. The line</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>indicates that the program “returns” the value 0 to the operating
system when it terminates.</p>
<h3 id="compiling-and-linking">2.1.2 Compiling and Linking</h3>
<p>Despite its brevity, getting <code>pun.c</code> to run is more
involved than you might expect. First, we need to create a file named
<code>pun.c</code> containing the program (any text editor will do). The
name of the file doesn’t matter, but the <code>.c</code> extension is
often required by compilers.</p>
<p>Next, we’ve got to convert the program to a form that the machine can
execute. For a C program, that usually involves three steps:</p>
<ul>
<li><strong>Preprocessing.</strong> The program is first given to a
<strong>preprocessor</strong>, which obeys commands that begin with
<code>#</code> (known as <strong><em>directives</em></strong>). A
preprocessor is a bit like an editor; it can add things to the program
and make modifications.<br />
</li>
<li><strong>Compiling.</strong> The modified program now goes to a
<strong>Compiler</strong>. which translates it into machine instructions
(<strong><em>object code</em></strong>). The program isn’t quite ready
to run yet, however.<br />
</li>
<li><strong>Linking.</strong> In the final step, a
<strong>linker</strong> combines the object code produced by the
compiler with any additional code needed to yield a complete executable
program. This additional code includes library functions (like
<code>printf</code>) that are used in the program.</li>
</ul>
<p>Fortunately, this process is often automated, so you won’t find it
too onerous. In fact, the preprocessor is usually integrated with the
compiler, so you probably won’t even notice it at work.</p>
<p>The commands necessary to compile and link vary, depending on the
compiler and operating system. Under UNIX, the C compiler is usually
named <code>cc</code>. To compile and link the <code>pun.c</code>
program, enter the following command in a terminal or command-line
window:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> cc pun.c</span></code></pre></div>
<p>(The <code>%</code> character is the UNIX prompt, not something that
you need to enter.) Linking is automatic when using <code>cc</code>; no
separate link command is necessary.</p>
<p>After compiling and linking the program, <code>cc</code> leaves the
executable program in a file named <code>a.out</code> by default.
<code>cc</code> has many options; one of them (the <code>-o</code>
option) allows us to choose the name of the file containing the
executable program. For example, if we want the executable version of
<code>pun.c</code> to be named <code>pun</code>, we would enter the
following command:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> cc <span class="at">-o</span> pun pun.c</span></code></pre></div>
<section id="the-gcc-compiler" class="infoBox">
<h3>The GCC Compiler</h3>
<p>One of the most popular C compilers is the GCC compiler, which is
supplied with Linux but is available for many other platforms as well.
Using this compiler is similar to using the traditional UNIX
<code>cc</code> compiler. For example, to compile the <code>pun.c</code>
program, we would use the following command:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">%</span> gcc <span class="at">-o</span> pun pun.c</span></code></pre></div>
<p>The Q&amp;A section at the end of the chapter provides more
information about GCC.</p>
</section>
<h3 id="integrated-development-environments">2.1.3 Integrated
development environments</h3>
<p>so far, we’ve assumed the use of a “command-line” compiler that’s
invoked by entering a command in a special window provided by the
operating system. The alternative is to use an <strong><em>integrated
development environment (IDE)</em></strong>, a software package that
allows us to
<code>edit, compile, link, execute, and even debug a program</code>
without leaving the environment. The components of an IDE are designed
to work together. For example, when the compiler detects an error in a
program, it can arrange for the editor to highlight the line that
contains the error. There’s a great deal of variation among IDEs, so I
won’t discuss them further in this book. However, I would recommend
checking to see which IDEs are available for your platform.</p>
<h2 id="the-general-form-of-a-simple-program">2.2 The General Form of a
Simple Program</h2>
<p>Let’s take a closer look at <code>pun.c</code> and see how we can
generalize it a bit. Simple C programs have the form</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>directives</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    statements</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice how the braces show where <code>main</code> begins and ends. C
uses <code>{</code> and <code>}</code> in much the same way that some
other languages use words like <code>begin</code> and <code>end</code>.
This illustrates a general point about C: it relies heavily on
abbreviations and special symbols, one reason that C programs are
concise (or – less charitably – cryptic).</p>
<p>Even the simplest C programs rely on three key language features:
directives (editing commands that modify the program prior to
compilation), functions (named blocks of executable code, of which
<code>main</code> is an example), and statements (commands to be
performed when the program is run). We’ll take a closer look at these
features now.</p>
<h3 id="directives">2.2.1 Directives</h3>
<p>Before a C program is compiled, it is first edited by a preprocessor.
Commands intended for the preprocessor are called directives. Chapter 14
and Chapter 15 discuss directives in detail. For now, we’re interested
only in the <code>#include</code> directive.</p>
<p>The <code>pun.c</code> program begins with the line</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span></code></pre></div>
<p>This directive states that the information is
<code>&lt;stdio.h&gt;</code> is to be “included” into the program before
it is compiled. <code>&lt;stdio.h&gt;</code> contains information about
C’s standard I/O library. C has a number of <em>headers</em> like
<code>&lt;stdio.h&gt;</code>; each contains information about some part
of the standard library. The reason we’re including
<code>&lt;stdio.h&gt;</code> is that C, unlike some programming
languages, has no built-in “read” and “write” commands. The ability to
perform input and output is provided instead by functions in the
standard library.</p>
<p>Directives always begin with <code>#</code> character, which
distinguishes them from other items in a C program. By default,
directives are one line long; there’s no semicolon or other special
marker at the end of a directive.</p>
<h3 id="functions">2.2.2 Functions</h3>
<p><strong>Functions</strong> are like “procedures” or “subroutines” in
other programming languages – they’re the building blocks from which
programs are constructed. In fact, a C program is little more than a
collection of functions. Functions fall into two categories: those
written by the programmer and those provided as part of the c
implementation. I’ll refer to the latter as <em>library functions</em>,
since they belong to a “library” of functions that are supplied with the
compiler.</p>
<p>The term “function” comes from mathematics, where a function is a
rule for computing a value when given one or more arguments:</p>
<p><span
class="math display"><em>f</em>(<em>x</em>) = <em>x</em> + 1</span></p>
<p><span
class="math display"><em>g</em>(<em>y</em>,<em>z</em>) = <em>y</em><sup>2</sup> − <em>z</em><sup>2</sup></span></p>
<p>C uses the term “function” more loosely. In C, a function is simply a
series of statements that have been grouped together and given a name.
Some functions compute a value; some don’t. A function that computes a
value uses the <code>return</code> statement to specify what value it
“returns.” For example, a function that adds 1 to its argument might
execute the statement <code>return x + 1;</code> while a function that
computes the difference of the squares of its arguments might execute
the statement <code>return y * y - z * z;</code></p>
<p>Although a C program may consist of many functions, only the
<code>main</code> function is mandatory. <code>main</code> is special:
it gets called automatically when the program is executed. Until Chapter
9, where we’ll learn how to write other functions, <code>main</code>
will be the only function in our programs.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>The name <code>main</code> is critical; it can’t be
<code>begin</code> or <code>start</code> or even <code>MAIN</code>.</p>
</div>
<p>If <code>main</code> is a function, does it return a value? Yes: it
returns a status code that is given to the operating system when the
program terminates. Let’s take another look at the <code>pun.c</code>
program:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The word <code>int</code> just before <code>main</code> indicates
that the <code>main</code> function returns an integer value. The word
<code>void</code> in parenthesis indicates that <code>mian</code> has no
arguments.</p>
<p>The statement <code>return 0;</code> has two effects: it causes the
main function to terminate (thus ending the program) and it indicates
that the <code>main</code> function returns a value of 0. We will have
more to say about <code>main</code>’s return value in a later chapter.
For now, we’ll always have <code>main</code> return the value 0, which
indicates normal program termination.</p>
<p>If there’s no <code>return</code> statement at the end of the
<code>main</code> function, the program will still terminate. However,
many compilers will produce a warning message (because the function was
supposed to return an integer but failed to).</p>
<h3 id="statements">2.2.3 Statements</h3>
<p>A <strong>Statement</strong> is a command to be executed when the
program runs. We’ll explore statements later in the book, primarily in
Chpater 5 and 6. The <code>pun.c</code> program uses only two kinds of
statements. One is the <code>return</code> statement; the other is the
<em>function call</em>. Asking a function to perform its assigned task
is known as <em>calling</em> the function. The <code>pun.c</code>
program, for example, calls the <code>printf</code> function to display
a string on the screen:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question. </span><span class="sc">\n</span><span class="st">);</span></span></code></pre></div>
<p>C requires that each statement end with a semicolon. (As with any
good rule, there’s one exception: the compound statement, which we’ll
encounter later.) The semicolon shows the compiler where the statement
ends; since statements can continue over several lines, it’s not always
obvious where they end. Directives, on the other hand, are normally one
line long, and they don’t end with a semicolon.</p>
<h3 id="printing-strings">2.2.4 Printing Strings</h3>
<p><code>printf</code> is a powerful function that we’ll examine in
Chapter 3. So far, we’ve only used <code>printf</code> to display a
<strong>string literal</strong> – a series of characters enclosed in
double quotation marks. When <code>printf</code> displays a string
literal, it doesn’t show the quotation marks.</p>
<p><code>printf</code> doesn’t automatically advance to the next output
line when it finishes printing. To instruct <code>printf</code> to
advance one line, we must include <code>\n</code> (the <em>new-line
character</em>) in the string to be printed. Writing a new-line
character terminates the current output line; subsequent output goes on
to the next line. to illustrate this point, consider the effect of
replacing the statement</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>by two calls of <code>printf</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C: &quot;</span><span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>The first call of <code>printf</code> writes
<code>To C, or not to C:</code>. The second call writes
<code>that is the question.</code> and advances to the next line. The
net effect is the same as the original <code>printf</code> – the user
can’t tell the difference.</p>
<p>The new-line character can appear more than once in a string literal.
To display the message</p>
<pre><code>Brevity is the soul of wit.
  --Shakespeare</code></pre>
<p>we could write</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Brevity is the soul of wit.</span><span class="sc">\n</span><span class="st">  --Shakespeare</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<h2 id="comments">2.3 Comments</h2>
<p>Our <code>pun.c</code> program still lacks something important:
documentation. Every program should contain identifying information: the
program name, the date written, the author, the purpose of the program,
and so forth. In C, this information is placed in
<strong><em>Comments</em></strong>. The symbol <code>/*</code> marks the
beginning of a comment and the symbol <code>*/</code> marks the end:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* This is a comment */</span></span></code></pre></div>
<p>Comments may appear almost anywhere in a program, either on separate
lines or on the same lines as other program text. Here’s what
<code>pun.c</code> might look like with comments added at the
beginning:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c */</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* Purpose: Prints a bad pun. */</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* Author: K. N. King */</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;To C, or not to C: that is the question.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Comments may extend over more than one line; once it has seen the
<code>/*</code> symbol, the compiler reads (and ignores) whatever
follows until it encounters the <code>*/</code> symbol. If we like, we
can combine a series of short comments into one long comment:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">   Purpose: Prints a bad pun.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">   Author: K. N. King */</span></span></code></pre></div>
<p>A comment like this can be hard to read, though, because it’s not
easy to see where the comment ends. Putting <code>*/</code> on a line by
itself helps:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Name: pun.c</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">   Purpose: Prints a bad pun.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">   Author: K. N. King </span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span></code></pre></div>
<p>Even better, we can form a “box” around the comment to make it stand
out:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">/************************************************************ </span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">* Name: pun.c                                               *</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">* Purpose: Prints a bad pun.                                *</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">* Author: K. N. King                                        *</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">************************************************************/</span></span></code></pre></div>
<p>Programmers often simplify boxed comments by omitting three of the
sides:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * Name: pun.c</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a bad pun.</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span></code></pre></div>
<p>A short comment can go on the same line with other program code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span>    <span class="co">/* Beginning of main program */</span></span></code></pre></div>
<p>A comment like this is sometimes called a “winged comment”.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Forgetting to terminate a comment may cause the compiler to ignore
part of your program. Consider the following example:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;My &quot;</span><span class="op">);</span>    <span class="co">/* forgot to close this comment...</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">printf(&quot;cat &quot;);</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">printf(&quot;has &quot;);    /* so it ends here */</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;fleas&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Because we have neglected to terminate the first comment, the
compiler ignores the middle two statements, and the example prints
<code>My fleas</code>.</p>
</div>
<p><span class="C99Symbol"></span></p>
<p>C99 provides a second kind of comment, which begins with
<code>//</code> (two adjacent slashes):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a comment</span></span></code></pre></div>
<p>This style of comment ends automatically at the end of a line. To
create a commet that’s more than one line long, we can either use the
older comment style (<code>/* ... */</code>) or else put <code>//</code>
at the beginning of each comment line:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Name: pun.c</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Purpose: Prints a bad pun.</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Author: K. N. King</span></span></code></pre></div>
<p>The newer comment style has a couple of important advantages. First,
because a comment automatically ends at the end of a line, there’s no
chance that an unterminated comment will accidentally consume part of a
program. Second, multiline comments stand out better, thanks to the
<code>//</code> that’s required at the beginning of each line.</p>
<h2 id="variables-and-assignment">2.4 Variables and Assignment</h2>
<p>Few programs are as simple as the one in Section 2.1. Most programs
need to perform a series of calculations before producing output, and
thus need a way to store data temporarily during program execution. In
C, as in most programming languages, these storage locations are called
<strong>variables</strong>.</p>
<h3 id="types">2.4.1 Types</h3>
<p>Every variable must have a <strong><em>type</em></strong>, which
specifies what kind of data it will hold. C has a wide variety of types.
For now, we’ll limit ourselves to just two: <code>int</code> and
<code>float</code>. Choosing the proper type is critical, since the type
affects how the variable is stored and what operations can be performed
on the variable. The type of a numeric variable determines the largest
and smallest numbers that the variable can store; it also determines
whether or not digits are allowed after the decimal point.</p>
<p>A variable of type <code>int</code> (short for <em>integer</em>) can
store a whole number such as 0, 1, 392, or -2553. The range of possible
values is limited, though. The largest <code>int</code> value is
typically 2,147,483,647 but can be as small as 32,767.</p>
<p><span class="QandA"></span></p>
<p>A variable of type <code>float</code> (short for
<em>floating-point</em>) can store much larger numbers than an
<code>int</code> variable. Furthermore, a <code>float</code> variable
can store numbers with digits after the decimal point, like 379.125.
<code>float</code> variables have drawbacks, however. Arithmetic on
<code>float</code> numbers may be slower than arithmetic on
<code>int</code> numbers. Most significantly, the value of a
<code>float</code> variable is often just an approximation of the number
that was stored in it. If we store 0.1 in a <code>float</code> variable,
we may later find that the variable has a value such as
0.09999999999999987, thanks to rounding error.</p>
<h3 id="declarations">2.4.2 Declarations</h3>
<p>Variables must be <strong>declared</strong>–described for the benefit
of the compiler–before they can be used. To declare a variable, we first
specify the <em>type</em> of the variable, then its <em>name</em>.
(Variable names are chosen by the programmer, subject to the rules
described in Section 2.7.) For example, we might declare variables
<code>height</code> and <code>profit</code> as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> profit<span class="op">;</span></span></code></pre></div>
<p>The first declaration states that <code>height</code> is a variable
of type <code>int</code>, meaning that <code>height</code> can store an
integer value. The second declaration says that <code>profit</code> is a
variable of type <code>float</code>.</p>
<p>If several variables have the same type, their declarations can be
combined:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> profit<span class="op">,</span> loss<span class="op">;</span></span></code></pre></div>
<p>Notice that each complete declaration ends with a semicolon. Ou Our
first template for <code>main</code> didn’t include declarations. When
<code>main</code> contains declarations, these must precede
statements:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    declarations</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    statements</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As we’ll see in Chapter 9, this is true of functions in general, as
well as blocks (statements that contain embedded declarations). As a
matter of style, it’s a good idea to leave a blank line between the
declarations and the statements.</p>
<p><span class="C99Symbol"></span></p>
<p>In C99, declarations don’t have to come before statements. For,
example, <code>main</code> might contain a declaration, then a
statement, and then another declaration. For compatibility with older
compilers, the programs in this book don’t take advantage of this rule.
However, it’s common in C++ and Java programs not to declare variables
until they’re first needed, so this practice can be expected to become
popular in C99 programs as well.</p>
<h3 id="assignment">2.4.3 Assignment</h3>
<p>A variable can be given a value by means of
<strong><em>assignment</em></strong>. For example, the statements</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<p>assign values to <code>height</code>, <code>length</code>, and
<code>width</code>. The numbers 8, 12, and 10 are said to be
<strong><em>constants</em></strong>.</p>
<p>Before a variable can be assigned a value–or used in any other way,
for that matter–it must first be declared. Thus, we could write</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span></code></pre></div>
<p>but not</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">;</span></span></code></pre></div>
<p>A constant assigned to a <code>float</code> variable usually contains
a decimal point. For example, if <code>profit</code> is a
<code>float</code> variable, we might write</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>profit <span class="op">=</span> <span class="fl">2150.48</span><span class="op">;</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>It’s best to append the letter <code>f</code> (for “float”) to a
constant that contains a decimal point if the number is assigned to a
<code>float</code> variable:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>profit <span class="op">=</span> <span class="fl">2150.48</span><span class="bu">f</span><span class="op">;</span></span></code></pre></div>
<p>Failing to include the <code>f</code> may cause a warning from the
compiler.</p>
<p>An <code>int</code> variable is normally assigned a value of type
<code>int</code>, and a <code>float</code> variable is normally assigned
a value of type <code>float</code>. Mixing types (such as assigning an
<code>int</code> value to a <code>float</code> variable or assigning a
<code>float</code> value to an <code>int</code> variable) is possible
but not always safe, as we’ll see in Section 4.2.</p>
<p>Once a variable has been assigned a value, it can be used to help
compute the value of another variable:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span>    <span class="co">/* volume is now 960 */</span></span></code></pre></div>
<p>In C, <code>*</code> represents the multiplication operator, so this
statement multiplies the values stored in <code>height</code>,
<code>length</code>, and <code>width</code>, then assigns the result to
the variable <code>volume</code>. In general, the right side of an
assignment can be a formula (or <strong><em>expression</em></strong>, in
C terminology) involving constants, variables, and operators.</p>
<h3 id="printing-the-value-of-a-variable">2.4.4 Printing the Value of a
Variable</h3>
<p>We can use <code>printf</code> to display the current value of a
variable. For example, to write the message</p>
<pre class="shell"><code>Height: h</code></pre>
<p>where <code>h</code> is the current value of the <code>height</code>
variable, we’d use the following call of <code>printf</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">);</span></span></code></pre></div>
<p><code>%d</code> is a placeholder indicating where the value of
<code>height</code> is to be filled in during printing. Note the
placement of <code>\n</code> just after <code>%d</code>, so that
<code>printf</code> will advance to the next line after printing the
value of <code>height</code>.</p>
<p><code>%d</code> works only for <code>int</code> variables; to print a
<code>float</code> variable, we’d use <code>%f</code> instead. By
default, <code>%f</code> displays a number with six digits after the
decimal point. To force <code>%f</code> to display <code>p</code> digits
after the decimal point, we can put <code>.p</code> between
<code>%</code> and <code>f</code>. For example, to print the line</p>
<pre class="shell"><code>Profit: $2150.48</code></pre>
<p>we’d call <code>printf</code> as follows:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Profit: $%.2f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> profit<span class="op">);</span></span></code></pre></div>
<p>There’s no limit to the number of variables that can be printed a
single call of <code>printf</code>. To display the values of both the
<code>height</code> and <code>length</code> variables, we could use the
following call of <code>printf</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d  Length: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">,</span> length<span class="op">);</span></span></code></pre></div>
<h3 id="program-computing-the-dimensional-weight-of-a-box">2.4.5
(PROGRAM) Computing the Dimensional Weight of a Box</h3>
<p>Shipping companies don’e especially like boxes that are larger but
very light, since they take up valuable space in a truck or airplane. In
fact, companies often charge extra for such a box, basing the fee on its
volume instead of its weight. In the United States, the usual method is
to divide the volume by 166 (the allowable number of cubic inches per
pound). If this number–the box’s “dimensional” or “volumetric”
weight–exceeds its actual weight, the shipping fee is based on the
dimensional weight. (The 166 divisor is for international shipments; the
dimensional weight of a domestic shipment is typically calculated using
194 instead).</p>
<p>Let’s say that you’ve been hired by a shipping company to write a
program that computes the dimensional weight of a box. Since you’re new
to C, you decide to start off by writing a program that calculates the
dimensional weight of a particular box that’s
<code>12" x 10" x 8"</code>. Division is represented by <code>/</code>
in C, so the obvious way to compute the dimensional weight would be</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> volume <span class="op">/</span> <span class="dv">166</span></span></code></pre></div>
<p>where <code>weight</code> and <code>volume</code> are integer
variables representing the box’s weight and volume. Unfortunately, this
formula isn’t quite what we need. In C, when one integer is divided by
another, the answer is “truncated”: all digits after the decimal point
are lost. The volume of a <code>12" x 10" x 8"</code> box will be 960
cubic inches. Dividing by 166 gives the answer 5 instead of 5.783, so we
have in effect rounded <em>down</em> to the next lowest pound; the
shipping company expects us to round <em>up</em>. One solution is to add
165 to the volume before dividing by 166:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span></code></pre></div>
<p>A volume of 166 would give a weight of 331/166, or 1, while a volume
of 167 would yield 332/166, or 2. Calculating the weight in this fashion
gives us the following program.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: dweight.c */</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* Computes the dimensional weight of a 12&quot; x 10&quot; x 8&quot; box */</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">,</span> weight<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Dimensions: %dx%dx%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> height<span class="op">);</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Volume (cubic inches): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    printd<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> weight<span class="op">);</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The output of the program is</p>
<pre class="shell"><code>Dimensions: 12x10x8
Volume (cubic inches): 960
Dimensional weight (pounds): 6</code></pre>
<h3 id="initialization">2.4.6 Initialization</h3>
<p>Some variables are automatically set to zero when a program begins to
execute, but most are not. A variable that doesn’t have a default value
and hasn’t yet been assigned a value by the program is said to be
<strong><em>uninitialized</em></strong>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Attempting to access the value of an uninitialized variable (for
example, by displaying the variable using <code>printf</code> or using
it in an expression) may yield an unpredictable result such as 2568,
-30891, or some equally strange number. With some compilers, worse
behavior–even a program crash–may occur.</p>
</div>
<p>We can always give a variable an initial value by using assignment,
of course. But there’s an easier way: put the initial value of the
variable in its declaration. For example, we can declare the
<code>height</code> variable and initialize it in one step:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span></code></pre></div>
<p>In C jargon, the value <code>8</code> is said to be an
<strong><em>initializer</em></strong>.</p>
<p>Any number o variables can be initialized in the same
declaration:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height <span class="op">=</span> <span class="dv">8</span><span class="op">,</span> length <span class="op">=</span> <span class="dv">12</span><span class="op">,</span> width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<p>Notice that each variable requires its own initializer. In the
ollowing example, the initializer <code>10</code> is good only or the
variable <code>width</code>, not for <code>height</code> or
<code>length</code> (which remain uninitialized):</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span></code></pre></div>
<h3 id="printing-expressions">2.4.7 Printing Expressions</h3>
<p><code>printf</code> isn’t limited to displaying numbers stored in
variables; it can display the value of <em>any</em> numeric expression.
Taking advantage of this property can simplify a program and reduce the
number of variables. For instance, the statements</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span></code></pre></div>
<p>could be replaced by</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">);</span></span></code></pre></div>
<p><code>printf</code>’s ability to print expressions illustrates one of
C’s general principles: <em>Wherever a value is needed, any expression
of the same type will do</em>.</p>
<h2 id="reading-input">2.5 Reading Input</h2>
<p>Because the <code>dweight.c</code> program calculates the dimensional
weight of just one box, it isn’t especially useful. To improve the
program, we’ll need to allow the user to enter the dimensions.</p>
<p>To obtain input, we’ll use the <code>scanf</code> function, the C
library’s counterpart to <code>printf</code>. The <code>f</code> in
<code>scanf</code>, like the <code>f</code> in <code>printf</code>,
stands for “formatted”; both <code>scanf</code> and <code>printf</code>
require the use of a <strong><em>format string</em></strong> to specify
the appearance of the input or output data. <code>scanf</code> needs to
know what form the input data will take, just as <code>printf</code>
needs to know how to display output data.</p>
<p>To read an <code>int</code> value, we’d use <code>scanf</code> as
follows:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span>    <span class="co">/* reads an integer; stores into i */</span></span></code></pre></div>
<p>The <code>"%d"</code> string tells <code>scanf</code> to read input
that represents an integer; <code>i</code> is an <code>int</code>
variable into which we want <code>scanf</code> to store the input. The
<code>&amp;</code> symbol is hard to explain at this point; for now,
I’ll just note that it is usually (but not always) required when using
<code>scanf</code>.</p>
<p>Reading a <code>float</code> value requires a slightly different call
of <code>scanf</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>x<span class="op">);</span>    <span class="co">/* reads a float value; stores into x */</span></span></code></pre></div>
<p><code>%f</code> works only with variables of type <code>float</code>,
so I’m assuming that <code>x</code> is a <code>float</code> variable.
The <code>"%f"</code> string tells <code>scanf</code> to look for an
input value in <code>float</code> format (the number may contain a
decimal point, but doesn’t have to).</p>
<h3
id="program-computing-the-dimensional-weight-of-a-box-revisited">2.5.1
(PROGRAM) Computing the Dimensional Weight of a Box (Revisited)</h3>
<p>Here’s an improved version of the dimensional weight program in which
the user enters the dimensions. Note that each call of
<code>scanf</code> is immediately preceeded by a call of
<code>printf</code>. That way, the user will know when to enter input
and what input to enter.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* file: dweight2.c</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co">   purpose: Computes the dimensional weight of a </span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co">   box from input provided by the user */</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">,</span> length<span class="op">,</span> width<span class="op">,</span> volume<span class="op">,</span> weight<span class="op">;</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter height of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>height<span class="op">);</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter length of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>length<span class="op">);</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter width of box: &quot;</span><span class="op">);</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>width<span class="op">);</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">165</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Volume (cubic inches): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> volume<span class="op">);</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> weight<span class="op">);</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The output of the program has the following appearance</p>
<pre class="shell"><code>Enter height of box: 8
Enter length of box: 12
Enter width of box: 10
Volume (cubic inches): 960
Dimensional weight (pounds): 6</code></pre>
<p>A message that asks the user to enter input (a
<strong><em>prompt</em></strong>) normally shouldn’t end with a new-line
character, because we want the user to enter input on the same line as
the prompt itself. When the user presses the Enter key, the cursor
automatically moves to the next line–the program doesn’t need to display
a new-line character to terminate the current line.</p>
<p>The <code>dweight2.c</code> program suffers from one problem: it
doesn’t work correctly if the user enters nonnumeric input. Section 3.2
discusses this issue in more detail.</p>
<h2 id="defining-names-for-constants">2.6 Defining Names for
Constants</h2>
<p>When a program contains constants, it’s often a good idea to give
them names. The <code>dweight.c</code> and <code>dweight2.c</code>
programs rely on constant 166, whose meaning may not be at all clear to
someone reading the program later. Using feature know as
<strong><em>macro definition</em></strong>, we can name this
constant:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INCHES_PER_POUND 166</span></span></code></pre></div>
<p><code>#define</code> is a preprocessing directive, just as
<code>#include</code> is, so there’s no semicolon at the end of the
line.</p>
<p>When a program is compiled, the preprocessor replaces each macro by
the value that it represents. For example, the statement</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> INCHES_PER_POUND <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">/</span> INCHES_PER_POUND<span class="op">;</span></span></code></pre></div>
<p>will become</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>weight <span class="op">=</span> <span class="op">(</span>volume <span class="op">+</span> <span class="dv">166</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="dv">166</span><span class="op">;</span></span></code></pre></div>
<p>giving the same effect as if we’d written the latter statement in the
first place.</p>
<p>The value of a macro can be an expression:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define RECIPROCAL_OF_PI (1.0f / 3.14159f)</span></span></code></pre></div>
<p>If it contains operators; the expression should be enclosed ina
prantheses.</p>
<p>Notice that we’ve used only upper-case letters in macros names. This
a convention that most C programmers follow, not a requirement of the
language. (Still, C programmers have been doing this for decades; you
wouldn’t want to be the first to deviate.)</p>
<h3 id="program-converting-from-fahrenheit-to-celsius">2.6.1 (PROGRAM)
Converting from Fahrenheit to Celsius</h3>
<p>The following program prompts the user to enter a Fahrenheit
temperature; it then prints the equivalent Celsius temperature. The
output of the program will have the following appearance:</p>
<pre class="shell"><code>Enter Fahrenheit temperature: 212
Celsius equivalent: 100.0</code></pre>
<p>The program will allow temperatures that aren’t integers; that’s why
the Celsius temperature is displayed as 100.0 instead of 100. Let’s look
first at the entire program, then see how it’s put together.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * File: celsius.c</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Converts a Fahrenheit temperature to Celsius</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FREEZING_PT 32.0f</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCALE_FACTOR (5.0f /9.0f)</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fahrenheit<span class="op">,</span> celsius<span class="op">;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>fahrenheit<span class="op">);</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The statement</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span></code></pre></div>
<p>converts the Fahrenheit temperature to Celsius. Since
<code>FREEZING_PT</code> stands for <code>32.0f</code> and
<code>SCALE_FACTOR</code> stands for <code>(5.0f /9.0f)</code>, the
compiler sees this statement as</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> <span class="fl">32.0</span><span class="bu">f</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fl">5.0</span><span class="bu">f</span> <span class="op">/</span> <span class="fl">9.0</span><span class="bu">f</span><span class="op">);</span></span></code></pre></div>
<p>Defining <code>SCALE_FACTOR</code> to be <code>(5.0f / 9.0f)</code>
instead of <code>(5 / 9)</code> is important, becasuse C truncates the
result when two integers are divided. The value of <code>(5 / 9)</code>
would be <code>0</code>, which definitely isn’t what we want.</p>
<p>The call of <code>printf</code> writes the Celsius temperature:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span></code></pre></div>
<p>Notice the use of <code>%.1f</code> to display <code>celsius</code>
with just one digit after the decimal point.</p>
<h2 id="identifiers">Identifiers</h2>
<p>As we’re writing a program, we’ll have to choose names for variables,
functions, macros, and other entities. These names are called
<strong><em>identifiers</em></strong>. In C, an identifier may contain
letters, digits, and underscores, but must begin with a letter or
underscore.</p>
<p><span class="C99Symbol"></span></p>
<p>(In C99, identifiers may contain certain “universal character names”
as well.)</p>
<p>Here are some examples of legal identifers:</p>
<pre><code>times10
get_next_char
_done</code></pre>
<p>The following are <em>not</em> legal identifiers:</p>
<pre><code>10times
get-next-char</code></pre>
<p>The symbol <code>10times</code> begins with a digit, not a letter or
underscore. <code>get-next-char</code> contains minus signs, not
underscores.</p>
<p>C is <strong><em>case-sensitive</em></strong>: it distinguishes
between upper-case and lower-case letters in identifiers. For example,
the following identifiers are all different:</p>
<pre><code>job
joB
jOb
jOB
Job
JoB
JOb
JOB</code></pre>
<p>These eight identifiers could all be used simultaneously, each for a
completely different purpose. (Talk about obfuscation!) Sensible
programmers try to make identifiers look different unless they’re
somehow related.</p>
<p>Since case matters in C, many programmers follow the convention of
using only lower-case letters in identifiers (other than macros), with
underscores inserted when necessary for legibility:</p>
<pre><code>symbol_table
current_page
name_and_address</code></pre>
<p>Other programmers avoid underscores, instead using an upper-case
letter to begin each word within an identifier:</p>
<pre><code>symbolTable
currentPage
nameAndAddress</code></pre>
<p>(The first letter is sometimes capitalized as well.) Although the
former style is common in traditional C, the latter style is becoming
more popular thanks to its widespread use in Java and C# (and, to a
lesser extent, C++). Other reasonable conventions exist; just be sure to
capitalize an identifier the same way each time it appears in a
program.</p>
<p><span class="QandA"></span></p>
<p>C places no limit on the maximum length of an identifier, so don’t be
afraid to use long, descriptive names. A name such as
<code>current_page</code> is a lot easier to understand than a name like
<code>cp</code>.</p>
<h3 id="keywords">2.7.1 Keywords</h3>
<p><span class="C99Symbol"></span></p>
<p>The <strong><em>keywords</em></strong> in Table 2.1 have special
significance to C compilers and therefore can’t be used as identifiers.
Note that five keywords were added in C99.</p>
<p><strong>Table 2.1</strong><br>Keywords</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<tbody>
<tr class="odd">
<td><code>auto</code></td>
<td><code>enum</code></td>
<td><code>restrict</code><span class="staffOfHermis"></span></td>
<td><code>unsigned</code></td>
</tr>
<tr class="even">
<td><code>break</code></td>
<td><code>extern</code></td>
<td><code>return</code></td>
<td><code>void</code></td>
</tr>
<tr class="odd">
<td><code>case</code></td>
<td><code>float</code></td>
<td><code>short</code></td>
<td><code>volatile</code></td>
</tr>
<tr class="even">
<td><code>char</code></td>
<td><code>for</code></td>
<td><code>signed</code></td>
<td><code>while</code></td>
</tr>
<tr class="odd">
<td><code>const</code></td>
<td><code>goto</code></td>
<td><code>sizeof</code></td>
<td><code>_Bool</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="even">
<td><code>continue</code></td>
<td><code>if</code></td>
<td><code>static</code></td>
<td><code>_Complex</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="odd">
<td><code>default</code></td>
<td><code>inline</code><span class="staffOfHermis"></span></td>
<td><code>struct</code></td>
<td><code>_Imaginary</code><span class="staffOfHermis"></span></td>
</tr>
<tr class="even">
<td><code>do</code></td>
<td><code>int</code></td>
<td><code>switch</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>double</code></td>
<td><code>long</code></td>
<td><code>typedef</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>else</code></td>
<td><code>register</code></td>
<td><code>union</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="staffOfHermis"></span>C99 only</p>
<p>Because of C’s case-sensitivity, keywords must appear in programs
exactly as shown in Table 2.1, with all letters in lower case. Names of
functions in the standard library (such as <code>printf</code>) contain
only lower-case letters also. Avoid the plight of the unfortunate
programmer who enters an entire program in upper case, only to find that
the compiler can’t recognize keywords and calls of library
functions.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Watch out for other restrictions on identifiers. Some compilers treat
certain identifiers (<code>asm</code>, for example) as additional
keywords. Identifiers that belong to the standard library are restricted
as well. Accidentally using one of these names can cause an error during
compilation or linking. Identifiers that begin with an underscore are
also restricted.</p>
</div>
<h2 id="layout-of-a-c-program">2.8 Layout of a C Program</h2>
<p>We think of a C program as a series of
<strong><em>tokens</em></strong>: groups of characters that can’t be
split up without changing their meaning. Identifiers and keywords are
tokens. So are operators like <code>+</code> and <code>-</code>,
punctuation marks such as the comma and semicolon, and string literals.
For example, the statement</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Height: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> height<span class="op">);</span></span></code></pre></div>
<p>consists of seven tokens:</p>
<table>
<tbody>
<tr class="odd">
<td><code>printf</code></td>
<td><span class="circled1"></span></td>
</tr>
<tr class="even">
<td><code>(</code></td>
<td><span class="circled2"></span></td>
</tr>
<tr class="odd">
<td><code>"Height: %d\n"</code></td>
<td><span class="circled3"></span></td>
</tr>
<tr class="even">
<td><code>,</code></td>
<td><span class="circled4"></span></td>
</tr>
<tr class="odd">
<td><code>height</code></td>
<td><span class="circled5"></span></td>
</tr>
<tr class="even">
<td><code>)</code></td>
<td><span class="circled6"></span></td>
</tr>
<tr class="odd">
<td><code>;</code></td>
<td><span class="circled7"></span></td>
</tr>
</tbody>
</table>
<p>Tokens <span class="circled1"></span> and <span
class="circled5"></span> are identifiers, token <span
class="circled3"></span> is a string literal, and tokens <span
class="circled2"></span>, <span class="circled4"></span>, <span
class="circled6"></span>, and <span class="circled7"></span> are
punctuation.</p>
<p>The amount of space between tokens in a program isn’t critical in
most cases. At one extreme, tokens can be crammed together with no space
between them at all, except where this would cause two tokens to merge
into a third token. For example, we could delete most of the space in
the <code>celsius.c</code> program of Section 2.6, provided that we
leave space between tokens such as <code>int</code> and
<code>main</code> and between <code>float</code> and
<code>fahrenheit</code>:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Converts a Fahrenheit temperature to Celsius */</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FREEZING_PT 32.0f</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SCALE_FACTOR (5.0f/9.0f)</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">){</span><span class="dt">float</span> fahrenheit<span class="op">,</span>celsius<span class="op">;</span>printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span>scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,&amp;</span>fahrenheit<span class="op">);</span>celsius<span class="op">=(</span>fahrenheit<span class="op">-</span>FREEZING_PT<span class="op">)*</span>SCALE_FACTOR<span class="op">;</span>printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>celsius<span class="op">);</span><span class="cf">return</span> <span class="dv">0</span><span class="op">;}</span></span></code></pre></div>
<p>In fact, if the page were wider, we could put the entire
<code>main</code> function on a single line. We can’t put the whole
<em>program</em> on one line, though, because each preprocessing
directive requires a separate line.</p>
<p>Compressing programs in this fashion isn’t good idea. In fact, adding
spaces and blank lines to a program can make it easier to read and
understand. Fortunately, C allows us to insert any amouont of
space–blanks, tabs, and new-line characters–between tokens. This rule
has several important consequences for program layout:</p>
<!-- Ordered list Start here -->
<ul>
<li>
<p><em>Statements can be divided</em> over any number of lines. The
following statement, for example, is so long that it would be hard to
sqeeze it onto a single line:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Dimensional weight (pounds): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">(</span>volume <span class="op">+</span> INCHES_PER_POUND <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> INCHES_PER_POUND<span class="op">);</span></span></code></pre></div>
</li>
<li>
<p><em>Space between tokens</em> makes it easier for the eye to separate
them. For this reason, I usually put a space before and after each
operator:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>volume <span class="op">=</span> height <span class="op">*</span> length <span class="op">*</span> width<span class="op">;</span></span></code></pre></div>
<p>I also put a space after each comma. Some programmers go even
further, putting spaces around parentheses and other punctuation.</p>
</li>
<p><span class="QandA"></span></p>
<li>
<p><em>Indentation</em> can make nesting easier to spot. For example, we
should indent declarations and statements to make it clear that they’re
nested inside <code>main</code>.</p>
</li>
<li>
<p><em>Blank lines</em> can divide a program into logical units, making
it easier for the reader to discern the program’s structure. A program
with no blank lines is as hard to read as a book with no chapters.</p>
</li>
</ul>
<!-- Un ordered list end here -->
<p>The <code>celsius.c</code> program of Section 2.6 illustrates several
of these guidelines. Let’s take a closer look at the <code>main</code>
function in that program:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fahrenheit<span class="op">,</span> celsius<span class="op">;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter Fahrenheit temperature: &quot;</span><span class="op">);</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>fahrenheit<span class="op">);</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    celsius <span class="op">=</span> <span class="op">(</span>fahrenheit <span class="op">-</span> FREEZING_PT<span class="op">)</span> <span class="op">*</span> SCALE_FACTOR<span class="op">;</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Celsius equivalent: %.1f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> celsius<span class="op">);</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>First, observe how the space around <code>=</code>, <code>-</code>,
and <code>*</code> makes these operators stand out. Second, notice how
the indentation of declarations and statements makes it obvious that
they all belong to <code>main</code>. Finally, note how blank lines
divide <code>main</code> into five parts: (1) declaring the
<code>fahrenheit</code> and <code>celsius</code> variables; (2)
obtaining the Fahrenheit temperature; (3) calculating the value of
<code>celsius</code>; (4) printing the Celsius temperature; and (5)
returning to the operating system.</p>
<p>While we’re on the subject of program layout, notice how I’ve placed
the <code>{</code> token underneath <code>main()</code> and put the
matching <code>}</code> on a separate line, aligned with <code>{</code>.
Putting <code>}</code> on a separate line lets us insert or delete
statements at the end of the function; aligning it with <code>{</code>
makes it easy to spot the end of <code>main</code>.</p>
<p>A final note: Although extra spaces can be added <em>between</em>
tokens, it’s not possible to add space <em>within</em> a token without
changing the meaning of the program or causing an error. Writing</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>fl oat fahrenheit<span class="op">,</span> celsius<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>fl</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>oat fahrenheit<span class="op">,</span> celsius<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>produces an error when the program is compiled. Putting a space
inside a string literal is allowed, although it changes the meaning of
the string. However, putting a new-line character in a string (in other
words, splitting the string over two lines) is illegal:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;To C, or not to C:</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>that is the question<span class="op">.</span>\n<span class="st">&quot;);    /*** WRONG ***/</span></span></code></pre></div>
<p>Continuing a string from one line to the next requires a special
technique that we’ll learn in a later chapter.</p>
<hr />
<h2 id="q-a">Q &amp; A</h2>
<div class="QandA_question">
<p>Q: What does GCC stand for? [p. 11]</p>
</div>
<div class="QandA_answer">
<p>A: GCC originally stood for “<u>G</u>NU <u>C</u> <u>C</u>ompiler.” It
now stands for “<u>G</u>NU <u>C</u>ompiler <u>C</u>ollection,” because
the current version of GCC compiles programs written in a variety of
languages, including Ada, C, C++, Fortran, Java, and Objective-C.</p>
</div>
<div class="QandA_question">
<p>Q: OK, so what does GNU stand for?</p>
</div>
<div class="QandA_answer">
<p>A: GNU stands for “<u>G</u>NU’s <u>N</u>ot <u>U</u>nix!” (and is
pronounced <em>guh-NEW</em>, by the way). GNU is a project of the Free
Software Foundation, an organization set up by <strong>Ritchard M.
Stallman</strong> as a protest against the restrictions of licensed UNIX
software. According to its web site, the Free Software Foundation
believes that the users should be free to “run, copy, distribute, study,
change and improve” software. The GNU Project has rewritten much
traditional UNIX software from scratch and made it publicly available at
no charge.</p>
<p>GCC and other GNU software are crucial to Linux. Linux itself is only
the “kernel” of an operating system (the part that handles program
scheduling and basic I/O services); the GNU software is necessary to
have a fully functional operating system.</p>
<p>For more information on the GNU Project, visit <a
href="https://www.gnu.org/">www.gnu.org</a>.</p>
</div>
<div class="QandA_question">
<p>Q: What’s the big deal about the GCC anyway?</p>
</div>
<div class="QandA_answer">
<p>A: GCC is significant for many reasons, not least the fact that it’s
free and capable of compiling a number of languages. It runs under many
operating systems and generates code for many different CPUs, including
all the widely used ones. GCC is the primary compiler for many
UNIX-based operating systems, including Linux, BSD, and Mac OS X, and
it’s used extensively for commercial software development. For more
information about GCC, visit <a
href="https://gcc.gnu.org">gcc.gnu.org</a></p>
</div>
<div class="QandA_question">
<p>Q: How good is GCC at finding errors in programs?</p>
</div>
<div class="QandA_answer">
<p>A: GCC has various command-line options that control how thoroughly
it checks programs. When these options are used, GCC is quite good at
finding potential trouble spots in a program. Here are some of the more
popular options:</p>
<ul>
<li>
<p><code>-Wall</code></p>
<p>Causes the compiler to produce warning messages when it detects
possible errors. (<code>-W</code> can be followed by codes for specific
warnings; <code>-Wall</code> means “all <code>-W</code> options.”)
Should be used in conjunction with <code>-O</code> for maximum
effect.</p>
</li>
<li>
<p><code>-W</code></p>
<p>Issues additional warning messages beyond those produced by
<code>-Wall</code>.</p>
</li>
<li>
<p><code>-pedantic</code></p>
<p>Issues all warnings required by the C standard. Causes programs that
use non-standard features to be rejected.</p>
</li>
<li>
<p><code>-ansi</code></p>
<p>Turns off features of GCC that aren’t standard C and enables a few
standard features that are normally disabled.</p>
</li>
<li>
<pre><code>-std=c89
-std=c99</code></pre>
<p>Specifies which version of C the compiler should use to check the
program.</p>
</li>
</ul>
<p>These options are often used in combination:</p>
<pre class="shell"><code>gcc -O -Wall -W -pedantic -ansi -std=c99 -o pun pun.c</code></pre>
</div>
<div class="QandA_question">
<p>Q: Why is C so terse? It seems as though programs would be more
readable if C used <code>begin</code> and <code>end</code> instead of
<code>{</code> and <code>}</code>, <code>integer</code> instead of
<code>int</code>, and so forth. [p. 12]</p>
</div>
<div class="QandA_answer">
<p>A: Legend has it that the brevity of C programs is due to the
environment that existed in Bell Labs at the time the language was
developed. The first C compiler ran on a DEC PDP-11 (an early
minicomputer); programmers used a teletype–essentially a typewriter
connected to a computer–to enter programs and print listings. Because
teletypes were very slow (they could print only 10 characters per
second), minimizing the number of characters in a program was clearly
advantageous.</p>
</div>
<div class="QandA_question">
<p>Q: In some C books, the <code>main</code> function ends with
<code>exit(0)</code> instead of <code>return 0</code>. Are these the
same? [p. 14]</p>
</div>
<div class="QandA_answer">
<p>A: When they appear inside <code>main</code>, these statements are
indeed equivalent: both terminate the program, returning the value
<code>0</code> to the operating system. Which one to use is mostly a
matter of taste.</p>
</div>
<div class="QandA_question">
<p>Q: What happens if a program reaches the end of the <code>main</code>
function without executing a <code>return</code> statement? [p. 14]</p>
</div>
<div class="QandA_answer">
<p><span class="C99Symbol"></span></p>
<p>A: The <code>return</code> statement isn’t mandatory; if it’s
missing, the program will still terminate. In C89, the value returned to
the operating system is undefined. In C99, if <code>main</code> is
declared to return an <code>int</code> (as in our examples), the program
returns <code>0</code> to the operating system; otherwise, the program
returns an unspecified value.</p>
</div>
<div class="QandA_question">
<p>Q: Does the compiler remove a comment entirely or replace it with
blank space?</p>
</div>
<div class="QandA_answer">
<p>A: Some old C compilers deleted all the characters in each comment,
making it possible to write</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>a<span class="co">/**/</span>b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>and have the compiler interpret it as</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>ab <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>According to the C standard, however, the compiler must replace each
comment by a single space character, so this trick doesn’t work.
Instead, we’d end up with the following (illegal) statement:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>a b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
</div>
<div class="QandA_question">
<p>Q: How can I tell if my program has an unterminated comment?</p>
</div>
<div class="QandA_answer">
<p>A: If you’re lucky, the program won’t compile because the comment has
rendered the program illegal. If the program does compile, there are
several techniques that you can use. Stepping through the program line
by line with a debugger will reveal if any lines are being skipped. Some
IDEs display comments in a distinctive color to distinuish them from
sorrounding code. If you’re using such an environment, you can easily
spot unterminated comments, since program text will have different color
of it’s accidentally included in a comment. A program such as
<code>lint</code> can also help.</p>
</div>
<div class="QandA_question">
<p>Q: Is it legal to nest one comment inside another?</p>
</div>
<div class="QandA_answer">
<p>A: Old-style comments (<code>/* ... */</code>) can’t be nested. For
instance, the following code is illegal:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="co">    /*** WRONG ***/</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="op">*/</span></span></code></pre></div>
<p>The <code>*/</code> symbol on the second line matches the
<code>/*</code> symbol on the first line, so the compiler will flag the
<code>*/</code> symbol on the third line as an error.</p>
<p><span class="C99Symbol"></span></p>
<p>C’s prohibition against nested comments can sometimes be a problem.
Suppose we’ve written a long program containing many short comments. To
disable a portion of the program temporarily (during testing, say), our
first impulse is to “comment out” the offending lines with
<code>/*</code> and <code>*/</code>. Unfortunately, this method won’t
work if the lines contain old-style comments. C99 comments (those
beginning with <code>//</code>) can be nested inside old-style comments,
however–another advantage to using this kind of comment.</p>
<p>In any event, there’s a better way to disable portions of a program,
as we’ll see later.</p>
</div>
<div class="QandA_question">
<p>Q: Where does the <code>float</code> type get its name? [p. 17]</p>
</div>
<div class="QandA_answer">
<p>A: <code>float</code> is short for “floating-point”, a technique for
storing numbers in which the decimal point “floats”. A float value is
usually stored in two parts: the fraction (or mantissa) and the
exponent. The number 12.0 might be stored as <span
class="displayInlineMath"><span
class="math display">1.5 × 2<sup>3</sup></span></span>, for example,
where 1.5 is the fraction and 3 is the exponent. Some programming
languages call this type <code>real</code> instead of
<code>float</code>.</p>
</div>
<div class="QandA_question">
<p>Q: Why do floating-point constants need to end with letter
<code>f</code>? [p. 19]</p>
</div>
<div class="QandA_answer">
<p>A: For the full explanation, see Chapter 7. Here’s the short answer:
a constant that contains a decimal point but doesn’t end with
<code>f</code> has type <code>double</code> (short for
“double-precision”). <code>double</code> values are stored more
accurately than <code>float</code> values. Moreover, <code>double</code>
values can be larger than <code>float</code> values, which is why we
need to add the letter <code>f</code> when assigning to a
<code>float</code> variable. Without the <code>f</code>, a warning may
be generated about the possibility of a number being stored into a
<code>float</code> variable that exceeds the capacity of the
variable.</p>
</div>
<div class="QandA_question">
<p>*Q: Is it really true that there’s no limit on the length of an
identifier? [p. 26]</p>
</div>
<div class="QandA_answer">
<p>A:</p>
<p><span class="C99Symbol"></span></p>
<p>Yes and no. The C89 standard says that identifiers may be arbitrarily
long. However, compilers are only required to remember the first 31
characters (63 characters in C99). Thus, if two names begin with the
same 31 characters, a compiler might be unable to distinguish between
them.</p>
<p><span class="C99Symbol"></span></p>
<p>To make matters even more complicated, there are special rules for
identifiers with external linkage; most function names fall into this
category. Since these names must be made available to the linker, and
since some older linkers can handle only short names, only the first six
characters are significant in C89. Moreover, the case of letters may not
matter. As a result, <code>ABCDEFG</code> and <code>abcdefg</code> might
be treated as the same name. (In C99, the first 31 characters are
significant, and the case of letters is taken into account.)</p>
<p>Most compilers and linkers are more generous than the standard, so
these rules aren’t a problem in practice. Don’t worry about making
identifiers too long–worry about making them too short.</p>
</div>
<div class="QandA_question">
<p>Q: How many spaces should I use for indentation? [p. 28]</p>
</div>
<div class="QandA_answer">
<p>A: That’s a tough question. Leave too little space, and the eye has
trouble detecting indentation. Leave too much, and the lines run off the
screen (or page). Many C programmers indent nested statements eight
spaces (one tab stop), which is probably too much. Studies have shown
that the optimum amount of indentation is three spaces, but many
programmers feel uncomfortable with numbers that aren’t a power of two.
Although I normally prefer to indent three or four spaces. I’ll use two
spaces in this book so that my programs will fit within the margins.</p>
</div>
<h2 id="examples">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh02/cknkCh02Exmp/">./cknkCh02/cknkCh02Exmp/</a></li>
</ul>
<h2 id="exercises">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh02/cknkCh02Exrc/README.md">./cknkCh02/cknkCh02Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh02/cknkCh02Exrc/cknkCh02ExrcReadme.html">./cknkCh02/cknkCh02Exrc/cknkCh02ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh02/cknkCh02Exrc/">./cknkCh02/cknkCh02Exrc/</a></li>
</ul>
<h2 id="programming-projects">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh02/cknkCh02Prj/README.md">./cknkCh02/cknkCh02Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh02/cknkCh02Prj/cknkCh02PrjReadme.html">./cknkCh02/cknkCh02Prj/cknkCh02PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh02/cknkCh02Prj/">./cknkCh02/cknkCh02Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="formatted-inputoutput">3 Formatted Input/Output</h1>
<div class="theQuote">
In seeking the unattainable, simplicity only gets in the way.
</div>
<p><code>scanf</code> and <code>printf</code>, which support formatted
reading and writing, are two of the most frequently used functions in C.
As this chapter shows, both are powerful but tricky to use properly.
Section 3.1 describes <code>printf</code>, and Sectioon 3.2 covers
<code>scanf</code>. Neither section gives complete details, which will
have to wait until Chapter 22.</p>
<h2 id="the-printf-function">3.1 The <code>printf</code> Function</h2>
<p>The <code>printf</code> function is designed to display the contents
of a string, known as the <strong><em>format string</em></strong>, with
values possibly inserted at specified points in the string. When it’s
called, <code>printf</code> must be supplied with the format string,
followed by any values that are to be inserted into the string during
printing:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span>string<span class="op">,</span> expr1<span class="op">,</span> expr2<span class="op">,</span> <span class="op">...);</span></span></code></pre></div>
<p>The values displayed can be constants, variables, or more complicated
expressions. There’s no limit on the number of values that can be
printed by a single call of <code>printf</code>.</p>
<p>The format string may contain both ordinary characters and
<strong><em>conversion specifications</em></strong>, which begin with
the <code>%</code> character. A conversion specification is a place
holder representing a value to be filled in during printing. The
information that follows the % character <em>specifies</em> how the
value is <em>converted</em> from its internal form (binary) to printed
form (characters)–that’s where the term “conversion specification” comes
from. For example, the conversion specification <code>%d</code>
specifies that <code>printf</code> is to convert an <code>int</code>
value from binary to a string of decimal digits, while <code>%f</code>
does the same for a <code>float</code> value.</p>
<p>Ordinary characters in a format string are printed exactly as they
appear in the string; conversion specifications are replaced by the
values to be printed. Consider the following example:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">43.2892</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fl">5527.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i = %d, j = %d, x = %f, y = %f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span></code></pre></div>
<p>This call of <code>printf</code> produces the following output:</p>
<pre class="shell"><code>i = 10, j = 20, x = 43.289200, y = 5527.000000</code></pre>
<p>The ordinary characters in the format string are simply copied to the
output line. The four conversion specifications are replaced by the
values of the variables <code>i</code>, <code>j</code>, <code>x</code>,
and <code>y</code>, in that order.</p>
<div class="infoBox">
<p><span class="warningEmoji"><span></p>
<p>C compilers aren’t required to check that the number of conversion
specifications in a format string matches the number of output items.
The following call of <code>printf</code> has more conversion
specifications than values to be printed:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p><code>printf</code> will print the value of <code>i</code> correctly,
then print a second (meaningless) integer value. A call with too few
conversion specifications has similar problems:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>In this case, <code>printf</code> prints the value of <code>i</code>
but doesn’t show the value of <code>j</code>.</p>
<p>Furthermore, compilers aren’t required to check that a conversion
specification is appropriate for the type of item being printed. If the
programmer uses an incorrect specification, the program will simply
produce meaningless output. Consider the following call of
<code>printf</code>, in which the <code>int</code> variable
<code>i</code> and the <code>float</code> variable <code>x</code> are in
the wrong order:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%f %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> x<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>Since <code>printf</code> must obey the format string, it will
dutifully display a <code>float</code> value, followed by an
<code>int</code> value. Unfortunately, both will be meaningless.</p>
</div>
<h3 id="conversion-specifications">3.1.1 Conversion Specifications</h3>
<p>Conversion specifications give the programmer a great deal of control
over the appearance of output. On the other hand, they can be
complicated and hard to read. In fact, describing conversion
specifications in complete detail is too arduous a task to tackle this
early in the book. Instead, we’ll just take a brief look at some of
their more important capabilities.</p>
<p>In chapter 2 , we saw that a conversion specification can include
formatting information. In particular, we used <code>%.1f</code> to
display a <code>float</code> value with one digit after the decimal
point. More generally, a conversion specification can have the form
<code>%m.pX</code> or <code>%-m.pX</code>, where <code>m</code> and
<code>p</code> are integer constants and <code>X</code> is a letter.
Both <code>m</code> and <code>p</code> are optional; if <code>p</code>
is omitted, the period that separates <code>m</code> and <code>p</code>
is also dropped. In the conversion specification <code>%10.2f</code>,
<code>m</code> is <code>10</code>, <code>p</code> is <code>2</code>, and
<code>X</code> is <code>f</code>. In the specification
<code>%.2f</code>, <code>p</code> is <code>2</code> and <code>m</code>
is missing.</p>
<p>The <strong><em>minimum field width</em></strong>, <code>m</code>,
specifies the minimum number of characters to print. If the value to be
printed requires fewer than <code>m</code> characters, the values is
right justified within the field. (in other words, extra spaces precede
the value.) For example, the specification <code>%4d</code> would
display the number 123 as <code>123</code>. (Please notice the
preceeding space). If the value to be porinted requires more than
<code>m</code> characters, the field width automatically expands to the
necessary size. Thus, the specification <code>%4d</code> would display
the number 12345 as <code>12345</code>–no digits are lost. Putting a
minus sign in front of <code>m</code> causes left justification; the
specification <code>%-4d</code> would display 123 as
<code>123</code>.</p>
<p>The meaning of the <strong><em>precision</em></strong>,
<code>p</code> isn’t as easily described, since it depends on the choice
of <code>X</code>, the <strong><em>conversion specifier</em></strong>.
<code>X</code> indicates which conversion should be applied to the value
before it’s printed. The most common conversion specifiers for numbers
are:</p>
<ul>
<li>
<p><span class="QandA"></span></p>
<p><code>d</code> – Displays an integer in decimal (base 10) form.
<code>p</code> indicates the minimum number of digits to display (extra
zeros are added to the beginning of the number if necessary); if
<code>p</code> is omitted, it is assumed to have the value 1. (In other
words, <code>%d</code> is the same as <code>%.1d</code>.)</p>
</li>
<li>
<p><code>e</code> – Displays a floating-point number in exponential
format (scientific notation). <code>p</code> indicates how many digits
should appear after the decimal point (the default is 6). If
<code>p</code> is 0, the decimal point is not displayed.</p>
</li>
<li>
<p><code>f</code> – Displays a floating-point number in “fixed decimal”
format, without an exponent. <code>p</code> has the same meaning as for
the <code>e</code> specifier.</p>
</li>
<li>
<p><code>g</code> – Displays a floating-point number in either
exponential format or fixed decimal format, depending on the number’s
size. <code>p</code> indicates the maximum number of significant digits
(<em>not</em> digits after the decimal point) to be displayed. Unlike
the <code>f</code> conversion, the <code>g</code> conversion won’t show
trailing zeros. Furthermore, if the value to be printed has no digits
after the decimal point, <code>g</code> doesn’t display the decimal
point.</p>
</li>
</ul>
<p>The <code>g</code> specifier is especially useful for displaying
numbers whose size can’t be predicted when the program is written or
that tend to vary widely in size. When used to print a moderately large
or moderately small number, the <code>g</code> specifier uses fixed
decimal format. But when used to print a very large or very small
number, the <code>g</code> specifier switches to exponential format so
that the number will require fewer characters.</p>
<p>There are many other specifiers besides <code>%d</code>,
<code>%e</code>, <code>%f</code>, and <code>%g</code>. I’ll gradually
introduce many of them in subsequent chapters. For the full list, and
for a complete explanation of the other capabilities of conversion
specifications, consult Section 22.3.</p>
<h3 id="using-printf-to-format-numbers">3.1.2 Using <code>printf</code>
to Format Numbers</h3>
<p>The following program illustrates the use of <code>printf</code> to
print integers and floating-point numbers in various formats.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">/** </span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co">  * file: tprintf.c</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co">  * Purpose: Prints int and float values in various formats</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="co">  * Author: K. N. King</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="co">  */</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x<span class="op">;</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">40</span><span class="op">;</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="fl">839.21</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;|%d|%5d|%-5d|%5.3d|</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> i<span class="op">,</span> i<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;|%10.3f|%10.3e|%-10g|</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> x<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The character <code>|</code> in the <code>printf</code> format
strings are there merely to help show how much space each number
occupies when printed; unlike <code>%</code> or <code>\</code>, the
<code>|</code> character has no special significance to
<code>printf</code>. The output of this program is:</p>
<pre class="shell"><code>|40|   40|40   |  040|
|   839.210| 8.392e+02|839.21    |</code></pre>
<p>Let’s take a closer look at the conversion specifications used in
this program:</p>
<ul>
<li>
<p><code>%d</code> – Displays <code>i</code> in decimal form, using a
minimum amount of space.</p>
</li>
<li>
<p><code>%5d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters. Since <code>i</code> requires only two
characters,three spaces were added.</p>
</li>
<li>
<p><code>%-5d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters; since the value of <code>i</code> doesn’t
require five characters, the spaces are added afterward (that is,
<code>i</code> is left-justified in a field of length five).</p>
</li>
<li>
<p><code>%5.3d</code> – Displays <code>i</code> in decimal form, using a
minimum of five characters overall and a minimum of three digits. Since
<code>i</code> is only two digits long, an extra zero was added to
guarantee three digits. The resulting number is only three characters
long, so two spaces were added, for a total of five characters
(<code>i</code> is right-justified).</p>
</li>
<li>
<p><code>%10.3f</code> – Display <code>x</code> in fixed decimal form,
using 10 characters overall with three digits after the decimal point.
Since <code>x</code> requires only seven charcaters (three before the
decimal point, three after the decimal point, and one for the decimal
point itself), three spaces precede <code>x</code>.</p>
</li>
<li>
<p><code>%10.3e</code> – Displays <code>x</code> in exponential form,
using 10 characters overall, with three digits after the decimal point.
<code>x</code> requires nine characters altogether (including the
exponent), so one space precedes <code>x</code>.</p>
</li>
<li>
<p><code>%-10g</code> – Display <code>x</code> in either fixed decimal
form or exponential form, using 10 characters overall. In this case,
<code>printf</code> chose to display <code>x</code> in fixed decimal
form. The presence of the minus sign forces left justification, so
<code>x</code> is followed by spaces.</p>
</li>
</ul>
<h3 id="escape-sequences">3.1.3 Escape Sequences</h3>
<p>The <code>\n</code> code that we often use in format strings is
called an <strong><em>escape sequence</em></strong>. Escape sequences
enable strings to contain characters that would otherwise cause problems
for the compiler, including nonprinting (control) characters and
characters that have special meaning to the compiler (such as
<code>"</code>). We’ll provide a complete list of escape sequences
later; for now, here’s a sample:</p>
<table>
<tbody>
<tr class="odd">
<td>Alert (bell)</td>
<td><code>\a</code></td>
</tr>
<tr class="even">
<td>Backspace</td>
<td><code>\b</code></td>
</tr>
<tr class="odd">
<td>New line</td>
<td><code>\n</code></td>
</tr>
<tr class="even">
<td>Horizontal tab</td>
<td><code>\t</code></td>
</tr>
</tbody>
</table>
<p><span class="QandA"><span></p>
<p>When they appear in <code>printf</code> format strings, these escape
sequences represent actions to perform upon printing. printing
<code>\a</code> causes an audible beep on most machines. Printing
<code>\b</code> moves the cursor back one position. Printing
<code>\n</code> advances the cursor to the beginning of the next line.
printing <code>\t</code> moves the cursor to the next tab stop.</p>
<p>A string may contain any number of escape sequences. consider the
following <code>printf</code> example, in which the format string
contains six escape sequences:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Item</span><span class="sc">\t</span><span class="st">Unit</span><span class="sc">\t</span><span class="st">Purchase</span><span class="sc">\n\t</span><span class="st">Price</span><span class="sc">\t</span><span class="st">Date</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Executing this statement prints a two-line heading:</p>
<pre class="shell"><code>Item    Unit    Purchase
        Price   Date</code></pre>
<p>Another common escape sequence is <code>\"</code>, which represents
the <code>"</code> character. Since the <code>"</code> charcater marks
the beginning of this sequence. here’s and example:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\&quot;</span><span class="st">Hello!</span><span class="sc">\&quot;</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>This statement produces the following output:</p>
<pre class="shell"><code>&quot;Hello!&quot;</code></pre>
<p>Incidentally, you can’t just put a single <code>\</code> character in
a string; the compiler will assume that it’s the beginning of an escape
sequence. To print a single <code>\</code> character, put two
<code>\</code> characters in the string:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\\</span><span class="st">&quot;</span><span class="op">);</span>    <span class="co">/* prints one \ character */</span></span></code></pre></div>
<h2 id="the-scanf-function">3.2 The <code>scanf</code> Function</h2>
<p>Just as <code>printf</code> prints output in a specified format,
<code>scanf</code> reads input according to a particular format. A
<code>scanf</code> format string, like a <code>printf</code> format
string, may contain both ordinary characers and conversion
specifications. The conversions allowed with <code>scanf</code> are
essentially the same as those used with <code>printf</code>.</p>
<p>In many cases, a <code>scanf</code> format string will contain only
conversion specifications, as in the following example:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f, &amp;i, &amp;j, &amp;x, &amp;y);</span></span></code></pre></div>
<p>Suppose that the user enters the following input line:</p>
<pre class="shell"><code>1 -20 .3 -4.0e3</code></pre>
<p><code>scanf</code> will read the line, converting its characters to
the numbers they represent, and then assign 1, -20, 0.3, and -4000.0 to
<code>i</code>, <code>j</code>, <code>x</code>, and <code>y</code>,
respectively. “tightly packed” format strings like
<code>"%d%d%f%f</code> are common in <code>scanf</code> calls.
<code>printf</code> format strings are less likely to have adjacent
conversion specifications.</p>
<p><code>scanf</code>, like <code>printf</code>, contains several traps
for the unwary. When using <code>scanf</code>, the programmer must check
that the number of conversion specifications matches the number of input
variables and that each conversion is appropriate for the corresponding
variable–as with <code>printf</code>, the compiler isn’t required to
check for a possible mismatch. Another trap involves the
<code>&amp;</code> symbol, which normally precedes each variable in a
<code>scanf</code> call. The <code>&amp;</code> is usually (but not
always) required, and it’s the programmer’s responsibility to remember
to use it.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Forgetting to put the <code>&amp;</code> symbol in front of variable
in a call of <code>scanf</code> will have unpredictable–and possibly
disastrous–results. A program crash is a common outcome. At the very
least, the value that is read from the input won’t be stored in the
variable; instead, the variable will retain its old value (which may be
meaningles if the variable wasn’t given an initial value). Omitting the
<code>&amp;</code> is an extremely common error–be careful! Some
compilers can spot this error and produce a warning message such as
<em>“format argument is not a pointer”</em>. (The term <em>pointer</em>
is defined in Chapter 11; the <code>&amp;</code> symbol is used to
create a pointer to a variable.) If you get a warning, check for a
missing <code>&amp;</code>.</p>
</div>
<p>Calling <code>scanf</code> is a powerful but unforgiving way to read
data. Many professional C programmers avoid <code>scanf</code>, instead
reading all data in character form and converting it to numeric form
later. We’ll use <code>scanf</code> quite a bit, especially in the early
chapters of this book, because it provides a simple way to read numbers.
Be aware, however, that many of our programs won’t behave properly if
the user enters unexpected input. As we’ll see later, it’s possible to
have a program test whether <code>scanf</code> successfully read the
requested data (and attempt to recover if it didn’t). Such tests are
impractical for the programs in this book–they would add too many
statements and obscure the point of the examples.</p>
<h3 id="how-scanf-works">3.2.1 How <code>scanf</code> Works</h3>
<p><code>scanf</code> can actually do much more than I’ve indicated so
far. It is essentially a “pattern-matching” function that tries to match
up groups of input characters with conversion specifications.</p>
<p>Like the <code>printf</code> function, <code>scanf</code> is
controlled by the format string. When it is called, <code>scanf</code>
begins processing the information in the string, starting at the left.
For each conversion specification in the format string,
<code>scanf</code> tries to locate an item of the appropriate type in
the input data, skipping blank space if necessary. <code>scanf</code>
then reads the item, stopping when it encounters a character that can’t
possibly belong to the item. If the item was read sucessfully,
<code>scanf</code> continues processing the rest of the format string.
If any item is not read successfully, <code>scanf</code> returns
immediately without looking at the rest of the format string (or the
remaining input data).</p>
<p>As it searches for the beginning of a number, <code>scanf</code>
ignores <strong><em>white-space characters</em></strong> (the space,
horizontal and vertical tab, form-feed, and new-line characters). As a
result, numbers can be put on a single line or spread out over several
lines. Consider the following call of <code>scanf</code>:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span></code></pre></div>
<p>Suppose the user enters three lines of input:</p>
<pre class="shell"><code>  1
-20   .3
   -4.0e3</code></pre>
<p><code>scanf</code> sees one continuous stream of characters:</p>
<pre><code>&lt;space&gt;&lt;space&gt;1&lt;newLine&gt;-20&lt;space&gt;&lt;space&gt;&lt;space&gt;.3&lt;newLine&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;-4.0e3&lt;newLine&gt;</code></pre>
<p>(I’m using <code>&lt;space&gt;</code> to represent the space
character and <code>&lt;newLine&gt;</code> to represent the new-line
character.) Since it skips over white-space characters as it looks for
the beginning of each number, <code>scanf</code> will be able to read
the numbers successfully.</p>
<p><code>scanf</code> “peeks” at the final new-line character without
actually reading it. This new-line will be the first character read by
the next call of <code>scanf</code>.</p>
<p>What rules does <code>scanf</code> follow to recognize an integer or
a floating-point number? When asked to read an integer,
<code>scanf</code> first searches for a digit, a plus sign, or a minus
sign; it then reads digits until it reaches a nondigit. when asked to
read a floating-point number, <code>scanf</code> looks for<br />
- a plus or minus sign (optional), followed by<br />
- a series of digits (possibly containing a decimal point), followed
by<br />
- an exponent (optional). An exponent consists of the letter
<code>e</code> (or <code>E</code>), an optional sign, and one or more
digits.</p>
<p>The <code>%e</code>, <code>%f</code>, and <code>%g</code> conversions
are interchangeable when used with <code>scanf</code>; all three follow
the same rules for recognizing a floating-point number.</p>
<p><span class="QandA"><span></p>
<p>When <code>scanf</code> encounters a character that can’t be part of
the current item, the character is “put back” to be read again during
the scanning of the next input item or during the next call of
<code>scanf</code>. Consider the following (admittedly pathological)
arrangement of our four numbers:</p>
<pre class="shell"><code>1-20.3-4.0e3
</code></pre>
<p>Let’s use the same call of <code>scanf</code> as before:</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d%f%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span></code></pre></div>
<p>Here’s how <code>scanf</code> would process the new input:</p>
<ul>
<li>Conversion specification: <code>%d</code>. The first nonblank input
character is <code>1</code>; since integers can begin with 1,
<code>scanf</code> then reads the next character, <code>-</code>.
Recognizing that <code>-</code> can’t appear inside an integer,
<code>scanf</code> stores <code>1</code> into <code>i</code> and puts
the <code>-</code> character back.<br />
</li>
<li>Conversion specification: <code>%d</code>. <code>scanf</code> then
reads the characters <code>-</code>, <code>2</code>, <code>0</code>, and
<code>.</code> (period). Since an integer can’t contain a decimal point,
<code>scanf</code> stores <code>-20</code> into <code>j</code> and puts
the <code>.</code> character back.<br />
</li>
<li>Conversion specification: <code>%f</code>. <code>scanf</code> reads
the characters <code>.</code>, <code>3</code>, and <code>-</code>. Since
a floating-point number can’t contain a minus sign after a digit,
<code>scanf</code> stores <code>0.3</code> into <code>x</code> and puts
the <code>-</code> character back.<br />
</li>
<li>conversion specification <code>%f</code>. Lastly, <code>scanf</code>
reads the characters <code>-</code>, <code>4</code>, <code>.</code>,
<code>0</code>, <code>e</code>, <code>3</code>, and a new line. Since a
floating-point number can’t contain a new-line character,
<code>scanf</code> stores <span class="displayInlineMath"><span
class="math display">−4.0 × 10<sup>3</sup></span></span> into
<code>y</code> and puts the new-line character back.</li>
</ul>
<p>In this example, <code>scanf</code> was able to match every
conversion specification in the format string with an input item. Since
the new-line character wasn’t read, it will be left for the next call of
<code>scanf</code>.</p>
<h3 id="ordinary-characters-in-format-strings">3.2.2 Ordinary Characters
in Format Strings</h3>
<p>The concept of pattern-matching can be taken one step further by
writing format strings that contain ordinary characters in addition to
conversion specifications. The action that <code>scanf</code> takes when
it processes an ordinary character in a format string depends on whether
or not it’s a white-space character.</p>
<ul>
<li>
<p><strong><em>White-space characters.</em></strong> When it encounters
one or more consecutive white-space characters in a format string,
<code>scanf</code> repeatedly reads white-space characters from the
input until it reaches a non-white-space character (which is “put
back”). The number of white-space characters in the format string is
irrelevant; one white-space character in the format string will match
any number of white-space characters in the input. (Incidentally,
putting a white-space character in a format string doesn’t force the
input to contain white-space characters. A white-space character in a
format string matches <em>any</em> number of white-space characters in
the input, including none.)</p>
</li>
<li>
<p><strong><em>Other characters.</em></strong> When it encounters a
non-white-space character in a format string, <code>scanf</code>
compares it with the next input character. if the two characters match,
<code>scanf</code> discards the input character and continues processing
the format string. If the characters don’t match, <code>scanf</code>
puts the offencing character back into the input, then aborts without
further processing the format string or reading characters from the
input.</p>
<p>For example, suppose that the format string is <code>"%d/%d"</code>.
If the input is <code>&lt;space&gt;5/&lt;space&gt;96</code>,
<code>scanf</code> skips the first space while looking for an integer,
matches <code>%d</code> with <code>5</code>, matches <code>/</code> with
<code>/</code>, skips a space while looking for another integer, and
matches <code>%d</code> with <code>96</code>. On the other hand, if the
input is <code>&lt;space&gt;5&lt;space&gt;/&lt;space&gt;96</code>,
<code>scanf</code> skips one space, matches <code>%d</code> with
<code>5</code>, then attempts to match the <code>/</code> in the format
string with a space in the input. There’s no match, so
<code>scanf</code> puts the space back; the
<code>&lt;space&gt;/&lt;space&gt;96</code> characters remain to be read
by the next call of <code>scanf</code>. To allow spaces after the first
number, we should use the format string <code>"%d /%d"</code>
instead.</p>
</li>
</ul>
<h3 id="confusing-printf-with-scanf">3.2.3 Confusing <code>printf</code>
with <code>scanf</code></h3>
<p>Although calls of <code>scanf</code> and <code>printf</code> may
appear similar, there are significant differences between the two
functions; ignoring these differences can be hazardous to the health of
your program.</p>
<p>One common mistake is to put <code>&amp;</code> in front of variables
in a call of <code>printf</code>:</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>Fortunately, this mistake is fairly easy to spot: <code>printf</code>
will display a couple of odd-looking numbers instead of the values of
<code>i</code> and <code>j</code>.</p>
<p>Since <code>scanf</code> normally skips white-space characters when
looking for data items, there’s often no need for a format string to
include characters other than conversion specifications. Incorrectly
assuming that <code>scanf</code> format strings should resemble
<code>printf</code> format strings–another common error–may cause
<code>scanf</code> to behave in unexpected ways. Let’s see what happens
when the following call of <code>scanf</code> is executed:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d, %d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
<p><code>scanf</code> will first look for an integer in the input, which
it stores in the variables <code>i</code>. <code>scanf</code> will then
try to match a comma with the next input character. If the next input
character is a space, not a comma, <code>scanf</code> will terminate
without reading a value for <code>j</code>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Although <code>printf</code> format strings often end with
<code>\n</code>, putting a new-line character at the end of a
<code>scanf</code> format string is usually a bad idea. To
<code>scanf</code>, a new-line character in a format string is
equivalent to a space; both cause <code>scanf</code> to advance to the
next non-white-space character. For example, if the format string is
<code>" %d\n"</code>, <code>scanf</code> will skip white space, read an
integer, then skip to the next non-white-space character. A format
string like this can cause an interactive program to “hang” until user
enters a nonblank character.</p>
</div>
<h3 id="program-adding-fractions">3.2.4 (PROGRAM) Adding Fractions</h3>
<p>To illustrate <code>scanf</code>’s ability to match patterns,
consider the problem of reading a fraction entered by the user.
Fractions are customarily written in the form
<em>numerator/denominator</em>. Instead of having the user enter the
numerator and denominator of a fraction as separate integers,
<code>scanf</code> makes it possible to read the entire fraction. The
following program, which adds two fractions, illustartes this
technique.</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: addfrac.c</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Adds two fractions</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num1<span class="op">,</span> denom1<span class="op">,</span> num2<span class="op">,</span> denom2<span class="op">,</span> result_num<span class="op">,</span> result_denom<span class="op">;</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter first fraction: &quot;</span><span class="op">);</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d/%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num1<span class="op">,</span> <span class="op">&amp;</span>denom1<span class="op">);</span></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter second fraction: &quot;</span><span class="op">);</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d/%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num2<span class="op">,</span> <span class="op">&amp;</span>denom2<span class="op">);</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>    result_num <span class="op">=</span> num1 <span class="op">*</span> denom2 <span class="op">+</span> num2 <span class="op">*</span> denom1<span class="op">;</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>    result_denom <span class="op">=</span> denom1 <span class="op">*</span> denom2<span class="op">;</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;The sum is %d/%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> result_num<span class="op">,</span> result_denom<span class="op">);</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A session with this program might have the following appearance:</p>
<pre class="shell"><code>Enter first fraction: 5/6
Enter second fraction: 3/4
The sum is 38/24</code></pre>
<p>Note that the resulting fraction isn’t reduced to lowest terms.</p>
<hr />
<h2 id="q-a-1">Q &amp; A</h2>
<div class="QandA_question">
<p>*Q: I’ve seen the <code>%i</code> conversion used to read and write
integers. What’s the difference between <code>%i</code> and
<code>%d</code>? [p. 39]</p>
</div>
<div class="QandA_answer">
<p>A: In a <code>printf</code> format string, there’s no difference
between the two. In a <code>scanf</code> format string, however,
<code>%d</code> can only match an integer written in decimal (base 10)
form, while <code>%i</code> can match an integer expressed in octal
(base 8), decimal, or hexadecimal (base 16). If an input number has a
<code>0</code> prefix (as in <code>056</code>), <code>%i</code> treats
it as an octal number, if it has a <code>0x</code> or <code>0X</code>
prefix (as in <code>0x56</code>), <code>%i</code> treats it as a hex
number. Using <code>%i</code> instead of <code>%d</code> to read a
number can have surprising results if the user should accidentally put
<code>0</code> at the beginning of the number. Because of this trap, I
recommend sticking with <code>%d</code>.</p>
</div>
<div class="QandA_question">
<p>Q: If <code>printf</code> treats <code>%</code> as the beginning of a
conversion specification, how can I print the <code>%</code>
character?</p>
</div>
<div class="QandA_answer">
<p>A: If <code>printf</code> encounters two consecutive <code>%</code>
characters in a format strring, it prints a single <code>%</code>
character. For example, the statement</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Net profit: %d%%</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> profit<span class="op">);</span></span></code></pre></div>
<p>might print</p>
<pre class="shell"><code>Net profit: 10%</code></pre>
</div>
<div class="QandA_question">
<p>Q: The <code>\t</code> escape is supposed to cause
<code>printf</code> to advance to the next tab stop. How do I know how
far apart tab stops are? [p. 41]</p>
</div>
<div class="QandA_answer">
<p>A: You don’t. The effect of printing <code>\t</code> isn’t defined in
C; it depends on what your operating system does when asked to print a
tab character. Tab stops are typically eight characters apart, but C
makes no guarantee.</p>
</div>
<div class="QandA_question">
<p>Q: What does <code>scanf</code> do if it’s asked to read a number but
the user enters nonnumeric input?</p>
</div>
<div class="QandA_answer">
<p>A: Let’s look at the following example:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter a number: &quot;</span><span class="op">);</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span></code></pre></div>
<p>Suppose that the user enters a valid number, followed by nonnumeric
characters:</p>
<pre class="shell"><code>Enter a number: 23foo</code></pre>
<p>In this case, <code>scanf</code> reads the <code>2</code> and the
<code>3</code>, storing <code>23</code> in <code>i</code>. The remaining
characters (<code>foo</code>) are left to be read by the next call of
<code>scanf</code> (or some other input function). On the other hand,
suppose that the input is invalid from the beginning:</p>
<pre class="shell"><code>Enter a number: foo</code></pre>
<p>In this case, the value of <code>i</code> is undefined and
<code>foo</code> is left for the next <code>scanf</code>.</p>
<p>What can we do about this sad state of affairs? Later, we’ll see how
to test whether a call of <code>scanf</code> has succeeded. If the call
fails, we can have the program either terminate or try to recover,
perhaps by discarding the offending input and asking the user to try
again. (Ways to discard bad input are discussed in the Q&amp;A section
at the end of chapter 22.)</p>
</div>
<div class="QandA_question">
<p>Q: I don’t understand how <code>scanf</code> can “put back”
characters and read them again later. [p. 44]</p>
</div>
<div class="QandA_answer">
<p>A: As it turns out, programs don’t read user input as it is typed.
Instead input is stored in a hidden buffer, to which <code>scanf</code>
has access. It’s easy for <code>scanf</code> to put characters back into
the buffer for subsequent reading. Chapter 22 discusses input buffering
in more detail.</p>
</div>
<div class="QandA_question">
<p>Q: What does <code>scanf</code> do if the user puts punctuation marks
(commas, for example) between numbers?</p>
</div>
<div class="QandA_answer">
<p>A: Let’s look at a simple example. Suppose that we try to read a pair
of integers using <code>scanf</code>:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter two numbers: &quot;</span><span class="op">);</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
<p>If the user enters</p>
<pre class="shell"><code>4,28</code></pre>
<p><code>scanf</code> will read <code>4</code> and store it in
<code>i</code>, As it searches for the beginning of the second number,
<code>scanf</code> encounters the comma. Since numbers can’t begin with
a comma, <code>scanf</code> returns immediately. The comma and the
second number are left for the next call of <code>scanf</code>.</p>
<p>Of course, we can easily solve the problem by adding a comma to the
format string if we’re sure that the numbers will <em>always</em> be
separated by a comma:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter two numbers, separated by a comma: &quot;</span><span class="op">);</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>scanf<span class="op">(</span><span class="st">&quot;%d,%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i<span class="op">,</span> <span class="op">&amp;</span>j<span class="op">);</span></span></code></pre></div>
</div>
<h2 id="examples-1">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh03/cknkCh03Exmp/">./cknkCh03/cknkCh03Exmp/</a></li>
</ul>
<h2 id="exercises-1">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh03/cknkCh03Exrc/README.md">./cknkCh03/cknkCh03Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh03/cknkCh03Exrc/cknkCh03ExrcReadme.html">./cknkCh03/cknkCh03Exrc/cknkCh03ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh03/cknkCh03Exrc/">./cknkCh03/cknkCh03Exrc/</a></li>
</ul>
<h2 id="programming-projects-1">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh03/cknkCh03Prj/README.md">./cknkCh03/cknkCh03Prj/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh03/cknkCh03Prj/cknkCh03PrjReadme.html">./cknkCh03/cknkCh03Prj/cknkCh03PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh03/cknkCh03Prj/">./cknkCh03/cknkCh03Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="expressions">4 Expressions</h1>
<div class="theQuote">
<p>One does not learn computing by using a hand calculator, but one can
forget arithmetic.</p>
</div>
<p>One of C’s distinguishing characteristics is its emphasis on
expressions–formulas that show how to compute a value–rather than
statements. The simplest expressions are variables and constants. A
variable represents a value to be computed as the program runs; a
constant represents a value that doesn’t change. More complicated
expressions apply operators to operands (which are themselves
expressions). In the expression <code>a + (b * c)</code>, the
<code>+</code> operator is applied to the operands <code>a</code> and
<code>(b * c)</code>, both of which are expressions in their own
right.</p>
<p>Operators are the basic tools for building expressions, and C has an
unusually rich collection of them. To start off, C provides the
rudimentary operators that are found in most programming
languages:<br />
- Arithmetic operators, including addition, subtraction, multiplication,
and division.<br />
- Relational operators to perform comparisons such as “<code>i</code> is
<em>greater than</em> 0.”<br />
- Logical operators to build conditions such as “<code>i</code> is
greater than 0 <em>and</em> <code>i</code> is less than 10.”</p>
<p>But C doesn’t stop here; it goes on to provide dozens of other
operators. There are so many operators, in fact, that we’ll need to
introduce them gradually over the first twenty chapters of this book.
Mastering so many operators can be a chore, but it’s essential to
becoming proficient at C.</p>
<p>In this chapter, we’ll cover some of C’s most fundamental operators:
the arithmetic operators (Section 4.1), the assignment operators
(Section 4.2), and the increment and decrement operators (Section 4.3).
Section 4.1 also explains operator precedence and associativity, which
are important for expressions that contain more than one operator.
Section 4.4 describes how C expressions are evaluated. Finally, Section
4.5 introduces the expression statement, an unusual feature that allows
any expression to serve as a statement.</p>
<h2 id="arithmetic-operators">4.1 Arithmetic Operators</h2>
<p>The <strong><em>arithmetic operators</em></strong>–operators that
perform addition, subtraction, multiplication, and division–are the
workhorses of many programming languages, including C. Table 4.1 shows
C’s arithmetic operators.</p>
<p><strong>Table 4.1:</strong> Arithmetic Operators</p>
<table>
<thead>
<tr>
<th rowspan="2" style="text-align: center">
<p><strong><em>Unary</em></strong></p>
</th>
<th colspan="2" style="text-align: center">
<p><strong><em>Binary</em></strong></p>
</th>
</tr>
<tr>
<th style="text-align: center">
<p><strong><em>Additive</em></strong></p>
</th>
<th style="text-align: center">
<p><strong><em>Multiplicative</em></strong></p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><code>+</code> unary plus</p>
</td>
<td>
<p><code>+</code> addition</p>
</td>
<td>
<p><code>*</code> multiplication</p>
</td>
</tr>
<tr>
<td>
<p><code>-</code> unary minus</p>
</td>
<td>
<p><code>-</code> subtraction</p>
</td>
<td>
<p><code>/</code> division</p>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
<p><code>%</code> remainder</p>
</td>
</tr>
</tbody>
</table>
<p>The additive and multiplicative operators are said to be
<strong><em>binary</em></strong> because they require <em>two</em>
operands. The <strong><em>unary</em></strong> operators require
<em>one</em> operand:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">+</span><span class="dv">1</span><span class="op">;</span>    <span class="co">/* + used as a unary operator */</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span>    <span class="co">/* - used as a unary operator */</span></span></code></pre></div>
<p>The unary <code>+</code> operator does nothing; in fact, it didn’t
even exist in K &amp; R C. It’s used primarily to emphasize that a
numeric constant is positive.</p>
<p>The binary operators probably look familiar. The only one that might
not is <code>%</code>, the remainder operator. The value of
<code>i % j</code> is the remainder when <code>i</code> is divided by
<code>j</code>. For example, the value of <code>10 % 3</code> is 1, and
the value of <code>12 % 4</code> is 0.</p>
<p><span class="QandA"></span></p>
<p>The binary operators in Table 4.1–with the exception of
<code>%</code>–allow either integer or floating-point operands, with
mixing allowed. When <code>int</code> and <code>float</code> operands
are mixed, the result has type <code>float</code>. Thus,
<code>9 + 2.5f</code> has the value <code>11.5</code>, and
<code>6.7f / 2</code> has the value <code>3.35</code>.</p>
<p>The <code>/</code> and <code>%</code> operators require special
care:</p>
<ul>
<li>
<p>The <code>/</code> operator can produce surprising results. When both
of its operands are integers, the <code>/</code> operator “truncates”
the result by dropping the fractional part. Thus, the value of
<code>1 / 2</code> is 0, not <code>0.5</code>.</p>
</li>
<li>
<p>The <code>%</code> operator requires integer operands; if either
operand is not an integer, the program won’t compile.</p>
</li>
<li>
<p>Using zero as the right operand of either <code>/</code> or
<code>%</code> causes undefined behavior.</p>
</li>
<li>
<p><span class="QandA"></span></p>
<p><span class="C99Symbol"></span></p>
<p>Describing the result when <code>/</code> and <code>%</code> are used
with negative operands is tricky. The C89 standard states that if either
operand is negative, the result of a division can be rounded either up
or down. (For example, the value of <code>-9 / 7</code> could be either
-1 or -2). If <code>i</code> or <code>j</code> is negative, the sign of
<code>i % j</code> in C89 depends on the implementation. (For example,
the value of <code>-9 % 7</code> could be either -2 or 5). In C99, on
the other hand, the result of a division is always truncated toward zero
(so <code>-9 / 7</code> has the value -1) and the value of
<code>i % j</code> has the same sign as <code>i</code> (hence the value
of <code>-9 % 7</code> is -2).</p>
</li>
</ul>
<section id="implementation-defined-behaviour" class="infoBox">
<h3>Implementation-Defined Behaviour</h3>
<p>The term <strong><em>Implementation-defined</em></strong> will arise
often enough that it’s worth taking a moment to discuss it. The C
standard deliberately leaves parts of the language unspecified, with the
understanding that an “implementation”–the software needed to compile,
link, and execute programs on a particular platform–will fill in the
details. As a result, the behavior of the program may vary somewhat from
one implementation to another. The behavior of the <code>/</code> and
<code>%</code> operators for negative operands in C89 is an example of
implementation-defined behavior.</p>
<p>Leaving parts of the language unspecified may seem odd or even
dangerous, but it reflects C’s philosophy. One of the language’s goals
is efficiency, which often means matching the way that hardware behaves.
Some CPUs yield -1 when -9 is divided by 7, while others produce -2; the
C89 standard simply reflects this fact of life.</p>
<p>It’s best to avoid writing programs that depend on
implementation-defined behavior. If that’s not possible, at least check
the manual carefully–the C standard requires that implementation-defined
behaior be documented.</p>
</section>
<h3 id="operator-precedence-and-associativity">4.1.1 Operator Precedence
and Associativity</h3>
<p>When an expression contains more than one operator, its
interpretation may not be immediately clear. For example, does
<code>i + j * k</code> mean “add <code>i</code> and <code>j</code>, then
multiply the result by <code>k</code>,” or does it mean “multiply
<code>j</code> and <code>k</code>, then add <code>i</code>”? One
solution to this problem is to add parentheses, writing either
<code>(i + j) * k</code> or <code>i + (j * K)</code>. As a general rule,
C allows the use of parentheses for grouping in all expressions.</p>
<p>What if we don’t use parentheses, though? Will the compiler interpret
<code>i + j * k</code> as <code>(i + j) * k</code> or
<code>i + (j * k)</code>? Like many other languages, C user
<strong><em>operator precedence</em></strong> rules to resolve this
potential ambiguity. The arithmetic operators have the following
relative precedence:</p>
<table>
<tbody>
<tr class="odd">
<td>Highest:</td>
<td><code>+</code></td>
<td><code>-</code></td>
<td>(unary)</td>
</tr>
<tr class="even">
<td></td>
<td><code>*</code></td>
<td><code>/</code></td>
<td><code>%</code></td>
</tr>
<tr class="odd">
<td>Lowest:</td>
<td><code>+</code></td>
<td><code>-</code></td>
<td>(binary)</td>
</tr>
</tbody>
</table>
<p>Operators listed on the same line (such as <code>+</code> and
<code>-</code>) have equal precedence.</p>
<p>When two or more operators appear in the same expression, we can
determine how the compiler will interpret the expression by repeatedly
putting parentheses around subexpressions, starting with high-precedence
operators and working down to low-precedence operators. The following
examples illustrate the result:</p>
<table>
<tbody>
<tr class="odd">
<td><code>i + j * k</code></td>
<td>is equivalent to</td>
<td><code>i + (j * k)</code></td>
</tr>
<tr class="even">
<td><code>-i * -j</code></td>
<td>is equivalent to</td>
<td><code>(-i) * (-j)</code></td>
</tr>
<tr class="odd">
<td><code>+i + j / k</code></td>
<td>is equivalent to</td>
<td><code>(+i) + (j / k)</code></td>
</tr>
</tbody>
</table>
<p>Operator precedence rules alone aren’t enough when an expression
contains two or more operators at the same level of precedence. In this
situation, the <strong><em>associativity</em></strong> of the operators
comes into play. An operator is said to be <strong><em>left
associative</em></strong> if it groups from left to right. The binary
arithmetic operators (<code>*</code>, <code>/</code>, <code>%</code>,
<code>+</code>, and <code>-</code>) are all left associative, so</p>
<table>
<tbody>
<tr class="odd">
<td><code>i - j - k</code></td>
<td>is equivalent to</td>
<td><code>(i - j) - k</code></td>
</tr>
<tr class="even">
<td><code>i * j / k</code></td>
<td>is equivalent to</td>
<td><code>(i * j) / k</code></td>
</tr>
</tbody>
</table>
<p>An operator is <strong><em>right associative</em></strong> if it
groups from right to left. The unary arithmetic operators
(<code>+</code> and <code>-</code>) are both right associative, so</p>
<table>
<tbody>
<tr class="odd">
<td><code>- + i</code></td>
<td>is equivalent to</td>
<td><code>-(+i)</code></td>
</tr>
</tbody>
</table>
<p>Precedence and associativity rules are important in many laguages,
but especially so in C. However, C has so many operators (almost fifty!)
that few programmers bother to memorize the precedence and associativity
rules. Instead, they consult a table of operators when in doubt or just
use plenty of parentheses.</p>
<h3 id="program-computing-a-upc-check-digit">4.1.2 (PROGRAM) Computing a
UPC Check Digit</h3>
<p>For a number of years, manufacturers of goods sold in U.S. and
Canadian stores have put a bar code on each product. This code, known as
a Universal Product Code (UPC), identifies both the manufacturer and the
product. Each bar code represents a twelve-digit number, which is
usually printed underneath the bars. For example, the following bar code
comes from a package of Stouffer’s French Bread Pepperoni Pizza:</p>
<p><img src="./images/cknkCh04_barcode.jpg" style="width:200px; position: relative; left: 50%; right: 50%"/></p>
<p>The digits <code>0  13800 15173  5</code> appear underneath the bar
code. The first digit identifies the type of item (0 or 7 for most
items, 2 for items that must be weighed, 3 for drugs and health-related
merchandise, and 5 for coupons). The first group of five digits
identifies the manufacturer (13800 is the code for Nestlé USA’s Frozen
Food Division). The second group of five digits identifies the product
(including package size). The final digit is a “check digit,” whose only
purpose is to help identify an error in the preceding digits. If the UPC
is scanned incorrectly, the first 11 digits probably won’t be consistent
with the last digit, and the store’s scanner will reject the entire
code.</p>
<p>Here’s one method of computing the check digit:</p>
<blockquote>
<p>Add the first, third, fifth, seventh, ninth, and eleventh
digits.<br />
Add the second, fourth, sixth, eighth, and tenth digits.<br />
Multiply the first sum by 3 and add it to the second sum.<br />
Subtract 1 from the total.<br />
Compute the remainder when the adjusted total is divided by 10.<br />
Subtract the remainder fom 9.</p>
</blockquote>
<p>Using the Stouffer’s example, we get <span
class="displayInlineMath"><span
class="math display">0 + 3 + 0 + 1 + 1 + 3 = 8</span></span> for the
first sum and <span class="displayInlineMath"><span
class="math display">1 + 8 + 0 + 5 + 7 = 21</span></span> for the second
sum. Multiplying the first sum by 3 and adding the second yields 45.
Subtracting 1 gives 44. The remainder upon dividing by 10 is 4. When the
remainder is subtracted from 9, the result is 5. Here are a couple of
other UPCs, in case you want to try your hand at computing the check
digit (raiding the kitchen cabinet for the answer is <em>not</em>
allowed):</p>
<p>Jif Creamy Peanut Butter (18 oz.):
<code>0   51500 24128   ?</code><br />
Ocean Spray Jellied Cranberry Sauce (8 oz.):
<code>0   31200 01005   ?</code></p>
<p>The answers: 8 for Jif and 6 for Ocean Spray.</p>
<p>Let’s write a program that calculates the check digit for an
arbitrary UPC. We’ll ask the user to enter the first 11 digits of the
UPC, then we’ll display the corresponding check digit. To avoid
confusion, we’ll ask the user to enter the number in three parts: the
single digit at the left, the first group of five digits, and the second
group of five digits. Here’s what a session with the program will look
like:</p>
<pre class="shell"><code>Enter the first (single) digit: 0
Enter first group of five digits: 138000
Enter second group of five digits: 15173
Check digit: 5</code></pre>
<p>Instead of reading each digit group as a <em>five</em>-digit number,
we’ll read it as five <em>one</em>-digit numbers. Reading the numbers as
single digits is more convenient; also, we won’t have to worry that one
of the five-digit numbers is too large to store in an <code>int</code>
variable. (Some older compilers limit the maximum value of an
<code>int</code> variable to 32,767.) To read single digits, we’ll use
<code>scanf</code> with the <code>%1d</code> conversion specification,
which matches a one-digit integer.</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: upc.c</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Computes a Universal Product Code check digit</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d<span class="op">,</span> i1<span class="op">,</span> i2<span class="op">,</span> i3<span class="op">,</span> i4<span class="op">,</span> i5<span class="op">,</span> j1<span class="op">,</span> j2<span class="op">,</span> j3<span class="op">,</span> j4<span class="op">,</span> j5<span class="op">,</span> first_sum<span class="op">,</span> second_sum<span class="op">,</span> total<span class="op">;</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter the first (single) digit: &quot;</span><span class="op">);</span></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>d<span class="op">);</span></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter first group of five digits: &quot;</span><span class="op">);</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d%1d%1d%1d%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>i1<span class="op">,</span> <span class="op">&amp;</span>i2<span class="op">,</span> <span class="op">&amp;</span>i3<span class="op">,</span> <span class="op">&amp;</span>i4<span class="op">,</span> <span class="op">&amp;</span>i5<span class="op">);</span></span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter second group of five digits: &quot;</span><span class="op">);</span></span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%1d%1d%1d%1d%1d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>j1<span class="op">,</span> <span class="op">&amp;</span>j2<span class="op">,</span> <span class="op">&amp;</span>j3<span class="op">,</span> <span class="op">&amp;</span>j4<span class="op">,</span> <span class="op">&amp;</span>j5<span class="op">);</span></span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>    first_sum <span class="op">=</span> d <span class="op">+</span> i2 <span class="op">+</span> i4 <span class="op">+</span> j1 <span class="op">+</span> j3 <span class="op">+</span> j5<span class="op">;</span></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>    second_sum <span class="op">=</span> i1 <span class="op">+</span> i3 <span class="op">+</span> i5 <span class="op">+</span> j2 <span class="op">+</span> j4<span class="op">;</span></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> first_sum <span class="op">+</span> second_sum<span class="op">;</span></span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Check digit: %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">9</span> <span class="op">-</span> <span class="op">((</span>total <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="dv">10</span><span class="op">));</span></span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the expression <code>9 - ((total - 1) % 10)</code> could
have been written as <code>9 - (total - 1) % 10</code>, but the extra
set of parentheses makes it easier to understand.</p>
<h2 id="assignment-operators">4.2 Assignment Operators</h2>
<p>Once the value of an expression has been computed, we’ll often need
to store it in a variable for later use. C’s <code>=</code>
(<strong><em>simple assignment</em></strong>) operator is used for that
purpose. For updating a value already stored in a variable, C provides
an assortment of compound assignment operators.</p>
<h3 id="simple-assignment">4.2.1 Simple Assignment</h3>
<p>The effect of the assignment <span class="displayInlineMath"><span
class="math display"><em>v</em> = <em>e</em></span></span> is to
evaluate the expression <code>e</code> and copy its value into
<code>v</code>. As the following examples show, <code>e</code> can be a
constant, a variable, or a more complicated expression:</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>    <span class="co">/* i is now 5 */</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> i<span class="op">;</span>    <span class="co">/* j is now 5 */</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> i <span class="op">+</span> j<span class="op">;</span>    <span class="co">/* k is now 55 */</span></span></code></pre></div>
<p>If <code>v</code> and <code>e</code> don’t have the same type, then
the value of <code>e</code> is converted to the type of <code>v</code>
as the assignment takes place:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="fl">72.99</span><span class="bu">f</span><span class="op">;</span>    <span class="co">/* i is now 72 */</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="dv">136</span><span class="op">;</span>    <span class="co">/* f is now 136.0 */</span></span></code></pre></div>
<p>We’ll return to the topic of type conversion later.</p>
<p>In many programming languages, assignment is a <em>statement</em>; in
C, however, assignment is an <em>operator</em>, just like
<code>+</code>. In other words, the act of assignment produces a result,
just as adding two numbers produces a result. The value of an assignment
<span class="displayInlineMath"><span
class="math display"><em>v</em> = <em>e</em></span></span> is the value
of <code>v</code> after the assignment. Thus, the value of
<code>i = 72.99f</code> is 72 (not 72.99).</p>
<section id="side-effects" class="infoBox">
<h3>Side effects</h3>
<p>We don’t normally expect operators to modify their operands, since
operators in mathematics don’t. Writing <code>i + j</code> doesn’t
modify either <code>i</code> or <code>j</code>; it simply computes the
result of adding <code>i</code> and <code>j</code>.</p>
<p>Most C operators don’t modify their operands, but some do. We say
that these operators have <strong><em>side effects</em></strong>, since
they do more than just compute a value. The simple assignment operator
is the first operator we’ve seen that has side effects; it modifies its
left operand. Evaluating the expression <code>i = 0</code> produces the
result 0 and–as a side effect–assigns 0 to <code>i</code>.</p>
</section>
<p>Since assignment is an operator, several assignments can be chained
together:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> j <span class="op">=</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>The <code>=</code> operator is right associative, so this assignment
is equivalent to</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="op">(</span>j <span class="op">=</span> <span class="op">(</span>k <span class="op">=</span> <span class="dv">0</span><span class="op">));</span></span></code></pre></div>
<p>The effect is to assign 0 first to <code>k</code>, then to
<code>j</code>, and finally to <code>i</code>.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Watch out for unexpected results in chained assignments as a result
of type conversion:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> f<span class="op">;</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> i <span class="op">=</span> <span class="fl">33.3</span><span class="bu">f</span><span class="op">;</span></span></code></pre></div>
<p><code>i</code> is assigned the value 33, then <code>f</code> is
assigned 33.0 (not 33.3, as you might think).</p>
</div>
<p>In general, an assignment of the form <code>v = e</code> is allowed
wherever a value of type <code>v</code> would be permitted. In the
following example, the expression <code>j = i</code> copies
<code>i</code> to <code>j</code>; the new value of <code>j</code> is
then added to 1, producing the new value of <code>k</code>:</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="op">(</span>j <span class="op">=</span> i<span class="op">);</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d %d %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">);</span>    <span class="co">/*prints &quot;1 1 2&quot; */</span></span></code></pre></div>
<p>Using the assignment operator in this fashion usually isn’t a good
idea. For one thing, “embedded assignments” can make programs hard to
read. They can also be a source of subtle bugs, as we’ll see in Section
4.4.</p>
<h3 id="lvalues">4.2.2 Lvalues</h3>
<p>Most C operators allow their operands to be variables, constants, or
expressions containing other operators. The assignment operator,
however, requires an <strong><em>lvalue</em></strong> as its left
operand. An lvalue (pronounced “L-value”) represents an object stored in
computer memory, not a constant or the result of a computation.
Variables are lvalues; expressions such as <code>10</code> or
<code>2 * i</code> are not. At this point, variables are the only
lvalues that we know about; other kinds of lvalues will appear in later
chapters.</p>
<p>Since the assignment operator requires an lvalue as its left operand,
it’s illegal to put any other kind of expression on the left side of an
assignment expression:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span> <span class="op">=</span> i<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">+</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="op">-</span>i <span class="op">=</span> j<span class="op">;</span>    <span class="co">/*** WRONG ***/</span></span></code></pre></div>
<p>The compiler will detect errors of this nature, and you’ll get an
error message such as “<em>invalid lvalue in assignment</em>.”</p>
<h3 id="compound-assignment">3.2.3 Compound Assignment</h3>
<p>Assignments that use the old value of a variable to compute its new
value are common in C programs. The following statement, for example,
adds 2 to the value stored in <code>i</code>:</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>C’s <strong><em>compound assignment</em></strong> operators allow us
to shorten this statement and others like it. Using the <code>+=</code>
operator, we simply write:</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span>    <span class="co">/* same as i = i + 2; */</span></span></code></pre></div>
<p>The <code>+=</code> operator adds the value of the right operand to
the variable on the left.</p>
<p>There are nine other compound assignment operators, including the
following:</p>
<p><code>-=   *=   /=   %=</code></p>
<p>(We’ll cover the remaining compound assignment operators in a later
chapter.) All compound assignment operators work in much the same
way:</p>
<blockquote>
<p><code>v += e</code> adds <code>v</code> to <code>e</code>, storing
the result in <code>v</code><br />
<code>v -= e</code> subtracts <code>e</code> from <code>v</code>,
storing the result in <code>v</code><br />
<code>v *= e</code> multiplies <code>v</code> by <code>e</code>, storing
the result in <code>v</code><br />
<code>v /= e</code> divides <code>v</code> by <code>e</code>, storing
the result in <code>v</code><br />
<code>v %= e</code> computes the remainder when <code>v</code> is
divided by <code>e</code>, storing the result in <code>v</code>.</p>
</blockquote>
<p><span class="QandA"></span></p>
<p>Note that I’ve been careful not to say that <code>v += e</code> is
“equivalent” to <code>v = v + e</code>. One problem is operator
precedence: <code>i *= j + k</code> isn’t the same as
<code>i = i * j + k</code>. There are also rare cases in which
<code>v += e</code> differs from <code>v = v + e</code> because
<code>v</code> itself has a side effect. Similar remarks apply to the
other compound assignment operators.</p>
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>When using the compound assignment operators, be carefull not to
switch the two characters that make up the operator. Switching the
characters may yield an expression that is acceptable to the compiler
but that doesn’t have the intended meaning. For example, if you meant to
write <code>i += j</code> but you typed <code>i =+ j</code> instead, the
program will still compile. Unfortunately, the latter expression is
equivalent to <code>i = (+j)</code>, which merely copies the value of
<code>j</code> into <code>i</code>.</p>
</div>
<p>The compound assignment operators have the same properties as the
<code>=</code> operator. In particular, they’re right associative, so
the statement</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> j <span class="op">+=</span> k<span class="op">;</span></span></code></pre></div>
<p>means</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="op">(</span>j <span class="op">+=</span> k<span class="op">);</span></span></code></pre></div>
<h2 id="incremet-and-decrement-operators">4.3 Incremet and Decrement
Operators</h2>
<p>Two of the most common operations on a variable are “incrementing”
(adding 1) and “decrementing” (subtracting 1). We can, of course,
accomplish these tasks by writing</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> j <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>The compound assignment operators allow us to condense these
statements a bit:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>But C allows increments and decrements to be shortened even further,
using the <code>++</code> (<strong><em>increment</em></strong>) and
<code>--</code> (<strong><em>decrement</em></strong>) operators.</p>
<p>At first glance, the increment and decrement operators are simplicity
itself: <code>++</code> adds 1 to its operand, whereas <code>--</code>
subtracts 1. Unfortunately, this simplicity is misleading–the increment
and decrement operators can be tricky to use. One complication is that
<code>++</code> and <code>--</code> can be used as
<strong><em>prefix</em></strong> operators (<code>++i</code> and
<code>--i</code>, for example) or <strong><em>postfix</em></strong>
operators (<code>i++</code> and <code>i--</code>). The correctness of a
program may hinge on picking the proper version.</p>
<p>Another complication is that, like the assignment operators,
<code>++</code> and <code>--</code> have side effects: they modify the
values of their operands. Evaluating the expression <code>++i</code> (a
“pre-increment”) yields <code>i + 1</code> and–as a side
effect–increments <code>i</code>:</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">++</span>i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span></code></pre></div>
<p>Evaluating th expression <code>i++</code> (a “post-increment”)
produces the result <code>i</code>, but causes <code>i</code> to be
incremented afterwards:</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">++);</span>    <span class="co">/* prints &quot;i is 1&quot; */</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 2&quot; */</span></span></code></pre></div>
<p><span class="QandA"></span></p>
<p>The first <code>printf</code> shows the original value of
<code>i</code>, before it is incremented. The second <code>printf</code>
shows the new value. As these examples illustrate, <code>++i</code>
means “increment <code>i</code> immediately,” while <code>i++</code>
means “use the old value of <code>i</code> for now, but increment
<code>i</code> later.” How much later? The C standard doesn’t specify a
precise time, but it’s safe to assume that <code>i</code> will be
incremented before the next statement is executed.</p>
<p>The <code>--</code> operator has similar properties:</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">--</span>i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span></code></pre></div>
<div class="sourceCode" id="cb132"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">--);</span>    <span class="co">/* prints &quot;i is 1&quot; */</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;i is %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span>    <span class="co">/* prints &quot;i is 0&quot; */</span></span></code></pre></div>
<p>When <code>++</code> or <code>--</code> is used more than once in the
same expression, the result can often be hard to understand. Consider
the following statements:</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="op">++</span>i <span class="op">+</span> j<span class="op">++;</span></span></code></pre></div>
<p>What are the values of <code>i</code>, <code>j</code> and
<code>k</code> after these statements are executed? Since <code>i</code>
is incremented <em>before</em> its value is used, but <code>j</code> is
incremented <em>after</em> it is used, the last statement is equivalent
to</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> i <span class="op">+</span> j<span class="op">;</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>so the final values of <code>i</code>, <code>j</code>, and
<code>k</code> are 2, 3, and 4, respectively. In contrast, executing the
statements</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> i<span class="op">++</span> <span class="op">+</span> j<span class="op">++;</span></span></code></pre></div>
<p>will give <code>i</code>, <code>j</code>, and <code>k</code> the
values 2, 3, and 3, respectively.</p>
<p>For the record, the postfix versions of <code>++</code> and
<code>--</code> have higher precedence than unary plus and minus and are
left associative. The prefix versions have the same precedence as unary
plus and minus and are right associative.</p>
<h2 id="expression-evaluation">4.4 Expression Evaluation</h2>
<p>Table 4.2 summarizes the operators we’ve seen so far. (Appendix A has
a similar table that shows <em>all</em> operators.) The first column
shows the precedence of each operator relative to the other operators in
the table (the highest precedence is 1: the lowest is 5). The last
column shows the associativity of each operator.</p>
<p><strong>Table 4.2:</strong> A Partial list of C Operators</p>
<table>
<thead>
<tr class="header">
<th>Precedence</th>
<th>Name</th>
<th>Symbol(s)</th>
<th>Associativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>increment (postfix)</td>
<td><code>++</code></td>
<td>left</td>
</tr>
<tr class="even">
<td>1</td>
<td>decrement (postfix)</td>
<td><code>--</code></td>
<td>left</td>
</tr>
<tr class="odd">
<td>2</td>
<td>increment (prefix)</td>
<td><code>++</code></td>
<td>right</td>
</tr>
<tr class="even">
<td>2</td>
<td>decrement (prefix)</td>
<td><code>--</code></td>
<td>right</td>
</tr>
<tr class="odd">
<td>2</td>
<td>unary plus</td>
<td><code>+</code></td>
<td>right</td>
</tr>
<tr class="even">
<td>2</td>
<td>unary minus</td>
<td><code>-</code></td>
<td>right</td>
</tr>
<tr class="odd">
<td>3</td>
<td>multiplicative</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>left</td>
</tr>
<tr class="even">
<td>4</td>
<td>additive</td>
<td><code>+</code> <code>-</code></td>
<td>left</td>
</tr>
<tr class="odd">
<td>5</td>
<td>assignment</td>
<td><code>=</code> <code>*=</code> <code>/=</code> <code>%=</code>
<code>+=</code> <code>-=</code></td>
<td>right</td>
</tr>
</tbody>
</table>
<p>Table 4.2 (or its larger cousin in Appendix A) has a variety of uses.
Let’s look at one of these. Suppose that we run across a complicated
expression such as</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> c<span class="op">++</span> <span class="op">-</span> d <span class="op">+</span> <span class="op">--</span>e <span class="op">/</span> <span class="op">-</span>f</span></code></pre></div>
<p>as we’re reading someone’s program. This expression would be easier
to understand if there were parentheses to show how the expression is
constructed from subexpressions. With the help of Table 4.2, adding
parentheses to an expression is easy: after examining the expression to
find the operator with highest precedence, we put parentheses around the
operator and its operands, indicating that it should be treated as a
single operand from that point onwards. We then repeat the process until
the expression is fully parenthesized.</p>
<p>In our example, the operator with highest precedence is
<code>++</code>, used here as a postfix operator, so we put parentheses
around <code>++</code> and its operand:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> <span class="op">(</span>c<span class="op">++)</span> <span class="op">-</span> d <span class="op">+</span> <span class="op">--</span>e <span class="op">/</span> <span class="op">-</span>f</span></code></pre></div>
<p>We now spot a prefix <code>--</code> operator and a unary minus
operator (both precedence 2) in the expression:</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> <span class="op">(</span>c<span class="op">++)</span> <span class="op">-</span> d <span class="op">+</span> <span class="op">(--</span>e<span class="op">)</span> <span class="op">/</span> <span class="op">(-</span>f<span class="op">)</span></span></code></pre></div>
<p>Note that the other minus sign has an operand to its immediate left,
so it must be a subtraction operator, not a unary minus operator.</p>
<p>Next, we notice the <code>/</code> operator (precedence 3):</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> <span class="op">(</span>c<span class="op">++)</span> <span class="op">-</span> d <span class="op">+</span> <span class="op">((--</span>e<span class="op">)</span> <span class="op">/</span> <span class="op">(-</span>f<span class="op">))</span></span></code></pre></div>
<p>The expression contains two operators with precedence 4, subtraction
and addition. Whenever two operators with the same precedence are
adjacent to an operand, we’ve got to be careful about associativity. In
our example, <code>-</code> and <code>+</code> are both adjacent to
<code>d</code>, so associativity rules apply. The <code>-</code> and
<code>+</code> operators group from left to right, so parentheses go
around the subtraction first, then the addition:</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> b <span class="op">+=</span> <span class="op">((</span>c<span class="op">++)</span> <span class="op">-</span> d<span class="op">)</span> <span class="op">+</span> <span class="op">((--</span>e<span class="op">)</span> <span class="op">/</span> <span class="op">(-</span>f<span class="op">))</span></span></code></pre></div>
<p>The only remaining operators are <code>=</code> and <code>+=</code>.
Both operators are adjacent to b, so we must take associativity into
account. Assignment operators group from right to left, so parentheses
go around the <code>+=</code> expression first, then the <code>=</code>
expression:</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>a <span class="op">=</span> <span class="op">(</span>b <span class="op">+=</span> <span class="op">(((</span>c<span class="op">++)</span> <span class="op">-</span> d<span class="op">)</span> <span class="op">+</span> <span class="op">((--</span>e<span class="op">)</span> <span class="op">/</span> <span class="op">(-</span>f<span class="op">)))))</span></span></code></pre></div>
<p>The expression is now fully parenthesized.</p>
<h3 id="order-of-subexpression-evaluation">4.4.1 Order of Subexpression
Evaluation</h3>
<p>The rules of operator precedence and associativity allow us to break
any C expression into subexpressions—to determine uniquely where the
parentheses would go if the expression were fully parenthesized.
Paradoxically, these rules don’t always allow us to determine the value
of the expression, which may depend on the order in which its
subexpressions are evaluated.</p>
<p>C doesn’t define the order in which subexpressions are evaluated
(with the exception of subexpressions involving the logical
<em>and</em>, logical <em>or</em>, conditional, and comma operators).
Thus, in the expression <code>(a + b) * (c - d)</code> we don’t know
whether (a + b) will be evaluated before <code>(c - d)</code>.</p>
<p>Most expressions have the same value regardless of the order in which
their subexpressions are evaluated. However, this may not be true when a
subexpression modifies one of its operands. Consider the following
example:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="op">(</span>b <span class="op">=</span> a <span class="op">+</span> <span class="dv">2</span><span class="op">)</span> <span class="op">-</span> <span class="op">(</span>a <span class="op">=</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>The effect of executing the second statement is undefined: the C
standard doesn’t say what will happen. With most compilers, the value of
<code>c</code> will be either 6 or 2. If the subexpression
<code>(b = a + 2)</code> is evaluated first, <code>b</code> is assigned
the value 7 and <code>c</code> is assigned 6. But if
<code>(a = 1)</code> is evaluated first, <code>b</code> is assigned 3
and <code>c</code> is assigned 2.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Avoid writing expressions that access the value of a variable and
also modify the variable elsewhere in the expression. The expression
<code>(b =a + 2) - (a = 1)</code> accesses the value of <code>a</code>
(in order to compute <code>a + 2</code>) and also modifies the value of
<code>a</code> (by assigning it 1). Some compilers may produce a warning
message such as “<em>operation on ‘a’ may be undefined</em>” when they
encounter such an expression.</p>
</div>
<!-- END: div -->
<p>To prevent problems, it’s a good idea to avoid using the assignment
operators in subexpressions; instead, use a series of separate
assignments. For example, the statements above could be rewritten as</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> b <span class="op">-</span> a<span class="op">;</span></span></code></pre></div>
<p>The value of <code>c</code> will always be 6 after these statements
are executed.</p>
<p>Besides the assignment operators, the only operators that modify
their operands are increment and decrement. When using these operators,
be careful that your expressions don’t depend on a particular order of
evaluation. In the following example, <code>j</code> may be assigned one
of two values:</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> i <span class="op">*</span> i<span class="op">++;</span></span></code></pre></div>
<p>It’s natural to assume that <code>j</code> is assigned the value 4.
However, the effect of executing the statement is undefined, and
<code>j</code> could just as well be assigned 6 instead. Here’s the
scenario: (1) The second operand (the original value of 1) is fetched,
then 1 is incremented. (2) The first operand (the new value of 1) is
fetched. (3) The new and old values of <code>i</code> are multiplied,
yielding 6. “Fetching” a variable means to retrieve the value of the
variable from memory. A later change to the variable won’t affect the
fetched value, which is typically stored in a special location (known as
a register) inside the CPU.</p>
<!-- START: div -->
<div class="infoBox">
<p>Undefined Behavior</p>
<p>According to the C standard, statements such as
<code>c = (b = a + 2) - (a = 1);</code> and <code>j = i * i++;</code>
cause undefined behavior, which is different from implementation-defined
behavior (see Section 4.1). When a program ventures into the realm of
undefined behavior, all bets are off. The program may behave differently
when compiled with different compilers. But that’s not the only thing
that can happen. The program may not compile in the first place, if it
compiles it may not run, and if it does run, it may crash, behave
erratically, or produce meaningless results. In other words, undefined
behavior should be avoided like the plague.</p>
</div>
<!-- END: div -->
<h2 id="expression-statements">4.5 Expression Statements</h2>
<p>C has the unusual rule that any expression can be used as a
statement. That is, any expression—regardless of its type or what it
computes—can be turned into a statement by appending a semicolon. For
example, we could turn the expression <code>++i</code> into a
statement:</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="op">++</span>i<span class="op">;</span></span></code></pre></div>
<p>When this statement is executed, <code>i</code> is first incremented,
then the new value of <code>i</code> is fetched (as though it were to be
used in an enclosing expression). However, since <code>++i</code> isn’t
part of a larger expression, its value is discarded and the next
statement executed. (The change to 1 is permanent, of course.)</p>
<p>Since its value is discarded, there’s little point in using an
expression as a statement unless the expression has a side effect. Let’s
look at three examples. In the first example, 1 is stored into
<code>i</code>, then the new value of <code>i</code> is fetched but not
used:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>In the second example, the value of <code>i</code> is fetched but not
used; however, <code>i</code> is decremented afterwards:</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>i<span class="op">--;</span></span></code></pre></div>
<p>In the third example, the value of the expression
<code>i * j - 1</code> is computed and then discarded:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">*</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>Since <code>i</code> and <code>j</code> aren’t changed, this
statement has no effect and therefore serves no purpose.</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>A slip of the finger can easily create a “do-nothing™ expression
statement. For example, instead of entering</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>we might accidentally type</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+</span> j<span class="op">;</span></span></code></pre></div>
<p>(This kind of error is more common than you might expect, since the
<code>=</code> and <code>+</code> characters usually occupy the same
key.) Some compilers can detect meaningless expression statements;
you’ll get a warning such as “<em>statement with no effect</em>.”</p>
</div>
<!-- END: div -->
<hr />
<h2 id="q-a-2">Q &amp; A</h2>
<!-- START: div -->
<div class="QandA_question">
<p>Q: I notice that C has no exponentiation operator. How can I raise a
number to a power?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Raising an integer to a small positive integer power is best done
by repeated multiplication (<code>i * i * i</code> is <code>i</code>
cubed). To raise a number to a noninteger power, call the
<code>pow</code> function.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: I want to apply the <code>%</code> operator to a floating-point
operand, but my program won’t compile. What can I do? [p. 54]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The <code>%</code> operator requires integer operands. Try the
<code>fmod</code> function instead.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: Why are the rules for using the <code>/</code> and <code>%</code>
operators with negative operands so complicated? [p. 54]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="C99Symbol"></span></p>
<p>A: The rules aren’t as complicated as they may first appear. In both
C89 and C99, the goal is to ensure that the value of
<code>(a / b) * b + a % b</code> will always be equal to <code>a</code>
(and indeed, both standards guarantee that this is the case, provided
that the value of <code>a / b</code> is “representable”). The problem is
that there are two ways for <code>a / b</code> and <code>a % b</code> to
satisfy this equality if either <code>a</code> or <code>b</code> is
negative, as seen in C89, where either <code>-9 / 7</code> is -1 and
<code>-9 % 7</code> is -2, or <code>-9 / 7</code> is -2 and
<code>-9 % 7</code> is 5. In the first case,
<code>(-9 / 7) * 7 + -9 % 7</code> has the value
<code>-1 x 7 + -2 = -9</code>, and in the second case,
<code>(-9 / 7) * 7 + -9 % 7</code> has the value
<code>-2 x 7 + 5 = -9</code>. By the time C99 rolled around, most CPUs
were designed to truncate the result of division toward zero, so this
was written into the standard as the only allowable outcome.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>If C has lvalues, does it also have rvalues? [p. 59]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>Yes, indeed. An <em>l</em>value is an expression that can appear on
the <em>left</em> side of an assignment; an <em>r</em>value is an
expression that can appear on the <em>right</em> side. Thus, an rvalue
could be a variable, constant, or more complex expression. In this book,
as in the C standard, we’ll use the term “expression™ instead of
“rvalue.”</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>You said that <code>v += e</code> isn’t equivalent to
<code>v = v + e</code> if <code>v</code> has a side effect. Can you
explain? [p. 60]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>Evaluating <code>v += e</code> causes <code>v</code> to be evaluated
only once; evaluating <code>v = v + e</code> causes <code>v</code> to be
evaluated twice. Any side effect caused by evaluating <code>v</code>
will occur twice in the latter case. In the following example,
<code>i</code> is incremented once:</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>A<span class="op">[</span>i<span class="op">++]</span> <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>If we use <code>=</code> instead of <code>+=</code>, here’s what the
statement will look like:</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">[</span>i<span class="op">++]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">++]</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p>The value of <code>i</code> is modified as well as used elsewhere in
the statement, so the effect of executing the statement is undefined.
It’s likely that <code>i</code> will be incremented twice, but we can’t
say with certainty what will happen.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Why does C provide the <code>++</code> and <code>--</code> operators?
Are they faster than other ways of incrementing and decrementing, or
they are just more convenient? [p. 61]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>C inherited <code>++</code> and <code>--</code> from <strong>Ken
Thompson</strong>’s earlier B language. Thompson apparently created
these operators because his B compiler could generate a more compact
translation for <code>++i</code> than for <code>i = i + 1</code>. These
operators have become a deeply ingrained part of C (in fact, many of C’s
most famous idioms rely on them). With modern compilers, using
<code>++</code> and won’t make a compiled program any smaller or faster;
the continued popularity of these operators stems mostly from their
brevity and convenience.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Do <code>++</code> and <code>--</code> work with <code>float</code>
variables?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>Yes; the increment and decrement operations can be applied to
floating-point numbers as well as integers. In practice, however, it’s
fairly rare to increment or decrement a <code>float</code> variable.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>When I use the postfix version of <code>++</code> or <code>--</code>,
just when is the increment or decrement performed? [p. 62]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>That’s an excellent question. Unfortunately, it’s also a difficult
one to answer. The C standard introduces the concept of “sequence point”
and says that “updating the stored value of the operand shall occur
between the previous and the next sequence point.” There are various
kinds of sequence points in C: the end of an expression statement is one
example. By the end of an expression statement, all increments and
decrements within the statement must have been performed; the next
statement can’t begin to execute until this condition has been met.</p>
<p>Certain operators that we’ll encounter in later chapters (logical
and. logical or, conditional, and comma) also impose sequence points. So
do function calls: the arguments in a function call must be fully
evaluated before the call can be performed. If an argument happens to be
an expression containing a <code>++</code> or <code>--</code> operator,
the increment or decrement must occur before the call can take
place.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: What do you mean when you say that the value of an expression
statement is discarded? [p. 65]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>By definition, an expression represents a value. If <code>i</code>
has the value 5, for example, then evaluating <code>i + 1</code>
produces the value 6. Let’s turn <code>i + 1</code> into a statement by
putting a semicolon after it:</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>When this statement is executed, the value of <code>i + 1</code> is
computed. Since we have failed to save this value—or at least use it in
some way—it is lost.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: But what about statements like <code>i = 1;</code>? I don’t see
what is being discarded.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>Don’t forget that <code>=</code> is an operator in C and produces a
value just like any other operator. The assignment</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>assigns 1 to <code>i</code>. The value of the entire expression is 1,
which is discarded. Discarding the expression’s value is no great loss,
since the reason for writing the statement in the first place was to
modify <code>i</code>.</p>
</div>
<!-- END: div -->
<hr />
<h2 id="examples-2">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh04/cknkCh04Exmp/">./cknkCh04/cknkCh04Exmp/</a></li>
</ul>
<h2 id="exercises-2">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh04/cknkCh04Exrc/README.md">./cknkCh04/cknkCh04Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh04/cknkCh04Exrc/cknkCh04ExrcReadme.html">./cknkCh04/cknkCh04Exrc/cknkCh04ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh04/cknkCh04Exrc/">./cknkCh04/cknkCh04Exrc/</a></li>
</ul>
<h2 id="programming-projects-2">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh04/cknkCh04Prj/README.md">./cknkCh04/cknkCh04Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh04/cknkCh04Prj/cknkCh04PrjReadme.html">./cknkCh04/cknkCh04Prj/cknkCh04PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh04/cknkCh04Prj/">./cknkCh04/cknkCh04Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<h1 id="selection-statements">5 Selection Statements</h1>
<!-- START: div -->
<div class="theQuote">
<p>Programmers are not to be measured by their ingenuity and their logic
but by the completeness of their case analysis.</p>
</div>
<!-- END: div -->
<p>Although C has many operators, it has relatively few statements.
We’ve encountered just two so far: the <code>return</code> statement and
the expression statement. Most of C’s remaining statements fall into
three categories, depending on how they affect the order in which
statements are executed:</p>
<ul>
<li><strong><em>Selection statements</em></strong>, The <code>if</code>
and <code>switch</code> statements allow a program to select a
particular execution path from a set of alternatives.<br />
</li>
<li><strong><em>Iteration statements</em></strong>. The
<code>while</code>, <code>do</code>, and <code>for</code> statements
support iteration (looping).<br />
</li>
<li>*<strong>Jump statements</strong>. The <code>break</code>,
<code>continue</code>, and <code>goto</code> statements cause an
unconditional jump to some other place in the program. (The return
statement belongs in this category, as well.)</li>
</ul>
<p>The only other statements in C are the compound statement, which
groups several statements into a single statement, and the null
statement, which performs no action.</p>
<p>This chapter discusses the selection statements and the compound
statement. (Chapter 6 covers the iteration statements, the jump
statements, and the null statement.) Before we can write <code>if</code>
statements, we’ll need logical expressions: conditions that
<code>if</code> statements can test. Section 5.1 explains how logical
expressions are built from the relational operators (<code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>), the
equality operators (<code>==</code> and <code>!=</code>), and the
logical operators (<code>&amp;&amp;</code>, <code>||</code>, and
<code>!</code>). Section 5.2 covers the <code>if</code> statement and
compound statement, as well as introducing the conditional operator
(<code>?:</code>), which can test a condition within an expression.
Section 5.3 describes the <code>switch</code> statement.</p>
<h2 id="logical-expressions">5.1 Logical Expressions</h2>
<p>Several of C’s statements, including the <code>if</code> statement,
must test the value of an expression to see if it is “true™ or “false.”
For example, an <code>if</code> statement might need to test the
expression <code>i &lt; j;</code> a true value would indicate that
<code>i</code> is less than <code>j</code>. In many programming
languages, an expression such as <code>i &lt; j</code> would have a
special “Boolean” or “logical” type. Such a type would have only two
values, <code>false</code> and <code>frue</code>. In C, however, a
comparison such as <code>i &lt; j</code> yields an integer: either 0
(false) or 1 (true). With this in mind, let’s look at the operators that
are used to build logical expressions.</p>
<h3 id="relational-operators">5.1.1 Relational Operators</h3>
<p>C’s <strong><em>relational operators</em></strong> (Table 5.1)
correspond to the <code>&lt;</code>, <code>&gt;</code>, <code>≤</code>,
and <code>≥</code> operators of mathematics, except that they produce 0
(false) or 1 (true) when used in expressions. For example, the value of
<code>10 &lt; 11</code> is 1; the value of <code>11 &lt; 10</code> is
0.</p>
<p><strong>Table 5.1</strong>: Relational Operators</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;</code></td>
<td>less than</td>
</tr>
<tr class="even">
<td><code>&gt;</code></td>
<td>greater than</td>
</tr>
<tr class="odd">
<td><code>≤</code></td>
<td>less than or equal to</td>
</tr>
<tr class="even">
<td><code>≥</code></td>
<td>greater than or equal to</td>
</tr>
</tbody>
</table>
<p>The relational operators can be used to compare integers and
floating-point numbers, with operands of mixed types allowed. Thus,
<code>1 &lt; 2.5</code> has the value 1, while <code>5.6 &lt; 4</code>
has the value 0.</p>
<p>The precedence of the relational operators is lower than that of the
arithmetic operators; for example, <code>i + j &lt; k - 1</code> means
<code>(i + j) &lt; (k - 1)</code>. The relational operators are left
associative.</p>
<!-- START: div -->
<div class="infoBox">
<p>The expression <code>i &lt; j &lt; k</code> is legal in C, but
doesn’t have the meaning that you might expect. Since the
<code>&lt;</code> operator is left associative, this expression is
equivalent to <code>(i &lt; j) &lt; k</code>.</p>
<p>In other words, the expression first tests whether <code>i</code> is
less than <code>j</code>; the 1 or 0 produced by this comparison is then
compared to <code>k</code>. The expression does not test whether
<code>j</code> lies between <code>i</code> and <code>k</code>. (We’ll
see later in this section that the correct expression would be
<code>i &lt; j &amp;&amp; j &lt; k</code>.)</p>
</div>
<!-- END: div -->
<h3 id="equality-operators">5.1.2 Equality Operators</h3>
<p>Although the relational operators are denoted by the same symbols as
in many other programming languages, the <strong><em>equality
operators</em></strong> have a unique appearance (Table 5.2). The “equal
to” operator is two adjacent <code>=</code> characters, not one, since a
single <code>=</code> character represents the assignment operator. The
“not equal to” operator is also two characters: <code>!</code> and
<code>=</code>.</p>
<p><strong>Table 5.2</strong>: Equality Operators</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>==</code></td>
<td>equal to</td>
</tr>
<tr class="even">
<td><code>!=</code></td>
<td>not equal to</td>
</tr>
</tbody>
</table>
<p>Like the relational operators, the equality operators are left
associative and produce either O (false) or 1 (true) as their result.
However, the equality operators have <em>lower</em> precedence than the
relational operators. For example, the expression
<code>i &lt; j == j &lt; k</code> is equivalent to
<code>(i &lt; j) == (j &lt; k)</code> which is true if
<code>i &lt; j</code> and <code>j &lt; k</code> are both true or both
false.</p>
<p>Clever programmers sometimes exploit the fact that the relational and
equality operators return integer values. For example, the value of the
expression <code>(i &gt;= j) + (i == j)</code> is either 0, 1, or 2,
depending on whether <code>i</code> is less than, greater than, or equal
to <code>j</code>, respectively. Tricky coding like this generally isn’t
a good idea, however; it makes programs hard to understand.</p>
<h3 id="logical-operators">5.1.3 Logical Operators</h3>
<p>More complicated logical expressions can be built from simpler ones
by using the <strong><em>logical operators</em></strong>: <em>and</em>,
<em>or</em>, and <em>not</em> (Table 5.3). The <code>!</code> operator
is unary, while <code>&amp;&amp;</code> and <code>||</code> are
binary.</p>
<p><strong>Table 5.3</strong>: Logical Operators</p>
<table>
<thead>
<tr class="header">
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>!</code></td>
<td>logical negation</td>
</tr>
<tr class="even">
<td><code>&amp;&amp;</code></td>
<td>logical <em>and</em></td>
</tr>
<tr class="odd">
<td><code>||</code></td>
<td>logical <em>or</em></td>
</tr>
</tbody>
</table>
<p>The logical operators produce either 0 or 1 as their result. Often,
the operands will have values of 0 or 1, but this isn’t a requirement;
the logical operators treat any nonzero operand as a true value and any
zero operand as a false value.</p>
<p>The logical operators behave as follows:</p>
<ul>
<li><code>!expr</code> has the value 1 if <code>expr</code> has the
value 0.<br />
</li>
<li><code>exprl &amp;&amp; expr2</code> has the value 1 if the values of
<code>expr1</code> and <code>expr2</code> are both non Zero.<br />
</li>
<li><code>exprl || expr2</code> has the value 1 if either
<code>expr1</code> or <code>expr2</code> (or both) has a nonzero
value.</li>
</ul>
<p>In all other cases, these operators produce the value 0.</p>
<p>Both <code>&amp;&amp;</code> and <code>||</code> perform
“short-circuit” evaluation of their operands. That is, these operators
first evaluate the left operand, then the right operand. If the value of
the expression can be deduced from the value of the left operand alone,
then the right operand isn’t evaluated. Consider the following
expression:</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>i <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>j <span class="op">/</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>To find the value of this expression, we must first evaluate
<code>(i != 0)</code>. If <code>i</code> isn’t equal to 0, then we’ll
need to evaluate <code>(j / 1 &gt; 0)</code> to determine whether the
entire expression is true or false. However, if <code>i</code> is equal
to 0, then the entire expression must be false, so there’s no need to
evaluate <code>(j / i &gt; 0)</code>. The advantage of short circuit
evaluation is apparent—without it, evaluating the expression would have
caused a division by zero.</p>
..md<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Be wary of side effects in logical expressions. Thanks to the
short-circuit nature of the <code>&amp;&amp;</code> and <code>||</code>
operators, side effects in operands may not always occur. Consider the
following expression:</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="op">++</span>j <span class="op">&gt;</span> <span class="dv">0</span></span></code></pre></div>
<p>Although <code>j</code> is apparently incremented as a side effect of
evaluating the expression, that isn’t always the case. If
<code>i &gt; 0</code> is false, then <code>++j &gt; 0</code> is not
evaluated, so <code>j</code> isn’t incremented. The problem can be fixed
by changing the condition to <code>++j &gt; 0 &amp;&amp; i &gt; 0</code>
or, even better, by incrementing <code>j</code> separately.</p>
</div>
<!-- END: div -->
<p>The <code>!</code> operator has the same precedence as the unary plus
and minus operators. The precedence of <code>&amp;&amp;</code> and
<code>||</code> is lower than that of the relational and equality
operators; for example, <code>i &lt; j &amp;&amp; k == m</code> means
<code>(i &lt; j) &amp;&amp; (k == m)</code>. The ! operator is right
associative; <code>&amp;&amp;</code> and <code>||</code> are left
associative.</p>
<h2 id="the-if-statement">5.2 The <code>if</code> Statement</h2>
<p>The <code>if</code> statement allows a program to choose between two
alternatives by testing the value of an expression. In its simplest
form, the <code>if</code> statement has the form</p>
<pre><code>if(expression) statement</code></pre>
<p>Notice that the parentheses around the expression are mandatory;
they’re part of the <code>if</code> statement, not part of the
expression. Also note that the word then doesn’t come after the
parentheses, as it would in some programming languages.</p>
<p>When an <code>if</code> statement is executed. the expression in the
parentheses is evaluated: if the value of the expression is
nonzero—which C interprets as true—the statement after the parentheses
is executed. Here’s an example:</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX_LINES<span class="op">)</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>The statement <code>line_num = 0;</code> is executed if the condition
<code>line_num == MAX_LINES</code> is true (has a nonzero value).</p>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Don’t confuse <code>==</code> (equality) with <code>=</code>
(assignment). The statement <code>if(i == 0) ...</code> tests whether
<code>i</code> is equal to 0. However, the statement
<code>if (i = 0) ...</code> assigns 0 to <code>i</code>, then tests
whether the <em>result</em> is nonzero. In this case, the test always
fails.</p>
<p><span class="QandA"></span></p>
<p>Confusing <code>==</code> with <code>=</code> is perhaps the most
common C programming error, probably because <code>=</code> means “is
equal to” in mathematics (and in certain programming languages). Some
compilers issue a warning if they notice <code>=</code> where
<code>==</code> would normally appear.</p>
</div>
<!-- END: div -->
<p>Often the expression in an <code>if</code> statement will test
whether a variable falls within a range of values. To test whether
<code>0 ≤ i &lt; n</code>, for example, we’d write</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="dv">0</span> <span class="op">&lt;=</span> i <span class="op">&amp;&amp;</span> i <span class="op">&lt;</span> n<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>To test the opposite condition (<code>i</code> is outside the range),
we’d write</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> i <span class="op">&gt;=</span> n<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>Note the use of the <code>||</code> operator instead of the
<code>&amp;&amp;</code> operator.</p>
<h3 id="compound-statements">5.2.1 Compound Statements</h3>
<p>In our <code>if</code> statement template, notice that statement is
singular, not plural:</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span> statement</span></code></pre></div>
<p>What if we want an <code>if</code> statement to control fwo or more
statements? That’s where the <strong><em>compound
statement</em></strong> comes in. A compound statement has the form</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> statements <span class="op">}</span></span></code></pre></div>
<p>By putting braces around a group of statements, we can force the
compiler to treat it as a single statement.</p>
<p>Here’s an example of a compound statement:</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> page num<span class="op">++;</span> <span class="op">}</span></span></code></pre></div>
<p>For clarity, I’ll usually put a compound statement on several lines,
with one statement per line:</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>    line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that each inner statement still ends with a semicolon, but the
compound statement itself does not.</p>
<p>Here’s what a compound statement would look like when used inside an
<code>if</code> statement:</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX LINES<span class="op">)</span> <span class="op">{</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>    line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Compound statements are also common in loops and other places where
the syntax of C requires a single statement, but we want more than
one.</p>
<h3 id="the-else-clause">5.2.2 The <code>else</code> Clause</h3>
<p>An <code>if</code> statement may have an <code>else</code>
clause:</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span> statement <span class="cf">else</span> statement</span></code></pre></div>
<p>The statement that follows the word <code>else</code> is executed if
the expression in parentheses has the value 0.</p>
<p>Here’s an example of an <code>if</code> statement with an
<code>else</code> clause:</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>    max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>    max <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>Notice that both “inner” statements end with a semicolon.</p>
<p>When an <code>if</code> statement contains an <code>else</code>
clause, a layout issue arises: where should the else be placed? Many C
programmers align it with the <code>if</code> at the beginning of the
statement, as in the previous example. The inner statements are usually
indented, but if they’re short they can be put on the same line as the
<code>if</code> and <code>else</code>:</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span> max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> max <span class="op">=</span> j<span class="op">;</span></span></code></pre></div>
<p>There are no restrictions on what kind of statements can appear
inside an <code>if</code> statement. In fact, it’s not unusual for
<code>if</code> stalements to be nested inside other <code>if</code>
statements. Consider the following <code>if</code> statement, which
finds the largest of the numbers stored in <code>i</code>,
<code>j</code>, and <code>k</code> and stores that value in
<code>max</code>:</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> k<span class="op">)</span></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> k<span class="op">)</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-12"><a href="#cb169-12" aria-hidden="true" tabindex="-1"></a>`if` statements can be nested to any depth<span class="op">.</span> Notice how aligning each `e1se` with the matching `if` makes the nesting easier to see<span class="op">.</span> If you still find the nesting confusing<span class="op">,</span> don’t hesitate to add braces<span class="op">:</span></span>
<span id="cb169-13"><a href="#cb169-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-14"><a href="#cb169-14" aria-hidden="true" tabindex="-1"></a>```C</span>
<span id="cb169-15"><a href="#cb169-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb169-16"><a href="#cb169-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb169-17"><a href="#cb169-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> K<span class="op">)</span></span>
<span id="cb169-18"><a href="#cb169-18" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb169-19"><a href="#cb169-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb169-20"><a href="#cb169-20" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb169-21"><a href="#cb169-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb169-22"><a href="#cb169-22" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb169-23"><a href="#cb169-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb169-24"><a href="#cb169-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> k<span class="op">)</span></span>
<span id="cb169-25"><a href="#cb169-25" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb169-26"><a href="#cb169-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb169-27"><a href="#cb169-27" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb169-28"><a href="#cb169-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Adding braces to statements—even when they’re not necessary—is like
using parentheses in expressions: both techniques help make a progrum
more readable while at the same time avoiding the possibility that the
compiler won’t understand the program the way we thought it did.</p>
<p>Some programimers use as many braces as possible inside
<code>if</code> statements (and iteration statements as well). A
programmer who adopts this convention would include a pair of braces for
every <code>if</code> clause and every <code>else</code> clause:</p>
<div class="sourceCode" id="cb170"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> K<span class="op">)</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb170-13"><a href="#cb170-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb170-14"><a href="#cb170-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> k<span class="op">)</span></span>
<span id="cb170-15"><a href="#cb170-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb170-16"><a href="#cb170-16" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb170-17"><a href="#cb170-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-18"><a href="#cb170-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb170-19"><a href="#cb170-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb170-20"><a href="#cb170-20" aria-hidden="true" tabindex="-1"></a>        max <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb170-21"><a href="#cb170-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-22"><a href="#cb170-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Using braces even when they’re not required has two advantages.
First, the program becomes easier to modify, because more statements can
easily be added to any <code>if</code> or <code>else</code> clause.
Second, it helps avoid errors that can result from forgetting to use
braces when adding statements to an <code>if</code> or <code>else</code>
clause.</p>
<h3 id="cascaded-i-f-statements">5.2.3 Cascaded i f Statements</h3>
<p>We’ll often need to test a series of conditions, stopping as soon as
one of them is true. A “cascaded” <code>if</code> statement is often the
best way to write such a series of tests. For example, the following
cascaded <code>if</code> statement tests whether <code>n</code> is less
than 0, equal to 0, or greater than 0:</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;n is less than 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;n is equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;n is greater than 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Although the second <code>if</code> statement is nested inside the
first, C programmers don’t usually indent it. Instead, they align each
else with the original <code>if</code>:</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;n is less than 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;n is equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;n is greater than 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>This arrangement gives the cascaded <code>if</code> a distinctive
appearance:</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>    statement</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>    statement</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span> expression <span class="op">)</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>    statement</span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>    statement</span></code></pre></div>
<p>The last two lines (<code>else</code> <em>statement</em>) aren’t
always present, of course. This way of indenting the cascaded
<code>if</code> statement avoids the problem of excessive indentation
when the number of tests is large. Moreover, it assures the reader that
the statement is nothing more than a series of tests.</p>
<p>Keep in mind that a cascaded <code>if</code> statement isn’t some new
kind of statement; it’s just an ordinary <code>if</code> statement that
happens to have another <code>if</code> statement as its
<code>else</code> clause (and <em>that</em> <code>if</code> statement
has another <code>if</code> statement as its <code>else</code> clause,
<em>ad infinitum</em>).</p>
<h3 id="program-calculating-a-brokers-commission">5.2.4 (PROGRAM)
Calculating a Broker’s Commission</h3>
<p>When stocks are sold or purchased through a broker, the broker’s
commission is often computed using a sliding scale that depends upon the
value of the stocks traded. Let’s say that a broker charges the amounts
shown in the following table:</p>
<table>
<thead>
<tr class="header">
<th>Transaction size</th>
<th>Commission rate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Under $2,500</td>
<td>$30 + 1.7%</td>
</tr>
<tr class="even">
<td>$2,500-$6,250</td>
<td>$56 + 0.66%</td>
</tr>
<tr class="odd">
<td>$6,250-$20,000</td>
<td>$76 + 0.34%</td>
</tr>
<tr class="even">
<td>$20,000-$50,000</td>
<td>$100 + 0.22%</td>
</tr>
<tr class="odd">
<td>$50,000-$500,000</td>
<td>$155 + 0.11%</td>
</tr>
<tr class="even">
<td>Over $500,000</td>
<td>$255 + 0.09%</td>
</tr>
</tbody>
</table>
<p>The minimum charge is $39. Our next program asks the user to enter
the amount of the trade, then displays the amount of the commission:</p>
<pre class="shell"><code>Enter value of trade: 30000
Commission: $166.00</code></pre>
<p>The heart of the program is a cascaded if statement that determines
which range the trade falls into.</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: broker.c</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Calculates a broker&#39;s commission </span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> commission<span class="op">,</span> value<span class="op">;</span></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter value of trade: &quot;</span><span class="op">);</span></span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%f&quot;</span><span class="op">,</span> <span class="op">&amp;</span>value<span class="op">);</span></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">2500.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">30.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.017</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">6250.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">56.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0066</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-24"><a href="#cb175-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">20000.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-25"><a href="#cb175-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-26"><a href="#cb175-26" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">76.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0034</span><span class="bu">f</span> <span class="op">+</span> value<span class="op">);</span></span>
<span id="cb175-27"><a href="#cb175-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-28"><a href="#cb175-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">50000.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-29"><a href="#cb175-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-30"><a href="#cb175-30" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">100.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0022</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-31"><a href="#cb175-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-32"><a href="#cb175-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">500000.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-33"><a href="#cb175-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-34"><a href="#cb175-34" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">155.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0011</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-35"><a href="#cb175-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-36"><a href="#cb175-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb175-37"><a href="#cb175-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-38"><a href="#cb175-38" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">255.00</span><span class="bu">f</span> <span class="op">+</span> <span class="op">(</span><span class="fl">0.0009</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">);</span></span>
<span id="cb175-39"><a href="#cb175-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-40"><a href="#cb175-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-41"><a href="#cb175-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>commission <span class="op">&lt;</span> <span class="fl">39.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb175-42"><a href="#cb175-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb175-43"><a href="#cb175-43" aria-hidden="true" tabindex="-1"></a>        commission <span class="op">=</span> <span class="fl">39.00</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb175-44"><a href="#cb175-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-45"><a href="#cb175-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-46"><a href="#cb175-46" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Commission: $%.2f</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> commission<span class="op">);</span></span>
<span id="cb175-47"><a href="#cb175-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-48"><a href="#cb175-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb175-49"><a href="#cb175-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The cascaded <code>if</code> statement could have been written this
way instead:</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> <span class="fl">2500.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>    commission <span class="op">=</span> <span class="fl">30.00</span><span class="bu">f</span> <span class="op">+</span> <span class="fl">.017</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">;</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;=</span> <span class="fl">2500.00</span><span class="bu">f</span> <span class="op">&amp;&amp;</span> value <span class="op">&lt;</span> <span class="fl">6250.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    commission <span class="op">=</span> <span class="fl">56.00</span><span class="bu">f</span> <span class="op">+</span> <span class="fl">.0066</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">;</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;=</span> <span class="fl">6250.00</span><span class="bu">f</span> <span class="op">&amp;&amp;</span> value <span class="op">&lt;</span> <span class="fl">20000.00</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>    commission <span class="op">=</span> <span class="fl">76.00</span><span class="bu">f</span> <span class="op">+</span> <span class="fl">.0034</span><span class="bu">f</span> <span class="op">*</span> value<span class="op">;</span></span></code></pre></div>
<p>Although the program will still work, the added conditions aren’t
necessary. For example, the first <code>if</code> clause tests whether
value is less than 2500 and, if so, computes the commission. When we
reach the second <code>if</code> test
(<code>value &gt;= 2500.00f &amp;&amp; value &lt; 6250.00f</code>), we
know that value can’t be less than 2500 and therefore must be greater
than or equal to 2500. The condition <code>value &gt;= 2500.00f</code>
will always be true, so there’s no point in checking it.</p>
<h3 id="the-dangling-e1se-problem">5.2.5 The “Dangling e1se”
Problem</h3>
<p>When <code>if</code> statements are nested, we’ve got to watch out
for the notorious “dangling <code>else</code>” problem. Consider the
following example:</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>y <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> x <span class="op">/</span> y<span class="op">;</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Error: y ic equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>To which <code>if</code> statement does the <code>else</code> clause
belong? The indentation suggests that it belongs to the outer
<code>if</code> statement. However, C follows the rule that an
<code>else</code> clause belongs to the nearest <code>if</code>
statement that hasn’t already been paired with an <code>else</code>. In
this example, the <code>else</code> clause actually belongs to the inner
<code>if</code> statement, so a correctly indented version would look
like this:</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>y <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> x <span class="op">/</span> y<span class="op">;</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Error: y ic equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>To make the <code>else</code> clause part of the outer
<code>if</code> statement, we can enclose the inner <code>if</code>
statement in braces:</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>y <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> x <span class="op">/</span> y<span class="op">;</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Error: y ic equal to 0</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
<p>This example illustrates the value of braces; <code>if</code> we’d
used them in the original <code>if</code> statement, we wouldn’t have
gotten into this situation in the first place.</p>
<h3 id="conditional-expressions">5.2.6 Conditional Expressions</h3>
<p>C’s <code>if</code> statement allows a program to perform one of two
actions depending on the value of a condition, C also provides an
<em>operator</em> that allows an expression to produce one of two
<em>values</em> depending on the value of a condition.</p>
<p>The <strong><em>conditional operator</em></strong> consists of two
symbols (<code>?</code> and <code>:</code>), which must be used together
in the following way:</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>exprl <span class="op">?</span> expr2 <span class="op">:</span> expr3</span></code></pre></div>
<p><code>exprl</code>, <code>expr2</code>, and <code>expr3</code> can be
expressions of any type. The resulting expression is said to be a
<strong><em>conditional expression</em></strong>. The conditional
operator is unique among C operators in that it requires three operands
instead of one or two. For this reason, it is often referred to as a
*<strong>ternary</strong> operator.</p>
<p>The conditional expression <code>exprl</code> ? <code>expr2</code> :
<code>expr3</code> should be read “if <code>exprl</code> then
<code>expr2</code> else <code>expr3</code>.” The expression is evaluated
in stages: <code>expr1</code> is evaluated first; if its value isn’t
zero, then <code>expr2</code> is evaluated, and its value is the value
of the entire conditional expression. If the value of <code>expr1</code>
is zero, then the value of <code>expr3</code> is the value of the
conditional.</p>
<p>The following example illustrates the conditional operator:</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">,</span> j<span class="op">,</span> k<span class="op">;</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> i <span class="op">&gt;</span> j <span class="op">?</span> i <span class="op">:</span> j<span class="op">;</span>    <span class="co">/* k is now 2 */</span></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">?</span> i <span class="op">:</span> <span class="dv">0</span><span class="op">)</span> <span class="op">+</span> j<span class="op">;</span>    <span class="co">/* k is now 3 */</span></span></code></pre></div>
<p>The conditional expression <code>i &gt; j ? i : j</code> in the first
assignment to <code>k</code> returns the value of either <code>i</code>
or <code>j</code>, depending on which one is larger. Since
<code>i</code> has the value 1 and <code>j</code> has the value 2, the
<code>i &gt; j</code> comparison fails, and the value of the conditional
is 2, which is assigned to <code>k</code>. In the second assignment to
<code>k</code>, the <code>i &gt;= 0</code> comparison succeeds; the
conditional expression (<code>i &gt;= 0 ? i : 0</code>) has the value 1,
which is then added to <code>j</code> to produce 3. The parentheses are
necessary, by the way; the precedence of the conditional operator is
less than that of the other operators we’ve discussed so far, with the
exception of the assignment operators.</p>
<p>Conditional expressions tend to make programs shorter but harder to
understand, so it’s probably best to avoid them. There are, however, a
few places in which they’re tempting; one is the return statement.
Instead of writing</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> j<span class="op">;</span></span></code></pre></div>
<p>many programmers would write</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> i <span class="op">&gt;</span> j <span class="op">?</span> i <span class="op">:</span> j<span class="op">;</span></span></code></pre></div>
<p>Calls of <code>printf</code> can sometimes benefit from condition
expressions. Instead of</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;&amp;d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> j<span class="op">);</span></span></code></pre></div>
<p>we could simply write</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i <span class="op">&gt;</span> j <span class="op">?</span> i <span class="op">:</span> j<span class="op">);</span></span></code></pre></div>
<p>Conditional expressions are also common in certain kinds of macro
definitions,</p>
<h3 id="boolean-values-in-c89">5.2.7 Boolean Values in C89</h3>
<p>For many years, the C language lacked a proper Boolean type, and
there is none defined in the C89 standard. This omission is a minor
annoyance, since many programs need variables that can store either
<code>false</code> or <code>true</code>. One way to work around this
limitation of C89 is to declare an <code>int</code> variable and then
assign it either 0 or 1;</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> flag<span class="op">;</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>Although this scheme works, it doesn’t contribute much to program
readability, It’s not obvious that <code>flag</code> is to be assigned
only Boolean values and that 0 and 1 represent <code>false</code> and
<code>true</code>.</p>
<p>To make programs more understandable, C89 programmers often define
macros with names such as <code>TRUE</code> and <code>FALSE</code>:</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TRUE 1</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FALSE 0</span></span></code></pre></div>
<p>Assignments to <code>flag</code> now have a more natural
appearance:</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> FALSE<span class="op">;</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> TRUE<span class="op">;</span></span></code></pre></div>
<p>To test whether <code>flag</code> is true, we can write</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>flag <span class="op">==</span> TRUE<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>or just</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>flag<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>The latter form is better, not only because it’s more concise, but
also because it will still work correctly if <code>flag</code> has a
value other than 0 or 1.</p>
<p>To test whether <code>flag</code> is false, we can write</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>flag <span class="op">==</span> FALSE<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!</span>flag<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>Carrying this idea one step further, we might even define a macro
that can be used as a type:</p>
<div class="sourceCode" id="cb193"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define BOOL int</span></span></code></pre></div>
<p><code>BOOL</code> can take the place of <code>int</code> when
declaring Boolean variables:</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>BOOL flag<span class="op">;</span></span></code></pre></div>
<p>It’s now clear that <code>flag</code> isn’t an ordinary integer
variable, but instead represents a Boolean condition, (The compiler
still treats <code>flag</code> as an <code>int</code> variable, of
course.) In later chapters, we’ll discover better ways to set up a
Boolean type in C89 by using type definitions and enumerations.</p>
<p><span class="C99Symbol"></span></p>
<h3 id="boolean-values-in-c99">5.2.8 Boolean Values in C99</h3>
<p><span class="QandA"></span></p>
<p>The longstanding lack of a Boolean type has been remedied in C99,
which provides the <code>_Bool</code> type. In this version of C, a
Boolean variable can be declared by writing</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="dt">_Bool</span> flag<span class="op">;</span></span></code></pre></div>
<p><code>_Bool</code> is an integer type (more precisely, an
<em>unsigned</em> integer type), so a <code>_Bool</code> variable is
really just an integer variable in disguise. Unlike an ordinary integer
variable, however, a <code>_Bool</code> variable can only be assigned 0
or 1. In general, attempting to store a nonzero value into a
<code>_Bool</code> variable will cause the variable to be assigned
1:</p>
<div class="sourceCode" id="cb196"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">/* flag ie assigned 1 */</span></span></code></pre></div>
<p>iI’s legal (although not advisable) to perform arithmetic on
<code>_Bool</code> variables; it’s also legal to print a
<code>_Bool</code> variable (either 0 or 1 will be displayed). And, of
course, a <code>_Bool</code> variable can be tested in an
<code>if</code> statement:</p>
<div class="sourceCode" id="cb197"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>flag<span class="op">)</span> <span class="co">/* tests whether flag is 1 */</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>In addition to defining the <code>_Bool</code> type, C99 also
provides a new header, <code>&lt;stdbool.h&gt;</code>, that makes it
easier to work with Boolean values. This header provides a macro,
<code>bool</code>, that stands for <code>_Bool</code>. If
<code>&lt;stdbool.h&gt;</code> is included, we can write</p>
<div class="sourceCode" id="cb198"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> flag<span class="op">;</span> <span class="co">/* same as _Bool flag; */</span></span></code></pre></div>
<p>The <code>&lt;stdbool.h&gt;</code> header also supplies macros named
<code>true</code> and <code>false</code>, which stand for 1 and 0,
respectively, making it possible to write</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>flag <span class="op">=</span> true<span class="op">;</span></span></code></pre></div>
<p>Because the <code>&lt;stdbool.h&gt;</code> header is so handy, I’ll
use it in subsequent programs whenever Boolean variables are needed.</p>
<h2 id="the-switch-statement">5.3 The switch Statement</h2>
<p>In everyday programming, we’ll often need to compare an expression
against a series of values to see which one it currently matches. We saw
in Section 5.2 that a cascaded <code>if</code> statement can be used for
this purpose. For example, the following cascaded <code>if</code>
statement prints the English word that corresponds to a numerical
grade:</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">4</span><span class="op">)</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Excellent&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Good&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Average&quot;</span><span class="op">);</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Poor&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>grade <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true" tabindex="-1"></a>    printf <span class="op">(</span><span class="st">&quot;Illegal grade&#39;&quot;</span><span class="op">);</span></span></code></pre></div>
<p>As an alternative to this kind of cascaded <code>if</code> statement,
C provides the switch statement. The following switch is equivalent to
our cascaded <code>if</code>:</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Excellent&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Good&quot;</span><span class="op">);</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Average&quot;</span><span class="op">);</span></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Poor&quot;</span><span class="op">);</span></span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a><span class="cf">default</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Illegal grade&quot;</span><span class="op">);</span></span>
<span id="cb201-14"><a href="#cb201-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb201-15"><a href="#cb201-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When this statement is executed, the value of the variable grade is
tested against 4, 3, 2, 1, and 0. If it matches 4, for example, the
message <code>Excellent</code> is printed, then the <code>break</code>
statement transfers control to the statement following the
<code>switch</code>. If the value of grade doesn’t match any of the
choices listed, the <code>default</code> case applies, and the message
<code>Illegal grade</code> is printed.</p>
<p>A <code>switch</code> statement is often easier to read than a
cascaded <code>if</code> statement. Moreover, <code>switch</code>
statements are often faster than <code>if</code> statements, especially
when there are more than a handful of cases.</p>
<p><span class="QandA"></span></p>
<p>In its most common form, the <code>switch</code> statement has the
form</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span> expression <span class="op">)</span> <span class="op">{</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> constant<span class="op">-</span>expression <span class="op">:</span> statements</span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> constant<span class="op">-</span>expression <span class="op">:</span> statements</span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span> <span class="op">:</span> statements</span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>switch</code> statement is fairly complex; let’s look at
its components one by one:</p>
<ul>
<li><strong><em>Controlling expression</em></strong>. The word switch
must be followed by an integer expression in parentheses. Characters are
treated as integers in C and thus can be tested in <code>switch</code>
statements. Floating-point numbers and strings don’t qualify,
however.<br />
</li>
<li><strong><em>Case labels</em></strong>. Each case begins with a label
of the form <code>case constant-expression:</code> A
<strong><em>constant expression</em></strong> is much like an ordinary
expression except that it can’t contain variables or function calls.
Thus, 5 is a constant expression, and <code>5 + 10</code> is a constant
expression, but <code>n + 10</code> isn’t a constant expression (unless
<code>n</code> is a macro that represents a constant). The constant
expression in a case label must evaluate to an integer (characters are
also acceptable).<br />
</li>
<li><strong><em>Statements</em></strong>. After each case label comes
any number of statements. No braces are required around the statements.
(Enjoy it—this is one of the few places in C where braces aren’t
required.) The last statement in each group is normally
<code>break</code>.</li>
</ul>
<p>Duplicate case labels aren’t allowed. The order of the cases doesn’t
matter; in particular, the default case doesn’t need to come last.</p>
<p>Only one constant expression may follow the word <code>case</code>;
however, several <code>case</code> labels may precede the same group of
statements:</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span></span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Passing&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Illegal grade&quot;</span><span class="op">);</span></span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb203-12"><a href="#cb203-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To save space, programmers sometimes put several case labels on the
same line:</p>
<div class="sourceCode" id="cb204"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> </span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Passing&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Illegal grade&quot;</span><span class="op">);</span></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unfortunately, there’s no way to write a case label that specifies a
range of values, as there is in some programming languages.</p>
<p>A <code>switch</code> statement isn’t required to have a
<code>default</code> case. If <code>default</code> is missing and the
value of the controlling expression doesn’t match any of the case
labels, control simply passes to the next statement after the
<code>switch</code>.</p>
<h3 id="the-role-of-the-break-statement">5.3.1 The Role of the break
Statement</h3>
<p>Now, let’s take a closer look at the mysterious <code>break</code>
statement. As we’ve seen, executing a <code>break</code> statement
causes the program to “break™ out of the <code>switch</code> statement;
execution continues at the next statement after the
<code>switch</code>.</p>
<p>The reason that we need break has to do with the fact that the
<code>switch</code> statement is really a form of “computed jump.” When
the controlling expression is evaluated, control jumps to the case label
matching the value of the <code>switch</code> expression. A case label
is nothing more than a marker indicating a position within the
<code>switch</code>, When the last statement in the case has been
executed, control “falls through” to the first statement in the
following case; the case label for the next case is ignored. Without
<code>break</code> (or some other jump statement), control will flow
from one case into the next. Consider the following switch
statement:</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Excellent&quot;</span><span class="op">);</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Good&quot;</span><span class="op">);</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Average&quot;</span><span class="op">);</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Poor&quot;</span><span class="op">);</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Failing&quot;</span><span class="op">);</span></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Illegal grade&quot;</span><span class="op">);</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If the value of grade is 3, the message printed is</p>
<pre class="shell"><code>GoodAveragePoorFailingIllegal grade</code></pre>
<!-- START: div -->
<div class="infoBox">
<p><span class="warningEmoji"></span></p>
<p>Forgetting to use <code>break</code> is a common error. Although
omitting <code>break</code> is sometimes done intentionally to allow
several cases to share code, it’s usually just an oversight.</p>
</div>
<!-- END: div -->
<p>Since deliberately falling through from one case into the next is
rare, it’s a good idea to point out any deliberate omission of
<code>break</code>:</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>grade<span class="op">)</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>        num_passings<span class="op">++;</span></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* FALL THROUGH */</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span> total grades<span class="op">++;</span></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Without the comment, someone might later fix the “error” by adding an
unwanted <code>break</code> statement.</p>
<p>Although the last case in a <code>switch</code> statement never needs
a <code>break</code> statement, it’s common practice to put one there
anyway to guard against a “missing <code>break</code>” problem if cases
should later be added.</p>
<h3 id="program-printing-a-date-in-legal-form">5.3.2 (PROGRAM) Printing
a Date in Legal Form</h3>
<p>Contracts and other legal documents are often dated in the following
way:</p>
<pre><code>Dated this __________ day of __________ . 20 __ .</code></pre>
<p>Let’s write a program that displays dates in this form. We’ll have
the user enter the date in month/day/year form, then we’ll display the
date in “legal” form:</p>
<pre class="shell"><code>Enter date (mm/dd/yy): 7/19/14
Dated this 19th day of July, 2014.</code></pre>
<p>We can get <code>printf</code> to do most of the formatting. However.
we’re left with two problems: how to add “th” (or “st” or “nd” ar “rd”)
to the day. and how to print the month as a word instead of a number.
Fortunately, the <code>switch</code> statement is ideal for both
situations; we’ll have one switch print the day suffix and another print
the month name.</p>
<div class="sourceCode" id="cb210"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * file: date.c</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Purpose: Prints a date in legal form</span></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * Author: K. N. King</span></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb210-11"><a href="#cb210-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> month<span class="op">,</span> day<span class="op">,</span> year<span class="op">;</span></span>
<span id="cb210-12"><a href="#cb210-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-13"><a href="#cb210-13" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Enter date (mm/dd/yy): &quot;</span><span class="op">);</span></span>
<span id="cb210-14"><a href="#cb210-14" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&quot;%d / %d /%d&quot;</span><span class="op">,</span> <span class="op">&amp;</span>month<span class="op">,</span> <span class="op">&amp;</span>day<span class="op">,</span> <span class="op">&amp;</span>year<span class="op">);</span></span>
<span id="cb210-15"><a href="#cb210-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-16"><a href="#cb210-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Dated this %d&quot;</span><span class="op">,</span> day<span class="op">);</span></span>
<span id="cb210-17"><a href="#cb210-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span><span class="op">(</span>day<span class="op">)</span></span>
<span id="cb210-18"><a href="#cb210-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb210-19"><a href="#cb210-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">21</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">31</span><span class="op">:</span></span>
<span id="cb210-20"><a href="#cb210-20" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;st&quot;</span><span class="op">);</span></span>
<span id="cb210-21"><a href="#cb210-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-22"><a href="#cb210-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">22</span><span class="op">:</span></span>
<span id="cb210-23"><a href="#cb210-23" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;nd&quot;</span><span class="op">);</span></span>
<span id="cb210-24"><a href="#cb210-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-25"><a href="#cb210-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">23</span><span class="op">:</span></span>
<span id="cb210-26"><a href="#cb210-26" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;rd&quot;</span><span class="op">);</span></span>
<span id="cb210-27"><a href="#cb210-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-28"><a href="#cb210-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb210-29"><a href="#cb210-29" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;th&quot;</span><span class="op">);</span></span>
<span id="cb210-30"><a href="#cb210-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-31"><a href="#cb210-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb210-32"><a href="#cb210-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot; day of &quot;</span><span class="op">);</span></span>
<span id="cb210-33"><a href="#cb210-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-34"><a href="#cb210-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>month<span class="op">)</span></span>
<span id="cb210-35"><a href="#cb210-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb210-36"><a href="#cb210-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;January&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-37"><a href="#cb210-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;February&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-38"><a href="#cb210-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;March&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-39"><a href="#cb210-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">4</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;April&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-40"><a href="#cb210-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;May&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-41"><a href="#cb210-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">6</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;June&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-42"><a href="#cb210-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">7</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;July&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-43"><a href="#cb210-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">8</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;August&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-44"><a href="#cb210-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">9</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;September&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-45"><a href="#cb210-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">10</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;October&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-46"><a href="#cb210-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">11</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;November&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-47"><a href="#cb210-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">12</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;December&quot;</span><span class="op">);</span><span class="cf">break</span><span class="op">;</span></span>
<span id="cb210-48"><a href="#cb210-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb210-49"><a href="#cb210-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-50"><a href="#cb210-50" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;, 20%.2d.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> year<span class="op">);</span></span>
<span id="cb210-51"><a href="#cb210-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-52"><a href="#cb210-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb210-53"><a href="#cb210-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note the use of <code>%.2d</code> to display the last two digits of
the year. If we had used <code>%d</code> instead, single-digit years
would be displayed incorrectly (2005 would be printed as 205).</p>
<hr />
<h2 id="q-a-3">Q &amp; A</h2>
<!-- START: div -->
<div class="QandA_question">
<p>Q: My compiler doesn’t give a warning when I use <code>=</code>
instead of <code>==</code>. Is there some way to force the compiler to
notice the problem? [p. 77]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: Here’s a trick that some programmers use: instead of writing</p>
<div class="sourceCode" id="cb211"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>they habitually write</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="dv">0</span> <span class="op">==</span> i<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>Now suppose that the <code>==</code> operator is accidentally written
as <code>=</code>:</p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span><span class="dv">0</span> <span class="op">=</span> i<span class="op">)</span> <span class="op">...</span></span></code></pre></div>
<p>The compiler will produce an error message, since it’s not possible
to assign a value to 0. I don’t use this trick, because I think it makes
programs look unnatural. Also, it can be used only when one of the
operands in the test condition isn’t an lvalue.</p>
<p>Fortunately, many compilers are capable of checking for suspect uses
of the <code>=</code> operator in <code>if</code> conditions. The GCC
compiler, for example, will perform this check if the
<code>-Wparentheses</code> option is used or if <code>-Wall</code> (all
warnings) is selected. GCC allows the programmer to suppress the warning
in a particular case by enclosing the if condition in a second set of
parentheses:</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">((</span>i <span class="op">=</span> j<span class="op">))</span> <span class="op">...</span></span></code></pre></div>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: C books seem to use several different styles of indentation and
brace placement for compound statements. Which style is best?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>According to The <em>New Hacker’s Dictionary</em> (Cambridge, Mass.:
MIT Press, 1996), there are four common styles of indentation and brace
placement:</p>
<!-- START: unordered-list -->
<ul>
<li>
<p>The <em>K&amp;R</em> style, used in Kernighan and Ritchie’s <em>The C
Programming Language</em>, is the one I’ve chosen for the programs in
this book. In the K&amp;R style, the left brace appears at the end of a
line:</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX LINES<span class="op">)</span> <span class="op">{</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>    line num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The K&amp;R style keeps programs compact by not putting the left
brace on a line by itself. A disadvantage: the left brace can be hard to
find. (I don’t consider this a problem, since the indentation of the
inner statements makes it clear where the left brace should be.) The
K&amp;R style is the one most often used in Java, by the way.</p>
</li>
<li>
<p>The <em>Allman style</em>, named after <strong>Eric Allman</strong>
(the author of <code>sendmail</code> and other UNIX utilities), puts the
left brace on a separate line:</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX_ LINES<span class="op">)</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>    line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This style makes it easy to check that braces come in matching
pairs.</p>
</li>
<li>
<p>The <em>Whitesmiths style</em>, popularized by the Whitesmiths C
compiler, dictates that braces be indented:</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX LINES<span class="op">)</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>    line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>    page_num<span class="op">++;</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
</li>
<li>
<p>m The GNU style, used in software developed by the GNU Project,
indents the braces, then further indents the inner statements:</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>line_num <span class="op">==</span> MAX LINES<span class="op">)</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>        line_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a>        page_num<span class="op">++;</span></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
</li>
</ul>
<!-- END: unordered-list -->
<p>Which style you use is mainly a matter of taste; there’s no proof
that one style is clearly better than the others. In any event, choosing
the right style is less important than applying it consistently.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: If <code>i</code> is an <code>int</code> variable and
<code>f</code> is a <code>float</code> variable, what is the type of the
conditional expression <code>(i &gt; 0 ? i : f)</code>?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: When <code>int</code> and <code>float</code> values are mixed in a
conditional expression, as they are here, the expression has type
<code>float</code>. If <code>i &gt; 0</code> is <code>true</code>, the
value of the expression will be the value of <code>i</code> after
conversion to <code>float</code> type.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: Why doesn’t C99 have a better name for its Boolean type?
[p. 85]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p><span class="C99Symbol"></span></p>
<p>A: <code>_Bool</code> isn’t a very elegant name, is it? More common
names, such as <code>bool</code> or <code>boolean</code>, weren’t chosen
because existing C programs might already define these names, causing
older code not to compile.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: OK, so why wouldn’t the name <code>_Bool</code> break older
programs as well?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The C89 standard specifies that names beginning with an underscore
followed by an uppercase letter are reserved for future use and should
not be used by programmers.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: The template given for the <code>switch</code> statement described
it as the “most common form.” Are there other forms? [p. 87]</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: The <code>switch</code> statement is a bit more general than
described in this chapter, although the description given here is
general enough for virtually all programs. For example, a
<code>switch</code> statement can contain labels that aren’t preceded by
the word <code>case</code>, which leads to an amusing (?) trap. Suppose
that we accidentally misspell the word <code>default</code>:</p>
<div class="sourceCode" id="cb219"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>    defualt<span class="op">:</span> <span class="op">...</span></span></code></pre></div>
<p>The compiler may not detect the error, since it assumes that
<code>defualt</code> is an ordinary label.</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_question">
<p>Q: I’ve seen several methods of indenting the <code>switch</code>
statement. Which way is best?</p>
</div>
<!-- END: div -->
<!-- START: div -->
<div class="QandA_answer">
<p>A: There are at least two common methods. One is to put the
statements in each case <em>after</em> the <code>case</code> label:</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>coin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Cent&quot;</span><span class="op">);</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Nickel&quot;</span><span class="op">);</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">10</span><span class="op">:</span> printf <span class="op">(</span><span class="st">&quot;Dime&quot;</span><span class="op">);</span></span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">25</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Quarter&quot;</span><span class="op">);</span></span>
<span id="cb220-9"><a href="#cb220-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb220-10"><a href="#cb220-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If each case consists of a single action (a call of
<code>printf</code>, in this example), the <code>break</code> statement
could even go on the same line as the action:</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>coin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Cent&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Nickel&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">10</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Dime&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">25</span><span class="op">:</span> printf<span class="op">(</span><span class="st">&quot;Quarter&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The other method is to put the statements <em>under</em> the case
label, indenting the statements to make the case label stand out:</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>coin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Cent&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">5</span><span class="op">:</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Nickel&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">10</span><span class="op">:</span></span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Dime&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">25</span><span class="op">:</span></span>
<span id="cb222-12"><a href="#cb222-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Quarter&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb222-13"><a href="#cb222-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb222-14"><a href="#cb222-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In one variation of this scheme, each case label is aligned under the
word <code>switch</code>.</p>
<p>The first method is fine when the statements in each case are short
and there are relatively few of them. The second method is better for
large switch statements in which the statements in each case are complex
and/or numerous.</p>
</div>
<!-- END: div -->
<hr />
<h2 id="examples-3">Examples</h2>
<ul>
<li>Programs: <a
href="./cknkCh05/cknkCh05Exmp/">./cknkCh05/cknkCh05Exmp/</a></li>
</ul>
<h2 id="exercises-3">Exercises</h2>
<ul>
<li>Readme: <a
href="./cknkCh05/cknkCh05Exrc/README.md">./cknkCh05/cknkCh05Exrc/README.md</a><br />
</li>
<li>Readme (html): <a
href="./cknkCh05/cknkCh05Exrc/cknkCh05ExrcReadme.html">./cknkCh05/cknkCh05Exrc/cknkCh05ExrcReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh05/cknkCh05Exrc/">./cknkCh05/cknkCh05Exrc/</a></li>
</ul>
<h2 id="programming-projects-3">Programming Projects</h2>
<ul>
<li>Readme: <a
href="./cknkCh05/cknkCh05Prj/README.md">./cknkCh05/cknkCh05Prj/README.md</a><br />
</li>
<li>Readme: <a
href="./cknkCh05/cknkCh05Prj/cknkCh05PrjReadme.html">./cknkCh05/cknkCh05Prj/cknkCh05PrjReadme.html</a><br />
</li>
<li>Programs: <a
href="./cknkCh05/cknkCh05Prj/">./cknkCh05/cknkCh05Prj/</a></li>
</ul>
<hr class="chapterDivider"/>
<hr class="chapterDivider"/>
</body>
</html>
