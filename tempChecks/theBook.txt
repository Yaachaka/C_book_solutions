Programming Projects

Mmﬂfy the stack example of Section 10.2 so that it stores characters instead of integers.
Next, add a `main` function that asks the user to enter a series of parentheses and/or braces,
then indicates whether or not they re properly nested:

Enter parentheses and/or braces: ((){}{(0)})
Parentheses/braces are nested properly

Hint: As the program reads characters, have it push each left parenthesis or left brace. When
it reads a right parenthesis or brace, have it pop the stack and check that the item popped is a
maching parenthesis or brace. (If not, the parentheses/braces aren’t nested properly.) When
the program reads the new-line character, have it check whether the stack is empty; if so, the
parentheses/braces are matched. If the stack isn' empty (or if stack_underflow is ever

3

5t

Programming Projects 239

called), the parentheses/braces aren’t matched. If stack_overflow is called, have the
program print the message Stack overtlow and terminate immediately.

Modify the poker.c program of Section 10.5 by moving the num_in_rank and
num_in_suit arays into main, which will pass them as arguments to read_cards
and analyze hand.

Remove the num_in_rank, num_in_suit, and card exists arrays from the
poker.c program of Section 10.5. Have the program store the cards in a 5 x 2 array
instead. Each row of the array will represent a card. For example, if the array is named
hand, then hand [0] [0] will store the rank of the first card and hand [0] [1] will store
the suit of the first card,

Modify the pokex . c program of Section 10.5 by having it recognize an additional cate-
gory, “royal flush” (ace, king, queen, jack, ten of the same suit). A royal flush ranks higher
than all other hands.

Modify the poker . c program of Section 10.5 by allowing “ace-low” straights (ace, two,
three, four, five).

Some calculators (notably those from Hewlett-Packard) use a system of writing mathemati-
cal expressions known as Reverse Polish Notation (RPN). In this notation, operators are
placed after their operands instead of benween their operands. For example, | +2 would be
written 1 2 + in RPN, and 1 + 2 * 3 would be written 1 2 3 * +. RPN expressions can easily
be evaluated using a stack. The algorithm involves reading the operators and operands in an
expression from left to right, performing the following actions:

When an operand is encountered, push it onto the stack.

When an operator is encountered, pop its operands from the stack, perform the opera-
tion on those operands, and then push the result onto the stack.

Wirite a program that evaluates RPN expressions. The operands will be single-digit integers.
The operators are +, -, *, /, and =. The = operator causes the top stack item to be displayed;
afterwards, the stack is cleared and the user is prompted to enter another expression. The
process continues until the user enters a character that is not an operator or operand:

Enter an RPN expression: 1 2 3 * + =
Value of expression: 7

Enter an RPN expression: 58 * 4 9 - / =
Value of expression: -8

Enter an RPN expression: g

If the stack overflows, the program will display the message Expression is Loo com-
plex and terminate. If the stack underflows (because of an expression such as 12 + +), the
program will display the message Not enough operands in expression and termi-
nate. Hints: Incorporate the stack code from Scction 10.2 into your program. Use
scanf (" %c", &ch) to read the operators and operands.

Write a program that prompts the user for a number and then displays the number, using

characters to simulate the effect of a seven-segment display:

Enter a number: 491-9014

1 e O 1 T
i R e

Characters other than digits should be ignored. Write the program so that the maximum
number of digits is controlled by a macro named MAX_DTGITS, which has the value 10. If
240

Chapter 10  Program Organization

the number contains more than this number of digits, the extra digits are ignored. Hinrs: Use
two external arrays. One is the segments array (see Exercise 6 in Chapter 8), which stores
data representing the correspondence between digits and segments. The other array, dig-
its, will be an array of characters with 4 rows (since each scgmented digit is four charac-
ters high) and MAX_DIGITS * 4 columns (digits are three characters wide, but a space is
needed between digits for readability), Write your program as four functions: main,
clear_digits_array. process_digit, and print_digits array. Here are
the prototypes for the latter three functions:

void clear digits array(void
void process_digit (int digit,
void print_digits_array(void);

int position);

clear _digits_array will store blank characters into all elements of the digits
array, process digit will store the seven-segment representation of digit into a
specified position in the digits array (positions range from 0 to MAX DIGITS - 1).
print_digits array will display the rows of the digits array. each on a single line,
producing output such as that shown in the example.

11

11.1

Pointers

The 11th commandment was ‘Thou Shalt Compute”
or “Thou Shalt Not Compute”—1 forget which.

Pointers are one of C's most important—and most often misunderstood—features.
Because of their importance, we’ll devote three chapters to pointers. In this chap-
ter, we’ll concentrate on the basics; Chapters 12 and 17 coyer more advanced uses
of pointers.

We'll start with a discussion of memory addresses and their relationship to
pointer variables (Section 11.1). Section 11.2 then introduces the address and indi-
rection operators. Section 11.3 covers pointer assignment. Section 11.4 cxplains
how to pass pointers to functions, while Section 11.5 discusses returning pointers
from functions.

Pointer Variables

The first step in understanding pointers is visualizing what they represent at the
machine level. In most modern computers, main memory is divided into byfes,
with each byte capable of storing eight bits of information:

o e e

Each hyte has a unique address to distinguish it from the other bytes in memory. If
there are i bytes in memory, we can think of addresses as numbers that range from
0 to n — 1 (see the figure at the top of the next page).

An executable program consists of both code (machine instructions corre-
sponding to statements in the original C program) and data (variables in the origi-
nal program). Each variable in the program occupies one or more bytes of memory;

241
242

Chapter 11

Pointers

Address Contents

0 01010011

ik 01110101
2 01110011
3 01100001

4 01101110

n-1 |01000011

the address of the first byte is said to be the address of the variable. In the following
figure, the variable i occupies the bytes at addresses 2000 and 2001, so 1°s address
is 2000:

2000

2001

Here’s where pointers come in. Although addresses are represented by num-
hers, their range of values may differ from that of integers, so we can’t necessarily
store them in ordinary integer variables. We can, however. store them in special
pointer variables. When we store the address of a variable i in the pointer variable
p. we say that p “points to” 1. In other words, a pointer is nothing more than an
address, and a pointer variable is just a variable that can store an address.

Instead of showing addresses as numbers in our examples, I'll use a simpler
notation. To indicate that a pointer variable p stores the address of a variable i, I'll
show the contents of p as an arrow directed toward 1:

B

Declaring Pointer Variables

A pointer variable is declared in much the same way as an ordinary variable, The
only difference is that the name of a pointer variable must be preceded by an aster-
isk:

int *p;
abstract abjects » 19,1

pointers tc pointers »17.6

iilc2

Ivalues »4.2

11.2 The Address and Indirection Operators 243

This declaration states that p is a pointer variable capable of pointing to objects of
type int. I'm using the term object instead of variable since—as we'll see in
Chapter 17—p might point to an area of memory that doesn’t belong to a variable.
(Be aware that “object” will have a different meaning when we discuss program
design in Chapter 19.)

Pointer variables can appear in declarations along with other variables:

intoi, 4, valled, bI201, % *q;

In this example, i and j are ordinary integer variables, a and b are arrays of inte-
gers, and p and g are pointers to integer objects.

C requires that every pointer variable point only to objects of a particular type
(the referenced type):

ints *p; /* points only to integers */
double *g; /* points only to doubles )
char *r; /* points only to characters */

There are no restrictions on what the referenced type may be. In fact, a pointer
variable can even point to another pointer.

The Address and Indirection Operators

C provides a pair of operators designed specifically for use with pointers. To find
the address of a variable, we use the & (address) operator. If x is a variable, then
&x is the address of x in memory. To gain access to the object that a pointer points
to, we use the * (indirection) operator. If p is a pointer, then *p represents the
object to which p currently points.

The Address Operator

Declaring a pointer variable sets aside space for a pointer but doesn’t make it point
to an object:

int *p; /* points nowhere in particular */

It's crucial to initialize p before we use it. One way to initialize a pointer variable
is to assign it the address of some variable—or, more generally, Ivalue—using the
& operator:

int i, *p;
p = &i;

By assigning the address of 1 to the variable p, this statement makes p point to i:

IS G
244

Chapter 11  Pointers

It’s also possible to initialize a pointer variable at the time we declare it:
int i;
int *p = &i;
We can even combine the declaration of i with the declaration of P, provided that
i is declared first:

4Rt 3 p =gt

The Indirection Operator

Once a pointer variable points to an object, we can use the * (indirection) operator
to access what's stored in the object. If p points to i, for example, we can print the
value of i as follows;

printf ("$d\n", *p);:

printf will display the value of 1, not the address of 1.

The mathematically inclined reader may wish to think of * as the inverse of &.
Applying & to a variable produces a pointer to the variable; applying * to the
pointer takes us back to the original variable:

o= *&i; /* same as j = i; */

As long as p points to 1, *p is an alias for i. Not only does *p have the same
value as i, but changing the value of *p also changes the value of i. (*p is an
Ivalue, so assignment to it is legal.) The following example illustrates the equiva-
lence of *p and i; diagrams show the values of p and i at various points in the
computation.

D= &i;
ey
printf ("&d\n", i); /* prints 1 */
printf ("jd\n", *p); /* prints 1 #/
*p = 2;

p

printf ("sd\n", /* prints 2 %/
printf("$d\n", *p); /+ prints 2 */

..4.
113

11.3 Pointer Assignment 245

Never apply the indirection operator to an uninitialized pointer variable. If a
pointer variable p hasn’t been initialized, altempting to use the value of p in any
way causes undefined behavior. In the following example, the call of printf may
print garbage, cause the program to crash, or have some other effect:

int *p;
printE | iEdi Sep) 5 x2S NRONG R SS /

Assigning a value to *p is particularly dangerous. If p happens to contain a valid
memory address, the following assignment will attempt to modify the data stored
at that address:

int *p;

*p = 1; /*** WRONG *#%+/

If the location modified by this assignment belongs to the program, it may behave
crratically; if it belongs to the operating system, the program will most likely
crash. Your compiler may issue a warning that p is uninitialized, so pay close
attention o any warning messages you get.

Pointer Assignment

C allows the use of the assignment operator to copy pointers, provided that they
have the same type. Suppose that 1, j. p, and g have been declared as follows:
int i, 3, *pr *a;

The statement

p = &i;

is an example of pointer assignment; the address of i is copied into p. Here's
another example of pointer assignment:

o gRti <]

This statement copies the contents of p (the address of 1) into g, in effect making
q point to the same place as p:

Both p and g now point to i, so we can change i by assigning a new value to
either *p or *q:
246 Chapter 11 Pointers

*p = 1;

*a

I
Y

Any number of pointer variables may point to the same object.
Be careful not to confuse

g = P;j
with
G = *py

The first statement is a pointer assignment: the second isn’t, as the following
example shows:

P = &i;
q = &j;
i=1;

*q = *p;

The assignment *q = *p copies the value that p points to (the value of 1) into the
object that g points to (the variable ).
11.4

11.4 Pointers as Arguments 247

Pointers as Arguments

So far, we’ve managed to avoid a rather important question: What are pointers
good for? There’s no single answer to that question, since pointers have several
distinct uses in C. In this section, we’ll see how a pointer to a variable can be use-
ful as a function argument. We'll discover other uses for pointers in Section 11.5
and in Chapters 12 and 17.

We saw in Section 9.3 that a variable supplied as an argument in a function
call is protected against change, because C passes arguments by value, This prop-
erty of C can be a nuisance if we want the function to be able to modify the vari-
able. In Section 9.3, we tried—and failed—to write a decompose function that
could modify two of its arguments.

Pointers offer a solution to this problem: instead of passing a variable x as the
argument to a function, we'll supply &x. a pointer to x. We'll declare the corre-
sponding parameter p to be a pointer. When the function is called, p will have the
value &x, hence *p (the object that p points o) will be an alias for x. Each appear-
ance of *p in the body of the function will be an indirect reference to x, allowing
the function both to read x and to modify it.

To see this technique in action, let's modify the decompose function by
declaring the parameters int_part and frac_part to be pointers. The defini-
tion of decompose will now look like this:

void decompose(double x, long *int_part, double *frac_part)
*int part = (lomg) x;
*frac part = x - *int_part;
The prototype [or decompose could be either
void decompose (double x, long *int part, double *frac_part);
or
void decompose (double, long *, double *);
We'll call decompose in the following way:
decompose (3.14159, &i, &d);

Because of the & operator in front of i and d. the arguments t0 decompose are
pointers to i and d, not the values of i and d. When decompose is called, the
value 3.14159 is copied into x, a pointer to i is stored in int_part, and a
pointer to d is stored in frac_part:
248

Chapter 11

Pointers

x| 3.14159 I
int_part d—» I

E i

The first assignment in the body of decompose converts the value of x to type
long and stores it in the object pointed to by int_part. Since int_part
points to 1, the assignment puts the value 3 in i:

x| 3.14159 |
int part -3—-{ 3 Ii
frac_part j_'( : Id

nment fetches the value that int_part points to (the value of
i), which is 3. This value is converted to type double and subtracted from x, giv-
ing .14159, which is then stored in the object that frac_part points to:

frac_part

x 14159 I
sa_paxe | |
frac_part 3—-{ 4159 Id

When decompose returns, i and d will have the values 3 and .14159, just as we
originally wanted.

Using pointers as arguments to functions is actually nothing new; we've been
doing it in calls of scanf since Chapter 2. Consider the following example:

int i;
scanf ("%d", &i);

‘We must put the & operator in front of i so that scanf is given a pointer to 1i: that
pointer tells scanf where to put the value that it reads. Without the &, scanf
would be supplied with the value of 1.

Although scanf’s arguments must be pointers, it's not always true that every
argument needs the & operator. In the following example, scanf is passed a
pointer variable:
PROGRAM

11.4 Pointers as Arguments 249

int i, *p;

p = &i;

scanf ("%d", p);

Since p contains the address of i, scanf will read an integer and store it in 1.
Using the & operator in the call would be wrong:

scanf ("$d", &p); /*** WRONG ***/

scanf would read an integer and store it in p instead of in i.

Failing to pass a pointer to a function when one is expected can have disastrous
results. Suppose that we call decompose without the & operator in front of i and
d:

decompose (3.14159, i, d);

decompose is expecting pointers as its second and third arguments, but it’s been
given the values of 1 and d instead. decompose has no way to tell the difference,
s0 it will use the values of i and d as though they were pointers. When decom-
pose stores values in *int_part and *frac_part, it will attempt to change
unknown memory locations instead of modifying i and d.

If we've provided a prototype for decompose (as we should always do, of
course), the compiler will let us know that we're attempting (o pass arguments of
the wrong type. In the case of scanf, however, failing to pass pointers often goes
undetected by the compiler, making scanf an especially error-prone function.

Finding the Largest and Smallest Elements in an Array

To illustrate how pointers are passed to functions, let’s look at a function named
max_min that finds the largest and smallest elements in an array. When we call
max_min, we'll pass it pointers to two variables; max_min will then store its
answers in these variables. max_min has the following prototype:

void max_min(int a[l, int n, int *max, int *min);
A call of max_min might have the following appearance:
max_min(b, N, &big, &small);

b is an array of integers: N is the number of elements in b. big and small are
ordinary integer variables. When max_min finds the largest element in b, it stores
the value in big by assigning it to *max. (Since max points to big, an assign-
ment to *max will modify the value of big.) max_min stores the smallest cle-
ment of b in small by assigning it to *min.

To test max_min, we'll write a program that reads 10 numbers into an array,
passes the array to max_min, and prints the results:
250 Chapter 11  Pointers

Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
Largest: 102
Smallest: 7

Here's the complete program:
maxmin.c /* Finds the largest and smallest elements in an array */

#include <stdio.h>
#define N 10
void wax min(int a[], int n, int *max, int *min);
int main(void)
. int b(N], i, big, small;

printf ("Enter %d numbers: ", N);

for (i = 0; i < N; i++)

scanf ("3d", &b[il);

max_min(b, N, &big, &small);

printf("Largest: %d\n", big);
printf ("Smallest: %d\n", small);

return 0;

void max min(int a[l, int n, int *max, int *min)
int i;
*max = *min alo]

fori {dus Tr G iy diek)
if (ali] > *max)
*max = alil;
else if (a[i] < *min)
*min = alil;

Using const to Protect Arguments

When we call a function and pass it a pointer to a variable, we normally assume
that the function will modify the variable (otherwise, why would the function
require a pointer?). For example, if we see a statement like

f (&x) ;
QzA

11.5

11.5 Pointers as Return Values 251

in a program, we’d probably expect f to change the value of x. It’s possible,
though, that f merely needs to examine the value of x, not change it. The reason
for the pointer might be efficiency: passing the value of a variable can waste time
and space if the variable requires a large amount of storage. (Section 12.3 covers
this point in more detail.)

We can use the word const to document that a function won’t change an
object whose address is passed to the function. const goes in the parameter’s
declaration, just before the specification of its type:

void f(const int *p)

{

*p = 0; /**% WRONG ***/

}

This use of const indicates that p is a pointer to a “constant integer.” Attempting
to modify *p is an error that the compiler will detect.

Pointers as Return Values

‘We can not only pass pointers to functions but also write functions that remurn
pointers. Such functions are relatively common; we'll encounter several in Chapter
13

The following function, when given pointers to two integers, returns a pointer
to whichever integer is larger:

int *max(int *a, int *b)
(
LE (*a = 5]
return a;
else
return b;

When we call max, we'll pass pointers to two int variables and store the result in
a pointer variable:

int *p, i, 3;
P = max(&i, &j);

During the call of max, *a is an alias for i, while *b is an alias for j. If i has a
larger value than j, max returns the address of 1; otherwise, it returns the address
of j. After the call, p points to either i or J.

Although the max function returns one of the pointers passed to it as an argu-
ment, that’s not the only possibility. A function could also return a pointer to an
external variable or to a local variable that’s been declared static.
252 Chapter 11

Pointers

ﬁ Never return a pointer to an automatic local variable:

*Q:

int *f(void)

int i;

return &i;

The variable i doesn’t exist once f returns, so the pointer to it will be invalid.
Some compilers issue a warning such as “function returns address of local vari-
able” in this situation.

Pointers can point to array elements, not just ordinary variables. If a is an
array, then &a [1] is a pointer to element i of a. When a function has an array
argument, it’s sometimes useful for the function to return a pointer to one of the
elements in the array. For example, the following function returns a pointer to the
middle element of the array a, assuming that a has n elements:

int *find middle(int a[l, int n) (
return &a(n/2];

}

Chapter 12 explores the relationship between pointers and arrays in considerable
detail.

Q&A

Is a pointer always the same as an address? [p. 242]

Usually, but not always. Consider a computer whose main memory is divided into
words rather than bytes. A word might contain 36 bits, 60 bits, or some other
number of bits. If we assume 36-bit words, memory will have the following
appearance:

Address. Contents

0 [001010011001010011001010011001010011

1 [001110101001110101001110101001110101

2 [001110012001110011001310011001120021

3 |001100001001100001001100001001100001

4 |001101210001101110001101110001101110

n-1 | 001000011001000011001000011001000011

Q&A 253

When memory is divided into words, each word has an address. An integer
usually occupies one word, so a pointer to an integer can just be an address. How-
ever, a word can store more than one character. For example, a 36-bit word might
store six 6-bit characters:

or four 9-bit characters:

For this reason, a pointer to a character may need to be stored in a different form
than other pointers. A pointer to a character might consist of an address (the word
in which the character is stored) plus a small integer (the position of the character
within the word).

On some computers, pointers may be “offsets” rather than complete
addresses. For example, CPUs in the Intel x86 family (used in many personal com-
puters) can execute programs in several modes. The oldest of these, which dates
back to the 8086 processor of 1978, is called real made. In this mode, addresses
are sometimes represented by a single 16-bit number (an offset) and sometimes by
two 16-bit numbers (a segment:offset pair). An offset isn’t a true memory address;
the CPU must combine it with a segment value stored in a special register. To sup-
port real mode, older C compilers often provide two kinds of pointers: near point-
ers (16-bit offsets) and far pointers (32-bit segment:offset pairs). These compilers
usually reserve the words near and far as nonstandard keywords that can be
used to declare pointer variables.

If a pointer can point to data in a program, is it possible to have a pointer to
program code?

Yes. We'll cover pointers to functions in Section 17.7.

It seems to me that there’s an inconsistency between the declaration

int *p = &i;

and the statement

p = &i;

Why isn’t p preceded by a * symbol in the statement, as it is in the declara-
tion? [p. 244]

The source of the confusion is the fact that the * symbol can have different mean-
ings in C, depending on the context in which it's used. In the declaration

int *p = &i;

the * symbol is not the indirection operator. Instead. it helps specify the type of p.
informing the compiler that p is a pointer to an int. When it appears in a statement,
254

Chapter 11

#Q:

Pointers

however, the * symbol performs indirection (when used as a unary operator). The
statement
*p = &i; [*** WRONG *#*/

would be wrong, because it assigns the address of i to the object that p points to,
not to p itself.

Is there some way to print the address of a variable? [p. 244]

Any pointer, including the address of a variable, can be displayed by calling the
printf function and using $p as the conversion specification. See Section 22.3
for details.

The following declaration is confusing:
void f(const int *p);

Does this say that f can’t modify p? [p. 251]

No. It says that f can’t change the integer that p points to; it doesn’t prevent f
from changing p itself.

void f(const int *p)

{
int j;
*p = 0; /*** WRONG *x%/
D = &j; /* legal */

Since arguments are passed by value, assigning p a new value—by making it point
somewhere else—won’t have any effect outside the function,

When declaring a parameter of a pointer type, is it legal to put the word
const in front of the parameter’s name, as in the following example?

void f(int * const p);

Yes, although the effect isn't the same as if const precedes p's type. We saw in
Section 11.4 that putting const before p's type protects the object that p points
to. Putting const after p's type protects p itself:

void f(int * conat p)
Int g
*p =0 /% legal */
P = &j; /*** WRONG ***/

This feature isn’t used very often. Since p is merely a copy of another pointer (the
argument when the function is called), there’s rarely any reason to protect it.

An even greater rarity is the need to protect both p and the object it points to,
which can be done by putting const both before and after p’s type:
Section 11.2

Section 11.3

Section 11.4

2

Exercises 255

void f(const int * const p)

e
int j;
“p = 0;  /*++ WRONG *#+/
P = &i; /*** WRONG **x/
}
Exercises
If 1 is a variable and p points to i, which of the following expressions are aliases for 17
(a) *p (€) *&p (e) *i (g) *&i
(b) &p (d) s*p 0 &i (h) &*i

If i is an int variable and p and g are pointers to int, which of the following assignments

@) p = &q; (® p = *q;
(&) p = *&q; (h) *p = q;
() &0 = q; ®p = a: (@) 4pi= *q;

The following function supposcdly computes the sum and average of the numbers in the
array 2, which has length n. avg and sum point to variables that the function should mod-
ify. Unfortunately, the function contains several errors; find and correct them.

void avg sum(double a[]l, int n, double *avg, double *sum)
int i
sum = 0.0;
for (f = 0y 4 < np )
sum += al[i];
avg = sum / n;
}
Write the following function:
void swap(int *p, int *q);
When passed the addresses of two variables, swap should exchange the values of the vari-
ables:
swap (&i, &j); /* exchanges values of i and j */

Write the following function:
veid split_time(long total_sec, int *hr, int *min, int *sec);

total secis atime represented as the number of seconds since midnight, hr, min, and
sec are pointers 10 variables in which the function will store the equivalent time in hours
(0-23), minutes (0-59), and seconds (0-59), respectively.

Write the following function:

void find_two_largest(int all, int n, int *largest,
int *second largest);
256 Chapter 11

Section 11.5

Pointers

When passed an array a of length n, the function will search a for its largest and second-
largest elements, storing them in the variables pointed to by largest and
secend largest, respectively.

Write the following function:

void split_date(int day of year, int year,

int *month, int *day);
day_of yeaxr isan integer between | and 366, specifying a particular day within the year
designated by year. month and day point to variables in which the function will store the
equivalent month (1-12) and day within that month (1-31).

Write the following function:
int *find largest (int a[], int n);

‘When passed an array a of length n, the function will return a pointer (o the array’s largest
element.

Programming Projects

Modify Programming Project 7 from Chapter 2 so that it includes the following function:

void pay_amount (int dollars, int *twenties, int *tens,
int *fives, int *ones);

The function determines the smallest number of $20, $10. $5, and $1 bills necessary to pay
the amount represented by the dollars parameter. The twenties parameter points (0 a
variable in which the function will store the number of $20 bills required. The tens,
fives, and ones parameters are similar.

Modify Programming Project 8 from Chapter 5 so that it includes the following function:

void find closest flight(int desired time,

int *departure time,

int *arrival time);
This function will find the flight whose departure time is closest o desired time
(expressed in minutes since midnight). It will store the departure and arrival times of this
flight (also expressed in minutes since midnight) in the variables pointed to by
departure_time and arrival_time, respectively.

Modify Programming Project 3 from Chapter 6 so that it includes the following tunction:

void reduce (int numerator, int denominator,
int *reduced numerator,
int *reduced_denominator) ;

numerator and denominator are the numerator and denominator of a fraction.
reduced numerator and reduced denominator are pointers to variables in
which the function will store the numerator and denominator of the fraction once it has been
reduced to lowest terms.

Modify the poker . c program of Section 10.5 by moving all external variables into main
and modifying functions so that they communicate by passing arguments. The
analyze hand function needs to change the straight, f1ush, four, three, and
pairs variables, 5o it will have to be passed pointers to those variables. |
12

121

Pointers and Arrays

Optimization hinders evolution.

Chapter 11 introduced pointers and showed how they're used as function argu-
ments and as values returned by functions. This chapter covers another application
for pointers. When pointers point to array elements, C allows us to perform arith-
metic-—addition and subtraction—on the pointers, which leads to an alternative
way of processing arrays in which pointers take the place of array subscripts.

The relationship between pointers and arrays in C is a close one, as we’ll soon
see. We'll exploit this relationship in subsequent chapters, including Chapter 13
(Strings) and Chapter 17 (Advanced Uses of Pointers). Understanding the connec-
tion between pointers and arrays is critical for mastering C: it will give you insight
into how C was designed and help you understand existing programs. Be aware,
however, that one of the primary reasons for using pointers to process arrays—effi-
ciency—is no longer as important as it once was, thanks to improved compilers.

Section 12.1 discusses pointer arithmetic and shows how pointers can be com-
pared using the relational and equality operators. Section 12.2 then demonstrates
how we can use pointer arithmetic for processing array elements. Section 12.3
reveals a key fact about arrays—an array name can serve as a pointer to the array’s
first element—and uses it to show how array arguments really work. Section 12.4
shows how the topics of the first three sections apply to multidimensional arrays.
Section 12.5 wraps up the chapter by exploring the relationship between pointers
and variable-length arrays, a C99 feature.

Pointer Arithmetic

‘We saw in Section 11.5 that pointers can point to array elements. For example,
suppose that a and p have been declared as follows:

257
258

Chapter 12 Pointers and Arrays

int al10], *p;
‘We can make p point to a [0] by writing
P = &al0l;

Graphically, here’s what we've just done:

We can now access a [0] through p; for example, we can store the value 5 in
a[0] by writing

=5,

Here’s our picture now:

Making a pointer p point to an element of an array a isn’t particularly excit-
ing. However. by performing peinter arithmetic (or address arithmetic) on p, we
can access the other elements of a. C supports three (and only three) forms of
pointer arithmetic:

Adding an integer to a pointer
Subtracting an integer from a pointer
Subtracting one pointer from another

Let’s take a close look at each of these operations. OQur examples assume that the
following declarations are in effect:

et i 6 ol M e i

Adding an Integer to a Pointer

Adding an integer j to a pointer p yields a pointer to the element j places after the
one that p points to. More precisely, if p points to the array element a [1]. then
D+ Jjpointstoali+]j] (provided, of course, that a [1+7] exists).

The following example illustrates pointer addition; diagrams show the values
of p and q at various points in the computation.
12.1  Pointer Arithmetic 259

p = &al2]; %]
qQ=p + 3; PL[J [y

kI

Subtracting an Integer from a Pointer

1f p points to the array element a [1], then p - J points to a [i-7]. For example:

p = &al8]; p?
ST
Gota g e e g b D

Subtracting One Pointer from Another

‘When one pointer is subtracted from another, the result is the distance (measured
in array elements) between the pointers. Thus, if p points to a [1] and g points to
al[jl.thenp - gisequal to i - j. For example:
260

Chapter 12 Pointers and Arrays

D

compound lerals »9.3

12:2

D
q

&a[5] ;
Q4

P - q; /* i is 4 */
Lot o [ i ds g %y

Performing arithmetic on a pointer that doesn’t point to an array element causes
undefined behavior. Furthermore, the effect of subtracting one pointer from
another is undefined unless both point to elements of the same array.

Comparing Pointers

We can compare pointers using the relational operators (<, <=, >, >=) and the
equality operators (== and |=), Using the relational operators to compare two
pointers is meaningful only when both point to elements of the same array. The
outcome of the comparison depends on the relative positions of the two elements
in the array. For example, after the assignments

&a[s];
&a[1] ;

P
q

[

the value of p <= g is 0 and the value ofps=qgisl.

Pointers to Compound Literals

It's legal for a pointer to point to an element within an array created by a com-
pound literal. A compound literal, you may recall, is a C99 feature that can be used
to create an array with no name.

Consider the following example:

int *p = (dint [1){3, 0, 3, 4, 1};

P points to the first element of a five-element array containing the integers 3, 0, 3,
4. and 1. Using a compound literal saves us the trouble of first declaring an array
variable and then making p point to the first element of that array:

dnteaill = (3, 0, 3, 4, 1}:
int *p = &a[0];

Using Pointers for Array Processing

Pointer arithmetic allows us to visit the elements of an array by repeatedly incre-
menting a pointer variable. The following program fragment, which sums the ele-
ments of an array a, illustrates the technique. In this example, the pointer variable
QeA

12.2  Using Pointers for Array Processing 261

p initially points to a [0]. Each time through the loop, p is incremented; as a
result, it points to a [1]. then a [2]. and so forth. The loop terminates when p
steps past the last element of a.

#define N 10

int a[N], sum, *p;

sum = 0;

for (p = &a[0]; p < &a[N]; p++)

sum += *p;

The following figures show the contents of a, sum, and p at the end of the first
three loop iterations (before p has been incremented).

At the end of the first iteration: I

79 | 20

At the end of the second iteration:

sun

At the end of the third iteration

0

sum| 12 I

The condition p < &a[N] in the `for` statement deserves special mention.
Strange as it may seem, it’s legal to apply the address operator to a [N], even
though this element doesn’t exist (a is indexed from 0 to N — 1). Using a [N] in
this fashion is perfectly safe, since the loop doesn’t attempt to examine its value.
The body of the loop will be executed with p equal to &a[0], &a[1], ...,
&a [N-1], but when p is equal to &a [N] , the loop terminates.

We could just as easily have written the loop without pointers, of course, using
subscripting instead. The argument most often cited in support of pointer arithmetic
is that it can save execution time. However, that depends on the implementation—
some C compilers actually produce better code `for` loops that rely on subscripting.
262

Chapter 12 Pointers and Arrays

Combining the * and ++ Operators

C programmers often combine the * (indirection) and ++ operators in statements
that process array elements. Consider the simple case of storing a value into an
array element and then advancing to the next element. Using array subscripting,
we might write

ali++] = j;

If p is pointing to an array element, the corresponding statement would be

*ptt = 4;

Because the postfix version of ++ takes precedence over *, the compiler sees this
as

*(p++) = 3

The value of p++ is p. (Since we're using the postfix version of ++, p won't be
incremented until after the expression has been evaluated.) Thus, the value of
* (p++) will be *p—the object to which p is pointing.

Of course, *p++ isn’t the only legal combination of * and ++. We could write
(*p) ++, for example, which returns the value of the object that p points to, and
then increments that object (p itself is unchanged). If you find this confusing, the
following table may help:

Expression Meaning
*pt+ OF * (pt+) Value of expression is *p before increment; increment p later
(*p) ++ Value of expression is *p before increment: increment *p later
*++por * (++p) Increment p first; value of expression is *p after increment
++*p Or ++ (*p) Increment *p first; value of expression is *p after increment

All four combinations appear in programs, although some are far more common
than others. The one we'll see most frequently is *p++, which is handy in loops.
Instead of writing

for (p = &a[0); p < &a[N]; p++)
sum += *p;

to sum the elements of the array a, we could write

p = &al0];
while (p < &al([N])
sum 4= *pra;

The * and - - operators mix in the same way as * and ++. For an application
that combines * and - -, let’s return to the stack example of Section 10.2. The orig-
inal version of the stack relied on an integer variable named top to keep track of
the “top-of-stack" position in the contents array. Let's replace top by a pointer
variable that points initially to element 0 of the contents array:

int *top ptr = &contents([0];
123

12.3 Using an Array Name as a Pointer 263

Here are the new push and pop functions (updating the other stack functions is
left as an exercise):

void push(int i)

{

if (is_full())
stack_overflow() ;
else

*top_ptr++ = i;

]

int pop (void)
{
if (is empty())
stack_underflow() ;
else
return *--top_ptr;

)

Note that I've written *--top_ptr, not *top_ptr--, since [ want pop to dec-
rement top_ptr before fetching the value to which it points.

Using an Array Name as a Pointer

Pointer arithmetic is one way in which arrays and pointers are related, but it’s not

the only connection between the two. Here's another key relationship: The name of

an array can be used as a pointer to the first element in the array. This relationship

simplifies pointer arithmetic and makes both arrays and pointers more versatile.
For example, suppose that a is declared as follows:

int af[10];

Using a as a pointer to the first element in the array, we can modify a [0] :
*a = 7; /* stores 7 in al0) */

We can modify a [1] through the pointer a + 1:

*(a+rl) = 12; /* stores 12 in a[1] */

In general, a + i is the same as &a [1] (both represent a pointer to element i of a)
and * (a+i) is equivalent to a[i] (both represent element i itself). In other
words, array subscripting can be viewed as a form of pointer arithmetic.

The fact that an array name can serve as a pointer makes it easier to write
loops that step through an array. Consider the following loop from Section 12.2:

for (p = &al0]; p < &a[N]; p++)
sum += *p;
264

Chapter 12 Pointers and Arrays

idiom

AN\

PROGRAM

reverse3.c

To simplify the loop, we can replace &a [0] by a and &a [N] by & + N:

for (p = a; p < a + N; p++)
sum += *p;

Although an array name can be used as a pointer, it's not possible to assign it a new
value. Attempting to make it point elsewhere is an error:

while (*a != 0)
at+; /*%* WRONG *#**/

This is no great loss; we can always copy a into a pointer variable, then change the
pointer variable:

Bi= &
while (*p != 0)
P+

Reversing a Series of Numbers (Revisited)

The reverse. c program of Section 8.1 reads 10 numbers, then writes the num-
bers in reverse order. As the program reads the numbers, it stores them in an array.
Once all the numbers are read, the program steps through the array backwards as it
prints the numbers.

The original program used subscripting to access elements of the array, Here's
anew version in which I've replaced subscripting with pointer arithmetic.

/* Reverses a series of numbers (pointer version) */
#include <stdio.h>
#define N 10
int main (void)
{
int a[N], *p;
printf ("Enter %d numbsrs: ', N);
for (p = a; p < a + Nj D++)
scanf ("%d", p);
printf ("In reverse order:");
for (pi=a + N = 1i p >= @ p--)
printf(" %dY, *pl;

printf ("\n");

return 0;

In the original program, an integer variable i kept track of the current position
within the array. The new version replaces i with p, a pointer variable. The num-
12.3 Using an Array Name as a Pointer 265

bers are still stored in an array: we’re simply using a different technique to keep
track of where we are in the array.

Note that the second argument (0 scanf is p, nol &p. Since p points (o an
array element, it's a satisfactory argument for scanf; &p, on the other hand,
would be a pointer to a pointer to an array element.

Array Arguments (Revisited)

‘When passed to a function, an array name is always treated as a pointer. Consider
the following function, which returns the largest element in an array of integers:

int find_largest (int al], int n)
int i, max;

max = a[0];
Eor (= st 1 < Sl d)
if (a[i] > max)
max = a[i];
return max;

Suppose that we call ffind largest as follows:
largest = find largest(b, N);

This call causes a pointer to the first element of b to be assigned to a: the array
itself isn’t copied.

The fact that an array argument is treated as a pointer has some important con-
sequences:

= When an ordinary variable is passed to a function, its value is copied; any
changes to the corresponding parameter don’t affect the variable. In contrast,
an array used as an argument isn’t protected against change, since no copy is
made of the array itself. For example, the following function (which we first
saw in Section 9.3) modifies an array by storing zero into each of its elements:

void store_zeros(int all, iat n)

{

int i;
for (i 0;
ali] = 0;
}

To indicate that an array parameter won’t be changed, we can include the word
const in its declaration:

i <mny i)

int find largest(const int a[], int n)

{
}
266

Chapter 12 Pointers and Arrays

If const is present, the compiler will check that no assignment to an element
of a appears in the body of find_largest.
m The time required to pass an array to a function doesn’t depend on the size of

the array. There’s no penalty for passing a large array, since no copy of the
array is made.

m An array paramecter can be declared as a pointer if desired. For example,
find largest could be defined as follows:

int find_largest (int *a, int n)

i

Declaring a to be a pointer is equivalent to declaring it to be an array; the
compiler treats the declarations as though they were identical.

Although declaring a parameter to be an array is the same as declaring it to be a
puinter, the same isn’t true for a variable. The declaration

int af10];
causes the compiler to set aside space for 10 integers. In contrast, the declaration
int *a;

causes the compiler to allocate space for a pointer variable. In the latter case, a is
not an array; attempting to use it as an array can have disastrous results. For exam-
ple, the assignment

*a = 0;  /*%* WRONG **%/

will store 0 where a is pointing. Since we don’t know where a is pointing, the
effect on the program is undefined.

= A function with an array parameter can be passed an array “slice”—a sequence
of consecutive elements. Suppose that we want find_largest to locate the
largest element in some portion of an array b, say elements b [5], ....b [14].
When we call find_largest, we'll pass it the address of b [5] and the
number 10, indicating that we want find largest to examine 10 array
elements, starting at b [5] :

largest = find largest (8b[5], 10);

Using a Pointer as an Array Name

If we can use an array name as a pointer, will C allow us to subscript a pointer as
though it were an array name? By now, you'd probably expect the answer (o be
yes, and you'd be right. Here's an example:
12.4

12.4 Pointers and Multidimensional Arrays 267

#define N 10

int a[N], i, sum = 0, *p = a;

for (i = 0; 1 < N; i++)
sum += p[i];

The compiler treats p [1] as * (p+1), which is a perfectly legal use of pointer

arithmetic. Although the ability to subscript a pointer may seem to be little more
than a curiosity, we'll see in Section 17.3 that it’s actually quite useful.

Pointers and Multidimensional Arrays

Just as pointers can point to elements of one-dimensional arrays, they can also
point to elements of multidimensional arrays. In this section, we’ll explore com-
mon techniques for using pointers to process the elements of multidimensional
arrays. For simplicity, I'll stick to two-dimensional arrays, but everything we'll do
applies equally to higher-dimensional arrays.

Processing the Elements of a Multidimensional Array

‘We saw in Section 8.2 that C stores two-dimensional arrays in row-major order; in
other words, the elements of row 0 come first. followed by the elements of row 1.
and so forth. An array with r rows would have the following appearance:

row 0 row 1 row r—1

We can take advantage of this layout when working with pointers. If we make a
pointer p point to the first element in a two-dimensional array (the element in row
0, column 0), we can visit every element in the array by incrementing p repeatedly.
As an example, let’s look at the problem of initializing all elements of a two-
dimensional array to zero. Suppose that the array has been declared as follows:

int a[NUM_ROWS] [NUM_COLS] ;
The obvious technique would be to use nested `for` loops:

int row, col;
for (row = 0; row < NUM ROWS; row++)
for (col = 0; col < NUM COLS; col++)
alrow] [col] = 0;
268

Chapter 12 Pointers and Arrays

QA

But if we view a as a one-dimensional array of integers (which is how it's stored),
we can replace the pair of loops by a single loop:

int *p;

for (p = &al[0] [0]; p <= &a[NUM ROWS-1] [NUM COLS-1]; p++)
*p = 0;

The loop begins with p pointing to a [0] [0]. Successive increments of p make
it point to a[o0] [1], a[0] [2], a[0] [3], and so on. When p reaches
a[0] [NUM_COLS-1] (the last element in row 0), incrementing it again makes
p point to a [1] [0], the first element in row 1. The process continues until p
goes past a [NUM_ROWS-1] [NUM_COLS-1], the last element in the array.

Although treating a two-dimensional array as one-dimensional may seem like
cheating, it works with most C compilers. Whether it's a good idea to do so is
another matter. Techniques like this one definitely hurt program readability, but—
at least with some older compilers—produce a compensating increase in effi-
ciency. With many modern compilers, though, there’s often little or no speed

advantage.

Processing the Rows of a Multidimensional Array

‘What about processing the elements in just one row of a two-dimensional array?
Again, we have the option of using a pointer variable p. To visit the elements of
row i, we'di ize p Lo point to element 0 in row i in the array a:

p = salil [0];
Or we could simply write
p = alil;

since, for any two-dimensional array a, the expression a [1] is a pointer to the
first element in row 1. To see why this works, recall the magic formula that relates
array subscripting to pointer arithmetic: for any array a, the expression a [1] is
equivalent to * (a + 1). Thus, &a [1] [0] is the same as &(* (a[1] + 0)),
which is equivalent to &*a [1], which is the same as a [1] ., since the & and *
operators cancel. We'll use this simplification in the following loop, which clears
row i of the array a:

int a[NUM_ROWS] [NUM_COLS], *p, i;

for (p = alil; p < ali] + NUM_COLS; p++)
+p = 0;

Since a[i] is a pointer to row i of the array a, we can pass a[i] toa
function that’s expecting a one-dimensional array as its argument. In other words,

a function that’s designed to work with one-dimensional arrays will also work
with a row belonging to a two-dimensional array. As a result, functions such as
12.4  Pointers and Multidimensional Arrays 269

find largest and store_zeros are more versatile than you might expect.
Consider find largest, which we originally designed to find the largest ele-
ment of a one-dimensional array. We can just as easily use find_largest to
determine the largest element in row i of the two-dimensional array a:

largest = find largest(a[i], NUM_COLS) ;

Processing the Columns of a Multidimensional Array

Processing the elements in a column of a two-dimensional array isn’t as easy,
because arrays are stored by row, not by column. Here's a loop that clears column
1 of the array a:

int a[NUM_ROWS] [NUM_COLS], (*p) [NUM _COLS], i;

;or (p = &al0]; p < & [NUM ROWS]; p++)
(*p) [1] = 0

I've declared p to be a pointer to an array of length NUM_COLS whose elements
are integers. The parentheses around *p in (*p) [NUM COLS] are required;
without them, the compiler would treat p as an array of pointers instead of a
pointer to an array. The expression p++ advances p to the beginning of the next
row. In the expression (*p) (11, *p represents an entire row of &, so (*p) [i]
selects the element in column i of that row. The parentheses in (*p) [1] are
essential, because the compiler would interpret *p [i] as * (p [i]).

Using the Name of a Multidimensional Array as a Pointer

Just as the name of a one-dimensional array can be used as a pointer, so can the
name of any array, regardless of how many dimensions it has. Some care is
required, though. Consider the following array:

int a[NUM_ROWS] [NUM_COLS] ;

a is not a pointer to a [0] [0]; instead, it’s a pointer to a [0]. This makes more
sense if we look at it from the standpoint of C. which regards a not as a two-
dimensional array but as a one-dimensional array whose elements are one
dimensional arrays. When used as a pointer, a has type int (*) [NUM_COLS]
(pointer to an integer array of length NUM_COLS).

Knowing that a points to a [0] is useful for simplifying loops that process the
elements of a two-dimensional array. For example, instead of writing

for (p = &al0]; p < &a[NUM_ROWS]; p++)
(*p) [1] = 0;

10 clear column 1 of the array a, we can write

for (p = a; p < a + NUM_ROWS; p++)
(*p) [1] = 0;
270

Chapter 12 Pointers and Arrays

12.5

variable-length arrays »8.3

Another situation in which this knowledge comes in handy is when we want
to “trick” a function into thinking that a multidimensional array is really one-
dimensional. For example, consider how we might use find_largest to find
the largest element in a. As the first argument to find_largest, let’s try
passing a (the address of the array); as the second, we’ll pass NUM_ROWS *
NUM_COLS (the total number of elements in a):

largest = find largest(a, NUM_ROWS * NUM _COLS) ; /* WRONG */

Unfortunately, the compiler will object to this statement, because the type of a is
int (*) [NuM_coLs] but find_largest is expecting an argument of type
int *. The correct call is

largest = find largest (a[0], NUM ROWS * NUM COLS);

a[0] points to element 0 in row 0, and it has type int * (after conversion by the
compiler), so the latter call will work correctly.

Pointers and Variable-Length Arrays (C99)

Pointers are allowed to point to elements of variable-length arrays (VLAs), a fea-
ture of C99. An ordinary pointer variable would be used to point to an element of a
one-dimensional VLA:

void f(int n)

{
int a[nl, *p;
P = a;

When the VLA has more than one dimension, the type of the pointer de-
pends on the length of each dimension except for the first. Let’s look at the two-
dimensional case:

void f(int m, int n)

int am] [n], (*p)[nl;
p=a

}

Since the type of p depends on n, which isn’t constant, p is said to have a variably
maodified type. Note that the validity of an assignment such as p = a can’t always
be determined by the compiler. For example, the following code will compile but is
correct only if m and 1 are equal:

int afml (nl, (*p) [m];
P = a;
*Q:

Q&A 271

If m# n, any subsequent use of p will cause undefined behavior.

Variably modified types are subject to certain restrictions, just as variable-
length arrays are. The most important restriction is that the declaration of a vari-
ably modified type must be inside the body of a function or in a function proto
type.

Pointer arithmetic works with VLAs just as it does for ordinary arrays.
Returning to the example of Section 12.4 that clears a single column of a two-
dimensional array a, let’s declare a as a VLA this time:

int afm] [n];
A pointer capable of pointing to a row of a would be declared as follows:
int (*p) [n];

The loop that clears column 1 is almost identical to the one we used in Section
12.4:

for (p = a; P < a + m; p++)
(*p) [1] = 0;

Q&A

1 don’t understand pointer arithmetic. If a pointer is an address, does that
mean that an expression like p + j adds j to the address stored in p? [p. 258]
No. Integers used in pointer arithmetic are scaled depending on the type of the
pointer. If p is of type int *, for example, then p + j typically adds 4x1top,
assuming that int values are stored using 4 bytes. But if p has type double *,
then p + j will probably add 8 x j to p, since double values are usually 8 bytes
long.

‘When writing a loop to process an array, is it better to use array subscripting
or pointer arithmetic? [p. 261]

There’s no easy answer to this question, since it depends on the machine you're
using and the compiler itself. In the early days of C on the PDP-11, pointer arith-
metic yielded a faster program. On today’s machines, using today's compilers,
array subseripting is often just as good, and sometimes even better. The bottom
line: Learn both ways and then use whichever is more natural for the kind of pro-
gram you're writing.

1 read somewhere that i [a] is the same as a [1]. Is this true?

Yes, it is, oddly enough. The compiler treats i [a] as * (i + a) , which is the same
as *(a + 1). (Pointer addition, like ordinary addition, is commutative.) But
* (a + 1) is equivalent to a [1]. Q.E.D. But please don’t use i [a] in programs
unless you're planning to enter the next Obfuscated C contest.
272

Chapter 12 Pointers and Arrays

Q:
A:

Why is *a the same as a [1 in a parameter declaration? [p. 266]

Both indicate that the argument is expected (o be a pointer. The same operations on
a are possible in both cases (pointer arithmetic and array subscripting, in particu-
lar). And, in both cases, a itself can be assigned a new value within the function.
(Although C allaws us to use the name of an array variable only as a “constant
pointer,” there’s no such restriction on the name of an array parameter.)

Is it better style to declare an array parameter as *a or a []?

That’s a tough one. From one standpoint, a [] is the obvious choice, since *a is
ambiguous (does the function want an array of objects or a pointer to a single
object?). On the other hand, many programmers argue that declaring the parameter
as *a is more accurate, since it reminds us that only a pointer is passed, not a copy
of the array. Others switch between *a and a []. depending on whether the func-
tion uses pointer arithmetic or subscripting to access the elements of the array.
(That’s the approach I'll use.) In practice, *a is more common than a [], so you'd
better get used to it. For what it's worth, Dennis Ritchie now refers to the a []
notation as “a living fossil” that “serves as much to confuse the learner as to alert
the reader.”

We’ve seen that arrays and pointers are closely related in C. Would it be accu-
rate to say that they’re interchangeable?

No. It’s true that array parameters are interchangeable with pointer parameters, but
array variables aren’t the same as pointer variables. Technically, the name of an
array isn’t a pointer; rather, the C compiler converts it to a pointer when necessary.
To see this difference more clearly, consider what happens when we apply the
sizeof operator to an array a. The value of sizeof (a) is the total number of
bytes in the array—the size of each element multiplied by the number of elements.
But if p is a pointer variable, sizeof (p) is the number of bytes required to store
a pointer value.

You said that treating a two-dimensional array as one-dimensional works
with “most” C compilers. Doesn’t it work with all compilers? [p. 268]

No. Some modern “bounds-checking" compilers track not only the type of a
pointer, but—when it points to an array—also the length of the array. For example,
suppose that p is assigned a pointer to a [0] [0] . Technically, p points to the first
element of a (0], a one-dimensional array. If we increment p repeatedly in an
effort to visit all the elements of a, we'll go out of bounds once p goes past the last
element of a [0]. A compiler that performs bounds-checking may insert code to
check that p is used only to access elements in the array pointed to by a [0]; an
attempt to increment p past the end of this array would be detected as an error.

If a is a two-dimensional array, why can we pass a [0]—but not a itself—to
find largest? Don’t both a and a [0] point to the same place (the begin-
ning of the array)? [p. 270]

They do, as a matter of fact—both point to element a (0] [0] . The problem is that
Section 12.1

Section 12.2

Section 12.3

@ 2.

3

Exercises 273

a has the wrong type. When used as an argument, it’s a pointer to an array, but
find largest is expecting a pointer to an integer. However, a [0] has type
int *, so it’s an acceptable argument for find_largest. This concern about
types is actually good: if C weren't so picky, we could make all kinds of horrible
pointer mistakes without the compiler noticing.

Exercises

Suppose that the following declarations are in effect:

int al) = {5, 15, 34, 54, 14, 2, 52, 72};
int *p = &a[1]l, *q = &a[5];

(a) Whatis the value of * (p+3) ?

(h) What is the value of * (g-3) 2

(c) What is the value of q - p?

(d) Is the condition p < g true or false?

(e) Is the condition *p < *q true or false?

Suppose that high, 1ow, and middle arc all pointer variables of the same type, and that
1ow and high point to elements of an array. Why is the following statement illegal, and
how could it be fixed?

middle = (low + high) / 2;
What will be the contents of the a array after the following statements are executed?
#define N 10

10t L IND =1, 02,0 3 a5, 06,07 B, 0. 10}
int *p = &a[0], *g = &a[N-1], temp;

while (p < @ {

temp - *p;
*pi+ = *q;
*g-- = temp;

}

Rewrite the make empty, is empty, and is_full functions of Section 10.2 to use the
pointer variable top_ptr instead of the integer variable top.

Suppose that a is a one-dimensional array and p is a pointer variable. Assuming that the
assignment p = a has just been performed, which of the following expressions are illegal
because of mismatched types? Of the remaining cxpressions, which are true (have a nonzero
value)?

@) p aflo]
() o &alo]
() *p afol

(d) plo]l == alol

Rewrite the following function to use pointer arithmetic instead of array subscripting. (In
other words, eliminate the variable i and all uses of the [] operator.) Make as few changes
as possible.
274 Chapter 12 Pointers and Arrays

Section 12.4

D 13

int sum_array(const int a[], int n)

int i, sum;

sum =

for (4 0; i < n; i++)
sum += a[il;

return sum;

}

Write the following function:

bool search(const int all, int n, int key);
a is an array to be searched, n is the number of elements in the array, and key is the search

key. search should return true if key matches some element of a, and false if it
doesn’t. Use pointer arithmetic—not subscripting—to visit array elements.

Rewrite the following function to use pointer arithmetic instead of array subscripting. (In
other words, eliminate the variable 1 and all uses of the [] operator.) Make as few changes
as possible.

void store zeros(int a(l, int n)

{

int i;

for (i
afd]

i< n; des)

Write the following function:

double inner product (coust double *a, const double *b,
int n);

a and b both point to arrays of length n. The function should return a [0] * b[0] +
afl] *o[1] +...+aln-1] * b[n-1]. Use pointer arithmetic—not subscripting—to
visit array elements.

Modify the find_middle function of Scction 11.5 so that it uses pointer arithmetic to
calculate the return value.

Modify the find largest function so that it uses pointer arithmetic—not subscript-
ing—to visit array elements.

Wite the following function:

void find two_largest(const int *a, int n, int *largest,
int *second largest) ;

a points to an array of length n. The function searches the array for its largest and second-
largest elements, storing them in the variables pointed to by largest and
second_largest, respectively. Use pointer arithmetic—not subscripting—to visit array
elements.

Section 8.2 had a program fragment in which two nested `for` loops initialized the array
ident for use as an identity matrix. Rewrite this code, using a single pointer to step
through the array one element at a time, Hini: Since we won't be using row and col index
variables, it won’t be easy 10 tell where to store 1. Instead, we can use the fact that the first
element of the array should be 1, the next N elements should be 0, the next element should

l

|
D 15

Programming Projects 275

be 1, and so forth. Use a variable to keep track of how many consecutive Os have been
stored; when the count reaches N, it's time to store 1.

Assume that the following array contains a week’s worth of hourly temperature readings,
with each row containing the readings for one day:

int temperatures[7] [24];

Write a statement that uses the search function (see Exercise 7) to search the entire
temperatures array for the value 32,

Write a loop that prints all temperature readings stored in row i of the temperatures
amay (see Exercise 14). Use a pointer to visit each element of the row.

Write a loop that prints the highest temperature in the temperatures array (see Exercise
14) for each day of the week. The loop body should call the find largest function,
passing it one row of the array at a time.

Rewrite the following function to use pointer arithmetic instead of array subscripting. (In
other words, eliminate the variables i and j and all uses of the [] operator.) Use a single
loop instead of nested loops.

int sum_two_dimensional array(const int a[] [LEN], int n)

{

int i, j, sum = 0;
i < n; it+4)

0; 3 < LEN; j++)
alil (31

return sum;

Write the evaluate _position function described in Excrcise 13 of Chapter 9. Use
pointer arithmetic—not subscripting—to visit array elements. Use a single loop instead of
nested loops.

Programming Projects

(a) Write a program that reads a message, then prints the reversal of the message:

Enter a message: Don't get mad, get even.

Revergal is: .neve teg ,dam teg t'moD

Hint: Read the message one character at a time (using ge tchar) and store the characters in
an array. Stop reading when the array is full or the character read is '\n'.

(b) Revise the program (o use a pointer instead of an integer to keep track of the current
position in the array.

(a) Write a program that reads a message, then checks whether it's a palindrome (the letters
in the message are the same from left to right as from right to left):

Enter a message: He lived as a devil, eh?
Palindrome

Enter a message: Madam, I am Adam.
Not a palindrome
276

Chapter 12 Pointers and Arrays

Ignore all characters that aren’t letters. Use integer variables to keep track of positions in the
array.

(b) Revise the program to use pointers instead of integers to keep track of positions in the
array.

Simplify Programming Project 1(b) by taking advantage of the fact that an array name can
be used as a pointer.

Simplify Programming Project 2(b) by taking advantage of the fact that an array name can
be used as a pointer.

Modify Programming Project 14 from Chapter & so that it uses a pointer instead of an inte-
ger to keep track of the current position in the array that contains the sentence,

Modify the gsort . e program of Section 9.6 so that 1ow, high, and middle are pointers
to array elements rather than integers. The split function will need to return a pointer, not
an integer.

Modify the maxmin.c program of Section 11.4 so that the max_min function uses a
pointer instead of an integer to keep track of the current position in the array.
13

13.1

Strings

It's difficult to extract sense from strings, but
they're the only communication coin we can count on.

Although we've used char variables and arrays of chax values in previous chap-
ters, we still lack any convenient way to process a series of characters (a string, in
C terminology). We’ll remedy that defect in this chapter, which covers both string
constants (or literals, as they're called in the C standard) and string variables,
which can change during the execution of a program.

Section 13.1 explains the rules that govern string literals, including the rules
for embedding escape sequences in string literals and for breaking long string liter-
als. Section 13.2 then shows how to declare string variables, which are simply
arrays of characters in which a special character—the null character—marks the
cnd of a string. Section 13.3 describes ways to read and write strings. Section 13.4
shows how to write functions that process strings, and Section 13.5 covers some of
the string-handling functions in the C library. Section 13.6 presents idioms that are
often used when working with strings. Finally, Section 13.7 describes how to set
up arrays whose elements are pointers to strings of different lengths. This section
also explains how C uses such an array to supply command-line information to
programs.

String Literals

A string literal is a sequence of characters enclosed within double quotes:
"ihen you come to a fork in the road, take it."

We first encountered string literals in Chapter 2: they often appear as format
strings in calls of printf and scanf.

217
278

Chapter 13 Strings

escape sequances >7.3

Escape Sequences in String Literals

String literals may contain the same escape sequences as character constants.
We've used character escapes in printf and scanf format strings for some
time. For example, we've seen that each \n character in the string

"Candy\nIs dandy\nBut liquor\nIs quicker.\n --Ogden Nash\n"
causes the cursor to advance to the next line:

Candy

1s dandy

But liquor

Is quicker.
--Cgden Nagh

Although octal and hexadecimal escapes are also legal in string literals, they're not
as common as character escapes.

Be careful when using octal and hexadecimal escape sequences in string literals.
An octal escape ends after three digits or with the first non-octal character. For
example, the string "\1234" contains two characters (\123 and 4), and the
string "\ 189" contains three characters (\ 1, &, and 9). A hexadecimal escape, on
the other hand, isn’t limited to three digits; it doesn’t end until the first non-hex
character. Consider what happens if a string contains the escape \xfc, which rep-
resents the character i in the Latin] character sel, a common extension of ASCIL.
The string "Z\xfcrich" (“Ziirich”) has six characters (2, \xfe, z, i, c, and
h), but the string " \xfcber" (a failed attempt at “iiber”) has only two (\xfcbe
and x). Most compilers will object to the latter string, since hex escapes are usually
limited to the range \x0-\xfff.

Continuing a String Literal

If we find that a string literal is too long to fit conveniently on a single line, C
allows us to continue it on the next line, provided that we end the first line with a
backslash character (\). No other characters may follow \ on the same line, other
than the (invisible) new-line character at the cnd:

printf ("When you come to a fork in the road, take it. \
--Yogi Berra");

In general, the \ character can be used to join two or more lines of a program into
a single line (a process that the C standard refers to as “splicing”). We'll see more
examples of splicing in Section 14.3.

The \ technique has one drawback: the string must continue at the beginning
of the next line, thereby wrecking the program’s indented structure. There's a bet-
ter way to deal with long string literals, thanks to the following rule: when two or
more string literals are adjacent (separated only by white space), the compiler will
13.1 String Literals 279

join them into a single string. This rule allows us to split a string literal over two or
more lines:

printf ("when you come to a fork in the road, take it. "
"--Yogi Berra");

How String Literals Are Stored

We've used string literals often in calls of printf and scant. But when we call
printf and supply a string literal as an argument, what are we actually passing?
To answer this question, we need to know how string literals are stored.

In essence, C treats string literals as character arrays. When a C compiler
encounters a string literal of length » in a program, it sets aside n + 1 bytes of
memory for the string. This area of memory will contain the characters in the
string, plus one extra character—the null character—to mark the end of the string.
The null character is a byte whose bits are all zero, so it's represented by the \ 0
escape sequence.

Don’t confuse the null character (' \0 ') with the zero character (' 0'). The null
character has the code 0; the zero character has a different code (48 in ASCII).

For example, the string literal "abc" is stored as an array of four characters

(a, b, c, and \0):
‘ \o |

String literals may be empty: the string " " is stored as a single null character:

0

Since a string literal is stored as an array, the compiler treats it as a pointer of
type char *. Both printf and scanf, for example, expect a value of type
char * as their first argument. Consider the following example:

printf ("abc") ;

When printf is called, it’s passed the address of "abc" (a pointer to where the
letter a is stored in memory).

Operations on String Literals

In general, we can use a string literal wherever C allows a char * pointer. For
example, a string literal can appear on the right side of an assignment:
280

Chapter 13 Strings

QsA

char *p;
p = "abcr;

This assignment doesn’t copy the characters in "abc"; it merely makes p point to
the first character of the string.
C allows pointers to he subscripted, so we can subscript string literals:

char ch;
eh = ‘"abch[1] ;

The new value of ch will be the letter b. The other possible subscripts are 0 (which
would select the letter a), 2 (the letler c), and 3 (the null character). This property
of string literals isn’t used that much, but occasionally it’s handy. Consider the fol-
lowing function, which converts a number between 0 and 15 into a character that
represents the equivalent hex digit:

char digit to_hex char(int digit)

return "0123456789ABCDEF" [digit] ;

Attempting to modify a string literal causes undefined behavior:
char *p = "abc";
*p = 'd'; /*4% WRONG *#%/

A program that tries to change a string literal may crash or behave erratically.

String Literals versus Character Constants

A string literal containing a single character isn’t the same as a character constant,
The string literal "a" is represented by a pointer to a memory location that con-
tains the character a (followed by a null character). The character constant 'a ' is
represented by an integer (the numerical code for the character).

Don’t ever use a character when a string is required (or vice versa). The call
printf ("\n") ;

is legal, because printf expects a pointer as its first argument. The following
call isn’t legal, however:

printf ('\n'); /*** WRONG ***/

13.2

idiom

13.2 String Variables 281

String Variables

Some programming languages provide a special string type for declaring string
variables. C takes a different tack: any one-dimensional array of characters can be
used (o store a string, with the understanding that the string is terminated by a null
character. This approach is simple. but has significant difficulties. It's sometimes
hard to tell whether an array of characters is being used as a string. If we write our
own string-handling functions, we've got to be careful that they deal properly with
the null character. Also, there'’s no [aster way to determine the length of a string
than a character-by-character search for the null character.

Let’s say that we need a variable capable of storing a string of up to 80 charac-
ters. Since the string will need a null character at the end, we’ll declare the variable
1o be an array of 81 characters:

4define STR LEN 80
char str[STR_LEN+1] ;

We defined STR_LEN to be 80 rather than 81, thus emphasizing the fact that st
can store strings of no more than 80 characters, and then added 1 to STR_LEN in
the declaration of st r. This a common practice among C programmers.

When declaring an array of characters that will be used to hold a string, always
make the array one character longer than the string, because of the C convention
that every string is terminated by a null character. Failing to leave room for the null
character may cause unpredictable results when the program is executed, since
functions in the C library assume that strings are null-terminated.

Declaring a character array to have length STR_LEN + | doesn’t mean that it
will always contain a string of STR_LEN characters. The length of a string
depends on the position of the terminating null character, not on the length of the
array in which the string is stored. An array of STR_LEN + | characters can hold
strings of various lengths, ranging from the empty string to strings of length
STR_LEN.

Initializing a String Variable
A string variable can be initialized at the same time it’s declared:

char datel[8] = "June 14";
282

Chapter 13 Strings

array inftiaizers > 8.1

The compiler will put the characters from "June 14" in the datel array, then
add a null character so that datel can be used as a string, Here's what datel
will look like:

d:\Lel! T ‘ u|n|e 1 4 |\o

Although "June 14" appears to be a string literal, it's not. Instead, C views it as
an abbreviation for an array initializer. In fact, we could have written

char datel[g] = {'J', 'u', 'm', ‘fe', ' L, *1', 141, \O'};

I'think you’ll agree that the original version is easier to read.
What if the initializer is too short to fill the string variable? In that case, the
compiler adds extra null characters. Thus, after the declaration

char date2[9] = "June 14";

date2 will have the following appearance:

datezlJ an e 24 \u‘\u

This behavior is consistent with C’s treatment of array initializers in general. When
an array initializer is shorter than the array itself, the remaining elements are ini-
tialized to zero. By initializing the leftover elements of a character array to \ 0, the
compiler is following the same rule.

What if the initializer is longer than the string variable? That's illegal for
strings, just as it’s illegal for other arrays. However, C does allow the initializer
(not counting the null character) to have exactly the same length as the variable;

char date3[7] = "June 14";

There’s no room for the null character, so the compiler makes no attempt to store
one:

dated | d | u | n

1f you're planning fo initialize a character array to contain a string, be sure that the
length of the array is longer than the length of the initializer. Otherwise, the com-
piler will quietly omit the null character, making the array unusable as a string.

The declaration of a string variable may omit its length, in which case the
compiler computes it:

char date4[] = "June 14";
dynamically allocated strings »17.2

13.2 String Variables ~ 283

The compiler sets aside eight characters for date4, enough to store the characters
in "June 14" plus a null character. (The fact that the length of date4 isn’t spec-
ified doesn’t mean that the array’s length can be changed later. Once the program
is compiled, the length of date4 is fixed at eight.) Omitting the length of a string
variable is especially useful if the initializer is long, since computing the length by
hand is error-prone.

Character Arrays versus Character Pointers
Let's compare the declaration

char date[] = "June 14";

which declares date to be an array, with the similar-looking
char *date = "June 14";

which declares date to be a pointer. Thanks to the close relationship between
arrays and pointers, we can use either version of date as a stiing. In particular,
any function expecting to be passed a character arvay or character pointer will
accept either version of date as an argument.

However, we must be careful not to make the mistake of thinking that the two
versions of date are interchangeable. There are significant differences between
the two:

u In the array version, the characters stored in date can be modified, like the
elements of any array. In the pointer version, date points to a string literal,
and we saw in Section 13.1 that string literals shouldn’t be modified.

= In the array version, date is an array name. In the pointer version, date isa
variable that can be made to point to other strings during program execution.
If we need a string that can be modified, it's our responsibility to set up an
array of characters in which to store the string: declaring a pointer variable isn't
enough. The declaration

char *p;

causes the compiler to set aside enough memory for a pointer variable; unfortu-
nately. it doesn’t allocate space for a string. (And how could it? We haven’t indi-
cated how long the string would be.) Before we can use p as a string, it must point
to an array of characters. One possibility is to make p point to a string variablc:
char str[STR_LEN+1], *p;

P = str;

p now points to the first character of str. so we can use p as a string. Another
possibility is to make p point to a dynamically allocated string.
284

Chapter 13  Strings

A

133

Using an uninitialized pointer variable as a string is a serious error. Consider the
following example, which attempts to build the string "abc":

char *p;

plol = 'a'; J%%% WRONG #h%/
Pl =ihts /***x WRONG **%/
210 S ley, /*** WRONG *#%/
P31 =" INor ST kS R TRONG Sxa e/

Since p hasn’t heen initialized, we don’t know where it’s pointing. Using the
pointer to write the characters a, b, c, and \0 into memory causes undefined
behavior.

Reading and Writing Strings

Writing a string is easy using either the printf or puts functions. Reading a
string is a bit harder, primarily because of the possibility that the input string may
be longer than the string variable into which it’s being stored. To read a string in a
single step, we can use either scanf or gets. As an alternative, we can read
strings one character at a time.

Weriting Strings Using printf and puts

The %s conversion specification allows printf to write a string. Consider the
following example:

char str[] = "Are we having fun yet?";
printf ("$s\n", str);

The output will be

Are we having fun yet?

printf writes the characters in a string one hy one until it encounters a null char-
acter. (If the null character is missing, printf continues past the end of the string
until—eventually—it finds a null character somewhere in memory.)

To print just part of a string, we can use the conversion specification % .ps,
where p is the number of characters to be displayed. The statement

printf ("%.6s\n", str);
will print

Are we
white-space characters »3.2

13.3 Reading and Writing Strings 285

A string, like a number, can be printed within a field. The $ms conversion will
display a string in a field of size m. (A string with more than m characters will be
printed in full, not truncated.) If the string has fewer than m characters, it will be
right-justified within the field. To force left justification instead, we can put a
minus sign in front of m. The m and p values can be used in combination: a conver-
sion specification of the form % . ps causes the first p characters of a string to be
displayed in a field of size m.

printf isn’t the only function that can write strings. The C library also pro-
vides puts, which is used in the following way:

puts (str) ;

puts has only one argument (the string to be printed). After writing the string,
puts always writes an additional new-line character, thus advancing to the begin-
ning of the next output line.

Reading Strings Using scanf and gets

The %s conversion specification allows scanf to read a string into a character
array:

gcanf ("¥s", str);

There's no need to put the & operator in front of st in the call of scanf: like any
array name, st is treated as a pointer when passed to a function.

When scanf is called, it skips white space, then reads characters and stores
them in stz until it encounters a white-space character. scanf always stores a
null character at the end of the string.

A string read using scanf will never contain white space. Consequently,
scanf won’t usually read a full line of input; a new-line character will cause
scanf to stop reading, but so will a space or tab character. To read an entire line
of input at a time, we can use gets. Like scanf, the gets function reads input
characters into an array, then stores a null character. In other respects, however,
gets is somewhat different from scanf:

m gets doesn't skip white space before starting to read the string (scanf
does).

= gets reads until it finds a new-line character (scanf stops at any white-
space character). Incidentally, gets discards the new-line character instead of
storing it in the array: the null character takes its place.

To see the difference between scanf and gets, consider the following pro-
gram fragment:

char sentence [SENT LEN+1];

printf ("Enter a sentence:\n");
scanf ("%s", sentence);
286

Chapter 13  Strings

A

LyeLs lunclion »22.5

Suppose that after the prompt
Enter a sentence:
the user enters the line
To C, or not to C: that is the guestion.

scanf will store the string "To" in sentence. The next call of scanf will
resume reading the line at the space after the word To.
Now suppose that we replace scanf by gets:

gete (sentence) ;
When the user enters the same input as before, gets will store the string
" To C, or not to C: that is the question."

in sentence.

As they read characters into an array, scanf and gets have no way to detect
when it’s full. Consequently, they may store characters past the end of the array,
causing undefined behavior. scanf can be made safer by using the conversion
specification %ns instead of %s, where n is an integer indicating the maximum
number of characters to be stored. gets, unfortunately, is inherently unsafe:
fgets is a much better alternative,

Reading Strings Character by Character

Since both scanf and gets are risky and insufficiently flexible for many appli-
cations, C programmers often write their own input functions, By reading strings
one character at a time, these functions provide a greater degree of control than the
standard input functions,

If we decide to design our own input function, we'll need to consider the fol-
lowing issues:

= Should the function skip white space before beginning to store the string?

= What character causes the function to stop reading: a new-line character, any
white-space character, or some other character? Is this character stored in the
string or discarded?

= What should the function do if the input string is too long to store: discard the
extra characters or leave them for the next input operation?

Suppose we need a function that doesn’t skip white-space characters, stops
reading at the first new-line character (which isn't stored in the string), and dis-
cards extra characters. The function might have the following prototype:

int read line(char str(], int n);
getchar function >7.3

QaA

13.4

13.4 Accessing the Characters in a String 287

str represents the array into which we’ll store the input, and n is the maximum
number of characters to be read. If the input line contains more than n characters,
read line will discard the additional characters. We'll have read line
return the number of characters it actually stores in stx (a number anywhere from
0 to n). We may not always need read line’s return value, but it doesn’t hurt to
have it available.

read_line consists primarily of a loop that calls getchar to read a char-
acter and then stores the character in str, provided that there’s room left. The loop
terminates when the new-line character is read. (Strictly speaking, we should also
have the loop terminate if getchar should fail to read a character, but we’ll
ignore that complication for now.) Here's the complete definition of read line:

int read line(char str[], int n)
int ch, i = 0;

while ((ch = getchar()) != '\n')
iE (. € m)
strli++] = ch;
strli] = '\o'; /* terminates string */
return i; /* number of characters stored */

/

Note that ch has int type rather than chax type, because getchar returns the
character that it rcads as an int value.

Before returning, read line puts a null character at the end of the string.
Standard functions such as scanf and gets automatically put a null character at
the end of an input string; if we're writing our own input function, however, we
must take on that responsibility.

Accessing the Characters in a String

Since strings are stored as arrays, we can use subscripting to access the characters
in a string. To process every character in a string s, for example, we can set up a
loop that increments a counter i and selects characters via the expression s [1].

Suppose that we need a function that counts the number of spaces in a string.
Using array subscripting, we might write the function in the following way:

int count spaces(const char s[])

{

int count = 0, i;

for (i = s[i] = '\0'; i++)
T Efd] ==y )
count++;
return count;
288

Chapter 13  Strings

I've included const in the declaration of s to indicate that count_spaces
doesn’t change the array that s represents. If s were not a string, the function
would need a second argument specifying the length of the array. Since s is a
string, however, count_spaces can determine where it ends by testing for the
null character.

Many C programmers wouldn't write count_spaces as we have. Instead,
they’d use a pointer to keep track of the current position within the string. As we
saw in Section 12.2. this technique is always available for processing arrays, but it
proves to be especially convenient for working with strings.

Let’s rewrite the count_spaces function using pointer arithmetic instead
of array subscripting. We’ll eliminate the variable 1 and use s itself to keep track
of our position in the string. By incrementing s repeatedly, count_spaces can
step through each character in the string. Here’s our new version of the function:

int count_spaces (const char *s)

{

int count = 0;

for (; *a
S (X
count++;
return count;

}

Note that const doesn’t prevent count_spaces from modifying s: it’s there to
prevent the function from modifying what s points to. And since s is a copy of the
pointer that’s passed to count_spaces, incrementing s doesn’t affect the origi-
nal pointer.

The count_spaces example raises some questions about how to write
string functions:

u [s it better to use array operations or pointer operations to access the char-
acters in a string? We're free to use whichever is more convenient; we can
even mix the two. In the second version of count_spaces, treating s as a
pointer simplifies the function slightly by remaving the need for the variable
i. Traditionally, C programmers lean toward using pointer operations for pro-
cessing strings.

u Should a string parameter be declared as an array or as a pointer? The two
versions of count spaces illustrate the options: the first version declares s
to be an array; the second declares s to be a pointer. Actually, there’s no dif-
ference between the two declarations—recall from Section 12.3 that the com-
piler treats an array parameter as though it had been declared as a pointer.

u Does the form of the parameter (s [1 or *s) affect what can be supplied as
an argument? No. When count_spaces is called, the argument could he
an array name, a pointer variable, or a string literal—count _spaces can't
tell the difference.
13.5

<string.h- header » 226

13.5 Using the C String Library =~ 289

Using the C String Library

Some programming languages provide operators that can copy strings, compare
strings, concatenate strings, select substrings, and the like. C's operators, in con-
trast, are essentially useless for working with strings. Strings are treated as arrays
in C. so theyre restricted in the same ways as arrays—in particular, they can’t be
copied or compared using operators.

Direct attempts to copy or compare strings will fail. For example, suppose that
strl and str2 have been declared as follows:

char stri[10], str2[10];
Copying a string into a character array using the = operator is not possible:

strl = "abct; /kkk WRONG *x*/
8tr2 = strl; /*** WRONG ***/

We saw in Section 12.3 that using an array name as the left operand of = is illegal.
Initializing a character array using = is legal, though:

char strl[10] = "abe";

In the context of a declaration, = is not the assignment operator.
Attempting to compare strings using a relational or equality operator is legal
but won’t produce the desired result:

if (stri 8tx2) .. /*** WRONG xx**/

This statement compares stx1 and stx2 as pointers: it doesn’t compare the con-
tents of the two arrays. Since strl and str2 have different addresses, the
expression strl == str2 must have the value 0.

Fortunately, all is not lost: the € library provides a rich set of functions for
performing operations on strings. Prototypes for these functions reside in the
<string.h> header, so programs that need string operations should contain the
following line:

#include <string.h>

Most of the functions declared in <string.h> require at least one string as
an argument. String parameters are declared to have type char *, allowing the
argument 1o be a character array, a variable of type char *, or a string literal—all
are suitable as strings. Watch out for string parameters that aren’t declared const,
however. Such a parameter may be modified when the function is called, so the
corresponding argument shouldn’t be a string literal.
290

Chapter 13  Strings

A

strncpy lunction »23.6

There are many functions in <string.hs; I'll cover a few of the most basic.
In subsequent examples, assume that stx1 and str2 are character arrays used as
strings.

The strcpy (String Copy) Function
The strcpy function has the following prototype in <string.h>:
char *strcpy(char *sl, const char *g2);

strcpy copies the string s2 into the string s1. (To be precise, we should say
“strcpy copies the string pointed to by s2 into the array pointed to by s1.7)
That is, strcpy copies characters from s2 to s1 up to (and including) the first
null character in s2. strcpy returns s1 (a pointer to the destination string). The
string pointed to by s2 isn’t modified, so it’s declared const.

The existence of strcpy compensates for the fact that we can’t use the
assignment operator to copy strings. For example, suppose that we want to store
the string "abed" in str2. We can’t use the assignment

str2 = "abcd"; /***x WRONG ***/

because str2 is an array name and can’t appear on the left side of an assignment.
Instead, we can call strcpy:

strepy(str2, "abcd"); /* str2 now contains "abcd" */
Similarly, we can’t assign str2 to str1 directly, but we can call strcpy:
strcpy(strl, str2); /* strl now contains "abcd" */

Most of the time, we'll discard the value that strcpy returns. On occasion,
though, it can be uscful to call strcpy as part of a larger expression in order to
use its return value. For example, we could chain together a series of sLrcpy
calls:

strepy(strl, strcpy(str2, "abed"));
/* both strl and str2 now contain "abed" */

In the call strepy (strl, str2), strcpy has no way to check that the string
pointed to by str2 will actually fit in the array pointed to by str1. Suppose that
strl points to an array of length n. If the string that str2 points to has no more
than n — 1 characters, then the copy will succeed. But if stx2 points to a longer
string, undefined behavior occurs. (Since strepy always copies up to the first null
character, it will continue copying past the end of the array that stx1 points to.)

Calling the strncpy function is a safer, albeit slower, way to copy a string.
strncpy is similar to st repy but has a third argument that limits the number of
characters that will be copied. To copy str2 into strl, we could use the follow-
ing call of st rncpy:
size_t ypo > 76

13.5 Using the C String Library ~ 291

strncpy(strl, str2, sizeof (strl));

As long as str1 is large enough to hold the string stored in str2 (including the
null character), the copy will be done correctly. st rncpy itself isn’t without dan-
ger, though. For one thing, it will leave the string in strl without a terminating
null character if the length of the string stored in str2 is greater than or equal to
the size of the str1 array. Here's a safer way to use strncpy:

strncpy (strl, str2, sizeof (strl) - 1);
stril [sizeof (strl)-1] = '\0';

The second statement guarantees that strl is always null-terminated, even if
strnepy fails to copy a null character from stx2.

The strlen (String Length) Function
The strlen function has the following prototype:
size t strlen(ccnst char *s);

siz

. which is defined in the C library, is a typedef name that represents
one of C’s unsigned integer types. Unless we're dealing with extremely long
strings, this technicality need not concern us—we can simply treat the return value
of strlen as an integer.

strlen returns the length of a string s: the number of characters in s up to,
but not including, the first null character. Here are a few examples:

int len;

len = strlen("abe'); /* len is now 3 */
len ‘= stxlen("") /* len is now 0 */
strepy(strl, "abc");

len = strlen(strl); /* len is now 3 */

The last example illustrates an important point. When given an array as its argu-
ment, strlen doesn’t measure the length of the array itself; instead, it returns the
length of the string stored in the array.

The strecat (String Concatenation) Function
The strcat function has the following prototype:
char *strcat(char *sl, const char *s2);

strcat appends the contents of the string s2 to the end of the string s1: it
returns s1 (a pointer to the resulting string).
Here are some examples of strcat in action:

strepy(strl, "abe");
strcat (stxl, "def"); /* strl now contains "abcdef" %/
292

Chapter 13 Strings

strrcat functon »23.6

QzA

strepy(strl, "abc");
strcpy(str2, "def");
streat (strl, str2); /* strl now contains "abcdef" */

As with strepy, the value returned by strcat is normally discarded. The
following example shows how the return value might be used:

strcpy (strl, 'abe");
strepy(str2, "def');
strcat(strl, strecat (str2, "ghi"));
/* strl now contains "abcdefghi"; stx2 contains "defghi" */

The effect of the call streat (strl, str2) is undefined if the array pointed to
by str1 isn't long enough to accommodate the additional characters from stzr2.
Consider the following example:

char stri[6] = "abc";
strcat (strl, "def"); /*** WRONG #***/

strcat will attempt to add the characters d, e, f, and \ 0 to the end of the string
already stored in str1. Unfortunately, strl is limited to six characters. causing
strcat to write past the end of the array.

The strncat function is a safer but slower version of strcat. Like
strncpy, it has a third argument that limits the number of characters it will copy.
Here’s what a call might look like:

strncat (strl, str2, sizeof(strl) - strlen(strl) - 1);

strncat will terminate str1 with a null character, which isn’t included in the
third argument (the number of characters to be copied). In the example, the third
argument calculates the amount of space remaining in str1 (given by the expres-
sion sizeof (strl) - strlen(strl)) and then subtracts 1 to ensure that
there will be room for the null character.

The strcmp (String Comparison) Function
The strcmp function has the following prototype:
int stremp(const char *sl, const char *s2);

stremp compares the strings s1 and s2, returning a value less than, egual to, or
greater than 0, depending on whether s1 is less than, equal to, or greater than s2.
For example, to see if str1 is less than str2, we'd write

if (strecmp(strl, str2) < 0) /* is strl < str2? */
ASCIl characer sel > Apgendix f

PROGRAM

13.5 Using the C String Library ~ 293

To test whether strl is less than or equal to str2, we'd write

if (stremp(strl, str2) <= 0) /* is strl <= str2? */

By choosing the proper relational operator (<, <=, >, >=) or equality operator (=
1=), we can Lest any possible relationship between strl and str2.

stremp compares strings based on their lexicographic ordering, which re-
sembles the way words are arranged in a dictionary. More precisely, strcmp con-
siders s1 to be less than s2 if either one of the following conditions is satisfied:

m The first i characters of s1 and s2 match, but the (i+1)st character of s1 is
less than the (7+1)st character of s2. For example, "abc" is less than "bed",
and "abd" is less than "abe".

m All characters of 531 match s2, but s1 is shorter than s2. For example,
"abe! is less than "abed".

As it compares characters from two strings, stremp lovks at the numerical
codes that represent the characters. Some knowledge of the underlying character
set is helpful in order to predict what st remp will do. For example, here are a few
important properties of the ASCII character set:

m The characters in each of the sequences A-Z, a—z, and 0-9 have consecutive
codes.

= All upper-case letters are less than all lower-case letters. (In ASCII, codes
between 65 and 90 represent upper-case letters; codes between 97 and 122
represent lower-case letters.)

= Digits are less than letters. (Codes between 48 and 57 represent digits.)

m Spaces are less than all printing characters. (The space character has the value
32in ASCIL)

Printing 2 One-Month Reminder List

To illustrate the use of the C string library, we’ll now develop a program that prints
a one-month list of daily reminders. The user will enter a series of reminders, with
each prefixed by a day of the month. When the user enters 0 instead of a valid day.
the program will print a list of all reminders entered, sorted by day. Here's what a
session with the program will look like:

Enter day and reminder: 24 Susan's birthday
Enter day and reminder: 5 6:00 - Dinner with Marge and Russ

Enter day and reminder: 26 Movie - "Chinatown'
Enter day and reminder: 7 10:30 - Dental appointment
Enter day and reminder: 12 Movie - "Dazed and Confused”

Enter day and reminder: 5 Saturday class
Enter day and reminder: 12 Saturday class

Enter day and reminder: 0
294

Chapter 13 Strings

sprintf function »22.6

remind.c

Day Reminder
5 Saturday class
5 6:00 - Dinner with Marge and Russ
7 10:30 - Dental appointment

12 Saturday class

12 Movie - "Dazed and Confused"
24 Susan's birthday
26 Movie - "Chinatown"

The overall strategy isn’t very complicated: we'll have the program read a
series of day-and-reminder combinations, storing them in order (sorted by day),
and then display them. To read the days, we'll use scanf; to read the reminders,
we'll use the read_1ine function of Section 13.3.

‘We'll store the strings in a two-dimensional array of characters, with each row
of the array containing one string. After the program reads a day and its associated
reminder, it will search the array to determine where the day belongs. using
strcemp to do comparisons. It will then use strepy to move all strings below
that point down one position. Finally, the program will copy the day into the array
and call strcat to append the reminder to the day. (The day and the reminder
have been kept separate up to this point.).

Of course, there are always a few minor complications, For example, we want
the days to be right-justified in a two-character field, so that their ones digits will
line up. There are many ways to handle the problem. I've chosen to have the pro-
gram use scant to read the day into an integer variable, then call sprintf to
convert the day back into string form. sprintf is a library function that’s similar
to printf, except that it writes output into a string. The call

sprintf (day_str, "$2d", day);

writes the value of day into day_str. Since sprint f automatically adds a null
character when it’s through writing, day str will contain a properly null-termi-
nated string.

Another complication is making sure that the user doesn’t enter more than two
digits. We'll use the following call of scant for this purpose:

scanf ("$2d", &day):

The number 2 between % and d tells scanf to stop reading after two digits, even
if the input has more digits.
With those details out of the way, here’s the program:

/* Prints a one-month reminder list */

#include <stdio.h>
#include estring.hs

#define MAX REMIND 50 /* maximum number of reminders */
#detine MSG_LEN 60 /* max length of reminder message */
13.5 Using the C String Library ~ 295

int read_line(char str[l, int m);

int wain(void)

char reminders [MAX_REMIND] [MSG_LEN+3] ;
char day str(3], msg_str[MSG LEN+1] ;
int day, i, j, num _remind = 0;

For (7 H) {
if (num remind == MAX REMIND) {
printf (M-~ No space Isft -=\n");
break;

}

printf ("Enter day and reminder: ");
scanf ("t2d", &day);
if (day == 0)
break;
sprintf (day_stxr, "%2d", day):
read line(msg_str, MSG_LEN);

for (1 = 0; i < num remind; i++)
if (strcmp(day_str, reminders([i]) < 0)
break;
for (j = num remind; 1 > i; j--)
strcpy (reminders [j], reminders([j-1]);

strepy (reminders (i), day str);
strcat (reminders(i], msg_strx);

num_remind-+;
)

printf (*\nDay Remindsr\n");
for (i = 0; i < num remind; i++)
printf (" %s\n", reminders[i]);

return 0;

}

int read line(char str[], int m)

int ch, i = 0;

while ((ch = getchar()) t= *\n')
1ot m)
str(i++] = ch;
stoii] = \oFy
return i;

Although remind. c is useful for demonstrating the strcpy, strcat, and
stremp functions, it lacks something as a practical reminder program. There are
296

Chapter 13 Strings

13.6

obviously a number of improvements needed, ranging from minor tweaks to major
enhancements (such as saving the reminders in a file when the program termi-
nates). We'll discuss several improvements in the programming projects at the end
of this chapter and in later chapters.

String Idioms

Functions that manipulate strings are a particularly rich source of idioms. In this
section, we'll explore some of the most famous idioms by using them to write the
strlen and strcat functions. You'll never have to write these functions, of
course, since they're part of the standard library, but you may have to write func-
tions that are similar.

The concise style I'l] use in this section is popular with many C programmers.
You should master this style even if you don’t plan to use it in your own programs,
since you're likely to encounter it in code written by others.

One last note before we get started. If you want to try out any of the versions
of strlen and streat in this section, be sure to alter the name of the function
(changing strlen to my strlen, for example). As Section 21.1 explains,
we e not allowed to write a function that has the same name as a standard library
function, even when we don't include the header to which the function belongs. In
fact, all names that begin with stxr and a lower-case letter are reserved (to allow
functions to be added to the <string.h> header in future versions of the C stan-
dard).

Searching for the End of a String

Many string operations require searching for the end of a string. The strlen
function is a prime example. The following version of stx1len searches its string
argument to find the end. using a variable to keep track of the string’s length:

size t strlen(const char *s)

(

size t n;

for (n = 0; *s != '"\0'; s++)
4+
return n;

As the pointer s moves across the string from left to right, the variable n keeps
track of how many characters have been seen so far. When s finally points to a null
character, nn contains the length of the string.

Let’s see if we can condense the function. First, we'll move the initialization
of n to its declaration:
13.6 String Idioms 297

size_t strlen(const char *s)

for (; i os++)
ntt;
return n;
Next, we notice that the condition *g != '\0' is the same as *s | = 0, because

the integer value of the null character is 0. But testing *s 1= 0 is the same as test-
ing *s; both are true if *s isn’t equal to 0. These observations lead to our next ver-
sion of strlen:

size_t strlen(const char *s)

size t n = 0;

for, (i; *si s#+)
nii;
return n;

But, as we saw in Section 12.2, it’s possible to increment s and test *s in the same
expression;

size_t strlen(const char *s)
size t n = 0;
for (; *s++;)

N4+
return n;

}

Replacing the `for` statement with a `while` statement, we arrive at the following
version of strlen:

size t strlen(conct char *s)

{

size it n =

while (¥*s++)
n4+;
return n;

}

Although we've condensed st rlen quite a bit, it’s likely that we haven’t in-
creased its speed. Here’s a version that does run faster, at least with some compilers:

size t strlen(const char *s)

const char *p = s}
298 Chapter 13 Strings

while (*s)
S4+7
return s - p;

This version of st rlen computes the length of the string by locating the position
of the null character, then subtracting from it the position of the first character in
the string. The improvement in speed comes from not having to increment n inside
the `while` loop. Note the appearance of the word const in the declaration of p,
by the way; without it, the compiler would notice that assigning s to p places the
string that s points to at risk.

The statement

idiom while (*s)
S++;

and the related

idiom while (*s++)

are idioms meaning “search for the null character at the end of a string.” The first
version leaves s pointing to the null character. The second version is more concise,
but leaves s pointing just past the null character.

Copying a String

Copying a string is another common operation. To introduce C’s “string copy”
idiom, we'll develop two versions of the strcat function. Let's start with a
straightforward but somewhat lengthy version:

char *strcat (char *s1, const char *s2)

{

char *p = s1;

while (*p != '\0')
P+i

while (*s2 != '\0') {
*p = *82;
DH+;
S2+4;

*p = 1\0';

return s1;

)

This version of strcat uses a two-step algorithm: (1) Locate the null character at
the end of the string s1 and make p point to it. (2) Copy characters one by one
from s2 to where p is pointing

The first `while` statement in the function implements step (1). p is set to
point to the first character in the s1 string. Assuming that s1 points to the string
"abc", we have the following picture:
13.6 String Idioms 299

p is then incremented as long as it doesn’t point to a null character. When the loop
terminates, p must be pointing to the null character:

The second `while` statement implements step (2). The loop body copies one
character from where s2 points to where p points, then increments both p and s2.
If s2 originally points to the string "def", here’s what the strings will look like

after the first loop iteration:
82 I I

sl| 1

| f [\o
-0

v

2 \o

After putting a null character where p is pointing, strcat returns.
By a process similar to the one we used for strlen. we can condense the
definition of strcat, arriving at the following version:

char *strcat (char *sl, const char *s2)

{

char *p = s8l;

while (*p)
Dt
while (*p++ = *s2+4+)

return sl;
300

Chapter 13 Strings

idiom

13.7

The heart of our streamlined strcat function is the “string copy” idiom:

while (*p++ = *s2++)

If we ignore the two ++ operators, the expression inside the parentheses simplifies
to an ordinary assignment:

*p = *s2

This expression copies a character from where s2 points to where p points. After
the assignment, both p and s2 are incremented, thanks to the ++ operators.
Repeatedly executing this expression has the effect of copying a series of charac-
ters from where s2 points (o where p points.

But what causes the loop to terminate? Since the primary operator inside the
parentheses is assignment, the `while` statement tests the valuc of the assign-
ment—the character that was copied. All characters except the null character test
true, so the loop won’t terminate until the null character has been copied. And
since the loop terminates affer the assignment, we don’t need a separate statement
to put a null character at the end of the new string.

Arrays of Strings

Let’s now turn to a question that we'll often encounter: what's the best way to store
an array of strings? The obvious solution is to create a two-dimensional array of
characters, then store the strings in the array, one per row. Consider the following
example:

char planets(] [8] = {"Mercury", "Venus", "Earth",
"Mars", "Jupiter®, "Saturn
"Uranus", "Neptune', "Pluto"};

(In 2006, the International Astronomical Union demoted Pluto from “planet” to
“dwarf planet,” but I've left it in the planets array for old times’ sake.) Note that
we're allowed to omit the number of rows in the planets array—since that’s
obvious from the number of elements in the initializer—but C requires that we
specify the number of columns.

The figure at the top of the next page shows what the planets array will
look like. Not all our strings were long enough to fill an entire row of the array, so
C padded them with null characters. There’s a bit of wasted space in this array,
since only three planets have names long enough (v reyuire eight characters
(including the terminating null character). The remind. c program (Section 13.5)
is a glaring example of this kind of waste. It stores reminders in rows of a two-
dimensional character array, with 60 characters set aside for each reminder. In our
example, the reminders ranged from 18 to 37 characters in length, so the amount of
wasted space was considerable.
13.7 Arrays of Strings 301

The inefficiency that’s apparent in these examples is common when working
with strings, since most collections of strings will have a mixture of long strings
and short strings. What we need is a ragged array: a two-dimensional array whose
rows can have different lengths, C doesn’t provide a “ragged array type,” but it
does give us the tools to simulate one. The secrel is Lo creale an array whose ele-
ments are pointers to strings.

Here's the planets array again, this time as an array of pointers to strings:

char =planets[] = {"Mercury", "Venus", "Earth",
“Mars", "Jupiter", "Saturn",
"Uranus", "Neptune", "Pluto"};

Not much of a change, eh? We simply removed one pair of brackets and put an aster-
isk in frontof planets. The effect on how planets is stored is dramatic, though:

planets

Bach element of planets is a pointer to a null-terminated string. There are no
longer any wasted characters in the strings, although we’ve had to allocate space
for the pointers in the planets array.

To access one of the planet names, all we need do is subscript the planets
array. Because of the relationship between pointers and arrays, accessing a charac-
ter in a planet name is done in the same way as accessing an element of a two-
302

Chapter 13  Strings

null pointers > 17.1

dimensional array. To search the planets array for strings beginning with the
letter M, for example, we could use the following loop:

for (i =/0; i < 9; duw)
if (planets([i] [0] == f)
printf ("js begins with M\n', planets[i]);

Command-Line Arguments

When we run a program, we’ll often need to supply it with information—a file
name, perhaps, or a switch that modifies the program’s behavior. Consider the
UNIX 1s command. If we run 1s by typing

1s

at the command line, it will display the names of the files in the current directory.
But if we instead type

1s -1

then Ls will display a “long” (detailed) listing of files, showing the size of each file,
the file’s owner, the date and time the file was last modified, and so forth. To modify
the behavior of 1s further, we can specify that it show details for just one file:

1s -1 remind.c

1s will display detailed information about the file named remind. c.

Command-line information is available to all programs, not just operating sys-
tem commands. To obtain access to these command-line arguments (called pro-
gram parameters in the C standard), we must define main as a function with two
parameters, which are customarily named arge and argv:

i'nt main(int arge, char *argv[])
}
arge (“argument count") is the number of command-line arguments (including
the name of the program itself). argv (“argument vector”) is an array of pointers
to the command-line arguments, which are stored in string form. argv [0] points
to the name of the program, while argv [1] through argv [argc-1] point to
the remaining command-line arguments.

argv has one additional element, argv [argc], which is always a mull
pointer—a special pointer that points to nothing. We’ll discuss null pointers in a
later chapter; for now, all we need to know is that the macro NULL represents a null
pointer.

If the user enters the command line

1s -1 remind,c

then arge will be 3, argv[0] will point to a string containing the program
PROGRAM

13.7 Arrays of Strings 303

name, argv [1] will point to the string "-1", argv [2] will point to the string
"remind.c", and argv [3] will be a null pointer:

argv

This figure doesn’t show the program name in detail, since it may include a path or
other information that depends on the operating system. If the program name isn’t
available, argv [0] points to an empty string.

Since argv is an array of pointers, accessing command-line arguments is
easy. Typically, a program that expects command-line arguments will set up a loop
that examines each argument in turn. One way to write such a loop is to use an
integer variable as an index into the argv array. For example, the following loop
prints the command-line arguments, one per line:

JmEitsy

for (i = 1; i < argc; i++)

printf ("%s\n", argv[i]);
Another technique is to set up a pointer to argv [1], then increment the pointer
repeatedly to step through the rest of the array. Since the last element of argv is al-
ways a null pointer, the loop can terminate when it finds a null pointer in the array:

char *¥p;

for (p = &argv[l]; *p != NULL; p++)
printf("%s\n", *p);

Since p is a pointer to a pointer to a character, we've got to use it carefully. Setting
p equal to &argv[1] makes sense; argv [1] is a pointer to a character, so
&argv [1] will be a pointer to a pointer. The test *p ! = NULL is OK, since *p
and NULL are both pointers. Incrementing p looks good; p points to an array ele-
ment, so incrementing it will advance it to the next element. Printing *p is fine,
since *p points to the first character in a string.

Checking Planet Names

Our next program. planet.c, illustrates how to access command-line argu-
ments. The program is designed to check a series of strings to see which ones are
names of planets. When the program is run, the user will put the strings to be tested
on the command line:

planet Jupiter venus Earth fred
304

Chapter 13 Strings

Pplanet.c

The program will indicate whether or not each string is a planet name; if it is, the
program will also display the planet’s number (with planet 1 being the one closest
to the Sun):

Jupiter is planet 5

venus is not a planet

Earth is planet 3

fred is not a plamet

Notice that the program doesn’t recognize a string as a planet name unless its first
letter is upper-case and its remaining letters are lower-case.

/* Checks planet names */

#include <stdio.h>
#include <string.h>

#define NUM PLANETS 9

int main(int arge, char *argv[])

char splanets[] = {"Mercury", "Venus", "Earth",
"Mars", “Jupiter", "Saturn",
'Uranus", "Neptune", "Pluto"};

int 4, 47

for (i = 1; i = axge; 144 {
for (j = 0; j < NUM_PLANETS; j++)

if (strcmp(argv[i], planets[i]) == 0) {
printf("$s is planet %d\n", argv[il], j + 1);
break;

if (j == NUM_PLANETS)
printf("$s is not a planet\n", argv(il);

return 0;

The program visits each command-line argument in turn, comparing it with
the strings in the planets array until it finds a match or reaches the end of
the array. The most interesting part of the program is the call of strcmp, in
which the arguments are argv [1] (a pointer to a command-line argument) and
planets[j] (apointer to a planet name).

Q&A

How long can a string literal be?
According to the C89 standard, compilers must allow string literals to be at least
Q&A 305

509 characters long. (Yes, you read that right—509. Don’t ask.) C99 increases the
minimum to 4095 characters.

‘Why aren’t string literals called “string constants”?

Because they're not necessarily constant. Since string literals are accessed through
pointers, there’s nothing to prevent a program from attempting to modify the char-
acters in a string literal.

How do we write a string literal that represents “iiber” if " \xfcbexr" doesn’t
work? [p. 278]

The secret is to write two adjacent string literals and let the compiler join them into
one. In this example, writing "\xfc" "ber" will give us a string literal that rep-
resents the word “iiber.”

Modifying a string literal seems harmless enough. Why does it cause unde-
fined behavior? [p. 280]

Some compilers try to reduce memory requirements by storing single copies of
identical string literals. Consider the following example:

char *p = "abec", *g = "abe";

A compiler might choose to store "abe" just once, making both p and g point to
it. If we were to change "abe" through the pointer p, the string that g points to
would also be affected. Needless to say, this could lead to some annoying bugs
Another potential problem is that string literals might be stored in a “read-only"
area of memory: a program that attempts to modify such a literal will simply crash.

Should every array of characters include room for a null character?
Not necessarily, since not every array of characters is used as a string, Including
room for the null character (and actually putting one into the array) is necessary
only if you'rc planning to pass it to a function that requires a null-terminated
string.

You do not need a null character if you'll only be performing operations on
individual characters. For example, a program might have an array of characters
that it will use to translate from one character set to another:

char translaticn table[12B];

The only operation that the program will perform on this array is subscripting.
(The value of translation table [ch] will be the translated version of the
character ch.) We would not consider translation_table to be a string: it
need not contain a null character, and no string operations will be performed on it.

If printf and scanf cxpect their first argument to have type char *, does
that mean that the argument can be a string variable instead of a string lir-
eral?
306 Chapter 13  Strings

A:

#Q:

A:

EOF macro » 224

Yes, as the following example shows:

char fmt[] = "%d\n";
nk o

printf (fmt, i);

This ability opens the door to some intriguing possibilities—reading a format
string as input, for example.

If I want printf to write a string stx, can’t I just supply stz as the format
string, as in the following example?

printf (str) ;

Yes, but it’s risky. If str contains the % character, you won't get the desired result,
since printf will assume it’s the beginning of a conversion specification.

How can read line detect whether getchar has failed to read a charac-
ter? [p. 287]

If it can’t read a character, either because of an error or because of end-of-file,
getchar returns the value EOF, which has type int. Here’s a revised version of
read_line that tests whether the return value of getchar is EOF. Changes are
marked in bold:

int read line(char str[], int n)

{
Ant el F=r 0
while ((ch = getchar()) = !
18 H<in)
str[i++]
str[i] = '\o
return i;

n' && ch |= EOF)

= 'chy

Why does strcmp return a number that’s less than, equal to, or greater than
zero? Also, does the exact return value have any significance? [p. 292]
stremp’s return value probably stems from the way the function is traditionally
written. Consider the version in Kernighan and Ritchie’s The C Programming Lan-
guage:

int strcmp(char *s, char *t)

{
int o
for (i = 07 8[i] == flil; 3++)
if (s[d] \Or)
return 0;

return s[i] - t[i];
Q&A 307

The return value is the difference between the first “mismatched” characters in the
s and t strings, which will be negative if s points to a “smaller” string than t and
positive if s points to a “larger” string, There’s no guarantee that strcmp is actu-
ally written this way, though, so it’s best not to assume that the magnitude of its
return value has any particular meaning.

My compiler issues a warning when I try to compile the `while` statement in
the strcat function:

while (¥p+t = *82++)

What am I doing wrong?

Nothing. Many compilers—but not all. by any mea: issue a warning if you use
= where is normally expected. This warning is valid at least 95% of the time,
and it will save you a lot of debugging if you heed it. Unfortunately, the warning
isn’t relevant in this particular example: we actually do mean to use =, not ==. To
getrid of the warning, rewrite the whi le loop as follows:

while ((*p++ = *s244) 1= 0)

Since the `while` statement normally tests whether *p++ = *s2++ is not 0, we
haven’t changed the meaning of the statement. The warning goes away, however,
because the statement now tests a condition, not an assignment. With the GCC
compiler, putting a pair of parentheses around the assignment is another way to
avoid a warning:

while ((*p++ = *82++))

Are the strlen and strcat functions actually written as shown in Section
13.6?

Possibly, although it’s common practice for compiler vendors to write these func-
tions—and many other string functions—in assembly language instead of C. The
string functions need to be as fast as possible, since they’re used often and have to
deal with strings of arbitrary length. Writing these functions in assembly language
makes it possible to achieve great efficiency by taking advantage of any special
string-handling instructions that the CPU may provide.

Why does the C standard use the term “program parameters" instead of
‘“command-line arguments”? [p. 302]

Programs aren’t always run from a command line. In a typical graphical user inter-
face, for example, programs are launched with a mouse click. In such an environ-
ment, there's no traditional command line, although there may be other ways of
passing information to a program; the term “program parameters” leaves the door
open for these alternatives.
308 Chapter 13 Strings

dynamic storage allocation >17.1

Section 13.3 1;

O 4

isspace functon »23.5

Do I have to use the names argc and argv for main’s parameters? [p. 302]

No. Using the names argc and argv is merely a convention. not a language
requirement.

I’ve seen argv declared as * *argv instead of *argv []. Is this legal?

Certainly. When declaring a parameter, writing *a is always the same as writing
a[], regardless of the type of a’s elements.

We’ve seen how to set up an array whose elements are pointers to string liter-
als. Are there any other applications for arrays of pointers?

Yes. Although we’ve focused on arrays of pointers to character strings, that's not
the only application of arrays of pointers. We could just as easily have an array
whose elements point to any type of data, whether in array form or not. Arrays of
pointers are particularly useful in conjunction with dynamic storage allocation.

Exercises

The following function calls supposedly write a single new-line character, but some are
incorrect. Identify which calls don’t work and explain why.

(@) printf("$c", '\n'); (g) putchar('\n');
(b) printf("%c", "\n"); (h) putchar("\n");
(c) printf("%s", '\n'); @) puts('\n');

(d) printf("%s", "\n"); () puts("\n");
(e) printf('\n'); (k) puts (") ;

(f) printf ("\n");

Suppose that p has been declared as follows:

char *p = "abc";

Which of the following function calls are legal? Show the output produced by each legal
call, and explain why the others are illegal.

(a) putchar (p) ;

(b) putchar (*p) ;

(c) puts(p);

(d) puts(*p);

Suppose that we call canf as follows:

scanf ("%d%sid", &i, s, &j);

If the user enters 12abc34 56def78, what will be the values of i, s, and j after the
call? (Assume that 1 and j are int variables and s is an array of characters.)

Modify the read_1ine function in each of the following ways:

(a) Have it skip white space before beginning to store input characters.

(b) Have it stop reading at the first white-space character. Hint: To determine whether or
not a character is white space, call the isspace function.
Section 13.4

toupper function »23.5

Section 13.5

® o

75

@ 10

Exercises 309

(c) Have it stop reading at the first new-line character, then store the new-line character in
the string.
(d) Have it leave behind characters that it doesn't have room to store.

(a) Wiite a function named capitalize that capitalizes all letters in its argument. The
argument will be a null-terminated string containing arbitrary characters, not just letters.
Use array subscripting to access the characters in the string. Hinr: Use the toupper func-
tion to convert each character to upper-case.

(b) Rewrite the capitalize function, this time using pointer arithmetic to access the
characters in the string.

‘Write a function named censor that modifies a siring by replacing every occurrence of
foo by xxx. For example, the string "food fool" would become "xxxd k1" Make
the function as short as possible without sacrificing clarity.

Suppose that str is an array of characters, Which one of the following statements is not
equivalent to the other three?

(a) *stxr = 0;

(b) stx[0] = '\0';

(c) strepy (str, "");

(d) strecat(str, "");

‘What will be the value of the string stx after the following statements have been executed?

strcpy (str, "tire-bouchon');
strepy (&str(4], "d or-wi");
strcat (str, "red?");

What will be the value of the string s1 after the following statements have been executed?

strepy(sl, "computer');

stropy(s2, "science');

if (stremp(sl, s2) < 0)
strcat(sl, s2);

else
strcat(s2, sl);
sl[strlen(sl)-6] = '\0';

The following function supposedly creates an identical copy of a string. What's wrong with
the function?

char *duplicate(const char *p)

char *q;

strepy(q, p);
return q;

1
}

The Q&A section at the end of this chapter shows how the stremp function might be writ-
ten using array subscripting. Modify the function to use pointer arithmetic instead.

‘Writc the following function:

void get_extension(const char *file name, char *extension);
310

Section 13.6

*14.

@*15.

O 16

Chapter 13~ Strings

file name points to a string containing a file name. The function should store the exten-
sion on the file name in the string pointed to by extension. For example, if the file name
is "memc. txt ", the function will store "txt " in the string pointed to by extension, If
the file name doesn’t have an extension, the function should store an empty string (a single
null character) in the string pointed to by extension. Keep the function as simple as pos-
sible by having it use the strlen and strcpy functions,

‘Write the following function:
void build index_url (const char *domain, char *index_url) ;

domain points to a string containing an Internet domain, such as "knking.com". The
function should add "http://www." to the beginning of this string and "/
index.html" to the end of the string, storing the result in the string pointed to by
index url. (In this example, the result will be "http://www.knking.com/
index.html".) You may assume that index url points to a variable that is long
enought to hold the resulting string. Keep the function as simple as possible by having it use
the strcat and strepy functions.

What does the following program print?
#include <stdio.hs

int main(void)

char s[] = "Hsjedi", *p;
for (p = 8; *p; p++)
Sy

puts(s);
return 0;

}

Let f be the following function:

int f(char *s, char *t)
char *pl, *p2;

for (pl = 8; *pl; pl++) o
for (p2 = t; *p2; p2++)
if (*pl == *p2) break;

if (*p2 == '\0") break;

return pl - s;
}
(a) What is the value of f ("abcd", "babc")?
(b) What is the value of f ("abcd”, "bed")?
(c) In general, what value does f return when passed two strings s and 7

Use the techniques of Section 13.6 to condense the count:_spaces function of Section
13.4. In particular, replace the `for` statement by a `while` loop.
Write the following function:

bool test extension(const char *file_name,
const char *extension);
toupper lunction »23.5

18.

Programming Projects 311

file_name points to a string containing a file name. The function should return true if
the file’s extension matches the string pointed 1o by extension, ignoring the case of let-
ters. For example, the call test extension("memo.txt", "TXT") would return
true. Incorporate the “search for the end of a string” idiom into your function. Hint: Use
the Loupper function to convert characters to upper case before comparing them.

Write the following function:
void remove filename(char *url);

url points 1o a string containing a URL (Uniform Resource Locator) that ends with a file
name (such as "http://www.knking.com/index.html"). The function should
modify the string by removing the file name and the preceding slash. (In this example, the
result will be "http: //www.knking.com".) Incorporate the “search for the end of a
string” idiom into your function. Hint: Have the function replace the last slash in the string
by a null character.

Programming Projects

Write a program that finds the “smallest” and “largest” in a serics of words. After the user
cnters the words, the program will determine which words would come first and last if the
words were listed in dictionary order. The program must stop accepting input when the user
enters a four-letter word. Assume that no word is more than 20 letters long. An interactive
session with the program might look like this:

Enter word: dog
Enter word: zebra
Enter word: rabbit
Enter word: catfish
Enter word: walrus
Enter word: cat
Enter word:

h

Smallest word: cat
Largest word: zebra

Hinz: Use two strings named smallest word and largest word to keep track of the
“smallest” and “largest” words entered so far. Each time the user enters a new word, use
stremp to compare it with smallest_word; if the new word is “smaller,” use strcpy
1o save it in smallest word. Do a similar comparison with largest_word. Use
strlen to determine when the user has entered a four-letter word.

Improve the remind . c program of Section 13.5 in the following ways:

(1) Have the program print an error message and ignore a reminder if the corresponding
day is negative or larger than 31. Hinr: Use the `continue` statement.

(b) Allow the user to enter a day, a 24-hour time, and a reminder. The printed reminder list
should be sorted first by day. then by time. (The original program allows the user to
enter a time, but it's treated as part of the reminder.)

(c) Have the program print a one-year reminder list. Require the user to enter days in the
form month/ day.

Modity the deal . c program of Section 8.2 so that it prints the full names of the cards it
deals:
312

Chapter 13 Strings

atoi function »26.2

o o

Enter number of cards in hand: 5
Your hand:

Seven of clubs

Twce of spades

Five of diamonds

Ace of spades

Two of hearts

Hint: Replace rank_code and suit_code by arrays containing pointers (o strings.
Write a program named reverse. c that echoes its command-line arguments in reverse
order. Running the program by typing

reverse void and null

should produce the following output:

null and void

Write a program named sum.c that adds up its command-line arguments, which are
assumed to be integers. Running the program by typing

sum 8 24 62

should produce the following output:

Total: 94

Hint: Use the atoi function to convert each command-line argument from string form to
integer form.

Improve the planet . c program of Section 13.7 by having it ignore case when comparing
command-line arguments with strings in the planets array.

Modify Programming Project 11 from Chapter 5 5o that it uses arrays containing pointers to
strings instead of `switch` statements. For example, instead of using a `switch` statement
to print the word for the first digit. use the digit as an index into an array that contains the
strings "twenty", "thirty", and so forth.

Modify Programming Project 5 from Chapter 7 so that it includes the following function:
int compute scrabble value(const char *word);
The function returns the SCRABBLE value of the string pointed to by word,

Modify Programming Project 10 from Chapter 7 so that it includes the following function:
int compute vowel count(const char *sentence) ;

The function returns the number of vowels in the string pointed to by the sentence
parameter.

Maodify Programming Project 11 trom Chapter 7 so that it includes the following function:
void reverse name(char *name);

The function expects name to point to a string containing a first name followed by a last
name. It modifies the string so that the last name comes first, followed by a comma, a space,
the first initial, and a period. The original string may contain extra spaces before the first
name, between the first and last names, and after the last name.

Modify Programming Project 13 from Chapter 7 so that it includes the following function:
double compute_average_word_length(const char *sentence);

The function returns the average length of the words in the string pointed to by sentence.
Programming Projects 313

Modify Programming Project 14 from Chapter 8 so that it stores the words in a two-
dimensional chax array as it reads the sentence, with each row of the array storing a sin-
gle word. Assume that the sentence contains no more than 30 words and no word is more
than 20 characters long. Be sure to store a null character at the end of each word so that it
can be treated as a string.

Maodify Programming Project 15 from Chapter 8 so that it includes the following function:
void encrypt (char *message, int shift);

The function expects message (0 point to a string containing the message to be encrypted:
shift represents the amount by which each letter in the message is to be shifted.

Modify Programming Project 16 from Chapter 8 so that it includes the following function:
bool are anagrams(const char *wordl, const char *word2);

The function returns true if the strings pointed to by word1 and woxd2 are anagrams.

Modify Programming Project 6 from Chapter 10 so that it includes the following function:
int evaluate RPN expression(const char *expression);
The function returns the value of the RPN expression pointed to by expression.

Modify Programming Project | from Chapter 12 so that it includes the following function:
void reverse(char *message);

The function reverses the string pointed to by message. Hint: Use two pointers, one ini-
tially pointing to the first character of the string and the other initially pointing to the last
character. Have the function reverse these characters and then move the pointers toward
each other, repeating the process until the pointers meet.

Modify Programming Project 2 from Chapter 12 so that it includes the following function:
bool is_palindrome (const char *message);

The function returns true if the string pointed to by message is a palindrome.

Write a program that accepts a date from the user in the form mm/dd/yyyy and then dis-

plays itin the form month dd, yyyy, where month is the name of the mon

Enter a date (mm/dd/yyyy): 2/17/2011
You entered the date February 17, 2011

Store the month names in an arcay that contains pointers to strings.

14

14.1

The Preprocessor

There will always be things we wish to say in our programs
that in all known languages can only be said poorly.

In previous chapters, I've used the #define and #include dircctives without
going into detail about what they do. These directives—and others that we haven’t
yet covered—are handled by the preprocessor, a picce of software that edits C pro
grams just prior to compilation. Its reliance on a preprocessor makes C (along with
C++) unique among major programming languages.

The preprocessor is a powerful tool, but it also can be a source of hard-to-find
bugs. Moreover, the preprocessor can easily be misused to create programs that are
almost impossible to understand. Although some C programmers depend heavily
on the preprocessor, I recommend that it—like so many other things in life—be
used in moderation.

This chapter begins by describing how the preprocessor works (Section 14.1)
and giving some general rules that affect all preprocessing directives (Section
14.2). Sections 14.3 and 14.4 cover two of the preprocessor’s major capabilities:
macro definition and conditional compilation. (Il defer detailed coverage of file
inclusion, the other major capability, until Chapter 15.) Section 14.5 discusses the
preprocessor’s lesser-used directives: #error, #1ine, and #pragma.

How the Preprocessor Works

The behavior of the preprocessor is controlled by preprocessing directives: com-
mands that begin with a # character. We've encountered two of these directives,
#define and #include, in previous chapters.

The #define directive defines a macro—a name that represents something
else, such as a constant or frequently used expression. The preprocessor responds to
a #def ine directive by storing the name of the macro together with its definition.

315
316 Chapter 14  The Preprocessor

When the macro is used later in the program, the preprocessor “expands” the
macro, replacing it by its defined value,

The #include directive tells the preprocessor to open a particular file and
“include" its contents as part of the file being compiled. For example, the line

#include <stdio.h>

instructs the preprocessor to open the file named stdic.h and bring its contents
into the program. (Among other things, stdio.h contains prototypes for C's
standard input/output functions.)

The following diagram shows the preprocessor’s role in the compilation pro-
cess:

c program

Preprocessor

|
v

Modified C program

Compiler

Object code

The input to the preprocessor is a C program, possibly containing directives. The
preprocessor executes these directives, removing them in the process. The output
of the preprocessor is another C program: an edited version of the original pro-
gram, containing no directives. The preprocessor’s output goes directly into the
compiler, which checks the program for errors and translates it to object code
(machine instructions).

To see what the preprocessor does, let’s apply it to the celsius. c program
of Section 2.6. Here’s the original program:

/* Converts a Fahrenheit temperature to Celsius */
#include <stdio.h>

#define FREEZING PT 32.0f
#define SCALE FACTOR (5.0f / 95.0%)

int main(void)
4

float fahrenheit, celsius;

printf ("Enter Fahrenheit temperature: ");
scanf ("$f", &fahrenheit);

celsius = (fahrenheit - FREEZING_PT) * SCALE FACTOR;
14.1 How the Preprocessor Works 317

printf ("Celsius equivalent is: %.1f\n", celsius);

return 0;

After preprocessing. the program will have the following appearance:

Blank line

Blank line

Lines brought in from stdio.h
Blank line

Blank line

Blank line

Blank line

int main(void)

{

float fahrenheit, celsius;

printf ("Enter Fahrenheit temperature: ");
scanf ("$f", &fahrenheit) ;

celsius = (fahrenheit - 32.0f) * (5.0f / 9.0f);
printf ("Celsius equivalent is: %.1f\n", celsius);

return 0;

}

The preprocessor responded to the #include directive by bringing in the con-
tents of stdio.h. The preprocessor also removed the #def ine directives and
replaced FREEZING PT and SCALE FACTOR wherever they appeared later in
the file. Notice that the preprocessor doesn’t remove lines containing directives;
instead, it simply makes them empty.

As this example shows, the preprocessor does a bit more than just execute
directives. In particular, it replaces each comment with a single space character.
Some preprocessors go further and remove unnecessary white-space characters,
including spaces and tabs at the beginning of indented lines.

In the early days of C, the preprocessor was a separate program that fed its
output into the compiler. Nowadays, the preprocessor is often part of the compiler,
and some of its output may not necessarily be C code. (For example, including a
standard header such as <stdio.h> may have the effect of making its functions
available to the program without necessarily copying the contents of the header
into the program’s source code.) Still, it's useful to think of the preprocessor as
separate from the compiler. In fact, most C compilers provide a way to view the
output of the preprocessor. Some compilers generate preprocessor output when a
certain option is specified (GCC will do so when the -E option is used). Others
come with a separate program that behaves like the integrated preprocessor. Check
your compiler’s documentation for more information.

A word of caution: The preprocessor has only a limited knowledge of C. As
aresult, it’s quite capable of creating illegal programs as it executes directives.
Often the original program looks fine, making errors harder to find. In complicated
318 Chapter 14  The Preprocessor

programs, examining the output of the preprocessor may prove useful for locating
this kind of error.

14.2 Preprocessing Directives
Most preprocessing directives fall into one of three categories:

w Macro definition. The fidefine directive defines a macro; the #undef
directive removes a macro definition.

u File inclusion. The #include directive causes the contents of a specified
file to be included in a program.

u Conditional compilation. The #if, #ifdef, #ifndef, #elif, #else,
and #endif directives allow blocks of text to he either included in or
excluded from a program, depending on conditions that can be tested by the
Preprocessor.

The remaining directives—#error, #line, and #pragma—are more special-
ized and therefore used less often. We'll devote the rest of this chapter to an in-
depth examination of preprocessing directives. The only directive we won't dis-
cuss in detail is #include, since it's covered in Section 15.2.

Before we go further. let's look at a few rules that apply to all directives:

m Directives always begin with the # symbol. The # symbol need not be at the be-
ginning of a line, as long as only white space precedes it. After the # comes the
name of the directive, followed by any other information the directive requires.

m Any number of spaces and horizontal tab characters may separate the
tokens in a directive. For example, the following directive is legal:

# define N 100

m Directives always end at the first new-line character, unless explicitly con-
tinued. To continue a directive to the next line, we must end the current line
with a \ character. For example, the following directive defines a macro that
represents the capacity of a hard disk, measured in bytes:

#define DISK_CAPACTTY (STDES * \
TRACKS_PER_SIDE * \
SECTORS_PER TRACK * \
BYTES_PER_SECTOR)

u Directives can appear anywhere in a program. Although we usually put
#define and #include directives at the beginning of a file, other directives
are more likely to show up later, even in the middle of function definitions.

u Comments may appear on the same line as a directive. In fact, it’s good prac-
tice to put a comment at the end of a macro definition to explain the meaning
of the macro:

#define FREEZING_PT 32.0f /* freezing point of water */
14.3

#define directive
(simple macro)

14.3 Macro Definitions 319

Macro Definitions

The macros that we've been using since Chapter 2 are known as simple macros,
because they have no parameters. The preprocessor also supports parameterized
macros. We'll look first at simple macros, then at parameterized macros. After
covering them separately, we’ll examine properties shared by both

Simple Macros

The definition of a simple macro (or object-like macro, as it’s called in the C stan-
dard) has the form

#define ideniifier replacement-list

replacement-list is any sequence of preprocessing tokens, which are similar to the
tokens discussed in Section 2.8. Whenever we use the term “token” in this chapter,
it means “‘preprocessing token.”

A macro’s replacement list may include identifiers, keywords, numeric con-
stants, character constants, string literals, operators, and punctuation. When it
encounters a macro definition, the preprocessor makes a note that identifier repre-
sents replacement-list; wherever identifier appears later in the file, the preproces-
sor substitutes replacement-list.

Don’t put any cxtra symbols in a macro definition—they’ll become part of the
replacement list. Putting the = symbol in a macro definition is a common error:

#define N = 100 /**¥* WRONG *#*/
int a[N]; /* becomes int al= 100]; */

In this example, we’ve (incorrectly) defined N to be a pair of tokens (= and 100).
Ending a macro definition with a semicolon is another popular mistake:

#define N 100; [*%* WRONG *%*/

int a(N]; /* becomes int a[100;]; */

Here N is defined to be the tokens 100 and ;.

The compiler will detect most errors caused by extra symbols in a macro defi-
nition. Unfortunately, the compiler will flag cach use of the macro as incorrect,
rather than identifying the actual culprit—the macro’s definition—which will have
been removed by the preprocessor.

Simple macros are primarily used for defining what Kernighan and Ritchie
call “manifest constants.” Using macros, we can give names to numeric, character,
and string values:
320

Chapter 14 The Preprocessor

type definitions >7.5

#define STR_LEN B0

#define TRUE 1!
#define FALSE 0
#define PT 3.14159
#define CR ANE!
#define EOS \0!

#define MEM_ERR "Error: not enough memory"
Using #define to create names for constants has several significant advantages:

u It makes programs easier to read. The name of the macro—if well-chosen—
helps the reader understand the meaning of the constant. The alternative is a
program full of “magic numbers" that can easily mystify the reader.

u It makes programs easier to modify. We can change the value of a constant
throughout a program by modifying a single macro definition. “Hard-coded”
constants are more difficult to change, especially since they sometimes appear
in a slightly altered form. (For example, a program with an array of length 100
may have a loop that goes from 0 to 99. If we merely try to locate occurrences.
of 100 in the program, we’ll miss the 99.)

u It helps avoid inconsistencies and typographical errors. If a numerical con-
stant like 3.14159 appears many times in a program, chances are it will
occasionally be written 3.1416 or 3.14195 by accident.

Although simple macros are most often used to define names for constants,

they do have other applications:

» Making minor changes to the syntax of C. We can—in effect—alter the syn-
tax of C by defining macros that serve as alternate names for C symbols. For
example, programmers who prefer Pascal’s begin and end to C's { and }
can define the following macros:

#define BEGIN {
#define END }

We could go so far as to invent our own language. For example, we might cre-
ate a LOOP “statement" that establishes an infinite loop:

#define LOOP for (;;)

Changing the syntax of C usually isn’t a good idea, though, since it can make
programs harder for others to understand.

u Renaming types. In Section 5.2, we created a Boolean type by renaming int: I

#define BOOL int

Although some programmers use macros for this purpose, type definitions are
a superior way to define type names.

u Controlling conditional compilation. Macros play an important role in con-
trolling conditional compilation, as we’ll see in Section 14.4. For example, the
presence of the following line in a program might indicate that it’s to be com-
#define directive
(parameterized macro)

A

14.3 Macro Definitions 321

piled in “debugging mode,” with extra statements included to produce debug-
ging output:

#define DEBUG

Incidentally, it’s legal for a macro’s replacement list to be empty, as this exam-
ple shows.

‘When macros are used as constants, C programmers customarily capitalize all
letters in their names. However, there’s no consensus as to how to capitalize mac-
ros used for other purposes. Since macros (especially parameterized macros) can
be a source of bugs, some programmers like to draw attention to them by using all
upper-case letters in their names. Others prefer lower-case names, following the
style of Kernighan and Ritchie’s The C Programming Language.

Parameterized Macros

The definition of a parameterized macro (also known as a function-like macro)
has the form

ttdefine identifier( x; , X , ... , X, | replacement-list

where x, X,, ..., x, are identifiers (the macro's parameters). The parameters may
appear as many times as desired in the replacement list.

There must be no space between the macro name and the left parenthesis. If space
is left, the preprocessor will assume that we're defining a simple macro; it will
treat (x;, %, ..., X,) as part of the replacement list.

When the preprocessor encounters the definition of a parameterized macro, it
stores the definition away for later use. Wherever a macro invocation of the form
identifier (y,, ¥5, ..., ¥,) appears later in the program (where y,, y5, ..., ¥, are
sequences of tokens), the preprocessor replaces it with replacement-list, substitut-
ing y; for x,, y, for x5, and so forth.

For example. suppose that we've defined the following macros:

#define MAX(x,y) ((x) =(y)2 (%) : (y))

#define IS _EVEN(n) ((n)3%2==0)

(The number of parentheses in these macros may seem excessive, but there’s a rea-
son, as we'll see later in this section.) Now suppose that we invoke the two macros
in the following way:

i = MAX(j+k, m-n);
if (IS EVEN(i)) i++;
322

Chapter 14  The Preprocessor

<ctype .h> header »23.5

{Coo)

Inline functions > 18.6

The preprocessor will replace these lines by

i = ((j+k)>(m-n)?(j+k): (m-n));

1f (((1)%2==0)) i++;

As this example shows, parameterized macros often serve as simple functions. MAX

behaves like a function that computes the larger of two values. IS_EVEN behaves

like a function that returns 1 if its argument is an even number and 0 otherwise.
Here's a more complicated macro that behaves like a function:

#define TOUPPER(c) ('a'<=(c)&&(c)<='z'2(c)-'a'+'a':(c))

This macro tests whether the character c is between 'a' and 'z'. If so, it pro
duces the upper-case version of c by subtracting 'a' and adding 'A'. If not, it
leaves e unchanged. (The <ctype . h> header provides a similar function named
toupper that’s more portable.)

A parameterized macro may have an empty parameter list. Here’s an example:

#define getchar() getc(stdin)

The empty parameter list isn’t really needed, but it makes getchar resemble a
function. (Yes, this is the same getchar that belongs to <stdio.h>. We'll see
in Section 22.4 that getchar is usually implemented as a macro as well as a
function.)

Using a parameterized macro instead of a true function has a couple of advan-
tages:

u The program may be slightly faster. A function call usually requires some
overhead during program execution—context information must be saved,
arguments copied, and so forth. A macro invocation, on the other hand,
requires no run-time overhead. (Note, however, that C99's inline functions
provide a way to avoid this overhead without the use of macros.)

u Macros are “generic.” Macro parameters, unlike function parameters, have
no particular type. As a result, a macro can accept arguments of any type, pro-
vided that the resulting program—after preprocessing—is valid. For example,
we could use the MAX macro to find the larger of two values of type int,
long, float, double, and so forth,

But parameterized macros also have disadvantages:

u The compiled code will often be larger. Each macro invocation causes the
insertion of the macro’s replacement list, thereby increasing the size of the
source program (and hence the compiled code). The more often the macro is
used, the more pronounced this effect is. The problem is compounded when
macro invocations are nested. Consider what happens when we use MAX t0
find the largest of three numbers:

n = MAX (i, MAX(3, k));
Here’s the same statement after preprocessing:

no= ((D)>(((F)>(k)2(F): (k)))2 (1) (((F)>(k)2(F): (k))));
14.3 Macro Definitions 323

w Arguments aren’t type-checked. When a function is called, the compiler
checks each argument to see if it has the appropriate type. If not, either the
argument is converted to the proper type or the compiler produces an error
message. Macro arguments aren't checked by the preprocessor, nor are they
converted.

m [t’s not possible to have a pointer to a macro. As we’ll see in Section 17.7, C
allows pointers to functions, a concept that’s quite useful in certain program-
ming situations. Macros are removed during preprocessing, so there’s no cor-
responding notion of “pointer to a macro"; as a result, macros can’t be used in
these situations.

m A macro may evaluate its arguments more than once. A function evaluates
its arguments only once; a macro may evaluate its arguments two or more
times. Evaluating an argument more than once can cause unexpected behavior
if the argument has side effects. Consider what happens if one of MAX’s argu-
ments has a side effect:

n o= MAX(i++, 3);
Here's the same line after preprocessing:
n o= ((E+4)2(3)2(i++) : (3)) 7

If 1 is larger than 7, then i will be (incorrectly) incremented twice and n will
be assigned an unexpected value.

Errors caused by evaluating a macro argument more than once can be difficult to
find, because a macro invocation looks the same as a function call. To make mat-
ters worse, a macro may work properly most of the time, failing only for certain
arguments that have side effects. For self-protection, it's a good idea to avoid side
effects in arguments.

Parameterized macros are good for more than just simulating functions. In
particular, they're often used as patterns for segments of code that we find our-
selves repeating. Suppose that we grow tired of writing

printf('sd\n", i);

every time we need to print an integer i. We might define the following macro,
which makes it easier to display integers:

#define PRINT_INT(n) printf("%d\n", n)

Once PRINT _INT has been defined, the preprocessor will turn the line
PRINT_INT (i/4):

into

printf("sd\n", i/4);
324

Chapter 14  The Preprocessor

The # Operator

Macro definitions may contain two special operators, # and ##. Neither operator is
recognized by the compiler; instead, they’re executed during preprocessing.

The # operator converts a macro argument into a string literal; it can appear
only in the replacement list of a parameterized macro. (The operation performed
by # is known as “stringization,” a term that I'm sure you won’t find in the dictio-
nary.)

There are a number of uses for #; let’s consider just one. Suppose that we
decide to use the PRINT TINT macro during debugging as a convenient way o
print the values of integer variables and expressions, The # operator makes it pos-
sible for PRINT_INT to label each value that it prints. Here's our new version of
PRINT_INT:

#define PRINT_INT(n) printf(#n " = %d\n", n)

The # operator in front of n instructs the preprocessor to create a string literal from
PRINT_INT's argument. Thus, the inyocation

PRINT INT(i/j);
will become
printf("i/j" " = 3a\n", i/4);

We saw in Section 13.1 that the compiler automatically joins adjacent string liter-
als, so this statement is equivalent to

printf('i/j = %d\n", i/3);

When the program is executed, printf will display both the expression i/j and
its value, If 1 is 11 and 7 is 2, for example, the output will be

i/l =5

The ## Operator

The ## operator can “paste” two tokens (identifiers, for example) together to form
a single token. (Not surprisingly, the #4# operation is known as “token-pasting.”) If
one of the operands is a macro parameter, pasting occurs after the parameter has
been replaced by the corresponding argument. Consider the following macro:

#define MK_ID(n) i##n

When MX_ID is invoked (as MK_ID (1), say), the preprocessor first replaces the
parameter n by the argument (1 in this case). Next, the preprocessor joins i and 1
to make a single token (i1). The following declaration uses MK_ID to create three
identifiers:

int MK _ID(1), MK ID(2), MK_ID(3);
14.3 Macro Definitions 325

After preprocessing, this declaration becomes
int i1, i2, i3;

The ## operator isn’t one of the most frequently used features of the prepro-
cessor; in fact, it’s hard to think of many situations that require it. To find a realistic
application of ##, let’s reconsider the MAX macro described earlier in this section.
As we observed then, MAX doesn’t behave properly if its arguments have side
effects. The alternative to using the MAX macro is to write a max function. Unfor-
tunately, one max function usually isn’t enough; we may need a max function
whose arguments are int values, one whose arguments are float values, and so
on. All these versions of max would be identical except for the types of the argu-
ments and the return type, so it seems a shame to define each one from scratch.

The solution is to write a macro that expands into the definition of a max func-
tion. The macro will have a single parameter, type, which represents the type of
the arguments and the return value. There's just one snag: if we use the macro to
create more than one max function, the program won’t compile. (C doesn’t allow
two functions to have the same name if both are defined in the same file.) To solve
this problem, we'll use the ## operator to create a different name for each version
of max. Here's what the macro will look like:

#define GENERIC_MAX (type) \
type type## max(type x, type y) \
\

return x > y ? x

5

Notice how type is joined with _max to form the name of the function.
Suppose that we happen to need a max function that works with float val-
ues. Here's how we'd use GENERIC_MAX to define the function:

GENERIC MAX (float]
The preprocessor expands this line into the following code:

float float_max(float x, float y) { return x >y ? x : y; }

General Properties of Macros

Now that we’ve discussed both simple and parameterized macros, let’s look at
some rules that apply to both:

u A macro’s replacement list may contain invocations of other macros. For
example, we could define the macro TWO_PI in terms of the macro PI:

#define PI 3.14159
#define TWO_PI (2*PI)

When it encounters TWO_P1T later in the program, the preprocessor replaces it
by (2*PI). The preprocessor then rescans the replacement list to see if it
326

Chapter 14 The Preprocessor

#undef directive

contains invocations of other macros (PT, in this case). The preprocessor will
rescan the replacement list as many times as necessary to eliminate all macro
names.

u The preprocessor replaces only entire tokens, not portions of tokens. As a
result, the preprocessor ignores macro names that are embedded in identifiers,
character constants, and string literals. For example, suppose that a program
contains the following lines:

#define SIZE 256
int BUFFER SIZE;

if (BUFFER_SIZE > SIZE)
puts ("Error: SIZE exceeded");

Afler preprocessing, these lines will have the following appearance:
int BUFFER_SIZE;

if (BUFFER SIZE > 256)
puts ("Exrror: SIZE exceeded");

The identifier BUFFER_SIZE and the string "Error: SIZE exceeded"
weren’t affected by preprocessing, even though both contain the word STZE.

u A macro definition normally remains in effect until the end of the file in
which it appears. Since macros are handled by the preprocessor, they don't
obey normal scope rules. A macro defined inside the body of a function isn't
local to that function it remains defined until the end of the file.

u A macro may not be defined twice unless the new definition is identical to
the old one. Differences in spacing are allowed, but the tokens in the macro's
replacement list (and the parameters, if any) must be the same.

u Macros may be “undefined” by the #undef directive. The #undef direc-
tive has the form

#undef identifier

where identifier is a macro name. For example, the directive
#undef N

removes the current definition of the macro N. (If i1 hasn’t been defined as a
macro, the #undef directive has no effect.) One use of #undef is to remove
the existing definition of a macro so that it can be given a new definition.

Parentheses in Macro Definitions

The replacement lists in our macro definitions have been full of parentheses. Is it
really necessary to have so many? The answer is an emphatic yes; if we use fewer
14.3 Macro Definitions 327

parentheses, the macros will sometimes give unexpected—and undesirable—
results.

There are two rules to follow when deciding where to put parentheses in a
macro definition, First, if the macro’s replacement list contains an operator, always
enclose the replacement list in parentheses:

#define TWO_PI (2+%3.14159)

Second, if the macro has parameters, put parentheses around each parameter every
time it appears in the replacement list:

#define SCALE(x]) ((x)*10)

Without the parentheses, we can’t guarantee that the compiler will treat replace-
ment lists and arguments as whole expressions. The compiler may apply the rules
of operator precedence and associativity in ways that we didn’t anticipate.

To illustrate the importance of putting parentheses around a macro’s replace-
ment list, consider the following macro definition, in which the parentheses are
missing:

#define TWO_PI 2%3.14159
/* needs parentheses around replacement list */

During preprocessing, the statement

conversion_factor = 360/TWO_PI;

becomes
conversion factor = 360/2%3.14159;

The division will be performed before the multiplication, yielding a result different
from the one intended.

Putting parentheses around the replacement list isn’t enough if the macro has
parameters—each occurrence of a parameter needs parentheses as well. For exam-
ple. suppose that SCALE is defined as follows:

#define SCALE(x) (x*10) /* needs parentheses around x */
During preprocessing, the statement

j = SCALE(i+1);

becomes

3 = Gir1®10)5

Since multiplication takes precedence over addition, this statement is equivalent to
j = i+10;

Of course, what we wanted was

3= (d+1)*30;
328

Chapter 14  The Preprocessor

A

A shortage of parentheses in a macro definition can cause some of C’s most frus-
trating errors. The program will usually compile and the macro will appear to
work, failing only at the least convenient times.

Creating Longer Macros

The comma operator can be useful for creating more sophisticated macros by
allowing us to make the replacement list a series of expressions. For example, the
following macro will read a string and then print it:

#define ECHO(s) (gets(s), puts(s))

Calls of gets and puts are expressions, so it’s perfectly legal to combine them
using the comma operator. We can invoke ECHO as though it were a function:

ECHO (strx) ; /* becomes (gets(str), puts(str)); */

Instead of using the comma operator in the definition of ECHO, we could have
enclosed the ealls of gets and puts in braces to form a compound statement:

#define ECHO(s) { gets(s); puts(s); }

Unfortunately, this method doesn’t work as well. Suppose that we use ECHO in an
`if` statement:

if (echo flag)
ECHO (str) ;

else
gets(str);

Replacing ECHO gives the following result;

if (echo_flag)

{ gets(str); puts(str); };
else

gets(str) ;

The compiler treats the first two lines as a complete 1f statement:

if (echo_flag)
{ gets(str); puts(str); }

It treats the semicolon that follows as a null statement and produces an error mes-
sage for the else clause, since it doesn’t belong to any if. We could solve the
problem by remembering not to put a semicolon after each invocation of ECHO,
but then the program would look odd.

The comma operator solves this problem for ECHO, but not for all macros.
Suppose that a macro needs to contain a series of statements, not just a series of
expressions. The comma operator is of no help: it can glue together expressions,
Table 14.1
Predefined Macros

14.3 Macro Definitions 329

but not statements. The solution is to wrap the statements in a `do` loop whose con-
dition is false (and which therefore will be executed just once):
do { .. } while (0)

Notice that the `do` statement isn’t complete—it needs a semicolon at the end. To
see this trick (ahem, technique) in action, let’s incorporate it into our ECHO macro:

#define ECHO(s) \
do { &
gets(s); \
puts(s); \

} while (0)

When ECHO is used, it must be followed by a semicolon, which completes the do
statement:

ECHO(stx) ;
/* becomes do { gets(str); puts(stzr); } while (0); */

Predefined Macros

C has several predefined macros. Each macro represents an integer constant or
string literal. As Table 14.1 shows, these macros provide information about the
current compilation or about the compiler itself.

Name Description
__ LINE__ Line number of file being compiled

FILE _  Name of file being compiled
__DATE__ Date of compilation (in the form "Mmm dd yyyy")
__TIME Time of compilation (in the form "hh:mm:ss")

STDC 1 if the compiler conforms to the C standard (C89 or C99) |

The _ DATE__ and __ TIME__ macros identify when a program was com-
piled. For example, suppose that a program begins with the following statements:

printf ("Wacky Windows (c) 2010 Wacky Software, Tnc.\n");
printf ("Compiled on %s at $s\n", _ DATE_, _ TIME_);

Each time it begins to execute, the program will print two lines of the form

Wacky Windows (cc) 2010 Wacky Software, Inc.
Compiled on Dec 23 2010 at 22:18:48

This information can be helpful for distinguishing among different versions of the
same program.

We can use the _ LINE__ and _ FILE__ macros to help locate errors.
Consider the problem of detecting the location of a division by zero. When a C
program terminates prematurely because it divided by zero, there’s usually no indi-
cation of which division caused the problem. The following macro can help us pin-

point the source of the error:

Chapter 14  The Preprocessor

assert macro »24.1

@

‘Table 14.2
Additional Predefined
Macros in C99

complex types »27.3

#define CHECK ZERO(divisor) \

if (divisor == 0) \
printf ("+** Attempt to divide by zero on line %d " \
ReE L Ns AR AR TR S PTER )

The CHECK_ZERQ macro would be invoked prior to a division:

CHECK_ZERO(3) ;
=1/ q;
If  happens to be zero, a message of the following form will be printed:

*¥* Attempt to divide by zero on line 9 of file foo.c ¥

Error-detecting macros like this one are quite useful. In fact, the C library has a
general-purpose error-detecting macro named assert.

The _ STDC__ macro exists and has the value 1 if the compiler conforms to
the C standard (either C89 or C99). By having the preprocessor test this macro, a
program can adapt (o a compiler that predates the C89 standard (see Section 14.4
for an example).

Additional Predefined Macros in C99
C99 provides a few additional predefined macros (Table 14.2).

Name Description
__STDC__HOSTED__ 1 if this is a hosted implementation; 0 if it is
freestanding
__STDC__VERSION _ Version of C standard supported
__‘STDCVIECVSES_1 1 if IEC 60559 floating-point arithmetic is
supported

_ STDC_IEC 559 COMPLEX ' 1if [EC 60559 complex arithmetic is supported
__STDC_ISO 10646 ' yyyymmL if wehar t values match the ISO
10646 standard of the specified year and month

Tconditionally defined

To understand the meaning of _ STDC__HOSTED__, we need some new
vocabulary. An implementation of C consists of the compiler plus other software
necessary to execute C programs. C99 divides implementations into two catego-
ries: hosted and freestanding. A hosted implementation must accept any program
that conforms to the C99 standard, whereas a freestanding implementation
doesn’t have to compile programs that use complex types or standard headers
beyond a few of the most basic. (In particular, a freestanding implementation
doesn’t have to support the <stdio.h> header) The _ STDC__HOSTED _
macro represents the constant 1 if the compiler is a hosted implementation: other-
wise, the macro has the value 0.

The STDC VERSION  macro provides a way to check which version
of the C standard is recognized by the compiler. This macro first appeared in
Amendment | to the C89 standard, where its value was specified to be the long
IEEE floating-point standard »7.2

wehax_t 1ype>25.2
ISO/IEC 10546 standard »25.2

D

14.3 Macro Definitions 331

integer constant 1994 09L (representing the year and month of the amendment). If
a compiler conforms to the C99 standard, the valuc is 199901L. For each subse-
quent version of the standard (and each amendment to the standard), this macro
will have a different value.
A C99 compiler may (or may not) define three additional macros. Each macro
is defined only if the compiler meets a certain requirement:
®m _ STDC_IEC 559 is defined (and has the value 1) if the compiler per-
forms floating-point arithmetic according to the IEC 60559 standard (another
name for the IEEE 754 standard).
m _ STDC IEC 559 COMPLEX _is defined (and has the value 1) if the
compiler performs complex arithmetic according to the IEC 60559 standard.
= STDC TSO 10646 _ is defined as an integer constant of the form
yyyymmL (for example, 199712L) if values of type wchar_t are repre-
sented by the codes in the ISO/IEC 10646 standard (with revisions as of the
specified year and month).

Empty Macro Arguments

C99 allows any or all of the arguments in a macro call to be empty. Such a call will
contain the same number of commas as a normal call, however. (That way, it’s easy
(o see which arguments have been omitted.)

In most cases, the effect of an empty argument is clear. Wherever the corre-
sponding parameter name appears in the replacement list, it’s replaced by noth-
ing—it simply disappears from the replacement list. Here's an example:

#define ADD(x,y) (x+y)

After preprocessing, the statement

i = ADD(j.k);
becomes
i= (3+k);

whereas the statement

i = abp(,Xk);
becomes
i= (+k);

When an empty argument is an operand of the # or ## operators, special rules
apply. If an empty argument is “stringized” by the # operator, the result is " * (the
empty string):

#define MK STR(x) #x

char empty string[] = MK_STR();
332

Chapter 14 The Preprocessor

@D

variable-tangth argument lists
>26.1

After preprocessing, the declaration will have the following appearance:
char empty string[] = "";

If one of the arguments of the ## operator is empty. it's replaced by an invisi-
ble “placemarker” token. Concatenating an ordinary token with a placemarker
token yields the original token (the placemarker disappears). If two placemarker
tokens are concatenated, the result is a single placemarker. Once macra expansion
has been completed, placemarker tokens disappear from the program. Consider the
following example:

#define JOIN(x,y,z) x##vi#z

int JOIN(a,b,c), JOIN(a,b,), JOIN(a,,c), JOIN(,,c);
After preprocessing, the declaration will have the following appearance:
int abc, ab, ac, c;

The missing arguments were replaced by placemarker tokens, which then disap-
peared when concatenated with any nonempty arguments. All three arguments to
the JOIN macro could even be missing, which would yield an empty result.

Macros with a Variable Number of Arguments

In C89, a macro must have a fixed number of arguments, if it has any at all. C99
loosens things up a bit, allowing macros that take an unlimited number of argu-
ments. This feature has long been available for functions, so it’s not surprising that
macros were finally put on an equal footing.

The primary reason for having a macro with a variable number of arguments is
that it can pass these arguments (o a function that accepts a variable number of
arguments. such as printf or scanf. Here's an example:

#define TEST(condition, ...) ((condition)? \
printf("Passed test: %s\n", fconditionm): \
printf(_ VA ARGS_ ))

The . . . token, known as ellipsis, goes at the end of a macro’s parameter list, pre-
ceded by ordinary parameters, if there are any. __ VA _ARGS__is a special identi-
fier that can appear only in the replacement list of a macro with a variable number
of arguments; it represents all the arguments that correspond to the ellipsis. (There
must be at least one argument that corresponds to the ellipsis, although that argu-
ment may be empty.) The TEST macro requires at least two arguments. The first
argument matches the condition parameter; the remaining arguments match
the ellipsis.
Here’s an example that shows how the TEST macro might be used:

TEST (voltage <= max _voltage,
"Voltage %d exceeds %d\n", voltage, max voltage) ;

The preprocessor will produce the following output (reformatted for readability):
14.4

14.4  Conditional Compilation ~ 333

((voltage <= max_voltage)?
printf ("Passed test: %s\n", "voltage <= max_voltage"):
printf ("Woltage ¥G exceeds %%d\n", voltage, max voltage));

When the program is executed, the program will display the message
Pasced test: voltage <= max_voltage

if voltage is no more than max_voltage. Otherwise, it will display the values
of voltage and max_voltage:

Voltage 125 exceeds 120

The _ func__ Identifier

Another new feature of C99 is the __func__ identifier.  func__ has nothing
to do with the preprocessor, so it actually doesn’t belong in this chapter. However,
like many preprocessor features, it's useful for debugging, so I've chosen to dis-
cuss it here.

Every function has access to the __func__ identifier, which behaves like a
string variable that stores the name of the currently executing function. The effect
is the same as if each function contains the following declaration at the beginning
of its body:

static const char _ func_ [l = "function-name" ;

where function-name is the name of the function. The existence of this identifier
makes it possible to write debugging macros such as the following:

#define FUNCTION CALLED() printf("%s called\n", _ func_ );
#define FUNCTION_RETURNS () printf("$s returns\n", func );

Calls of these macros can then be placed inside functions to trace their calls:
void f(void)
FUNCTION CALLED(); /* displays "f called" */

FUNCTION RETURNS(); /* displays "f returns" */

}

Another use of __func__: it can be passed to a function to let it know the name
of the function that called it.

Conditional Compilation

The C preprocessor recognizes a number of directives that support conditional
compilation—the inclusion or exclusion of a section of program text depending on
the outcome of a test performed by the preprocessor.
334

Chapter 14  The Preprocessor

#1if directive

#endif directive

The #1if and #endif Directives

Suppose we're in the process of debugging a program. We'd like the program to
print the values of certain variables, so we put calls of printf in critical parts of
the program. Once we’ve located the bugs, it’s often a good idea to let the printf
calls remain, just in case we need them later. Conditional compilation allows us to
leave the calls in place, but have the compiler ignore them.

Here’s how we'll proceed. We'll first define a macro and give it a nonzero
value:

#define DEBUG 1

The name of the macro doesn't matter. Next, we'll surround each group of
printf calls by an #if-#endif pair:

#if DEBUG

printf ("Value of i: %%d\n", 1i);

printf ("Value of j: %d\n", j);

#endif

During preprocessing, the #if directive will test the value of DEBUG. Since ils
value isn’t zero. the preprocessor will leave the two calls of printf in the pro-
gram (the #1f and #endif lines will disappear, though). If we change the value
of DEBUG to zero and recompile the program, the preprocessor will remove all
four lines from the program. The compiler won’t see the calls of printf, so they
won’t occupy any space in the object code and won’t cost any time when the pro-
gram is run. We can leave the #1 f-fendif blocks in the final program, allowing
diagnostic information to be produced later (by recompiling with DEBUG set to 1)
if any problems turn up.
In general, the #1 f directive has the form

Hif constant-expression
The #endif directive is even simpler:

#endif

When the preprocessor encounters the #if directive, it evaluates the constant
expression. If the value of the expression is zero, the lines between #if and
#endif will be removed from the program during preprocessing. Otherwise, the
lines between i1 and fendif will remain in the program to be processed by the
compiler—the #1f and #endif will have had no effect on the program.

It’s worth noting that the #1f directive treats undefined identifiers as macros
that have the value 0. Thus, if we neglect to define DEBUG, the test

#if DEBUG
#ifdef directive

14.4  Conditional Compilation 335

will fail (but not generate an error message), while the test
#if !DEBUG

will succeed.

The defined Operator

We encountered the # and ## operators in Section 14.3. There’s just one other
operator, defined. that's specific to the preprocessor. When applied to an identi-
fier, def ined produces the value 1 if the identifier is a currently defined macro; it
produces 0 otherwise. The defined operator is normally used in conjunction
with the #1 f directive; it allows us to write

#if defined (DEBUG)
;#‘endif

‘I'he lines between the #1f and #endif directives will be included in the program
only if DEBUG is defined as a macro. The parentheses around DEBUG aren’t
required; we could simply write

#1f defined DEBUG

Since defined tests only whether DEBUG is defined or not, it’s not neces-
sary to give DEBUG a value:

#define DEBUG

The #ifdef and #ifndef Directives

The #1ifdef directive tests whether an identifier is currently defined as a macro:
4#ifdef identifier

Using #ifdef is similar to using #if:

#ifdef identifier
Lines to be included if identifier is defined as a macro
#endif

Strictly speaking, there’s no need for #ifdef, since we can combine the #if
directive with the def ined operator to get the same effect. In other words, the
directive

#1ifdef identifier
is equivalent to

#if defined (identifier)
336 Chapter 14  The Preprocessor

#ifndef directive

#elif directive

#else directive

The #ifndef directive is similar to #ifdef, but tests whether an identifier
is not defined as a macro:

#ifndel identifier

Writing
#ifndef identifier
is the same as writing

#if \defined (identifier)

The #elif and #else Directives

#1if, #ifdef, and #ifndef blocks can be nested just like ordinary if state-
ments. When nesting occurs, it’s a good idea (0 use an increasing amount of inden-
tation as the level of nesting grows. Some programmers put a comment on each
closing #endif to indicate what condition the matching #1 f tests:

#if DEBUG
4endif /* DEBUG */

This technique makes it easier for e reader to find the beginning of the #1 f block.
For additional convenience, the preprocessor supports the 11 f and #else
directives:

#elif constani-expression

#else

#elif and #else can be used in conjunction with #if, #ifdef, or #ifndef
to test a series of conditions:

#if expri

Lines 10 be included if expr1 is nonzero

#elif expr2

Lines to be included if expr1 is zero but expr2 is nonzero
#else

Lines to be included otherwise

frendif

Although the #if directive is shown above, an #ifdef or #ifndef directive
can be used instead. Any number of #e11if directives—but at most one #else
may appear between #1 f and #endif.
14.4 Conditional Compilation 337

Uses of Conditional Compilation

Conditional compilation is certainly handy for debugging, but its uses don’t stop
there. Here are a few other common applications:

w Writing programs that are portable to several machines or operating sys-
tems. The following example includes one of three groups of lines depending
on whether WIN32, MAC_CS, or LINUX is defined as a macro:

#if defined (WIN32)

;elif defined (MAC_OS)

ge1if defined (LINUX)

;endif

A program might contain many of these #1f blocks. At the beginning of the
program, one (and only one) of the macros will be defined, thereby selecting a

particular operating system. For example, defining the LINUX macro might
indicate that the program is to run under the Linux operating system.

n Writing programs that can be compiled with different compilers. Different
compilers often recognize somewhat different versions of C. Some accept a
standard version of C, some don't. Some provide machine-specific language
extensions; some don't, or provide a different set of extensions. Conditional
compilation can allow a program to adjust to different compilers. Consider the
problem of writing a program that might have to be compiled using an older,
nonstandard compiler, The _ STDC _ macro allows the preprocessor to
detect whether a compiler conforms to the standard (either C89 or C99); if it
doesn’t, we may need to change certain aspects of the program. In particular,
we may have to use old-style function declarations (discussed in the Q&A at
the end of Chapter 9) instead of function prototypes. At each point where
functions are declared, we can put the following lines:

#if _ STDC__

Function protorypes

#else

Old-siyle function declarations
#endif

w Providing a default definition for a macro. Conditional compilation allows
us to check whether a macro is currently defined and, if not, give it a default
definition. For example, the following lines will define the macro
BUFFER_SIZEif it wasn’t previously defined:

#ifndef BUFFER SIZE
#define BUFFER_SIZE 256
#endif
338

Chapter 14  The Preprocessor

14.5

#error directive

INT_MAX macro >23.2

u Temporarily disabling code that contains comments. We can’tuse a /*,..% /
comment to “comment out” code that already contains /*...*/ comments.
Instead. we can use an #1f directive:

#if 0

Lines containing comments

#enaif

Disabling code in this way is often called “conditioning out.”

Section 15.2 discusses another common use of conditional compilation: pro-
tecting header files against multiple inclusion,

Miscellaneous Directives

To cnd the chapter, we'll take a brief look at the #error, #1ine, und #pragma
directives. These directives are more specialized than the ones we've already
examined, and they're used much less frequently.

The #error Directive

The #error directive has the form

#error message

where message is any sequence of tokens. If the preprocessor encounters an
#error directive, it prints an error message which must include message. The
exact form of the error message can vary from one compiler to another; it might be
something like

Error directive: message
or perhaps just
#erroxr message

Encountering an #error directive indicates a serious flaw in the program; some
compilers immediately terminate compilation without attempting to find other
errors.

#error directives are frequently used in conjunction with conditional com-
pilation to check for situations that shouldn’t arise during a normal compilation.
For example, suppose that we want to ensure that a program can’t be compiled on
a machine whose int type isn’t capable of storing numbers up to 100,000. The
largest possible int value is represented by the INT MAX macro, so all we need
do is invoke an #error directive if INT_MAX isn’t at least 100,000:
#1ine directive
(form 1)

@

#1line directive
(form 2)

14.5 Miscellaneous Directives 339

#if INT MAX < 100000
#error int type is too small
#endif

Attempting to compile the program on a machine whose integers are stored in 16
bits will produce a message such as

Error directive: int type is too small

The #error directive is often found in the #else part of an #if-#elif-
#else series:

#if defined(WIN32)
#elif defined(MAC OS)
#elif defined (LINUX)

#else
#error No operating system specified
#endif

The #1ine Directive

The #1ine directive is used to alter the way program lines are numbered. (Lines
are usually numbered 1, 2, 3, as you'd expect.) We can also use this directive to
make the compiler think that it’s reading the program from a file with a different
name.

The #1ine directive has two forms. In one form, we specify a line number:

#line n

n must be a sequence of digits representing an integer between 1 and 32767
(2147483647 in C99). This directive causes subsequent lines in the program to be
numbered 2, n+ 1, 7+ 2, and so forth.

In the second form of the #1 ine directive, both a line number and a file name
are specified:

#line n "file"

The lines that follow this directive are assumed to come from file, with line num-
bers starting at . The values of n and/or the file string can be specified using mac-
Tos.

One effect of the #1ine directive is to change the value of the _ LINE
macro (and possibly the FILE  macro). More importantly, most compilers
will use the information from the #1 ine directive when generating error messages.
340 Chapter 14 The Preprocessor

#pragma directive

For example, suppose that the following directive appears at the beginning of the
file foo.c:

#line 10 "bar.c"

Let’s say that the compiler detects an error on line 5 of foo .. c. The error message
will refer to line 13 of file bar . c, not line 5 of file f00. c. (Why line 13? The
directive occupies line 1 of f60. c, 5o the renumbering of f00 . c begins at line 2,
which is treated as line 10 of bar. c.)

At first glance, the #1ine directive is mystifying. Why would we want crror
messages to refer to a different line and possibly a different file? Wouldn't this
make programs harder to debug?

In fact, the #1ine directive isn’t used very often by programmers. Instead,
it’s used primarily by programs that generate C code as output. The most famous
example of such a program is yacc (Yet Another Compiler-Compiler), a UNIX
utility that automatically generates part of a compiler. (The GNU version of yacc
is named bison.) Before using yace, the programmer prepares a file that con-
tains information for yacc as well as fragments of C code. From this file, yace
generates a C program, y . tab. c, that incorporates the code supplied by the pro-
grammer. The programmer then compiles y . tab . c in the usual way. By inserting
#1line directives in y.tab.c, yacc tricks the compiler into believing that the
code comes from the original file—the one written by the programmer. As a result,
any error messages produced during the compilation of y.tab.c will refer to
lines in the original file, not lines in y.tab.c. This makes debugging easier,
because error messages refer to the file written by the programmer, not the (more
complicated) file gencrated by yace.

The #pragma Directive

The #pragma directive provides a way to request special behavior from the com-
piler. This directive is most useful for programs that arc unusually large or that
need (o take advantage of the capabilities of a particular compiler.

The #pragma directive has the form

#oragma ftokens

where fokens are arbitrary tokens. #pragma directives can be very simple (a sin-
gle token) or they can be much more elaborate:

#pragma data(heap size => 1000, stack size => 2000)

Not surprisingly, the set of commands that can appear in #pragma directives
is different for each compiler; you'll have to consult the documentation for your
compiler to see which commands it allows and what those commands do. Inciden-
tally, the preprocessor must ignore any #pragma directive that contains an unrec-
ognized command; it’s not permitted to give an error message.
_Pragma expression

14.5 Miscellaneous Directives 341

In €89, there are no standard pragmas—they’re all implementation-defined.
C99 has three standard pragmas, all of which use 8TDC as the first token following
#pragma. These pragmas are FP CONTRACT (covered in Section 23.4),
CX_LIMITED_RANGE (Section 27.4), and FENV_ACCESS (Section 27.6).

The _Pragma Operator

C99 introduces the _Pragma operator, which is used in conjunction with the
#pragma directive. A _Pragma expression has the form

_Pragma ( string-literal )

When it encounters such an expression, the preprocessor “destringizes" the string
literal (yes, that's the term used in the C99 standard!) by removing the double
quotes around the string and replacing the escape sequences \" and \\ by the
characters " and \, respectively. The result is a series of tokens, which are then
treated as though they appear in a fipragma directive. For example, writing

_Pragma ("data (heap_size => 1000, stack_size => 2000)")
is the same as writing
#pragma data(heap_size => 1000, stack size => 2000)

The _Pragma operator lets us work around a limitation of the preprocessor:
the fact that a preprocessing directive can’t generate another directive. _Pragma,
however, is an operator, not a directive, and can therefore appear in a macro defini-
tion. This makes it possible for a macro expansion to leave behind a #pragma
directive,

Let's look at an example from the GCC manual. The following macro uses the
_ Pragma operator:

#define NO_PRAGMA(x) _Pragma (#x)
The macro would be invoked as follows:
DO_PRAGMA (GCC dependency "parse.y")
After expansion, the result will be

#pragma GCC dependency "parse.y"

which is one of the pragmas supported by GCC. (It issues a warning if the date of
the specified file—parse. y in this example—is more recent than the date of the
current file—the one being compiled.) Note that the argument to the call of
DO_PRAGMA is a series of tokens. The # operator in the definition of DO_PRAGMA
causes the tokens to be stringized into "GCC dependency \"parse.y\"";
this string is then passed to the _Pragma operator, which destringizes it, produc-
ing a #pragma directive containing the original tokens.
342

Chapter 14 The Preprocessor

=

*Q:

Q&A

I’ve seen programs that contain a # on a line by itself. Is this legal?

Yes. This is the null directive; it has no effect. Some programmers use null direc-
tives for spacing within conditional compilation blocks:

#if TNT_MAX < 100000

#

#error int type is tao small

#

#endif

Blank lines would also work, of course, but the # helps the reader see the extent of
the block.

I’'m not sure which constants in a program need to be defined as macros. Are
there any guidelines to follow? [p. 319]

One rule of thumb says that every numeric constant, other than 0 or 1, should be a
macro. Character and string constants are problematic, since replacing a character
or string constant by a macro doesn’t always improve readability. I recommend
using a macro instead of a character constant or string literal provided that (1) the
constant is used more than once and (2) the possibility exists that the constant
might someday be modified. Because of rule (2), I don’t use macros such as

fidefine NUL '\0'
although some programmers do.
‘What does the # operator do if the argument that it’s supposed to *“‘stringize”

contains a " or \ character? [p. 324]
It converts " to \" and \ to \\. Consider the following macro:

#define STRINGIZE (x) #x

The preprocessor will replace STRINGIZE ("foo") by "\ "foo\"".

T can’t get the following macro to work properly:
#define CONCAT (x,y) ity

CONCAT (a,b) gives ab, as expected, but CONCAT (a, CONCAT (b, c) ) gives
an odd result. What’s going on?

Thanks to rules that Kernighan and Ritchie call “bizarre,” macros whose replace-
ment lists depend on ## usually can’t be called in a nested fashion. The problem is
that CONCAT {a, CONCAT (b, c) ) isn’t expanded in a “normal” fashion, with
CONCAT (b, c) yielding be, then CONCAT (a, be) giving abe. Macro parame-
ters that are preceded or followed by ## in a replacement list aren’t expanded at
*Q:

sgrt function >23.5

Q&A 343

the time of substitution. As a result, CONCAT (a, CONCAT (b, c) ) expands to
aCONCAT (b, c) , which can’t be expanded further. since there’s no macro named
aCONCAT.

There’s a way to solve the problem, but it’s not pretty. The trick is to define a
second macro that simply calls the first one:

Hidefine CONCAT2 (x,y) CONCAT(x,y)

Writing CONCAT2 (a, CONCAT2 (b, c) ) now yields the desired result. As the
preprocessor expands the outer call of CONCAT2, it will expand CONCAT2 (b, c)
as well: the difference is that CONCAT2’s replacement list doesn’t contain ##. If
none of this makes any sense, don't worry; it's not a problem that arises often.

The # operator has a similar difficulty, by the way. If #x appears in a replace-
ment list, where x is a macro parameter, the corresponding argument is not
expanded. Thus, if IV is a macro representing 10, and STR (x) has the replacement
list #x, expanding STR (M) yields "N, not "10". The solution is similar to the
one we used with CONCAT: defining a second macro whose job is to call STR.

Suppose that the preprocessor encounters the original macro name during
rescanning, as in the following example:

#define N (2+M)
#define M (N+1)

i = N; /* infinite loop? */

The preprocessor will replace N by (2*), then replace M by (N+1). Will the
preprocessor replace N again, thus going into an infinite loop? [p. 326]

Some old preprocessors will indeed go into an infinite loop, but newer ones
shouldn’t. According to the C standard, if the original macro name reappears dur-
ing the expansion of a macro, the name is not replaced again. Here's how the
assignment to 1 will look after preprocessing:

i = (2+(N+1));

Some enterprising programmers take advantage of this behavior by writing
macros whose names match reserved words or functions in the standard library.
Consider the sqgrt library function. sgrt computes the square root of its argu-
ment, returning an implementation-defined value if the argument is negative. Per-
haps we would prefer that sqrt return 0 if its argument is negative. Since sgrt is
part of the standard library. we can’t easily change it. We can, however, define a
sqrt macro that evaluates to 0 when given a negative argument:

H#undef sqrt
#define sqrt(x) ((x)>=0?sqrt (x):0)

A later call of sqrt will be intercepted by the preprocessor, which expands it into
the conditional expression shown here. The call of sqrt inside the conditional
expression won't be replaced during rescanning, so it will remain for the compiler
344

Chapter 14  The Preprocessor

to handle. (Note the use of #undef to undefine sqrt before defining the sqrt
macro. As we’ll see in Section 21.1, the standard library is allowed to have both a
macro and a function with the same name. Undefining sqrt before defining our
own sgrt macro is a defensive measure, in case the library has already defined
sqrt as a macro.)

I get an error when I try to use predefined macros such as __ LINE _ and
__FILE__.Isthere aspecial header that I need to include?

No. These macros are recognized automatically by the preprocessor. Make sure that
you have fwo underscores at the beginning and end of each macro name, not one.

What’s the purpose of distinguishing between a “hosted implementation” and
a “freestanding implementation"? If a freestanding implementation doesn’t
even support the <stdio.h> header, what use is it? [p. 330]

A hosted implementation is needed for most programs (including the ones in this
book), which rely on the underlying operating system for input/output and other
essential services. A freestanding implementation of C would be used for pro-
grams that require no operating system (or only a minimal operating system). For
example, a freestanding implementation would be needed for writing the kernel of
an operating system (which requires no traditional input/output and therefore
doesn’t need <stdio.h> anyway). Freestanding implementations are also useful
for writing software for embedded systems.

I thought the preprocessor was just an editor. How can it evaluate constant
expressions? [p, 334]

The preprocessor is more sophisticated than you might expect; it knows enough
about C to be able to evaluate constant expressions, although it doesn’t do so in
quite the same way as the compiler. (For one thing, the preprocessor treats any
undefined name as having the value 0. The other differences are too esoteric to go
into here.) In practice, the operands in a preprocessor constant expression are usu-
ally constants, macros that represent constants, and applications of the defined
operator.

Why does C provide the #ifdef and #ifndef directives, since we can get
the same effect using the #1if directive and the defined operator? [p. 335]
The #ifdef and #ifndef directives have been a part of C since the 1970s. The
defined operator, on the other hand, was added to C in the 1980s during stan-
dardization. So the real question is: Why was defined added to the language?
The answer is that def ined adds flexibility. Instead of just being able to test the
existence of a single macro using #ifdef or #ifndef, we can now test any
number of macros using #1 f together with defined. For example, the following
directive checks whether FOO and BAR are defined but BAZ is not defined:

#if defined(FOO) && defined(BAR) && !defined(BAZ)
Section 14.3

Q:

o .

Exercises 345

1 wanted to compile a program that I hadn’t finished writing, so I “condi-
tioned out” the unfinished part:

#1f 0
#endif

When I compiled the program, I got an error message referring to one of the
lines between #if and #endif. Doesn’t the preprocessor just ignore these
lines? [p. 338]

No, the lines aren’t completely ignored. Comments are processed before prepro-
cessing directives are executed, and the source code is divided into preprocessing
tokens. Thus, an unterminated comment between if and #fendif may cause an
crror message. Also, an unpaired single quote or double quote character may cause
undefined behavior.

Exercises

‘Write parameterized macros that compute the following values.

(2) The cube of x.
(b) The remainder when n is divided by 4.
(c) 1if the product of % and v is less than 100, 0 otherwise.

Do your macros always work? If not, describe what arguments would make them fail.
Write a macro NELEVMS (a) that computes the number of elements in a one-dimensional
array a. Hint: See the discussion of the sizeof operator in Section 8.1.

Let DOUBLE be the following macro:

#define DOUBLE (x) 2%x

(a) What is the value of DOUBLE {1+2) ?

(b) What is the value of 4 /DOUBLE (2) ?
(c) Fix the definition of DOUBLE.

For each of the following macros, give an example that illustrates a problem with the macro
and show how to fix it.

(a) #define AVG(x,y) (x-=y)/2
(b) #define AREA(x,y) (x)*(y)

Let TOUPPER be the following macro:

#define TOUPPER(c) ('a'<=(c)&&(c)<='z'?(c)-'a'+'A':(c))

Let s be a string and let i be an int variable. Show the output produced by cach of the fol-
lowing program fragments.

(a) stropy(s, "abcd");
i=0;
putchar (TOUPBER (s [++i]) ) ;
346 Chapter 14  The Preprocessor

Efprintf funclion >22.3

® 7

*8.

10.

11,

stderr siream »22.1

Section 14.4

@ 12

(b) strepy(s, "0123");
i=0;
putchar (TOUPPER (s [++1])) ;

(a) Write a macro DISP (f, %) that expands into a call of printf that displays the value
of the function f when called with argument . For example,

DISP(sqgrt, 3.0);

should expand into

printf ("sqrt(%g) = %g\n", 3.0, sgrt(3.0));

(b) Write a macro DISP2(f,x,y) that's similar to DISP but works for functions with
two argumcnts.

Let GENERIC_MAX be the following macro;

#define GENERIC MAX (type) N
type typet#ff_max(type %, type y) \
{ \

return x > y ? X : y; \
}

(a) Show the preprocessor’s expansion of GENERTC_MAX (long) .

(b) Explain why GENERIC MAX doesn’t work for basic types such as unsigned long.

(c) Describe a technique that would allow us to use GENERTC_MAX with basic types such
as unsigned long. Hint: Don't change the definition of GENERIC MAX.

Supposc we want a macro that expands into a string containing the current line number and
file name. In other words, we'd like to write

const char *str = LINE FILE;

and have it expand into

const char *str = "Line 10 of file foo.c";

where f00. o is the file containing the program and 10 is the line on which the invocation
of LINE FILE appears. Warning: This exercise is for experts only. Be sure to rcad the
Q&A scction carefully before attempting!

Write the following parameterized macros.

(a) CHECK(x,y,n) — Has the value | if both x and y fall between 0 and n — 1, inclusive.
(b) MEDIAN (x,y, z) — Finds the median of x. y. and z.
(c) POLYNOMIAL (x) — Computes the polynomial 3x° + 2x! — 5x° — 2% + 7x— 6.

Functions can often—but not always—be written as parameterized macros. Discuss what
characteristics of a function would make it unsuitable as a macro.

(C99) C programmers often use the fprintf function to write crror messages:

fprintf (stderr, "Range error: index = %%d\n", index);

stdexr is C's “standard error” stream; the remaining arguments are the same as those for
printf, starting with the format string. Write a macro named ERROR that generates the
call of fprintf shown above when given a format string and the items to be displayed:

ERROR ("Range error: index - %d\n", index);

Suppose that the macro M has been defined as follows:
#define M 10
@14

Exercises 347

Which of the following tests will fail?
(a) #if M

(b) #ifdef M

(c) #ifndef M

(d) #if defined (M)

(e) #if !defined (M)

(a) Show what the following program will look like after preprocessing. You may ignore
any lines added to the program as a result of including the <stdio.h> header.

#include <stdio.h>

#define N 100
void f(void);

int main(void)

f();
#ifdef N
#undef N
#endif

return 0;

}

void ff(void)
{
#if defined(N)

printf ("N is %d\n", N);
#else

printf ("N is undefined\n");
#endif

(b) What will be the output of this program?

Show what the following program will look like after preprocessing. Some lines of the pro-
gram may cause compilation errors; find all such errors.

#define N = 10

#define INC(x) x+1

#define SUB (x,y) x-y
#define SQR(x) ((x)*(x))
#define CUBE(x) (SOR(x)*(x))
f#define M1 (x,y) xi#y
#define M2 (x,y) #x #y

int main(void)

int ANl 1, J, k, ms

#ifdef N
1= g%
#else
3 =4
#endif

i = 10 * INC(]);
348  Chapler 14 The Preprocessor

Section 14.5

*16.

SUB(3, k);
SQR (SQR(J) ) ;
CUBE () ;

= ML(3, k);
puts (M2(1, j));

B b b e
"o

#undef SQR
i = SQR(3);

#define SOR
i = SQR(3);

return 0;

Suppose that a program needs to display messages in either English, French, or Spanish.
Using conditional compilation, write a program fragment that displays one of the following
three messages, depending on whether or not the specified macro is defined:

Insert Disk 1 (if ENGLTSH is defined)
Inserez Le Disque 1 (if FRENCH is defined)
Inserte El Disco 1  (if SPANISH is defined)

(C99) Assume that the following macro definitions are in effect:

#define IDENT(x) PRAGMA(ident #x)
#define PRAGMA(x) _Pragma (#x)

What will the following line look like after macro expansion?
IDENT (foo)

15

15.1

stacks >10.2

Writing Large Programs

Around computers it is difficuit to find the correct unit
of time to measure progress. Some cathedrals took a
century to complete. Can you imagine the grandeur
and scope of a program that would take as long?

Although some C programs are small enough to be put in a single file, most aren’t.
Programs that consist of more than one file are the rule rather than the exception. In
this chapter, we'll see that a typical program consists of several source files and
usually some header files as well. Source files contain definitions of functions and
external variahles: header files contain information to be shared among source files.
Section 15.1 discusses source files, while Section 15.2 covers header files. Section
15.3 describes how to divide a program into source files and header files. Section
15.4 then shows how to “build” (compile and link) a program that consists of more
than one file, and how to “rebuild" a program after part of it has been changed.

Source Files

Up to this point, we've assumed that a C program consists of a single file. In fact, a
program may be divided among any number of source files. By convention, source
files have the extension . c. Each source file contains part of the program, prima-
rily definitions of functions and variables. One source file must contain a function
named main, which serves as the starting point for the program.

For example, suppose that we want to write a simple calculator program that
evaluates integer expressions entered in Reverse Polish notation (RPN), in which
operators follow operands. If the user enters an expression such as

30 5= %

we want the program to print its value (175, in this case). Evaluating an RPN
expression is easy if we have the program read the operands and operators, one by
one, using a stack to keep track of intermediate results. If the program reads a

349
350

Chapter 15 Writing Large Programs

number, we'll haye it push the number onto the stack. If it reads an operator, we'll
have it pop two numbers from the stack, perform the operation, and then push the
result back onto the stack. When the program reaches the end of the user’s input,
the value of the expression will be on the stack. For example, the program will
evaluate the expression 30 5 - 7 * in the following way:

1. Push 30 onto the stack.

2. Push 5 onto the stack.

3. Pop the top two numbers from the stack, subtract 5 from 30, giving 25, and
then push the result back onto the stack.

4. Push 7 onto the stack.

5. Pop the top two numbers from the stack, multiply them, and then push the
result hack onto the stack.

After these steps, the stack will contain the value of the expression (175).
Turning this strategy into a program isn’t hard. The program’s `main` function
will contain a loop that performs the following actions:

Read a “token” (a number or an operator).

If the token is a number, push it onto the stack.

If the token is an operator, pop its operands from the stack, perform the opera-
tion, and then push the result back onto the stack

When dividing a program like this one into files, it makes sense to put related func-
tions and variables into the same file. The function that reads tokens could go into
one source file (coken.c, say), together with any functions that have to do with
tokens. Stack-related functions such as push, pop, make_empty, is_empty.
and is_full could go into a different file, stack. c. The variables that repre-
sent the stack would also go into stack. c. The `main` function would go into yet
another file, calc.c.
Splitting a program into multiple source files has significant advantages:

= Grouping related functions and variables into a single file helps clarify the
structure of the program.

m Each source file can be compiled separately—a great time-saver if the pro-
gram is large and must be changed frequently (which is common during pro-
gram development).

m Functions are more easily reused in other programs when grouped in separate
source files. In our example, splitting off stack.c and token.c from the
`main` function makes it simpler to reuse the stack functions and token func-
tions in the future,

15.2 Header Files

When we divide a program into several source files, problems arisc: How can a
function in one file call a function that’s defined in another file? How can a fune-
#include directive
(form 1)

#include directive
(form 2)

15.2 Header Files 351

tion access an external variable in another file? How can two files share the same
macro definition or type definition? The answer lies with the #include directive,
which makes it possible to share information—function prototypes, macro defini-
tions, type definitions, and more—among any number of source files.

The #include directive tells the preprocessor to open a specified file and
insert its contents into the current file. Thus, if we want several source files to have
access to the same information, we’ll put that information in a file and then use
#include to bring the file's contents into each of the source files. Files that are
included in this fashion are called header files (or sometimes include files): I'll
discuss them in more detail later in this section. By convention, header files have
the extension . h.

Note: The C standard uses the term “source file” to refer to all files written by
the programmer, including both . c and . h files. I'll use “source file" to refer to
. c files only.

The #include Directive

The #include directive has two primary forms. The first form is used for header
files that belong to C’s own library:

#include <filename>

The second form is used for all other header files, including any that we write:

#include "filename"
The difference between the two is a subtle one having to do with how the com-
piler locates the header file. Here are the rules that most compilers follow:

= #include <filenames: Search the directory (or directories) in which system
header files reside. (On UNIX systems, for example, system header files are
usually kept in the directory /usr/include.)

= #include "filename": Search the current directory, then search the direc-
tory (or directories) in which system header files reside.

The places to be searched for header files can usually be altered, often by a com-
mand-line option such as - Iparth.

Don’t use brackets when including header files that you have written:
#include <myheader.h> /*** WRONG ***/

The preprocessor will probably look for myheader . h where the system header
files are kept (and, of course, won’t find it).

352 Chapter 15 Writing Large Programs

portability tip

#include directive
(form 3)

preprocessing tokens » 14.3

The file name in an #include directive may include information that helps
locate the file, such as a directory path or drive specifier:

#include "c:\cprogs\utils.h" /* Windows path */
#include "/cprogs/utils.h" /* UNIX path */

Although the quotation marks in the #include directive make file names look
like string literals. the preprocessor doesn’t treat them that way. (That’s fortunate,
since \ c and \u—which appear in the Windows example—would be treated as
escape sequences in a string literal.)

It's wsually best not to include path or drive information in #include
directives. Such information makes it difficult to compile a program when
it's transported to another machine or, worse, another operating system.

For example, the following Windows #include directives specify drive and/or
path information that may not always be valid:

#include "d:utils.h"
#include "\cprogs\include\utils.h"
#include "d:\cprogs\include\utils.h"

The following directives are better: they don’t mention specific drives, and paths
are relative rather than absolute:

#include "utils.h"
#include ", . \include\utils.h"

The #include directive has athird form that’s used less often than the other
two:

#include tokens

where rokens is any sequence of preprocessing tokens. The preprocessor will scan
the tokens and replace any macros that it finds. After macro replacement, the
resulting directive must match one of the other forms of #include. The advan-
tage of the third kind of #ineclude is that the file name can be defined by a macro
rather than being “hard-coded" into the directive itself, as the following example
shows:

#if defined(IA32)

#define CPU FILE "ia32.h"
#elif defined (IA64)

#define CPU_FILE "ia64.h"
#elif defined (AMD64)

#define CPU FILE "amdé4.h"
#endif

#include CPU FILE
15.2 Header Files 353

Sharing Macro Definitions and Type Definitions

Most large programs contain macro definitions and type definitions that need to be
shared by several source files (or, in the most extreme case. by all source files).
These definitions should go into header files.

For example, suppose that we're writing a program that uses macros named
BOOL, TRUE, and FALSE. (There’s no need for these in C99, of course, because
the <stdbool . h> header defines similar macros.) Instead of repeating the defi-
nitions of these macros in each source file that needs them, it makes more sense to
put the definitions in a header file with a name like boolean. h:

#define BOOL int
#define TRUE 1
#define FALSE 0

Any source file that requires these macros will simply contain the line
#include "boolean.h"

In the following figure, two files include boolean.h:

#define BOOL int
#define TRUE 1
#define FALSE 0

boolean.h

“

#include "boglean.h! #include "boolean.h"

Type definitions are also common in header files. For example, instead of
defining a BOOL macro, we might use typedef to create a Boal type. If we do,
the boolean.h file will have the following appearance:

#idefine TRUE 1
#define FALSE 0
typedef int Bool;

Putting definitions of macros and types in header files has some clear advan-
tages. First, we save time by not having to copy the definitions into the source files
where they're needed. Second, the program becomes easier to modify. Changing
the definition of a macro or type requires only that we edit a single header file: we
don’t have to modify the many source files in which the macro or type is used.
Third, we don’t have to worry about inconsistencies caused by source files contain-
ing different definitions of the same macro or type.
354 Chapter 15 Writing Large Programs

default argument promotions >9.3

Sharing Function Prototypes

Suppose that a source file contains a call of a function f that’s defined in another
file. foo.c. Calling f without declaring it first is risky. Without a prototype to
rely on, the compiler is forced to assume that f’s return type is int and that the
number of parameters matches the number of arguments in the call of f. The argu-
ments themselves are converted automatically to a kind of “standard form” by the
default argument promotions. The compiler’s assumptions may well be wrong, but
it has no way to check them, since it compiles only one file at a time. If the
assumptions are incorreet, the program probably won't work, and there won’t be
any clues as to why it doesn’t. (For this reason, C99 prohibits calling a function for
which the compiler has not yet seen a declaration or definition.)

When calling a function f that's defined in another file, always make sure that the
compiler has seen a prototype for f prior to the call

Our first impulse is to declare f in the file where it’s called. That solves the
problem but can create a maintenance nightmare. Suppose that the function is
called in fifty different source files. How can we ensure that f's prototypes are the
same in all the files? How can we guarantee that they match the definition of f in
foo.c?If f should change later, how can we find all the files where it’s used?

The solution is obvious: put f's prototype in a header file, then include the
header file in all the places where f is called. Since f is defined in foo.c, let’s
name the header file foo.h, In addition to including foo.h in the source files
where f is called, we'll need to include it in foo.c, enabling the compiler to
check that f's prototype in fo0 . h matches its definition in foo. c.

Always include the header file declaring a function f in the source file that con-
tains f's definition. Failure to do so can cause hard-to-find bugs. since calls of f
elsewhere in the program may not match f’s definition.

If foo.c contains other functions, most of them should be declared in the
same header file as f. After all. the other functions in foo.c are presumably
related to f; any file that contains a call of f probably needs some of the other
functions in foo.c. Functions that are intended for use only within foo.c
shouldn’t be declared in a header file, however: to do so would be misleading.

To illustrate the use of function prototypes in header files, let’s return to the
RPN calculator of Section 15.1. The stack . c file will contain definitions of the
make_empty, is_empty, is_full, push, and pop functions. The following
prototypes for these functions should go in the stack. h header file:

void make_ empty (void) ;
int is_empty(void):
external variables »10.2

15.2 Header Files 355

int is full(void);
void push(int i);
int pop (void) ;

(To avoid complicating the example, is_empty and is_full will return int
values instead of Boolean values.) We'll include stack.h in calc.c to allow
the compiler to check any calls of stack functions that appear in the latter file.
We'll also include stack.hin stack. c so the compiler can verify that the pro-

totypes in stack.h match the definitions in stack.c. The following figure
shows stack.h, stack.c, and calc.c:

void make empty(void);
int is_empty (void) ;
int is full (void);
void push(int 1)

int pep(void) ;

stack.h

¥ “

#include "stack.h" #include "stack.h"

int main(void) int contents[100];

int top = 0;
make_empty () ;

N ‘ voxd’makeiempty(vcldr

ecalec.c

1 int is empty(void)
]

int is full(void)

void)push(;nt 1)

int pop(void)

stack.c

Sharing Variable Declarations

External variables can be shared among files in much the same way functions are.
To share a function, we put its definition in one source file, then put declarations in
other files that need to call the function. Sharing an external variable is done in
much the same way.

Up to this point, we haven't needed to distinguish between a variable’s decla-
ration and its definition. To declare a variable i, we’ve written

int i; /* declares i and defines it as well */
356 Chapter 15 Writing Large Programs

which not only declares 1 to be a variable of type int, but defines i as well, by
causing the compiler to set aside space for i. To declare i without defining it, we
externkeyword »182  must put the keyword extern at the beginning of its declaration:

extern int i; /* declares i without defining it */

extern informs the compiler that i is defined elsewhere in the program (most
likely in a different source file), so there's no need to allocate space for it.

extern works with variables of all types. When we use it in the declaration
of an array, we can omit the length of the array:

M extern int all;

Since the compiler doesn’t allocate space for a at this time, there’s no need for it to
know a’s length.

To share a variable 1 among several source files, we first put a definition of 1
in one file:

THt 37

If i needs to be initialized, the initializer would go here. When this file is com-
piled. the compiler will allocate storage for 1. The other files will contain declara-
tions of 1i:

extern int i;

By declaring i in each file, it becomes possible to access and/or modify i within
those files. Because of the word extern, however, the compiler doesn’t allocate
additional storage for i each time one of the files is compiled.

‘When a variable is shared among files, we'll face a challenge similar to one
that we had with shared functions: ensuring that all declarations of a variable agree
with the definition of the variable.

Q ‘When declarations of the same variable appear in different files., the compiler can't
check that the declarations match the variable’s definition. For example, one file
may contain the definition

Ny
while another file contains the declaration
extern long i;

An error of this kind can cause the program to behave unpredictably.

To avoid inconsistency, declarations of shared variables are usually put in
header files. A source file that needs access to a particular variable can then
include the appropriate header file. In addition, each header file that contains &
152 Header Files 357

variable declaration is included in the source file that contains the variable’s defini-
tion. enabling the compiler to check that the two match.

Although sharing variables among files is a long-standing practice in the C
world. it has significant disadvantages. In Section 19.2, we’ll see what the prob-
lems are and learn how to design programs that don't need shared variables.

Nested Includes

A header file may itself contain # include directives. Although this practice may
seem a bit odd, it can be quite useful in practice. Consider the stack.h file,
which contains the following prototypes:

int is_empty(void);
int is full (void);

Since these functions return only O or 1, it's a good idea to declare their return type
10 be Bool instead of int, where Bool is the type that we defined earlier in this
section:

Bool is_empty(void);
Bool is_full (void) ;

Of course, we'll need to include the boolean.h file in stack . h so that the def-
inition of Bool is available when stack.h is compiled. (In C99, we’d include
<stdbool . h> instead of boolean.h and declare the return types of the two
functions to be bool rather than Bool.)

Traditionally, C programmers shun nested includes. (Early versions of C
didn’t allow them at all.) However, the bias against nested includes has largely
faded away, in part because nested includes are common practice in C++.

Protecting Header Files

If a source file includes the same header file twice. compilation errors may result.
This problem is common when header files include other header files. For exam-
ple, suppose that filel.h includes file3.h, file2.h includes file3.h,
and prog . c includes both filel.h and file2.h (see the figure at the top of
the next page). When prog. c is compiled, f11e3 . h will be compiled twice.

Including the same header file twice doesn’t always cause a compilation error.
If the file contains only macro definitions, function prototypes, and/or variable
declarations, there won’t be any difficulty. If the file contains a type definition,
however, we’ll get a compilation error.

Just to be safe, it’s probably a good idea to protect all header files against mul-
tiple inclusion; that way, we can add type definitions to a file later without the risk
that we might forget to protect the file. In addition, we might save some time dur-
ing program development by avoiding unnecessary recompilation of the same
header file.
358 Chapter 15 Writing Large Programs

filed.h
#include "Eile3.h! : #include

le3.h"

file2.n

clude "filsl.h"
#include "filez.h"

prog.c

To protect a header file, we'll enclose the contents of the file in an #ifndef-
#endif pair. For example, the boolean . h file could be protected in the follow-
ing way:

#ifndef BOOLEAN H
#define BOOLEAN H

#define TRUE 1
#define FALSE 0
typedef int Bool;

#endif

When this file is included the first time, the BOOLEAN H macro won't be defined,
5o the preprocessor will allow the lines between #ifndef and #endif to stay.
But if the file should be included a second time, the preprocessor will remove the
lines between #ifndef and #endif.

The name of the macro (BOOLEAN H) doesn’t really matter. However, mak-
ing it resemble the name of the header file is a good way to avoid conflicts with
other macros. Since we can’t name the macro BOOLEAN . H (identifiers can’t con-
tain periods), a name such as BOOLEAN H is a good alternative.

#error Directives in Header Files

#erroxr drectves »145  #error directives are often put in header files to check for conditions under
which the header file shouldn’t be included. For example, suppose that a header
__STDC__macro > 14.3

15.3

PROGRAM

15.3 Dividing a Program into Files 359

file uses a feature that didn’t exist prior to the original C89 standard. To prevent the
header file from being used with older, nonstandard compilers, it could contain an
#1ifndef directive that tests for the existence of the  STDC___ macro:

#ifndef _ STDC__
#error This header requires a Standard C compiler
#endif

Dividing a Program into Files

Let’s now use what we know about header files and source files to develop a sim-
ple technique for dividing a program into files. We’ll concentrate on functions, but
the same principles apply to external variables as well. We'll assume that the pro-
gram has already been designed: that is, we’ve decided what functions the program
will need and how to arrange the functions into logically related groups. (We'll dis-
cuss program design in Chapter 19.)

Here's how we’ll proceed. Each set of functions will go into a separate source
file (let’s use the name foo. c for one such file). In addition, we'll create a header
file with the same name as the source file, but with the extension .h (foo.h, in
our case). Into foo.h, we'll put prototypes for the functions defined in foo.c.
(Functions that are designed for use only within foo.ec need not—and should
not—be declared in foo.h. The read_char function in our next program is an
example.) We'll include foo.h in each source file that needs to call a function
defined in foo. c. Moreover, we'll include foo. hin f00. c so that the compiler
can check that the function prototypes in foo . h are consistent with the definitions
in foo.c.

The `main` function will go in a file whose name matches the name of the pro-
gram—if we want the program to be known as bar, then main should be in the
file bar . c. It's possible that there are other functions in the same file as main, so
long as they e not called from other files in the program.

Text Formatting

To illustrate the technique that we've just discussed, let’s apply it to a small text-
formatting program named justify. As sample input to justify, we'll use a
file named quote that contains the following (poorly formatted) quotation from
“The development of the C programming language" by Dennis M. Ritchie (in His-
tory of Programming Languages II, edited by T. J. Bergin, Jr., and R. G. Gibson,
Jr., Addison-Wesley. Reading, Mass., 1996, pages 671-687):

c is quirky, flawed, and an
enormous success. Although accidents of history
surely helped, it evidently satisfied a meed

for a system implementation language efficient
360

Chapter 15 Writing Large Programs

input redirection 221

output redirection »22.1 .,

enough to displace assembly language,
yet sufficiently abstract and fluent to describe
algorithms and interactions in a wide variety

of environments.
2 Dennis M. Ritchie

To run the program from a UNIX or Windows prompt, we'd enter the com-
mand

justify <quote

The < symbol informs the operating system that justify will read from the file
quote instead of accepting input from the keyboard. This feature, supported by
UNIX, Windows, and other operating systems, is called input redirection. When
given the quote file as input, the justify program will produce the following
output:

C is quirky, flawed, and an enormous success. Although
accidents of history surely helped, it evidently satisfied a
need for a system implementation language efficient enough
to displace assembly language, yet sufficiently abstract and
fluent to describe algorithms and interactions in a wide
variety of environments. -- Dennis M. Ritchie

The output of justify will normally appear on the screen, but we can save it in a
file by using eutput redirection:

justify <quote >newquote

The output of justify will go into the file newguote.

In general, justify’s output should be identical to its input, except that
extra spaces and blank lines are deleted, and lines are filled and justified. “Filling”
a line means adding words until one more word would cause the line to overflow.
“Justifying” a line means adding extra spaces between words so that each line has
exactly the same length (60 characters). Justification must be done so that the
space between words in a line is equal (or as nearly equal as possible). The last line
of the output won't be justified.

We'll assume that no word is longer than 20 characters. (A punctuation mark
is considered part of the word to which it is adjacent.) That’s a bit restrictive, of
course, but once the program is written and debugged we can easily increase this
limit to the point that it would virtually never be exceeded. If the program encoun-
ters a longer word, it must ignore all characters after the first 20, replacing them
with a single asterisk. For example, the word

antidisestablishmentarianism
would be printed as

antidisestablishment*
15.3 Dividing a Program into Files 361

Now that we understand what the program should do, it’s time to think about a
design. We'll start by observing that the program can’t write the words one by one
as they're read. Instead. it will have to store them in a “line buffer” until there are
enough to fill a line. After further reflection, we decide that the heart of the pro-
gram will be a loop that goes something like this:

Ear: (5 1
read word ;
if (can't read word) |
write contents of line buffer without justification ;
terminate progrant ;

}

it (word doesn’t fit in line buffer) {
write contents of line buffer with justification;
clear line buffer;

add word to line buffer ;

}

Since we’ll need functions that deal with words and functions that deal with the
line buffer, let’s split the program into three source files, putting all functions
related to words in one file (word. c) and all functions related to the line buffer in
another file (1ine . c). A third file (justify.c) will contain the `main` function,
In addition to these files, we'll need two header files, word.h and 1ine.h. The
word. h file will contain prototypes for the functions in word.e; 1ine.h will
play a similar role for 1ine.c.

By cxamining the main loop, we see that the only word-related function
that we'll need is a read_woxrd function. (If read word can’t read a word
because it’s reached the end of the input file, we'll have it signal the main loop
by pretending to read an “empty” word.) Consequently, the woxd.h file is a
small one:

#ifndef WORD_H
#define WORD H

e e e

* read word: Reads the next word from the input and *
* stores it in word. Makes word empty if no *:
* word could be read because of end-of-file. *
* Truncates the word if its length exceeds *
* len. =
* *

R R

void read word(char *word, int len);
#endif

Notice how the WORD H macro protects word. h from being included more than
once. Although word.h doesn't really need it, it’s good practice to protect all
header files in this way.
362

Chapter 15 Writing Large Programs

line.h

The 1ine.h file won’t be as short as woxrd . h. Our outline of the main loop
reveals the need for functions that perform the following operations:

‘Write contents of line buffer without justification
Determine how many characters are left in line buffer
Write contents of line buffer with justification

Clear line buffer

Add word to line buffer

‘We'll call these functions flush_line, space_remaining, write line,
clear_line, and add_word. Here's what the 1ine.h header file will look
like:

#ifndef LINE H
#define LINE H

J S PR T T P P ey

* clear line: Clears the current line. *
B

void clear line (void);

[k ke ek kR ok ok kR kb ko kKR R KRR K kR KRR

* add_word: Adds word to the end of the current line. .
* 1f this is not the first word on the line, s
B puts one space before word. *

EAE KKK A AR AAAEAEIRTHI KA A XA KA EAE R AR RE RN A AR AR ANk [
void add word(const char *word) ;

JH KRR K KRR R E K KA KA KKK KK AR K KA RK R FA K F AR I RAA R * AR XA KRR T A

* space_remaining: Returns the number of characters left *
* in the current line. 5
B e e

int space remaining(void);

T T o
* write line: Writes the current line with i
* justification. ¥
B R e P

void write line(void);

D e S A S

* flush line: Writes the current line without ¥
* justification. If the line is empty, does *
* nothing. *

B S

void flush line(void);
#endif

Before we write the word.c and line.c files. we can use the functions
declared in word. hand 1ine.h to write justify.c, the main program. Writ-
ing this file is mostly a matter of translating our original loop design into C.
Justify.c

word.c

15.3 Dividing a Program into Files =~ 363

/* Formats a file of text */

#include <string.h>
#include "line.h"
#include "word.h"

#define MAX WORD_LEN 20
int main(void)

char word[MAX WORD_LEN+2] ;
int word len;

clear_line();
for ()
read word (word, MAX WORD LEN+1);
word len = strlen(woxd);
if (word len == 0)
flush_line():
return 0;

if (word len > MAX WORD_LEN)
word [MAX WORD LEN] = '*';

if (word len + 1 > space remaining()) {
write line();
clear_line();

add_word (word) ;
}
1

Including both 1ine.h and word.h gives the compiler access to the function
prototypes in both files as it compiles justify.c.

main uses a trick to handle words that exceed 20 characters. When it calls
read_word, main tells it to truncate any word that exceeds 21 characters. After
read_word returns, main checks whether word contains a string that’s longer
than 20 characters. If so, the word that was read must have been at least 21 charac-
ters long (before truncation), so main replaces the word's 21st character by an
asterisk.

Now it’s time to write word . c. Although the word . h header file has a pro-
totype for only one function, read_word, we can put additional functions in
wozrd. c if we need to. As it turns out, read_word is easier to write if we add a
small “helper” function, read_char. We'll assign read_char the task of read-
ing a single character and, if it’s a new-line character or tab, converting it to a
space. Having read word call read_char instead of getchar solves the
problem of treating new-line characters and tabs as spaces.

Here's the word. c file:

#include <stdio.h>
#include "word.h"
364

Chapter 15

EOF macro »22.4

line.c

Writing Large Programs

int read char(void)
int ch = getchar();

if (ch == '\n' || ch == "\t")
return ' '
return ch;

}

void read word(char *word, int len)

{

int ch, pos = 0;

while ((ch = read char()) LRy

while (ch != ' ' && ch 1= EOF) {
if {pos < len)
word [pos++] = ch;
ch = read char();

word[pos] = '\0';

Before we discuss read_word. a couple of comments are in order concern-
ing the use of getchar in the read_char function. First, getchar returns an
int value instead of a char value; that's why the variable ch in read char is
declared to have type int and why the return type of read char is int. Also,
getchar returns the value EOF when it's unable to continue reading (usually
because it has reached the end of the input file).

read_word consists of two loops. The first loop skips over spaces. stopping
at the first nonblank character. (EOF isn’t a blank. so the loop stops if it reaches the
end of the input file.) The second loop reads characters until encountering a space
or EOF. The body of the loop stores the characters in word until reaching the 1en
limit. After that, the loop continues reading characters but doesn’t store them. The
final statement in read_word ends the word with a null character, thereby mak-
ing it a string. If read word encounters EOF before finding a nonblank charac-
ter, pos will be 0 at the end. making word an empty string.

The only file left is 1ine.c, which supplies definitions of the functions
declared in the 1ine. h file. 1ine . c will also need variables to keep track of the
state of the line buffer. One variable, 1ine, will store the characters in the current
line. Strictly speaking, 1ine is the only variable we need. For speed and conve-
nience. however, we’ll use two other variables: 1ine len (the number of char-
acters in the current line) and num_woxrds (the number of words in the current
line).

Here's the Line. c file;

#include <stdioc.h>

#include <string.h>
#include "line.h"
15.3 Dividing a Program into Files

#define MAX LINE LEN 60

char line[MAX LINE LEN+1];
int line len = 0;
int num words = 0;

void clear_line(void)

line[0] = '\0';
line len = 0;
num_words = 0;

}

void add word (const char *word)
{
if (num words > 0) {
line[Tine len] = ' ';
line(line len+l] = '\0@';
line lent;

strcat (line, word);
line len += strlen(word);
num_words++;

}

int space remaining (void)

return MAX LINE LEN - line len;

void write line(void)

{

int extra_spaces, spaces to_ingert, i, j:

extra spaces = MAX LINE LEN - line len;
for (1 = 0; i < line lem; i++) {
if (1ine[i] 1= ' !
putchar (line [4]);
else {
spaces to_insert = extra spaces / (num words - 1);
for (j 1; j <= spaces_to_insert + 1; j++)
putchar (' ');
extra_spaces -= spaces_to_insert;
num_words--;

putchar (*\n') ;

}

void flush line (void)

if (line_lem > 0)
puts(line) ;

365
366

Chapter 15 Writing Large Programs

15.4

Most of the functions in 1ine.c are easy to write. The only tricky one is
write line, which writes a line with justification. write line writes the
characters in Line one by one, pausing at the space between each pair of words to
write additional spaces if needed. The number of additional spaces is stored in
spaces_to_insert, which has the value extra spaces / (num words
- 1), where extra_ spaces is initially the difference between the maximum
line length and the actual line length. Since extra_spaces and num_words
change after each word is printed, spaces_to_insert will change as well. If
extra_spaces is 10 initially and num_woxds is 5, then the first word will be
followed by 2 extra spaces, the second by 2, the third by 3, and the fourth by 3.

Building a Multiple-File Program

In Section 2.1, we examined the process of compiling and linking a program that
fits into a single file. Let’s expand that discussion to cover multiple-file programs.
Building a large program requires the same basic steps as building a small one:

= Compiling. Each source file in the program must be compiled separately.
(Header files don’t need to be compiled: the contents of a header file are auto-
matically compiled whenever a source file that includes it is compiled.) For
each source file, the compiler generates a file containing object code. These
files—known as object files—have the extension .o in UNIX and .cobj in
Windows.

m Linking. The linker combines the object files created in the previous step—
along with code for library functions—to produce an executable file. Among
other duties, the linker is responsible for resolving external references left
behind by the compiler. (An external reference occurs when a function in one
file calls a function defined in another file or accesses a variable defined in
another file.)

Most compilers allow us to build a program in a single step. With the GCC
compiler, for example, we'd use the following command to build the justify
program of Section 15.3:

gee -o justify justify.c line.c word.c

The three source files are first compiled into object code. The object files are then
automatically passed to the linker, which combines them into a single file. The -o
option specifies that we want the executable file to be named justify.

Makefiles

Putting the names of all the source files on the command line quickly gets tedious.
Worse still, we could waste a lot of time when rebuilding a program if we recom-
pile all source files, not just the ones that were affected by our most recent changes.
15.4 Building a Multiple-File Program 367

To make it easier to build large programs, UNIX originated the concept of the
makefile, a file containing the information necessary to build a program. A make-
file not only lists the files that are part of the program, but also describes depen-
dencies among the files. Suppose that the file foo. c includes the file baxr . h. We
say that foo . c “depends” on bar . h, because a change to bar . h will require us
to recompile foo. c.

Here's a UNIX makefile for the justify program. The makefile uses GCC
for compilation and linking:

justify: justify.o word.o line.o
gcc -o justify justify.o word.o line.o

justify.o: justify.c word.h line.h
gee -c justify.c

word.o: word.c word.h
gec -cc word.c

line.o: line.c line.h
gee -c line.c

There are four groups of lines; each group is known as a rule. The first line in each
rule gives a target file, followed by the files on which it depends. The second line
is a command to be executed if the target should need to be rebuilt because of a
change to one of its dependent files. Let’s look at the first two rules the last two
are similar.

In the first rule, justify (the executable file) is the target:

justify: justify.o word.o line.o
gce -o justify justify.o word.o line.o

The first line states that justify depends on the files justify.o, word.o,
and 1ine.o; if any one of these three files has changed since the program was
last built, then Justify needs to be rebuilt. The command on the following line
shows how the rebuilding is to be done (by using the gcc command to link the
three object files).

In the second rule, justify. o is the target:

justify.o: justify.c word.h line.h
gce -c justify.c

The first line indicates that justify.o needs to be rebuilt if there’s been a
change to justify.c, word.h, or line.h. (The reason for mentioning
word.hand 1ine . h is that justify.c includes both these files, so it's poten-
tially affected by a change to either one.) The next line shows how to update
justify.o (by recompiling justify.c). The -c option tells the compiler 0
compile justify.c into an object file but not attempt to link it.

Once we've created a makefile for a program, we can use the make utility to
build (or rebuild) the program. By checking the time and date associated with each
Chapter 15  Writing Large Programs

file in the program, make can determine which files are out of date. It then invokes
the commands necessary to rebuild the program.
If you want to give make a try, here are a few details you'll need to know:

= Each command in a makefile must be preceded by a tab character, not a series
of spaces. (In our example, the commands appear to be indented eight spaces,
but it’s actually a single tab character.)

= A makefile is normally stored in a file named Makefile (or makefile).
When the make utility is used, it automatically checks the current directory
for a file with one of these names.

= To invoke make, use the command

make rarger

where targer is one of the targets listed in the makefile, To build the justify
executable using our makefile, we would use the command

make justify

» If no target is specified when make is invoked. it will build the target of the
fitst rule. For example. the command

make

will build the Justify executable, since justify is the first target in our
makefile. Except for this special property of the first rule, the order of rules in
a makefile is arbitrary.

make is complicated enough that entire books have been written about it, so
we won't attempt to delve further into its intricacies. Let’s just say that real make-
files aren’t usually as easy to understand as our example, There are numerous
techniques that reduce the amount of redundancy in makefiles and make them eas-
ier to modify; at the same time, though, these techniques greatly reduce their read-
ability.

Not everyone uses makefiles, by the way. Other program maintenance tools
are also popular, including the “project files" supported by some integrated devel-
opment environments.

Errors During Linking

Some errors that can’t be detected during compilation will be found during linking.
In particular, if the definition of a function or variable is missing from a program,
the linker will be unable to resolve external references to it, causing a message
such as “undefined symbol " or “undefined reference.”

Errors detected by the linker are usually easy to fix. Here are some of the most
COMMON Causes;

n Misspellings. 1f the name of a variable or function is misspelled, the linker
will report it as missing. For example, if the function read_char is defined
15.4 Building a Multiple-File Program 369

in the program but called as read cahr, the linker will report that
read_cahr is missing.

» Missing files. If the linker can’t find the functions that are in file foo. c, it
may not know about the file. Check the makefile or project file to make sure
that f00 . c is listed there.

w Missing libraries. The linker may not be able to find all library functions used
in the program. A classic example occurs in UNIX programs that use the
<math.h> header. Simply including the header in a program may not be
enough; many versions of UNIX require that the -1m option be specified
when the program is linked, causing the linker to search a system file that con-
tains compiled versions of the <math.h> functions. Failing to use this option
may cause “undefined reference” messages during linking.

Rebuilding a Program

During the development of a program, it's rare that we'll need to compile all its
files. Most of the time, we'll test the program, make a change, then build the pro-
gram again. To save time, the rebuilding process should recompile only those files
that might be affected by the latest change.

Let’s assume that we've designed our program in the way outlined in Section
15.3. with a header file for each source file. To see how many files will need to be
recompiled after a change, we need to consider two possibilities.

The first possibility is that the change affects a single source file. In that case,
only that file must be recompiled. (After that, the entire program will need to be
relinked, of course.) Consider the justify program. Suppose that we decide to
condense the read_char function in word. c (changes are marked in bold):

int read char (void)

{

int ch = getchar();

return (ch == '\m' || ch == '\t') ? ' * : ch;

}

This modification doesn't affect word.h, so we need only recompile word.c
and relink the program.

The second possibility is that the change affects a header file. In that case, we
should recompile all files that include the header file, since they could potentially
be affected by the change. (Some of them might not be, but it pays to be conserva-
tive.)

As an example, consider the read_word function in the justify program.
Notice that main calls strlen immediately after calling read_word, in order
to determine the length of the word that was just read. Since read word already
knows the length of the word (read_word’s pos variable keeps track of the
length), it seems silly to use strlen. Modifying read word to return the
word’s length is easy. First, we change the prototype of read_word in word. h:
370 Chapter 15 Wiriting Large Programs

D S

* read word: Reads the next word from the input and *
* stores it in word. Makes word empty if no i
* word could be read because of end-of-file. *
* Truncates the word if its length exceeds i
i len. Returns the number of characters i
= stored. x
B S P T P PSS ST Py

int read word(char *word, int len);

Of course, we're careful to change the comment that accompanies read word.
Next, we change the definition of read_woxrd in word. c:

int read word(char *word, int len)
int ch, pos = 0;

while ((ch = read char()) Y

while (ch 1= ' ' && ch = BOF) |

if (pos < len)
word [pos++] = ch;

ch = read char();

wordlpos] = '\0';
return pos;

}

Finally, we modify justify.c by removing the include of <string.h> and
changing main as follows:

int main(void)

{
char word [MAX WORD LEN+2] ;
int word len;

clear line();

fox (ra) |
word len = read word(word, MAX WORD LEN+1) ;
if (word len == 0)
flush line();
return 0;

if (word len > MAX WORD_LEN)
word [MAX WORD LEN] = '»!;

if (word len + 1 > space_remaining()) {
write line();
clear line();

add_word (word) ;
peedefined macros > 14.3

15.4 Building a Multiple-File Program 371

Once we've made these changes, we'll rebuild the justify program by recom-
piling word. c and justify . c and then relinking. There’s no need to recompile
line.c, which doesn't include word.h and therefore won't be affected by
changes to it. With the GCC compiler, we could use the following command to
rebuild the program:

gee -o justify justify.c word.c line.o

Note the mention of 1ine .o instead of line. c.

One of the advantages of using makefiles is that rebuilding is handled auto-
matically. By examining the date of each file, the make utility can determine
which files have changed since the program was last built. It then recompiles
these files, together with all files that depend on them, either directly or indirect-
ly. For example, if we make the indicated changes to word.h, word.c, and
Justify.c and then rebuild the justify program, make will perform the
following actions:

1. Build justify.o by compiling justify.c (because justify.cand
word . h were changed).

2. Build word.o by compiling word.c (because word.c and word.h
were changed).

3. Build justify by linking justify.o, word.o, and line.o
(because justify.oand word .o were changed).

Defining Macros Outside a Program

C compilers usually proyide some method of specifying the value of a macro at the
time a program is compiled. This ability makes it easy to change the value of a
macro without editing any of the program’s files. It's especially valuable when pro-
grams are built automatically using makefiles.

Most compilers (including GCC) support the -D option, which allows the
value of a macro to be specified on the command line:

gce -DDERUG=1 foo.c

In this example, the DEBUG macro is defined to have the value 1 in the program
foo. c, justas if the line

#define DEBUG 1

appeared at the beginning of foo.c. If the -D option names a macro without
specifying its value, the value is taken to be 1.

Many compilers also support the ~U option, which “undefines” a macro as if
by using #undef. We can use -U to undefine a predefined macro or one that was
defined earlier in the command line using -D.
372

Chapter 15 Writing Large Programs

Q&A

You don’t have any examples that use the #include directive to include a
source file. What would happen if we were to do this?

That’s not a good practice, although it’s not illegal. Here’s an example of the kind
of trouble you can get into. Suppose that foo . c defines a function f that we'll
need inbar. c and baz. c, so we put the directive

#include "foo.c!

in both bar . c and baz. c. Each of these files will compile nicely. The problem
comes later, when the linker discovers two copies of the object code for f. Of
course, we would have gotten away with including foo. c if only bar.c had
included it, not baz.c as well. To avoid problems, it's best (o use #include
only with header files, not source files.

What are the exact search rules for the #include directive? [p. 351]

That depends on your compiler. The C standard is deliberately vague in its deserip-
tion of #include. If the file name is enclosed in brackets, the preprocessor looks
in a “sequence of implementation-defined places,” as the standard obliquely puts
it. If the file name is enclosed in quoration marks, the file “is searched for in an
implementation-defined manner” and, if not found, then searched as if its name
had been enclosed in brackets. The reason for this walfling is simple: not all oper-
ating systems have hierarchical (tree-like) file systems,

To make matters even more interesting, the standard doesn’t require that
names enclosed in brackets be file names at all, leaving open the possibility that
#include directives using <> are handled entirely within the compiler.

T don’t understand why each source file needs its own header file. Why not
have one big header file containing macro definitions, type definitions, and
function prototypes? By including this file, each source file would have access
to all the shared information it needs. [p. 354]

The “one big header file” approach certainly works; a number of programmers use
it. And it does haye an advantage: with only one header file. there are fewer files to
manage. For large programs, however, the disadvantages of this approach tend to
outweigh its advantages.

Using a single header file provides no useful information to someone reading
the program later. With multiple header files, the reader can quickly see what other
parts of the program are used by a particular source file.

But that's not all. Since each source file depends on the big header file, chang-
ing it will cause all source files to be recompiled—a significant drawback in a large
program. To make matters worse, the header file will probably change frequently
because of the large amount of information it contains.
Exercises 373

Q: The chapter says that a shared array should be declared as follows:
extern int all;
Since arrays and pointers are closely related, would it be legal to write
extern int *a;

instead? [p. 356]

A:  No. When used in expressions, arrays “decay” into pointers. (We've noticed this
behavior when an array name is used as an argument in a function call) In variable
declarations, however, arrays and pointers are distinct types.

Q: Does it hurt if a source file includes headers that it doesn’t really need?

A:  Not unless the header has a declaration or definition that conflicts with one in the
source file. Otherwise, the worst that can happen is a minor increase in the time it
takes to compile the source file.

Q: I needed to call a function in the file foo.e, so I included the matching
header file, foo. h. My program compiled, but it won’t link. Why?

A:  Compilation and linking are completely separate in C. Header files exist to provide
information to the compiler, not the linker. If you want to call a function in foo. c,
then you have to make sure that f0o. c is compiled and that the linker is aware
that it must search the object file for foo.c to find the function. Usually this
means naming f0o. c in the program’s makefile or project file.

Q: If my program calls a function in <stdio.h>, does that mean that all func-
tions in <stdio.h> will be linked with the program?

A:  No. Including <stdio.h> (orany other header) has no effect on linking. In any
event, most linkers will link only functions that your program actually needs.

Q: Where can I get the make utility? [p. 367]

A: make is a standard UNIX utility. The GNU version, known as GNU Make, is
included in most Linux distributions. It's also available directly from the Free Soft-
ware Foundation (www.gnu.org/software/maker).

Exercises

Section 15.1 1. Section 15.1 listed several advantages of dividing a program into multiple source files.
(a) Describe several other advantages
(b) Describe some disadvantages.

Section 15.2 @ 2. Whichof the following should rot be put in 4 header file? Why not?

(a) Function prototypes
(b) Function definitions
374 Chapter 15 Writing Large Programs

(c) Macro definitions
(d) Type definitions

3. We saw that writing #include <file> instead of #include "file" may not work if file is
one that we've written. Would there be any problem with writing #include "file" instead
of #include <file> if file is a system header?

4. Assume that debug. h is a header file with the followi ng contents:

#ifdef DEBUG

fidefine PRINT DEBUG (n) printf("value of " #n ": %d\n", n)
fielse

#define PRINT DEBUG(n)

#endif

Let testdebug. < be the following source file:

#include <stdio.h>

#define DEBUG
#include "debug.h"

int main(void)
~{
dpt d = 1, Fie 2,0k - 3y

#ifdef DEBUG

printf ("Output if DEBUG is defined:\n");
#else

printf ("Output if DEBUG is not defined:\n");
#endif

PRINT_DEBUG (i) ;

PRINT_DEBUG (j) ;

PRINT_DEBUG (k) ;

PRINT DEBUG (1 + j);

PRINT DEBUG(2 * i + j - k);

return 0;

}

(@) What is the output when the program is executed?

(b) What is the output if the #define directive is removed from testdebug.c?

(c) Explain why the output is different in parts (a) and (b).

(d) Is it necessary for the DEBUG macro to be defined before debug . h is included in order
for PRINT_DEBUG (o have the desired effect? Justify your answer.

Section 15.4 5. Suppose that a program consists of three source files—main.c, f1.c, and f2 .c—plus
1wo header files, f1. h and f2 . h. All three source files include f1. h, but only f1. c and
f2.c include f2.h, Write a makefile for this program, assuming that the compiler is gcc
and that the executable file is to be named demo.

@ 6. The following questions refer to the program described in Exercise 5.
(a) Which files need to be compiled when the program is built for the first time?
(b) If f1.c is changed after the program has been built. which files need to be recompiled?
(c) If f1.his changed after the program has been built, which files need to be recompiled?
(d) Iff2.his changed after the program has been built, which files need to be recompiled?
o

Programming Projects 375

Programming Projects

The justify program of Section 15.3 justifies lines by inserting extra spaces between
words, The way the write_line function currently works, the words closer to the end of
aline tend to have slightly wider gaps between them than the words at the beginning. (For
example, the words closer to the end might have three spaces between them, while the
words closer to the beginning might be separated by only two spaces.) Improve the program
by having write_line alternate between putting the larger gaps at the end of the line and
putting them at the beginning of the line.

Modify the justify program of Section 15.3 by having the read word function
(instead of main) store the * character at the end of a word that’s been truncated.

Modify the gsort .c program of Section 9,6 so that the quicksort and split func-
tions are in a separate file named quicksort .c. Create a header file named quick-
sort.h that contains prototypes for the two functions and have both gsort.c and
quicksort . c include this file.

Modify the remind. c program of Section 13.5 so that the read line function is in a
separate file named readline. c. Create a header file named readline.h that contains
4 prototype for the function and have both remind. c and readline.c include this file.

Modify Programming Project 6 from Chapter 10 so that it has separate stack.h and
stack. c files, as described in Section 15.2.
16

16.1

Structures, Unions, and
Enumerations

Functions delay binding: data structures induce binding.
Moral: Structure data late in the programming process.

This chapter introduces three new types: structures, unions, and enumerations. A
structure is a collection of values (members), possibly of different types. A union
is similar to a structure, except that its members share the same storage: as a result,
a union can store one member at a time. but not all members simultaneously. An
enumeration is an integer type whose values are named by the programmer.

Of these three types, structures are by far the most important, so I'll devote
most of the chapter to them. Section 16.1 shows how to declare structure variables
and perform basic operations on them. Section 16.2 then explains how to define
structure types, which—among other things—allow us to write functions that
accept structure arguments or return structures. Section 16.3 explores how arrays
and structures can be nested. The last two sections are devoted to unions (Section
16.4) and enumerations (Section 16.5),

Structure Variables

The only data structure we've covered so far is the array. Arrays have two impor-
tant properties. First, all elements of an array haye the same type. Second, to select
an array element, we specify its position (as an integer subscript)

The properties of a structure are quite different from those of an array. The
elements of a structure (its members. in C parlance) aren’t required to have the
same type. Furthermore. the members of a structure have names: to select a partic-
ular member, we specify its name, not its position.

Structures may sound familiar, since most programming languages provide a
similar feature. In some languages, structures are called records, and members are
known as fields.

377
378

Chapter 16  Structures, Unions, and Enumerations

Declaring Structure Variables

When we need to store a collection of related data items, a structure is a logical
choice. For example, suppose that we need to keep track of parts in a warchouse.
The information that we'll need to store for each part might include a part number
(an integer), a part name (a string of characters), and the number of parts on hand
(an integer). To create variables that can store all three items of data, we might use
a declaration such as the following:

struect {
int number;
char name [NAME_LEN+1] ;
int on_hand;

} parti, part2;

Each structure variable has three members: number (the part number), name (the
name of the part), and on_hand (the quantity on hand). Notice that this declara-
tion has the same form as other variable declarations in C: struct { ... } specifies
atype, while part1 and part2 are variables of that type.

The members of a structure are stored in memory in the order in which they're
declared. In order to show what the part1 variable looks like in memory, let's
assume that (1) part1 is located at address 2000, (2) integers occupy four bytes,
(3) NAME_LEN has the value 25, and (4) there are no gaps between the members.
With these assumptions, part 1 will have the following appearance:

2000
2001 |
number
2002
2003
2004
name
2029
2030
2031
on_hand

2032

2033

16.1 Structure Variables 379

Usually it’s not necessary to draw structures in such detail. I'll normally show
them more abstractly, as a series of boxes:

number
name

on_hand |

1 may sometimes draw the boxes horizontally instead of vertically:

i e i

number name on_hand

Member values will go in the boxes later; for now, I've left them empty.

Each structure represents a new scope; any names declared in that scope won't
conflict with other names in a program. (In C terminology, we say that each struc-
ture has a separate name space for its members.) For example, the following decla-
rations can appear in the same program:

struct {
int number;
char name [NAME LEN+1] ;
int on_hand;

} partl, part2;

struct {
char name [NAME LEN+1];
int number;
char sex;

} employeel, employee2;

The number and name members in the part1 and part2 structures don’t con-
flict with the number and name members in employeel and employee2.

Initializing Structure Variables

Like an array, a structure variable may be initialized at the time it’s declared. To
initialize a structure, we prepare a list of values to be stored in the structure and
enclose it in braces:

struct {
int number;
char name [NAME LEN+1] ;
int on_hand;
} partl = {528, "Disk drive", 10},
part2 = {914, "Printer cable", 5};
380

Chapter 16

Structures, Unions, and Enumerations

The values in the initializer must appear in the same order as the members of the
structure. In our example, the number member of part1 will be 528, the name
member will be "Disk drive", and so on. Here's how part1 will look after
initialization:

—
number | 528
name |Disk drive

on_hand 10

Structure initializers follow rules similar to those for array initializers. Expres-
sions used in a structure initializer must be constant: for example, we couldn’t have
used a variable to initialize part1’s on_hand member. (This restriction is re-
laxed in C99, as we’ll see in Section 18.5.) An initializer can have fewer members
than the structure it’s initializing; as with arrays, any “leftover” members are given
0 as their initial value. In particular, the bytes in a leftover character array will be
zero, making it represent the empty string.

Designated Initializers

(C99's designated initializers, which were discussed in Section 8.1 in the context of
arrays, can also be used with structures. Consider the initializer for part1 shown
in the previous example:

{528, "Disk drive", 10}

A designated initializer would look similar, but with each value labeled by the
name of the member that it initializes:

{.number = 528, .name = "Disk drive", .on_hand = 10}

The combination of the period and the member name is called a designator. (Des-
ignators for array elements have a different form.)

Designated initializers have several advantages. For one, they're easier to read
and check for correctness, because the reader can clearly see the correspondence
between the members of the structure and the values listed in the initializer.
Another is that the values in the initializer don’t have to be placed in the same
order that the members are listed in the structure. Our example initializer could be
written as follows:

{.on_hand = 10, .name = "Disk drive", .number = 528)

Since the order doesn’t matter, the programmer doesn’t have to remember the
order in which the members were originally declared. Moreover, the order of
the members can be changed in the future without affecting designated initializ-
ers.
Ivalues >4.2

table of operators > Appendix A

16.1 Structure Variables ~ 381

Not all values listed in a designated initializer need be prefixed by a designa-

tor. (This is true for arrays as well. as we saw in Section 8.1.) Consider the follow-
ing example:
{.number = 528, "Disk drive", .on_hand = 10}

The value "Disk drive! doesn’t have a designator, so the compiler assumes
that it initializes the member that follows number in the structure, Any members
that the initializer fails to account for are set Lo zero.

Operations on Structures

Since the most common array operation is subscripting—selecting an element by
position—it’s not surprising that the most common operation on a structure is
selecting one of its members. Structure members are accessed by name, though,
not by position.

To access a member within a structure, we write the name of the structure first,
then a period, then the name of the member. For example, the following statements
will display the values of part1’s members:
printf("Part number: %d\n", partl.number);

printf ("Part name: %¥s\n", partl.name);
printf ("Quantity on hand: %d\n", partl.on hand);

The members of a structure are Ivalues, so they can appear on the left side of
an assignment or as the operand in an increment or decrement expression:

partl.number = 258; /* changes partl's part number */
partl.on_hand++; /* increments partl's gquantity on hand */

The period that we use to access a structure member is actually a C operator. It
has the same precedence as the postfix ++ and - - operators, so it takes precedence
over nearly all other operators. Consider the following example:

scanf ("%d", &partl.on hand);

The expression &partl.on_hand contains two operators (& and .). The .
operator takes precedence over the & operator, so & computes the address of
partl.on_hand, as we wished.

The other major structure operation is assignment:

part2 = partl;

The effect of this statement is to copy part1.number into part2.number,
partl.name into part2.name. and so on.

Since arrays can’t be copied using the = operator, it comes as something of a
surprise 1o discover that structures can. It's even more surprising when you con-
sider that an array embedded within a structure is copied when the enclosing struc-
ture is copied. Some programmers exploit this property by creating “dummy"
structures to enclose arrays that will be copied later:
382

Chapter 16  Structures, Unions, and Enumerations

16.2

QaA
type definitions »7.5

struct { int al10]; } a1, a2;
al = a2; /* legal, mince al and a2 are structures */

The = operator can be used only with structures of compatible types. Two
structures declared at the same time (as part1 and part2 were) are compatible.
As we'll see in the next section, structures declared using the same “structure tag"
or the same type name are also compatible.

Other than assignment, C provides no operations on entire structures. In par-
ticular, we can't use the == and | = operators to test whether two structures are
equal or not equal.

Structure Types

Although the previous section showed how to declare structure variables, it failed
to discuss an important issue: naming structure fypes. Suppose that a program
needs to declare several structure variables with identical members. If all the vari-
ables can be declared at one time, there’s no problem. But if we need to declare the
variables at different points in the program. then life becomes more difficult. If we
write

struct {
int number;
char name [NAME LEN+1] ;
int on_hand;

} parti;

in one place and

struct {
int number;
char name [NAME LEN+1] ;
int on_hand;

} part2;

in another, we'll quickly run into problems. Repeating the structure information
will bloat the program, Changing the program later will be risky, since we can't
easily guarantee that the declarations will remain consistent.

But those aren't the biggest problems. According to the rules of C, parti
and part2 don't have compatible types. As a result, part1 can’t be assigned to
part2, and vice versa. Also, since we don’t have a name for the type of part1 or
part2, we can’t use them as arguments in function calls.

To avoid these difficulties, we need to be able to define a name that represents
a type of structure, not a particular structure variable. As it turns out, C provides
two ways to name structures: we can either declare a “‘structure tag” or use
typedef to define a type name.
16.2 Structure Types ~ 383

Declaring a Structure Tag

A structure fag is a name used to identify a particular kind of structure. The fol-
lowing example declares a structure tag named part:

struct part {
int number;
char name [NAME_LEN+1] ;
int on_hand;

bi

Notice the semicolon that follows the right brace—it must be present to terminate
the declaration.

entally omitting the semicolon at the end of a structure declaration can cause
g errors. Consider the following example:

struct part {
int number;
char name [NAME_LEN+1] ;
int on_hand;
} /*** WRONG: semicolon missing *#**/

f (void)

{

return 0; /* error detected at this line */

The programmer failed to specify the return type of the function f (a bit of sloppy
programming). Since the preceding structure declaration wasn't terminated prop-
erly, the compiler assumes that f returns a value of type struct part. The error
won't be detected until the compiler reaches the first `return` statement in the
function. The result: a cryptic error message.

Once we've created the part tag, we can use it to declare variables:
struct part partl, part2;
Unfortunately, we can’t abbreviate this declaration by dropping the word struct:
part partl, part2; [*** WRONG *#*+/

part isn’t a type name; without the word struct, it is meaningless.

Since structure tags aren’t recognized unless preceded by the word struct,
they don’t conflict with other names used in a program. It would be perfectly legal
(although more than a little confusing) to have a variable named part.

Incidentally, the declaration of a structure tag can be combined with the decla-
ration of structure variables:
384 Chapter 16  Structures, Unions, and Enumerations

linikes lists 3175

struct part {
int number;
char name [NAME LEN+1];

int on_hand;
} parti, part2;

Here, we've declared a structure tag named part (making it possible to use part
later to declare more variables) as well as variables named part1 and part2.

All structures declared to have type struct part are compatible with one
another:

struct part partl = {528, "Disk drive", 10};
struct part part2;

part2 = partl; /* legal; both parts have the same type */

Defining a Structure Type

As an alternative to declaring a structure tag, we can use typedef to define a
genuine type name. For example, we could define a type named Part in the fol-
lowing way:
typedef struet {

int number;

char name [NAME LEN+1] ;

int on_hand;
} Part;

Note that the name of the type. Part, must come at the end, not after the word
struct.

We can use Part in the same way as the built-in types. For example, we
might use it to declare variables:

Part partl, part2;

Since Part is a typedef name, we're not allowed to write struct Part. All
Part variables, regardless of where they’re declared, are compatible.

When it comes time to name a structure, we can usually choose either to
declare a structure tag or to use typedef. However. as we'll see later, declaring a
structure tag is mandatory when the structure is to be used in a linked list. I'll use
structure tags rather than typedef names in most of my examples.

Structures as Arguments and Return Values

Functions may have structures as arguments and return values. Let’s look at two
examples. Our first function, when given a part structure as its argument, prints
the structure’s members:

void print part(struct part p)

{

printf ("Part number: %%d\n", p.number);
FILE type »22.1

16.2 Structure Types 385

printf ("Part name: %s\n", p.name);
printf ("Quantity on hand: %d\n", p.on_hand);

}

Here's how print_part might be called:
print_part (partl);
Qur second function returns a part structure that it constructs from its arguments:

struct part build part(int number, const char *name,
int on_hand)
{

struct part p;

p-number = number;
strcpy(p.name; name);
p.on_hand = on_hand;
return p;

}

Notice that it’s legal for build part’s parameters to have names that match the
members of the part structure, since the structure has its own name space. Here's
how build part might be called:

partl = build part(528, "Disk drive", 10);

Passing a structure to a function and returning a structure from a function both
require making a copy of all members in the structure. As a result. these operations
impose a fair amount of overhead on a program, especially if the structure is large.
To avoid this overhead, it’s sometimes advisable to pass a pointer to a structure
instead of passing the structure itself. Similarly, we might have a function return a
pointer to a structure instead of returning an actual structure. Section 17.5 gives
examples of functions that have a pointer to a structure as an argument and/or
return a pointer to a structure.

There are other reasons to avoid copying structures besides efficiency. For
example, the <stdio.hs header defines a type named FILE. which is typically a
structure. Each FILE structure stores information about the state of an open file
and therefore must be unique in a program. Every function in <stdio.hs that
opens a file returns a pointer to a FILE structure, and every function that performs
an operation on an open file requires a FILE pointer as an argument.

On occasion, we may want to initialize a structure variable inside a function to
match another structure, possibly supplied as a parameter to the function. In the
following example, the initializer for part 2 is the parameter passed to the f func-
tion:

void ff(struct part partl)

struct part part2 = partl;

}
386 Chapter 16  Structures, Unions, and Enumerations

automatic storage duration > 10.1

@@

16.3

C permits initializers of this kind, provided that the structure we’re initializing
(part2, in this case) has automatic storage duration (it’s local to a function and
hasn’t been declared static). The initializer can be any expression of the proper
type, including a function call that returns a structure.

Compound Literals

Section 9.3 introduced the C99 feature known as the compound literal. In that sec-
tion, compound literals were used to create unnamed arrays, usually for the pur-
pose of passing the array to a function. A compound literal can also be used to
create a structure “on the fly,” without first storing it in a variable. The resulting
structure can be passed as a parameter, returned by a function, or assigned to a
variable. Let's look at a couple of examples.

First, we can use a compound literal to create a structure that will be passed to
a function. For example, we could call the print_part function as follows:

print_part ( (struct part) {528, "Disk drive", 10});

The compound literal (shown in bold) creates a part structure containing the
members 528, "Disk drive", and 10, in that order. This structure is then passed
to print_part, which displays it.

Here's how a compound literal might be assigned 1o a variable:

partl = (struct part) {528, "Disk drive", 10};

This statement resembles a declaration containing an initializer, but it’s not the
same—initializers can appear only in declarations, not in statements such as this
one.

In general, a compound literal consists of a type name within parentheses, fol-
lowed by a set of values enclosed by braces. In the case of a compound literal that
represents a structure, the type name can be a structure tag preceded by the word
struct—as in our examples—or a typedef name. A compound literal may
contain designators, just like a designated initializer:

print_part ((struct part) {.on hand = 10,
.name = "Disk drive",
.number = 528});

A compound literal may fail to provide full initialization, in which case any unini-
tialized members default to zero.

Nested Arrays and Structures

Structures and arrays can be combined without restriction. Arrays may have struc-
tures as their elements, and structures may contain arrays and structures as mem-
bers, We've already seen an example of an array nested inside a structure (the
16.3 Nested Arrays and Structures 387

name member of the part structure). Let's explore the other possibilities: struc-
tures whose members are structures and arrays whose elements are structures.

Nested Structures

Nesting one kind of structure inside another is often useful. For example, suppose
that we’ve declared the following structure, which can store a person’s first name,
middle initial, and last name:

struct person_name {
char first [FIRST NAME LEN+1];
char middle initial;
char last[LAST NAME LEN+1];

)
‘We can use the person_name structure as part of a larger structure:

struct student {
struct person name name;
int id, age;
char sex;

} studentl, student2;

Accessing student1’s first name, middle initial, or last name requires two appli-
cations of the . operator:

strcpy (studentl.name.first, "Fred");

One advantage of making name a structure (instead of having first,
middle initial, and last be members of the student structure) is that
we can more easily treat names as units of data. For example, if we were to
write a function that displays a name. we could pass it just one argument—a
person_name structure—instead of three arguments:

display_name (studentl.name) ;

Likewise, copying the information from a person_name structure to the name
member of a student structure would take one assignment instead of three:

struct person name new name;

studentl.name = new_name;

Arrays of Structures

One of the most common combinations of arrays and structures is an array whose
elements are structures. An array of this kind can serve as a simple database. For
example, the following array of part structures is capable of storing information
about 100 parts:

struct part inventory[100];
388

Chapter 16  Structures, Unions, and Enumerations

To access one of the parts in the array, we'd use subscripting. To print the part
stored in position i, for example, we could write

print_part (inventory([i]);

Accessing a member within a part structure requires a combination of sub-
scripting and member selection. To assign 883 to the number member of
inventory[i], we could write

inventory[i] .number = 883;

Accessing a single character in a part name requires subscripting (to select a par-
ticular part), followed by selection (to select the name member), followed by sub-
scripting (to select a character within the part name). To change the name stored in
inventory[di] toan empty string, we could write

inventory[i] .name[0] = '\0';

Initializing an Array of Structures

Initializing an array of structures is done in much the same way as initializing 4
multidimensional array. Each structure has its own brace-enclosed initializer; the
initializer for the array simply wraps another set of braces around the structure ini-
tializers.

One reason for initializing an array of structures is that we're planning to treat
it as a database of information that won't change during program execution. For
example, suppose that we're working on a program that will need access to the
country codes used when making international telephone calls. First, we’ll setup a
structure that can store the name of a country along with its code:

struct dialing code {
char *country;
int code;

}i

Note that country is a pointer, not an array of characters. That could be a prob-
lem if we were planning to use dialing code structures as variables, but we're
not. When we initialize a dialing_code structure, country will end up
pointing to a string literal.

Next. we'll declare an array of these structures and initialize it to contain the
codes for some of the world’s most populous nations:

const struct dialing_code country codes[] =

{{"argentina", 54}, {"Bangladesh", 880},
{"Braziln, 55}, {"Burma (Myanmar)", 95},
{"China", 86}, {"Colombia", 57},
{"Congo, Dem. Rep. of", 243}, {"Egypt", 20},
{"Ethiopia", 251}, {"France", I
{"Germany", 49}, {"India", o1},
PROGRAM

16.3 Nested Arrays and Structures 389

{*Indonesia", 62}, [rzran®, 98},
{"Italy", 39}, {"Japan", 81},
{"Mexico", 52}, {"Nigeria", 234},
{"Pakistan", 92}, {"Philippines", 63},
"Poland", 48}, {"Russia", Tk
%“South Africa", 27;, %"South Korea'", 52%,
{v"spain", 34}, {"Sudan", 249},
{"Thailand", 66}, {"Turkey", 90},
{"Ukraine", 380}, {"United Kingdom", 44},
{"United States", 1}, {"Vietnam", 84}};

The inner braces around each structure value are optional. As a matter of style,
however, I prefer not to omit them.

Because arrays of structures (and structures containing arrays) are so com-
mon, C99's designated initializers allow an item to have more than one designator.
Suppose that we want to initialize the inventoxry array to contain a single part.
The part number is 528 and the quantity on hand is 10, but the name is to be left
empty for now:

struct part inventory[100] =
{10] .number = 528, [0].on hand = 10, [0].namef0] = '\0'};

The first two items in the list use two designators (one to select array element 0—
a part structure—and one to select a member within the structure). The last item
uses three designators: one to select an array element, one to select the name
member within that element, and one to select element 0 of name.

Maintaining a Parts Database

To illustrate how nested arrays and structures are used in practice, we'll now
develop a fairly long program that maintains a database of information about parts
stored in a warchouse. The program is built around an array of structures, with
each structure containing information—part number, name, and quantity—about
one part. Our program will support the following operations:

u Add a new part number, part name, and initial quantity on hand. The pro-
gram must print an error message if the part is already in the database or if the
database is full.

n Given a part number, print the name of the part and the current quantity on
hand. The program must print an error message if the part number isn’t in the
database.

u Given a part number, change the quantity on hand. The program must print
an error message if the part number isn’t in the database.

w Prini a table showing all information in the database. Parts must be dis-
played in the order in which they were entered.

u Terminate program execution.
390 Chapter 16  Structures, Unions, and Enumerations

We'll use the codes i (insert), s (search), u (update), p (print), and g (quit) to rep-
resent these operations. A session with the program might look like this:

Enter operation code:
Enter part number: 528

Enter part name: Disk drive
Enter guantity on hand: 10

Enter operation code:
Enter part number: 528
Part name: Disk drive
Quantity on hand: 10

Enter operation code:
Enter part number: 914
Part not found.

Enter operation code: i
Enter part number: 914
Enter part name: Printer cable

Enter quantity on hand: 5

Enter operation code: u
Enter part number: 5
Enter change in quantity on hand: -2

Enter operation code: s
Enter part number: 528
Part name: Disk drive
Quantity on hand: 8

Enter operation code: p

Part Number Part Name Quantity on Hand
528 Digk drive 8
914 Printer cable 5

Enter operation code: g

The program will store information about each part in a structure. We'll limit
the size of the database to 100 parts, making it possible to store the structures in ar
array, which I'll call inventory. (If this limit proves to be too small, we can
always change it later.) To keep track of the number of parts currently stored in the
array, we'll use a variable named num_parts.

Since this program is menu-driven, it’s fairly easy to sketch the main loop:

for bz

prompt user to enter operation code ;

read code ;

switch (code) {
case 'i': perform insert operation; break;
cage 'g': perform search operation; break;
case 'u': perform update operation; break;
case 'p': perform print operation; break;
inventory.c

16.3 Nested Arrays and Structures 391

case 'q': terminate program;
default: print error message;

}
}

It will be convenient to have separate functions perform the insert, search,
update, and print operations. Since these functions will all need access to
inventory and num_parts. we might want to make these variables external.
As an alternative, we could declare the variables inside main, and then pass them
to the functions as arguments. From a design standpoint, it’s usually better to make
variables local to a function rather than making them external (see Section 10.2 if
you've forgotten why). In this program, however, putting inventory and
num_parts inside main would merely complicate matters.

For reasons that I'll explain later, I've decided to split the program into three
files: inventory.c, which contains the bulk of the program: readline.h,
which contains the prototype for the read_line function; and readline.c,
which contains the definition of read line. We'll discuss the latter two files
later in this section. For now, let’s concentrate on inventory.c.

/* Maintains a parts database (array version) */

#include <stdio.h>
#include "readline.h"

#define NAME_LEN 25
#define MAX PARTS 100

struct part {
int number;
char name [NAME LEN+1];
int on_hand;

} inventory[MAX PARTS] ;

int num_parts = 0; /* number of parts currently stored */

int find part (int number) ;
void insert (void) ;
void search (void) ;
void update (void) ;
void print(void);

d T e T

* main: Prompts the user to enter an cperation code, B
* then calls a function to perform the requested *
& action. Repeats until the user enters the *
* command 'g'. Prints an error message if the user *
* enters an illegal code. *
T T T

i
int main(void)

char code;
392 Chapter 16  Structures, Unions, and Enumerations

Tors L)
printf ("Enter operation code: ");
scanf (" $c", &code) ;
while (getchar() != '\n') /* skips to end of line */
switch (code) {
case 'i': insert();
break;
case 's': search();
break;
case 'u': update();
break;
case 'p': print();
break;
case 'q': return 0;
default: printf("Illegal code\n");

printf ("\n");
}
}

B e S

* find part: Looks up a part number in the inventory *
* array. Returns the array index if the part *
* number is found; otherwise, returns -1. A

B e e )
int find part(int number)

{

Ant.d;

for (i = 0; i < num_parts; i++)
if (inventory(i].number == number)
return i;
return -1;

R e

* insert:; Prompts the user for information about a new *
* part and then inserts the part into the *
* database. Prints an error megsage and returns *
¥ prematurely if the part already exists or the *
% database is full. *
B e )

void insert (void)
int part number;
if (num_parts == MAX PARTS) {

printf ("Database is full; can't add more parts.\n");
return;

printf ("Enter part number: ");
scanf ("%d", &part number);
}

16.3 Nested Arrays and Structures

if (find_part (part_number) >= 0) {
printf ("Part already exists.\n");
return;

inventory [num parts] .number = part number;
printf ("Enter part name: ");

read line (inventory [num parts] .name, NAME LEN) ;
printf ("Enter quantity on hand: ");

scanf ("%d", &inventory[num parts].on hand) ;
num_parts++;

393

Rk ok ok kR kR Rk ek R R Rk Rk ke

i if not, prints an error message.
Kk ke ke ok ko R R AR AR AR R KRR AR AR AR R AR AR KA A NN

void search(void)

{

}

int i, number;

printf ("Enter part number: ");
scanf ("%d", &number);
i = find part (number) ;
if (i >= 0) {
printf ("Part name: %$s\n", inventory[i] .name);

* search: Prompts the user to enter a part number, then *
# looks up the part in the database. If the part *
* exists, prints the name and quantity on hand; *

*

printf ("Quantity on hand: %d\n", inventoryl[i].on hand) ;

} else
printf ("Part not found.\n");

Rk Rk kR ke ek ks oK R KRR R R R

%

* ok ok

update: Prompts the user to enter a part number.
Prints an error message if the part doesn't
exist; otherwise, prompts the user to enter
change in quantity on hand and updates the
database.

Ak ko ke kR ok R ek Rk ke ok ok ok ke ke ke k ok Rk R kR Rk Rk R Rk

void update (void)

{

int i, number, change;

printf ("Enter part number: ");
scanf ("%d", &number) ;
i = find part (number) ;
if (1 >= 0)
printf ("Enter change in guantity on hand: ");
scanf ("%d", &change) ;
inventory[i] .on_hand += change;
} else
printf ("Part not found.\n");

*
*
*
*
*

/
394

Chapter 16  Structures, Unions, and Enumerations

J e
* print: Prints a listing of all parts in the database,

i showing the part number, part name, and *.
3 quantity on hand. Parts are printed in the *
* order in which they were entered into the *
2 database. ¥
ok kKRR Rk Kk KKKk R kR kR R R R Rk R R kR ke ek [

void print (void)

{

it dg

printf ("Part Number Part Name t
"Quantity on Hand\n');
for (i = 0; i < num parts; i++)
printf ("$7d %-258%11d\n", inventory[i] .number,
inventory[i] .name, inventory[i].on hand) ;

In the `main` function, the format string " %c" allows scanf to skip over
white space before reading the operation code. The space in the format string is
crucial; without it, scanf would sometimes read the new-line character that ter-
minated a previous line of input.

The program contains one function, find part, that isn’t called from
main. This “helper” function helps us avoid redundant code and simplify the
more important functions. By calling find_part, the insert, search, and
update functions can locate a part in the database {or simply determine if the
part exists).

There’s just one detail left: the read 1ine function, which the program uses
to read the part name. Section 13.3 discussed the issues that are involved in writing
such a function. Unfortunately, the version of read line in that section won't
work properly in the current program. Consider what happens when the user
inserts a part:

Enter part number: 528
Enter part name: Disk drive

The user presses the Enter key after entering the part number and again after enter-
ing the part name. each time leaving an invisible new-line character that the pro-
gram must read. For the sake of discussion, let’s pretend that these characters are
visible:

Enter part number: 5289
Enter part name: Disk drived

When we call scanf to read the part number. it consumes the 5. 2, and 8, but
leaves the @ character unread. If we try to read the part name using our original
read_line function, it will encounter the @ character immediately and stop
reading. This problem is common when numerical input is followed by character
input, Our solution will be to write a version of read line that skips white-
readline.h

readline.c

isspace function »23.5

16.3 Nested Arrays and Structures 395

space characters before it begins storing characters. Not only will this solve the
new-line problem, but it also allows us to avoid storing any blanks that precede the
part name.

Since read_1line is unrelated to the other functions in inventory.c, and
since it’s potentially reusable in other programs, I've decided to separate it from
inventory.c. The prototype for read line will go in the readline.h
header file:

#ifndef READLINE H
#idefine READLINE H

e

* read line: Skips leading white-space characters, then *
* reads the remainder of the input line and *
* stores it in str. Truncates the line if its *
5 length exceeds n. Returns the number of ke
& characters stored. P
B L L T e

int read line(char str(], int n);
#endif

‘We'll put the definition of read_1ine in the readline. c file:
#include <ctype.hs

#include <stdio.h>

#include "readline.h!

int read line(char str(], int n)

j

int ch, i 0;
while (isspace(ch = getchar()))

while (ch

t= '\n' && ch != EOF) {
CTI ]
str[i++] = ch;

ch = getchar();

str[i] = '\o';
return i;

}
The expression
isspace (ch = getchar())

controls the first `while` statement. This expression calls getchar to read achar-
acter, stores the character into ch, and then uses the isspace function to test
whether ch is a white-space character. If not. the loop terminates with ch contain-
ing a character that’s not white space. Section 15.3 explains why ch has type int
instead of char and why it’s good to test for EOF.
396

Chapter 16  Structures, Unions, and Enumerations

16.4 Unions

A union, like a structure, consists of one or more members, possibly of different
types. However, the compiler allocates only enough space for the largest of the
members, which overlay each other within this space. As a result, assigning a new
value to one member alters the values of the other members as well.

To illustrate the basic properties of unions, let’s declare a union variable, u,
with two members:

union {
i
double d;
} u;

Notice how the declaration of a union closely resembles a structure declaration:

struct {
int: 1
double d;
Jos:

In fact, the structure s and the union u differ in just one way: the members of s are
stored at different addresses in memory, while the members of u are stored at the
same address. Here's what s and u will look like in memory (assuming that int
values require four bytes and double values take eight bytes):

Structure Union

16.4 Unions 397

In the s structure, 1 and d occupy different memory locations: the total size of s is
12 bytes. In the u union, i and & overlap (1 is really the first four bytes of d), sou
occupies only eight bytes. Also, 1 and d have the same address.

Members of a union are accessed in the same way as members of a structure.
To store the number 82 in the 1 member of u, we would write

u.i = 82;
To store the value 74.8 in the d member, we would write
u.d = 74.8;

Since the compiler overlays storage for the members of a union, changing one
member alters any value previously stored in any of the other members. Thus, if
we store a value in u.d. any value previously stored in u.1 will be lost. (If we
examine the value of u. 1, it will appear to be meaningless.) Similarly, changing
u. i corrupts u.d. Because of this property, we can think of u as a place to store
either 1 or d. not both. (The structure s allows us to store i and d.)

The properties of unions are almost identical to the properties of structures.
We can declare union tags and union types in the same way we declare structure
tags and types. Like structures, unions can be copied using the = operator, passed
to functions, and returned by functions.

Unions can even be initialized in a manner similar to structures, However,
only the first member of a union can be given an initial value. For example, we can
initialize the i member of u to 0 in the following way:

union {
intidy
double d;

}u= {o}s

Notice the presence of the braces, which are required. The expression inside the
braces must be constant. (The rules are slightly different in C99, as we'll see in
Section 18.5.)

Designated initializers, a C99 feature that we’ve previously discussed in the
context of arrays and structures, can also be used with unions. A designated initial-
izer allows us to specify which member of a union should be initialized. For exam-
ple, we can initialize the d member of u as follows:

union {
int 1;
double d;

}u=da= 100}

Only one member can be initialized, but it doesn’t have to be the first one.

There are several applications for unions. We'll discuss two of these now.
Another application—viewing storage in different ways—is highly machine-
dependent, so I'll postpone it until Section 20.3.
398 Chapter 16  Structures, Unions, and Enumerations

Using Unions to Save Space

We'll often use unions as a way to save space in structures. Suppose that we're
designing a structure that will contain information about an item that's sold
through a gift catalog. The catalog carries only three kinds of merchandise: books,
mugs, and shirts. Each item has a stock number and a price, as well as other infor-
mation that depends on the type of the item:

Boaks: Title, author, number of pages
Mugs: Design
Shirts: Design, colors available, sizes available ‘

Our first design attempt might result in the following structure:

struct catalog_item {
int stock_number;
double price;
int item_type;
char title[TITLE LEN+1]
char author [AUTHOR LEN+1] ;
int num pages;
char design[DESIGN LEN+1];
int colors;
int sizes;

bi

The item type member would have one of the values BCOK, MUG, or SHIRT.
The colors and sizes members would store encoded combinations of colors
and sizes.

Although this structure is perfectly usable, it wastes space, since only part of
the information in the structure is common to all items in the catalog, If an item is
a book, for example, there's no need to store design, colors, and sizes. By
putting a union inside the catalog item structure, we can reduce the space
required by the structure. The members of the union will be structures, each con-
taining the data that’s needed for a particular kind of catalog item:

struct catalog item {
int stock_number;
double price;
int item type;
union {
struct {
char title [TITLE LEN+1] ;
char author [AUTHOR LEN+1] ;
int num pages;
} book;
struct {
char design[DESIGN LEN+1];
} mug;
16.4 Unions 399

struct |
char design[DESIGN LEN+1];
int colors;
int sizes;
} shirt;
} item;

}i

Notice that the union (named item) is a member of the catalog item
structure, and the book, mug, and shirt structures are members of item. If c is
acatalog_item structure that represents a book, we can print the book’s title in
the following way:

printf("$s", c.item.book.title);

As this example shows, accessing a union that’s nested inside a structure can be
awkward: to locate a book title, we had to specify the name of a structure (c), the
name of the union member of the structure (i tem), the name of a structure mem-
ber of the union (book), and then the name of a member of that structure (title).

We can use the catalog_item structure to illustrate an interesting aspect of
unions. Normally, it's not a good idea to store a value into one member of a union
and then access the data through a different member, because assigning to one
member of a union causes the values of the other members to be undefined. How-
ever, the C standard mentions a special case: two or more of the members of the
union are structures, and the structures begin with one or more matching members.
(These members need to be in the same order and have compatible types, but need
not have the same name.) If one of the structures is currently valid, then the match-
ing members in the other structures will also be valid.

Consider the union embedded in the catalog_item structure. It contains
three structures as members, two of which (mug and shirt) begin with a match-
ing member (design). Now, suppose that we assign a value to one of the
design members:

strcpy (c.item.mug.design, "Cats");
The design memberin the other structure will be defined and have the same value:

printf ("%$s", c.item.shirt.design); /* prints "Cats" */

Using Unions to Build Mixed Data Structures

Unions have another important application: creating data structures that contain a
mixture of data of different types. Let's say that we need an array whose elements
are a mixture of int and double values. Since the elements of an array must be
of the same type, it seems impossible to create such an array. Using unions,
though, it’s relatively easy. First, we define a union type whose members represent
the different kinds of data to be stored in the array:
400 Chapter 16  Structures, Unions, and Enumerations

typedef union {
dnt i:
double d;

} Number;

Next, we create an array whose elements are Number values:
Number number array[1000] ;

Each element of number_array is a Number union. A Number union can
store either an int value or a double value, making it possible to store a mixture
of int and double values in number array. For example, suppose that we
want element 0 of number array to store 5, while element 1 stores 8.395. The
following assignments will have the desired effect:

number array[0].i = 5;
number array[1].d = 8.395;

Adding a “Tag Field” to a Union

Unions suffer from a major problem: there’s no easy way to tell which member of
a union was last changed and therefore contains a meaningful value. Consider the
problem of writing a function that displays the value currently stored in a Number
union. This function might have the following outline:

void print_number (Number n)

if (n contains an integer)
printf(*%d", n.i);
else
printf ("%g", n.d);
}

Unfortunately, there’s no way for print number to determine whether n con-
tains an integer or a floating-point number.

In order to keep track of this information, we can embed the union within
structure that has one other member: a “tag field” or “discriminant,” whose pur-
pose is to remind us what’s currently stored in the union. In the catalog_iten
structure discussed earlier in this section, item_type served this purpose.

Let’s convert the Number type into a structure with an embedded union:

#define INT KIND 0
#define DOUBLE_KIND 1

typedef struct {
int kind; /* tag field */
union {
ine i
double d;
} ui
} Number;
16.5

16.5 Enumerations 401

Number has two members, kind and u. The value of kind will be either
INT_KIND or DOUBLE_KIND.

Each time we assign a value to a member of u, we'll also change kind to
remind us which member of u we modified. For example, if n is a Number vari-
able, an assignment to the 1 member of u would have the following appearance:

n.kind = INT_KIND;
n.u.i = 82;

Notice that assigning to i requires that we first select the u member of n, then the
1 member of u.

‘When we need to retrieve the number stored in a Number variable, kind will
tell us which member of the union was the last to be assigned a value. The
print_number function can take advantage of this capability:

void print_number (Number n)

{
if (n.kind INT_KIND)
printf(irar, niacd)s
else

printf (*%g", n.u.d);

1t's the program’s responsibility to change the tag field each time an assignment is
made to a member of the union.

Enumerations

In many programs, we'll need variables that have only a small set of meaningful
values. A Boolean variable, for example, should have only two possible values:
“true” and “false.” A variable that stores the suit of a playing card should have only
four potential values: “clubs.” “diamonds.” “hearts,” and “spades.” The obvious
way to deal with such a variable is to declare it as an integer and have a set of codes
that represent the possible values of the variable:

int s; /* s will store a suit */

s

2;  /* 2 represents "hearts" */

Although this technique works, it leaves much to be desired. Someone reading the
program can't tell that s has only four possible values, and the significance of 2
isn’t immediately apparent.

Using macros to define a suit “type” and names for the various suits is a step
in the right direction:
402

Chapter 16  Structures, Unions, and Enumerations

#define SUTT
ftdefine CLUBS

int
]
#define DIAMONDS 1
2
3

#define HEARTS
#define SPADES

Our previous example now becomes easier to read:

SUIT s;

s = HEARTS;

This technique is an improvement, but it’s still not the best solution. There’s no
indication to someone reading the program that the macros represent values of the
same “type.” If the number of possible values is more than a few, defining a sepa-
rate macro for each will be tedious. Moreover, the names we've defined—CLUBS,
DIAMONDS, HEARTS, and SPADES—will be removed by the preprocessor, so
they won't be available during debugging.

C provides a special kind of type designed specifically for variables that have
a small number of possible values. An enumerated type is a type whose values are
listed (“enumerated”) by the programmer, who must create a name (an enumera-
tion constant) for each of the values. The following example enumerates the val-
ues (CLUBS, DIAMONDS, HEARTS, and SPADES) that can be assigned to the
variables s1 and s2:

enum {CLUBS, DIAMONDS, HEARTS, SPADES} sl, s2;

Although enumerations have little in common with structures and unions, they’re
declared in a similar way. Unlike the members of a structure or union, however, the
names of enumeration constants must be different from other identifiers declared
in the enclosing scope.

Enumeration constants are similar to constants created with the #define
directive, but they’re not equivalent. For one thing, cnumeration constants are sub-
jeet to C’s scope rules: if an enumeration is declared inside a function, its constants
won'’t be visible outside the function.

Enumeration Tags and Type Names

We'll often need to create names for enumerations, for the same reasons that we
name structures and unions. As with structures and unions, there are two ways to
name an enumeration: by declaring a tag or by using typedef to create a genuine
type name.

Enumeration tags resemble structure and union tags. To define the tag suit,
for example, we could write

enum suit {CLUBS, DIAMONDS, HEARTS, SPADES};
suit variables would be declared in the following way:

enum suit s1, s2;
16.5 Enumerations 403

As an alternative, we could use typedef to make Suit atype name:

typedef enum {CLUBS, DIAMONDS, HEARTS, SPADES} Suit;
Suit s1, s2;

In C89, using typedef to name an enumeration is an excellent way to create
a Boolean type:

typedef enum {FALSE, TRUE} Bool;

(C99 has a built-in Boolean type, of course, so there’s no need for a C99 program-
mer to define a Bool type in this way.

Enumerations as Integers

Behind the scencs, C treats enumeration variables and constants as integers. By
default, the compiler assigns the integers 0, |, 2, ... to the constants in a particular
enumeration. In our suit enumeration, for example, CLUBS, DIAMONDS,
HEARTS, and SPADES represent 0, 1, 2, and 3, respectively.

We're free to choose different values for enumeration constants if we like.
Let’s say that we want CLUBS, DIAMONDS, EEARTS, and SPADES to stand for 1,
2, 3, and 4. We can specify these numbers when declaring the enumeration:

enum suit {CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4};

The values of enumeration constants may be arbitrary integers, listed in no particu-
lar order:

enum dept {RESEARCH = 20, PRODUCTION = 10, SALES = 25};

It’s even legal for two or more enumeration constants (o have the same value.

When no value is specified for an enumeration constant, its value is one
greater than the value of the previous constant. (The first enumeration constant has
the value 0 by default.) In the following enumeration, BLACK has the value 0,
LT _GRAY is 7, DK_GRAY is 8, and WHITE is 15:

enum EGA_colors {BLACK, LT GRAY = 7, DK _GRAY, WHITE = 15};

Since enumeration values are nothing but thinly disguised integers, C allows
us to mix them with ordinary integers:
int i;
enum {CLUBS, DIAMONDS, HEARTS, SPADES} s;

3. DIAMONDS ; J/* 1 isi now 1 i
s = 0; /* s is now 0 (CLUBS) */
sS4+ /* s is now 1 (DIAMONDS) */
iR 2y %=L g inow: 3 xf

The compiler treats s as a variable of some integer type; CLUBS, DIAMONDS,
HEARTS, and SPADES are just names for the integers 0, 1, 2, and 3.
404

Chapter 16  Structures, Unions, and Enumerations

A

Although it’s convenient to be able to use an enumeration value as an integer, it’s
dangerous to use an integer as an enumeration value. For example, we might acci-
dentally store the number 4—which doesn’t correspond to any suit—into s.

Using Enumerations to Declare “Tag Fields”

Enumerations are perfect for solving a problem that we encountered in Section
16.4: determining which member of a union was the last to be assigned a value. Tn
the Number structure, for example, we can make the kind member an cnumera-
tion instead of an int:

typedef struct {
enum {INT KIND, DOUBLE_KIND} kind;
union {
int i;
double 4;
) wg
} Number;
The new structure is used in exactly the same way as the old one. The advantages
are that we've done away with the INT_XIND and DOUBLE_KIND macros
(they’re now enumeration constants), and we've clarified the meaning of kind—
i’'s now obvious that kind has only two possible values: INT_KIND and
DOUBLE_XTIND.

Q&A

When I tried using the sizeof operator to determine the number of bytes in
a structure, I got a number that was larger than the sizes of the members
added together. How can this be?

Let’s look at an example:

struct {
char a;
int b;
} s:

If char values occupy one byte and int values occupy four bytes, how large is
87 The obvious answer—five bytes—may not be the correct one. Some computers
require that the address of certain data items be a multiple of some number of bytes
(typically two, four, or eight, depending on the item’s type). To satisfy this require-
ment, a compiler will “align” the members of a structure by leaving “holes"
(unused bytes) between adjacent members. If we assume (hat data items must
(=

Q&A 405

begin on a multiple of four bytes, the a member of the s structure will be followed
by a three-byte hole. As a result, sizeof (s) will be 8.

By the way, a structure can have a hole at the end, as well as holes between
members. For example, the structure

struct {
int a;
char b;
1 e

might have a three-byte holc after the b member.

Can there be a “hole” at the beginning of a structure?

No. The C standard specifies that holes are allowed only berween members or after
the last member. One consequence is that a pointer to the first member of a struc-
ture is guaranteed to be the same as a pointer to the entire structure. (Note, how-
ever. that the two pointers won't have the same type.)

Why isn’t it legal to use the == operator to test whether two structures are
equal? [p. 382]

This operation was left out of C because there’s no way to implement it that would
be consistent with the language's philosophy. Comparing structure members one
by one would be too inefficient. Comparing all bytes in the structures would be
better (many computers have special instructions that can perform such a compari-
son rapidly). If the structures contain holes, however, comparing bytes could yield
an incorrect answer; even if corresponding members have identical values, leftover
data stored in the holes might be different. The problem could be solved by having
the compiler ensure that holes always contain the same value (zero, say). Initializ-
ing holes would impose a performance penalty on all programs that use structures,
however, so it’s not feasible.

‘Why does C provide two ways to name structure types (tags and typedef
names)? [p. 382]

C originally lacked typedef, so tags were the only technique available for nam-
ing structure types. When typedcf was added. it was too late to remove tags.
Besides. a tag is still necessary when a member of a structure points to a structure
of the same type (see the node structure of Section 17.5).

Can a structure have both a tag and a typedef name? [p. 384]
Yes. In fact, the tag and the typedef name can even be the same, although that’s
not required:

typedef struct part {
int number;
char name [NAME LEN-1] ;
int on_hand;

} part;
406

Chapter 16  Structures, Unions, and Enumerations

Q:
A:

protecting header files » 152

=0

8-

Q. &

How can I share a structure type among several files in a program?

Put a declaration of the structure tag (or a typedef, if you prefer) in a header file,
then include the header file where the structure is needed. To share the part struc-
ture, for example, we’d put the following lines in a header file:

struct part {
int number;
char name [NAME LEN+1] ;
int on_hand;

b

Notice that we're declaring only the structure fag, not variables of this type.

Incidentally, a header file that contains a declaration of a structure tag or struc-
ture type may need protection against multiple inclusion. Declaring a tag or
typedef name twice in the same file is an error. Similar remarks apply to unions
and enumerations.

1f 1 include the declaration of the part structure into two different files, will
part variables in one file be of the same type as part variables in the other
file?

Technically. no. However, the C standard says that the part variables in one file
have a type that’s compatible with the type of the part variables in the other file.
Variables with compatible types can be assigned to each other, so there’s little
practical difference between types heing “compatible” and being “the same.”

The rules for structure compatibility in C89 and C99 are slightly different. In
€89, structures defined in different files are compatible if their members have the
same names and appear in the same order, with corresponding members having
compatible types. C99 goes one step further: it requires that either both structures
have the same tag or neither has a tag.

Similar compatibility rules apply to unions and enumerations (with the same
difference between C89 and C99).

Is it legal to have a pointer to a compound literal?

Yes. Consider the print_part function of Section 16.2. Currently, the parame-
ter to this function is a part structure. The function would be more efficient if it
were modified to accept a pointer to a part structure instead. Using the function
to print a compound literal would then be done by prefixing the argument with the
& (address) operator:

print_part (&(struct part) {528, "Disk drive", 10});

Allowing a pointer to a compound literal would scem to make it possible to
modify the literal. Is that the case?

Yes. Compound literals are lvalues that can be modified, although doing so is rare.

1saw a program in which the last constant in an enumeration was followed by

a comma, like th

Section 16.1

8.

0.8

Exercises 407

enum gray values {

BLACK = 0,
DARK_GRAY = 64,
GRAY = 128,
LIGHT GRAY - 192,
Y
Is this practice legal?

This practice is indeed legal in C99 (and is supported by some pre-C99 compilers as
well). Allowing a “trailing comma” makes enumerations easier to modify, because
we can add a constant to the end of an enumeration without changing existing lines
of code. For example, we might want to add WHTTE to our enumeration:

enum gray_values (

BIACK = 0,
DARK GRAY = 64,
GRAY = 128,

LIGHT GRAY = 182,
WHITE - 255,
}i

The comma after the definition of LTGHT GRAY makes it easy to add WHITE to
the end of the list.

One reason for this change is that C89 allows trailing commas in initializers,
so it seemed inconsistent not to allow the same flexibility in enumerations. Inci-
dentally, C99 also allows trailing commas in compound literals.

Can the values of an enumerated type be used as subscripts?

Yes, indeed. They are integers and have—by default—values that start at 0 and
count upward, so they make great subscripts. In C99, morcover, enumeration con-
stants can be used as subscripts in designated initializers. Here's an example:

enum weekdays {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY};
const char *daily specials[] = {

[MONDAY] = "Beef ravioli",

[TUESDAY] = "BLTs",

|WEDNESDAY] = "Pizza",

[THURSDAY] "Chicken fajitas",
[FRIDAY] = "Macaroni and cheesea"
)i
Exercises

In the following declarations, the x and y structures have members named x and v:
struct { int x, y; } *;

struct { int x, y; } y;

Are these declarations legal on an individual basis? Could both declarations appear as
shown in a program? Justify your answer.
408 Chapter 16  Structures, Unions, and Enumerations

Section 16.2

o 2

(a) Declare structure variables named c1. c2, and c3, each having members real and
imaginary of type double,

(b) Modify the declaration in part (a) so that c1's members initially have the values 0.0 and
1.0, while c2’s members are 1.0 and 0.0 initially. (23 is not initialized.)

(c) Write statements that copy the members of 2 into 1. Can this be done in one state-
ment, or does it require two?

(d) Write statements that add the corresponding members of c1 and 2, storing the result
ine3.

(a) Show how to declare a tag named complex for a structurc with two members, real
and imaginary. of type double.

(b) Use the complex tag to declare variables named c1, c2, and c3.

(c) Write a function named make_complex that stores its two arguments (both of type
double) in a complex structure, then returns the structure.

(d) Write a function named add_complex that adds the corresponding members of its
arguments (both complex structures), then returns the result (another comp1ex structure).

Repeat Exercise 3, but this time using a rype named Complex.

Write the following functions, assuming that the date structure contains three ‘members:
month, day, and year (all of type int).

(a) int day_of_year(struct date d);
Returns the day of the year (an integer between 1 and 366) that corresponds to the date d.
(b) int compare dates (struct date dl, struct date d2);

Returns —I if d1 is an earlier date than G2, +1 if d1 is a later date than 2, and 0 if 41 and
d2 are the same.

Write the following function, assuming that the time structure contains three members:
hours, minutes, and seconds (all of type int).

struct time split_time(long total seconds);

total seconds is a time represented as the number of seconds since midnight. The
function returns a structure containing the equivalent time in hours (0-23), minutes (0-59),
and seconds (0-59).

Assume that the fraction structure contains two members: numerator and denomi-
nator (both of type int). Write functions that perform the following operations on frac-
tions:

(a) Reduce the fraction f to lowest terms. Hint: To reduce a fraction to lowest terms, first
compute the greatest common divisor (GCD) of the numerator and denominator. Then
divide both the numerator and denominator by the GCD.

(b) Add the fractions f1 and f2.

() Subtract the fraction f2 from the fraction f1.

(d) Multiply the fractions f1 and f2

(e) Divide the fraction f1 by the fraction f2.

The fractions f, f1, and f2 will be arguments of type struct fraction;each function
will return a value of type struct fraction. The fractions returned by the functions in
parts (b)—(e) should be reduced 1o lowest terms. Hint: You may use the function from part
(a) to help writc the functions in parts (b)-(e).
Section 16.3

10.

Exercises 409

Let color be the following structure:

struct color {

int red;

int green;

int blue;
(a) Write a declaration for a const variable named MAGENTA of type struct color
whose members have the values 255, 0, and 255, respectively.
(b) (C99) Repeat part (a), hut use a designated initializer that doesn’t specify the value of
green, allowing it to default to 0.

Write the following [unctions. (The color structure is defined in Exercise 8.)
(a) struct color make_color(int red, int green, int blue);

Returns a color structure containing the specified red, green, and blue values. IT any arau-
ment is less than zero, the corresponding member of the structure will contain zero instead.
If any argument is greater than 255, the corresponding member of the structure will contain
255.

(b) int getRed(struct coler c);

Returns the value of c’s red member,

() bool equal_color (struct color colerl, struct color colorz);
Returns true if the corresponding members of colorl and coloxr2 are equal.

(d) struct color brighter(struct celor c);

Returns a colox structure that represents a brighter version of the color c. The structure is
identical to c, except that each member has been divided by 0.7 (with the result truncated to
an integer). However, there are three special cases: (1) If all members of c are zero, the
function returns a color whose members all have the value 3. (2) If any member of c is
greater than 0 but less than 3. it is replaced by 3 before the division by 0.7. (3) If dividing by
0.7 causes a member to exceed 255, it is reduced to 255.

(e) struct color darker(struct color c);

Retumns a color structure that represents a darker version of the color e, The structure is
identical to c, except that each member has been multiplied by 0.7 (with the result truncated
10 an integer).

The following structures are designed to store information about ohjects on a graphics
screen:

struct point { int x, y; };

struct rectangle { struct point upper left, lower right; }

A point structure stores the x and y coordinates of a point on the screen. A rectangle

structure stores the coordinates of the upper left and lower right corners of a rectangle. Write

functions that perform the following operations on a rectangle structure ¥ passed as an

argument:

(a) Compute the area of r.

(b) Compute the center of r. returning it as a point value. If either the x or y coordinate of
the center isn't an integer, store its truncated value in the point structure.

(c) Move r by x units in the x direction and y units in the y direction, returning the modi-

fied version of r. (x and y are additional arguments to the function.)

Determine whether a point p lies within x. returning true or false. (p is an addi-

tional argument of type st ruct point.)

(d
410 Chapter 16  Structures, Unions, and Enumerations

Section 16.4

[ TN

Suppose that s is the following structure:

struct {
double a;
union (
char b[4];
double c;
inkt d;
} es
char ff[4];
} s:
If char values occupy one byte, int values occupy four bytes, and double values occupy
eight bytes. how much space will a C compiler allocate for s? (Assume that the compiler
leaves no “holes” between members.)

Suppose that u is the following union:
union {
double a;
struct {
char b[4];
double c;
int d;
) e;
char f[4];
}oug
If char values occupy one byte, int values occupy four bytes, and double values occupy
eight bytes, how much space will a C compiler allocate for u? (Assume that the compiler
leaves no “holes" between members. )

Suppose that s is the following structure (point is  structure tag declared in Exercise 10):

struct chape {

int shape_kind; /* RECTANGLE or CIRCLE */
struct point center; /* coordinates of center */
union {

struct {

int height, width;
} rectangle;
struct {
int radius;
} circle;
¥ng
} s:
If the value of shape kind is RECTANGLE, the height and width members store the
dimensions of a rectangle. If the value of shape_kind is CIRCLE, the radius member
stores the radius of a circle, Indicate which of the following statements are legal, and show
how to repair the ones that aren’t:
(a) s.shape kind = RECTANGLE;
(b) s.center.x = 10;
(c) s.height = 25;
(@) s.u.rectangle.width = 8;
(e) s.u.circle = 5;
(f) s.u.radius = 5;

Section 16.5

@ 15

16.

@ 17

20.

Exercises 411

Let shape be the structure tag declared in Exercise 13. Write functions that perform the

following operations on a shape structure s passed as an argument;

(a) Compute the area of s.

(b) Move s by x units in the x direction and y units in the y direction, rcturning the modi-
fied version of s. (x and y are additional arguments ta the function.)

(c) Scale s by a factor of c (a double value), returning the modified version of s. (c is an
additional argument to the function.)

(a) Declare a tag for an enumeration whose values represent the seven days of the week.

(b) Use typedef to define a name for the enumeration of part (a).

Which of the following statements about enumeration constants are true?

(a) Anenumeration constant may represent any integer specified by the programmer.

(b) Enumeration constants have exactly the same properties as constants created using
#define.

(c) Enumeration constants have the values 0, 1,2, ... by default.

(d) All constants in an enumeration must have different values.

(c) Enumeration constants may be used as integers in expressions.

Suppose that b and i are declared as follows:

enum {FALSE, TRUE} b;

ant i

Which of the following statements are legal? Which ones are “safe” (always yield a mean-
ingful result)?

(@) b = FALSE;

(®) b = i;
(€) be+;
@ i = b;

(Rt SR T

(a) Each square of a chessboard can hold one piece—a pawn, knight. bishop. rook, queen,
or king—or it may be empty. Each piece is either black or white. Define two enumerated
types: Piece, which has seven possible values (one of which is “empty”). and Coloxr,
which has two.

(b) Using the types from part (), define a structure type named Square that can store both
the type of a piece and its color.

(c) Using the Square type from part (b), declare an 8 x 8 array named board that can
store the entire contents of a chesshoard.

(d) Add an initializer to the declaration in part (c) so that board’s initial value corresponds
to the usual arrangement of pieces at the start of a chess game. A square that's not occupied
by a piece should have an “empty” piece value and the color black.

Declare a structure with the following members whose tag is pinball_machine:
name — a string of up to 40 characters

year —an integer (representing the year of manufacture)

type — an enumeration with the values EM (electromechanical) and jS (solid state)
players —an integer (representing the maximum number of players)

Suppose that the direct ion variable is declared in the following way:
enum {NORTH, SOUTH, EAST, WEST} direction;
412

Chapter 16 ~ Structures, Unions, and Enumerations

o

Let x and y be int variables. Write a ewitch statement that tests the value of direc-
tion. incrementing x if direction is EAST, decrementing x if direction is WEST,
incrementing v if direction is SOUTH, and decrementing y if direction is NORTH.

What are the integer values of the enumeration constants in each of the following declara-
tions?

(a) enum (NUL, SOH, STX, ETX};

(b) enum (VT = 11, FF, CR};

(c) enum {SO = 14, SI, DLE, CAN = 24, EM};

(d) enum (ENQ - 45, ACK, BEL, LF¥ = 37, ETB, ESC};

Let chess_pieces be the following enumeration:
enum chess_pieces {KING, QUEEN, ROOK, BISHOP, KNIGHT, PAWN};

(a) Write a declaration (including an initializer) for a constant array of integers named
piece value that stores the numbers 200, 9, 5, 3, 3, and |, represenfing the value of cach
chess piece, from king to pawn. (The king's value is actually infinite, since “capturing” the
king (checkmate) ends the game, but some chess-playing software assigns the king a large
value such as 200.)

(b) (C99) Repeat part (a), but use a designated initializer to initialize the array. Use the enu-
meration constants in chegs_pieces as subseripts in the designators. (Hinr: See the last
question in Q&A for an cxample.)

Programming Projects

Write a program that asks the user to enter an international dialing code and then looks it up
in the country_codes array (see Section 16.3). If it finds the code, the program should
display the name of the corresponding country; if not, the program should print an error
message.

Modify the inventory . c program of Section 16.3 so that the p (print) operation displays
the parts sorted by part number.

Modify the inventory.c program of Section 163 by making inventory and
num_parts local to the mazn function,

Modify the inventory. c program of Section 16.3 by adding a pricc member to the
part structure. The insert function should ask the user for the price of a new item. The
gearch and print functions should display the price. Add a new command that allows
the user to change the price of a part.

Modify Programming Project 8 from Chapter 5 so that the times are stored in a single array.
The elements of the array will be structures, each containing a departure time and the corre-
sponding arrival time. (Each time will be an integer, representing the number of minutes
since midnight.) The program will use a loop to search the array for the departure time clos-
est 1o the time entered by the user.

Modify Programming Project 9 from Chapter 5 so that each date entered by the user is
stored in a date structure (see Exercise 5). Incorporate the compare_dates function of
Exercise 5 into your program.

17

Advanced Uses of Pointers

One can only display complex information in the mind.
Like seeing, movement or flow or alteration of view is more
important than the static picture, no matter how lovely.

In previous chapters, we've seen two important uses of pointers. Chapter 11
showed how using a pointer to a variable as a function argument allows the func-
ble. Chapter 12 showed how to process arrays by perform-
ing arithmelic on pointers (o array elements. This chapter completes our coverage
of puinters by examining two additional applications: dynamic storage allocation
and pointers to functions.

Using dynamic storage allocation, a program can obtain blocks of memory as
needed during execution. Section 17.1 explains the basics of dynamic storage allo-
cation. Section 17.2 discusses dynamically allocated strings, which provide more
flexibility than ordinary character arrays. Section 17.3 covers dynamic storage
allocation for arrays in general. Section 17.4 deals with the issue of storage deallo
cation—releasing blocks of dynamically allocated memory when they're no longer
needed.

Dynamically allocated structures play a big role in C programming, since they
can be linked together to form lists, trees, and other highly flexible data structures.
Section 17.5 focuses on linked lists, the most fundamental linked data structure.
One of the issues that arises in this section—the concept of a “pointer to a
important enough to warrant a section of its own (Section 17.6).

Section 17.7 introduces pointers to functions, a surprisingly useful concept.
Some of C’s most powerful library functions expect function pointers as argu-
ments. We'll examine one of these functions, gsoxrt, which is capable of sorting
any array.

The last two sections discuss pointer-related features that first appeared in
C99: restricted pointers (Section 17.8) and flexible array members (Section 17.9).
These features are primarily of interest to advanced C programmers. so both sec-
tions can be safely be skipped by the beginner.

413
414 Chapter 17 Advanced Uses of Pointers

1l

variable-length arrays » 8.3

=stdlib.hs header »262

Dynamic Storage Allocation

C’s data structures are normally fixed in size. For example, the number of elements
in an array is fixed once the program has been compiled. (In C99, the length of a
variable-length array is determined at run time, but it remains fixed for the rest of
the array’s lifetime.) Fixed-size data structures can be a problem, since we're
forced to choose their sizes when writing a program; we can’t change the sizes
without modifying the program and compiling it again.

Consider the inventory program of Section 16.3, which allows the user (o
add parts to a database. The database is stored in an array of length 100. To en-
large the capacity of the database, we can increase the size of the array and recom-
pile the program. But no matter how large we make the array, there's always the
possibility that it will fill up. Fortunately, all is not lost. C supports dynamic stor-
age allocation: the ability to allocate storage during program execution. Using dy-
namic storage allocation, we can design data structures that grow (and shrink) as
needed.

Although it's available for all types of data, dynamic storage allocation is used
most often for strings, arrays, and structures. Dynamically allocated structures are
of particular interest, since we can link them together to form lists, trees, and other
data structures.

Memory Allocation Functions

To allocate storage dynamically, we'll need to call one of the three memory alloca-
tion functions declared in the <stdlib. h> header:

= malloc—Allocates a block of memory but doesn’t initialize it.
= calloc—Allocates a block of memory and clears it.
m realloc—Resizes a previously allocated block of memory.

Of the three, malloc is the most used. It's more efficient than calloc, since it
doesn’t have to clear the memory block that it allocates

When we call a memory allocation function to request a block of memory, the
function has no idea what type of data we’re planning to store in the block, so it
can’t return a pointer to an ordinary type such as int or char. Instead, the func-
tion returns a value of type void *. A void * value is a “generic” pointer—
essentially, just a memory address.

Null Pointers

‘When a memory allocation function is called, there’s always a possibility that it
won't be able to locate a block of memory large enough to satisfy our request. If
17.1 Dynamic Storage Allocation 415

that should happen, the function will return a null pointer. A null pointer is a
“pointer to nothing"—a special value that can be distinguished from all valid
pointers. After we've stored the function’s return value in a pointer variable, we
must test to see if it’s a null pointer.

It’s the programmer’s responsibility to test the return value of any memory alloca-
tion function and take appropriate action if it's a null pointer. The effect of attempt-
ing to access memory through a null pointer is undefined; the program may crash
or behave unpredictably.

The null pointer is represented by a macro named NULL, so we can test
malloc’s return value in the following way:

p = malloc(10000);
if (p == WULL) {
/* allocation failed; take appropriate action */

Some programmers combine the call of malloc with the NULL test:
if ((p = walloc{10000)) NULL) {

/* allocation failed; take appropriate action */

}

The NULL macro is defined in six headers: <locale.h>, <stddef.h>,
<stdio.h>, c<stdlib.h>, <string.h>, and <time.h>. (The C99 header
<wchar . h> also defines NULL.) As long as one of these headers is included in a
program, the compiler will recognize NULL. A program that uses any of the mem-
ory allocation functions will include <stdlib.hs>, of course, making NUIT.T,
available.

In C, pointers test true or false in the same way as numbers. All non-null
pointers test true; only null pointers are false. Thus, instead of writing

if (p == NULL)
we could write
if (ip)

and instead of writing

NULL)

1EStp
we could write
if (p)

As a matter of style, I prefer the explicit comparison with NULL,
416

Chapter 17 Advanced Uses of Pointers

17.2

size tipe»7.6

Dynamically Allocated Strings

Dynamic storage allocation is often useful for working with strings. Strings are
stored in character arrays, and it can be hard to anticipate how long these arrays
need to be. By allocating strings dynamically, we can postpone the decision until
the program is running.

Using malloc to Allocate Memory for a String

The malloc function has the following prototype:
void *malloc(size t size);

malloc allocates a block of size bytes and returns a pointer to it. Note that
size has type size_t, an unsigned integer type defined in the C library. Unless
we're allocating a very large block of memory, we can just think of size as an
ordinary integer.

Using malloc to allocate memory for a string is easy, because C guarantees
that a char value requires exactly one byte of storage (sizeof (char) is I, in
other words). To allocate space for a string of n characters, we'd write

p = malloc(n + 1);

where p is a char * variable. (The argument is n + 1 rather than n to allow room
for the null character.) The generic pointer that mal loc returns will be converted
to char * when the assignment is performed; no cast is necessary. (In general, we
can assign a void * value o a variable of any pointer type and vice versa.) Never-
theless, some programmers prefer to cast malloc’s return value:

p = (char *) malloc(n + 1);

‘When using malloc to allocate space for a string, don’t forget to include room for
the null character.

Memory allocated using malloc isn’t cleared or initialized in any way, sop
will point to an uninitialized array of n + 1 characters:

17.2  Dynamically Allocated Strings 417
Calling strepy is one way to initialize this array:
strepy (p, "abe');

The first four characters in the array will now be a. b, c, and \ 0:

Using Dynamic Storage Allocation in String Functions

Dynamic storage allocation makes it possible to write functions that return a
pointer to a “new” string—a string that didn’t exist before the function was called.
Consider the problem of writing a function that concatenates two stiings withoul
changing either one. C’s standard library doesn’t include such a function (strcat
isn’t quite what we want, since it modifies one of the strings passed to it), but we
can easily write our own.

Our function will measure the lengths of the two strings to be concatenated,
then call malloc to allocate just the right amount of space for the result. The
funclion next copies the first string into the new space and then calls strcat to
concatenate the second string.

char *concat (const char *sl, const char *s2)

{

char *result;

result = malloc(strlen(sl) + strlen(s2) + 1);

if (result == NULL)
printf ("Error: malloc failed in concat\n");
exit (EXIT FAILURE) ;

strcpy (result,
strcat (result,
return result;

}

[f malloc returns a null pointer, concat prints an error message and terminates
the program. That's not always the right action to take; some programs need to
recover from memory allocation failures and continue running.

Here's how the concat function might be called:

w o

1);
2)

P = concat ("abe', "def');

After the call, p will point to the string "abedef ", which is stored in a dynami-
cally allocated array. The array is seven characters long, including the null charac-
ter at the end.
418

Chapter 17 Advanced Uses of Pointers

A

free function > 17.4

PROGRAM

remind2.c

Functions such as concat that dynamically allocate storage must be used with
care. When the string that concat returns is no longer needed, we'll want to call
the free function to release the space that the string occupies. If we don’t, the
program may eventually run out of memory.

Arrays of Dynamically Allocated Strings

In Section 13.7, we tackled the problem of storing strings in an array. We found
that storing strings as rows in a two-dimensional array of characters can waste
space, 50 we tried setting up an array of pointers to string literals. The techniques
of Section 13.7 work just as well if the elements of an array are pointers to dynam-
ically allocated strings. To illustrate this point, let’s rewrite the remind.c pro-
gram of Section 13.5, which prints a one-month list of daily reminders.

Printing a One-Month Reminder List (Revisited)

The original remind. c program stores the reminder strings in a two-dimensional
array of characters, with each row of the array containing one string. After the pro-
gram reads a day and ils associated reminder, it searches the array to determine
where the day belongs, using strcmp to do comparisons. It then uses strcpy to
move all strings below that point down one position. Finally, the program copies
the day into the array and calls strcat to append the reminder to the day.

In the new program (remind2 . c). the array will be one-dimensional: its ele-
ments will be pointers to dynamically allocated strings. Switching to dynamically
allocated strings in this program will have two primary advantages. First, we can
use space more efficiently by allocating the exact number of characters needed to
store a reminder, rather than storing the reminder in a fixed number of characters
as the original program does. Second, we won't need to call scrcpy to move
existing reminder strings in order to make room for a new reminder. Instead, we'll
merely move pointers (o strings.

Here's the new program, with changes in bold. Switching from a two-dimen-
sional array to an array of pointers turns out to be remarkably easy: we'll only need
to change eight lines of the program,

/* Prints a onc-month reminder list (dynamic string version) */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX REMIND 50 /* maximum number of reminders */
#define MSG_LEN G0 /* max length of reminder message */

int read_line(char str[], int n);
17.2. Dynamically Allocated Strings

int main(void)

char *reminders [MAX REMIND] ;
char day str(3], msg str[MSG LEN+1] ;
int day, i, j, num remind = 0;

for (G2
if (num_remind == MAX REMIND) (
printf("-- No space left --\n");
break;

printf ("Enter day and reminder: ");
scanf ("32d", &day) ;
if (day == 0)

break;
sprintf(day str, "$2d", day);
read_line(msg_str, MSG_LEN);

for (i = 0; i < num remind; i++)
if (stremp (day_str, reminders[i]) < 0)
break;
for (j = num remind; j > i; j--)
reminders[j] = reminders [3-11;

reminders[il = malloc(2 + strlen(msg str) + 1);

if (reminders[i] == NOULL) {
printf("-- No space left --\n");
break;

strepy (reminders[i], day str);
strcat (reminders (1], msg_str) ;

num_remind++;

}
printf ("\nDay Reminder\n") ;
for (i = 0; i < num remind; i++)

printf (" %s\n", reminders([i]);

return 0;

}
int read line(char str[], int n)

int ch, i = 03

while ((ch = getchar()) 1= '\n!)
if (1 < 1)
str[i++] = ch;

strli] = '\o';
return i;

419
420

Chapler 17 Advanced Uses of Pointers

17.3

512e0f Cparator »7.6

Dynamically Allocated Arrays

Dynamically allocated arrays have the same advantages as dynamically allocated
strings (not surprisingly, since strings are arrays). When we’re writing a program,
it’s often difficult to estimate the proper size for an array; it would be more conve-
nient to wait until the program is run to decide how large the array should be. C
solves this problem by allowing a program to allocate space for an array during
execution, then access the array through a pointer to its first element. The close
relationship between arrays and pointers, which we explored in Chapter 12, makes
a dynamically allocated array just as easy (o use as an ordinary array.

Although malloc can allocate space for an array, the calloc function is
sometimes used instead, since it initializes the memory that it allocates. The
realloc function allows us to make an array “grow” or “shrink" as needed.

Using malloc to Allocate Storage for an Array

We can use malloc to allocate space for an array in much the same way we used
it to allocate space for a string. The primary difference is that the elements of an
arbitrary array won’t necessarily bc one byte long, as they are in a string. As a
result, we’ll need to use the sizeof operator to calculate the amount of space
required for each element.

Suppose we're writing a program that needs an array of n integers, where n is
1o be computed during the execution of the program. We'll first declare a pointer
variable:

int *a;

Once the value of 1 is known, we'll have the program call malloc to allocate
space for the array:

a = malloc(n * sizeof (int));

Always use sizeof when calculating how much spuce is needed [or an array.
Failing to allocate enough memory can have severe consequences. Consider the
following attempt to allocate space for an array of n integers:

a = malloc(n * 2);

If int values are larger than two bytes (as they are on most computers), malloc
won't allocate a large enough block of memory. When we later try to access ele-
ments of the array, the program may crash or behave erratically.

Once it points to a dynamically allocated block of memory, we can ignore the
fact that a is a pointer and use it instcad as an array name, thanks to the relation-
17.3  Dynamically Allocated Arrays 421
ship between arrays and pointers in C. For example, we could usc the following
loop to initialize the array that a points to:

for (i
ali]

0; i < n; is4)
0;

"on

We also have the option of using pointer arithmetic instead of subscripting to
access the elements of the array.

The calloc Function

Although the malloc function can be used to allocate memory for an array, C
provides an alternative—the calloc function—that's sometimes better. calloc
has the following prototype in <stdlib.h>:

void *calloc(size t nmemb, size_t gize);

calloc allocates space for an array with nmemb elements, each of which is
size bytes long: it returns a null pointer if the requested space isn’t available.
After allocating the memory, calloc initializes it by setting all bits to 0. For
example, the following call of calloc allocates space for an array of n integers,
which are all guaranteed to be zero initially:

a = calloc(n, sizeof (int));

Since calloc clears the memory that it allocates but malloc doesn’t, we
may occasionally want to use calloc to allocate space for an object other than an
array. By calling calloc with 1 as its first argument, we can allocate space for a
data item of any type:

struct point { int x, y; } *p;
P = calloc(1, sizeof(struct point));

After this statement has been executed, p will point to a structure whose % and b
members have been set to zero.

The realloc Function

Once we've allocated memory for an array, we may later find that it’s too large or
too small. The realloe function can resize the array to better suit our needs, The
fallowing prototype for realloc appears in <stdlib.h>:

void *realloc(void *ptr, size_t size):

When realloc is called, ptr must point to a memory block obtained by a previ-
ous call of malloe, calloc, or realloc. The size parameter represents the
new size of the block, which may be larger or smaller than the original size.
Although realloc doesn’t require that ptr point to memory that’s being used as
an array, in practice it usually does.
22 Chapter 17  Advanced Uses of Pointers

17.4

Be sure that a pointer passed to realloc came from a previous call of malloc,
calloc, orrealloc. If it didn’t, calling realloc causes undefined behavior.

The C standard spells out a number of rules concerning the behavior of
realloc:

= When it expands a memory block, realloc doesn't initialize the bytes that
are added to the block.

m If realloc can't enlarge the memory block as requested, it returns a null
pointer; the data in the old memory block is unchanged.

u If realloc is called with a null pointer as its first argument, it behaves like
malloc.

= If realloc is called with 0 as its second argument, it frees the memory
block.

The C standard stops short of specifying exactly how realloc works. Still,
we expect it Lo be reasonably efficient. When asked to reduce the size of a memory
block, realloc should shrink the block “in place,” without moving the data
stored in the block. By the same token, realloc should always attempt to
expand a memory block without moving it. If it’s unable to enlarge the hlock
(because the bytes following the block are already in use for some other purpose),
reallcc will allocate a new block elsewhere, then copy the contents of the old
block into the new one.

Once realloc has returned, be sure to update all pointers to the memory block,
since it’s possible that realloc has moved the block elsewhere.

Deallocating Storage

malloc and the other memory allocation functions obtain memory blocks from a
storage pool known as the Aeap. Calling these functions too often—or asking them
for large blocks of memory—can exhaust the heap, causing the functions to return
a null pointer.

To make matters worse, a program may allocate blocks of memory and then
lose track of them, thereby wasting space. Consider the following example:

malloc(..) ;
malloc (w.
°

P
q

oo
17.4 Deallocating Storage 423

After the first two statements have been executed. P points to one memory block,
while g points to another;

There are no pointers to the first block (shaded), so we’ll never be able to use it
again,

A block of memory that’s no longer accessible to a program is said to be gar-
bage. A program that leaves garbage behind has a memory leak. Some languages
provide a garbage collector that automatically locates and recycles garbage, but C
doesn’t. Instead, each C program is responsible for recycling its own garbage by
calling the free function to release unneeded memory.

The free Function
The free function has the following prototype in <stdlib.hs:
void free(void *ptr);

Using free is easy; we simply pass it a pointer to a memory block that we no
longer need:

P = malloc %

q = malloc(.);

free(p);

Bis gy

Calling free releases the block of memory that p points to. This block is now
available for reuse in subsequent calls of malloc or other memory allocation
functions,

The argument to free must be a pointer that was previously returned by a mem-
ory allocation function. (The argument may also be a null pointer, in which case
the cull of free has no effect.) Passing free a pointer to any other object (such
as a variable or array element) causes undefined behavior,

424

Chapter 17 Advanced Uses of Pointers

17.5

The “Dangling Pointer”” Problem

Although the free function allows us to reclaim memory that's no longer needed,
using it leads 0 a new problem: dangling pointers. The call free (p) deallocates
the memory block that p points to, but doesn’t change p itself. If we forget that p
no longer points to a valid memory block, chaos may ensue:

char *p = malloc(4);
free(p);
strepy(p, "abe!); /x** WRONG *x=*/

Modifying the memory that p points to is a serious error, since our program no
longer has control of that memory.

Attempting to access or modify a deallocated memory block causes undefined
behavior. Trying to modify a deallocated memory block is likely to have disastrous
consequences that may include a program crash

Dangling pointers can be hard to spot, since several pointers may point to
the same block of memory. When the block is freed, all the pointers are left dan-

gling.

Linked Lists

Dynamic storage allocation is especially useful for building lists, trees, graphs, and
other linked data structures, We'll look at linked lists in this section; a discussion
of other linked data structures is beyond the scope of this book. For more informa-
tion, consult a book such as Robert Sedgewick’s Algorithns in C, Parts 1-4: Fun-
damentals, Data Structures, Sorting, Searching, Third Edition (Reading, Mass.:
Addison-Wesley, 1998).

A linked Hist consists of a chain of structures (called nodes), with each node
containing a pointer to the next node in the chain:

BE B S

The last node in the list contains a null pointer, shown here as a diagonal line.

In previous chapters, we've used an array whenever we'’ve needed to store a
collection of data items; linked lists give us an alternative. A linked list is more
flexible than an array: we can easily insert and delete nodes in a linked list, allow-
ing the list to grow and shrink as needed. On the other hand, we lose the “random
access” capability of an array. Any element of an array can be accessed in the same

17.5 Linked Lists 425

amount of time; accessing a node in a linked list is fast if the node is close to the
beginning of the list, slow if it’s near the end.

This section describes how to set up a linked list in C. It also shows how to
perform several common operations on linked lists: inserting a node at the begin-
ning of a list, searching for a node, and deleting a node.

Declaring a Node Type

To set up a linked list. the first thing we'll need is a structure that represents a sin-
gle node in the list. For simplicity, let’s assume that a node contains nothing but an
integer (the node’s data) plus a pointer to the next node in the list. Here’s what our
node structure will look like:

struct node {
int value; /* data stored in the node */
struct nede *next; /* pointer to the next node */

Notice that the next member has type st ruct node *, which means that it can
store a pointer to a node structure. There’s nothing special about the name node,
by the way; it's just an ordinary structure tag.

One aspect of the node structure deserves special mention. As Section 16.2
explained, we normally have the option of using either a tag or a typedef name
10 definc a name for a particular kind of structure, However, when a structure has a
member that points to the same kind of structure, as node does, we're required to
use a structure tag, Without the node tag, we'd have no way to declare the type of
next.

Now that we have the node structure declared, we'll need a way to keep track
of where the list begins. In other words, we’ll need a variable that always points to
the first node in the list. Let’s name the variable first:

struct node *first - NULL;

Setting first to NULL indicates that the list is initially empty.

Creating a Node

As we construct a linked list, we'll want (o create nodes one by one, adding each to
the list. Creating a node requires three steps:

1. Allocate memory for the node.
2. Store data in the node.
3. Insert the node into the list.

We’ll concentrate on the first two steps for now.
When we create a node, we'll need a variable that can point to the node tem-
porarily, until it's been inserted into the list. Let’s call this variable new_node:

struct node *new_node;
426 Chapter 17 Advanced Uses of Pointers

tabke of operators = Appendix A

We'll use malloc to allocate memory for the new node, saving the return value in
nev_node:

new node = malloc (sizeof (struct node));

new_node now points to a block of memory just large enough to hold a node

structure:

TATue men

Be careful to give sizeof the name of the fype to be allocated, not the name of a
pointer to that type:

new_node = malloc(sizeof (new_node)) ; /**% WRONG: *##/
The program will still compile, but malloc will allocate only enough memory for

a pointer to a node structure, The likely result is a crash later, when the program
attempts to store data in the node that new_node is presumably pointing to.

Next, we'll store data in the value member of the new node:
(*new_node) .value = 10;

Here's how the picture will look after thi

new_node I

To access the value member of the node, we've applied the indirection operator
* (to reference the structure to which new_node points), then the selection oper-
ator . (to select a member of the structure). The parentheses around *new_node
are mandatory because the . operator would otherwise take precedence over the *
opel‘ator.

ssignment:

The -> Operator

Before we go on to the next step, inserting a new node into a list, let’s take a
moment to discuss a useful shortcut. Accessing a member of a structure using a
pointer is so common that C provides a special operator just for this purpose. This
operator, known as right arrow selection, is a minus sign followed by >. Using the
- > operator, we can write

new_node->value = 10;

instead of
Ivalues »4.2

17.5 Linked Lists 427

(*new_node) .value = 10;

The - > operator is a combination of the * and . operators; it performs indirection
on new_node to locate the structure that it points to, then selects the value
member of the structure,

The -> operator produces an lIvalue, so we can use it wherever an ordi-
nary variable would be allowed. We've just seen an cxample in which
new_node->value appears on the left side of an assignment. It could just as
easily appear in a call of scanf:

scanf ("$d", &new node->value) ;

Notice that the & operator is still required, even though new_node is a pointer.
Without the &, we'd be passing scanf the value of new_node- >value, which
has type int.

Inserting a Node at the Beginning of a Linked List

One of the advantages of a linked list is that nodes can be added at any point in the
list: at the beginning, at the end, or anywhere in the middle. The beginning of a list
is the easiest place to insert a node, however, so let’s focus on that case.

If new node is pointing to the node to be inserted, and first is pointing to
the first node in the linked list, then we'll need two statements to insert the node
into the list. First, we'll modify the new node’s next member to point to the node
that was previously at the beginning of the list:

new_node->next = first;
Second, we'll make first point to the new node:
first = new_node;

Will these statements work if the list is empty when we insert a node? Yes,
fortunately. To make sure this is true, let’s trace the process of inserting two nodes
into an empty list. We'll insert a node containing the number 10 first, followed by a
node containing 20. In the figures that follow, null pointers are shown as diagonal
lines.

first = NULL;
firat | /

new_node = malloc(sizeof (struct node));

428 Chapter 17 Advanced Uses of Pointers

new_node >value = 10;
= firat

10

new_node->next - first;
= Eirst

~
A

new node wI"/

first = new_node; 4
e Y =
il
new_node|
new_node - malloc [sizeof (struct node)); %
T e

new node [« I

new_node->value = 20; =
2 first

new_node

new_node->next = first; 5t
& et

first = new_ncde;
e firse
~
-
niew_ncde | fI

Inserting anode into a linked list is such a common operation that we’ll probably
want to write a function for that purpose. Let’s name the function add_to 1ist.
It will have two parameters: 1ist (a pointer to the first node in the old list) and n
(the integer to be stored in the new node).

struct node *add to_list (struct node *list, int n)

struct node *new_nocde;

new node = malloc(sizeof (struct node)) :

if (new node == NULL)
printf ("Error: malloc failed in add to list\n");
exit (EXIT FAILURE);
idiom

17.5 Linked Lists 429

new node-svalue = n;
new_node->next list;
return new node;

}

Note that add_to_list doesn’t modify the 1ist pointer. Instead, it returns a
pointer to the newly created node (now at the beginning of the list). When we call
add_to_list, we’ll need to store its return value into first:

first = add to list(first, 10);
first = add to list(first, 20);

These statements add nodes containing 10 and 20 to the list pointed to by first.
Getting add_to list toupdate first directly, rather than return a new value
for first, turns out to be tricky. We’ll return to this issue in Section 17.6.

The following function uses add _to_list to create a linked list containing
numbers entered by the user:

struct node *read numbers (void)
struct node *first = NULL;
int n;

printf ("Enter a series of integers (0 tc terminate): ");
for i)
scanf ("%d", &n);
if (n == 0)
return first;
irst = add_to_list(first, n);

}
}

The numbers will be in reverse order within the list, since first always points to
the node containing the last number entered.

Searching a Linked List

Once we've created a linked list, we may need to search it for a particular piece of
data. Although a `while` loop can be used to search a list, the `for` statement is
often superior, We're accustomed to using the `for` statement when writing loops
that involve counting, but its flexibility makes the `for` statement suitable for other
tasks as well, including operations on linked lists. Here's the customary way to
visit the nodes in a linked list, using a pointer variable p to keep track of the “cur-
rent” node:

for (p = first; p != NULL; p = p->next)

The assignment

p = p->next
430

Chapter 17 Advanced Uses of Pointers

advances the p pointer from one node to the next. An assignment of this form is
invariably used in C when writing a loop that traverses a linked list.

Let’s write a function named search_1ist that searches a list (pointed to
by the parameter 11ist) for an integer n. If it finds n, search_list will return
a pointer to the node containing n; otherwise, it will return a null pointer. Our first
version of search_list relies on the “list-traversal” idiom:

struct node *search_list (struct node *list, int n)
struct node *p;

for (p - list; p != NULL; p = p->next)
if (p->value == n)
return p;
return NULL;

1

Of course, there are many other ways to write search list. One alterna-
tive would be to eliminate the p variable, instead using 11st itself to keep track of
the current node:

struct node *search list(struct node *list, int n)

for (; list != NULL; list = list->next)
if (list->value == n)
return list;
return NULL;

Since 1ist is a copy of the original list pointer, there’s no harm in changing it
within the function.

Another alternative is to combine the 1ist->value
list !=NULL test:

n test with the

struct node *search list (struct node #*list, int n)

{

for (; list != NULL && list->value

n; list = list->next)

return list;

!

Since 1ist is NULL if we reach the end of the list, returning 11 st is correct even
if we don’t find n. This version of search list might be a bit clearer if we
used a `while` statement:

struct node *search list(struct node *list, int n)

while (list != NULL && list-»value != n)
list = list->next;
return list;

}
17.6 Linked Lists 431

Deleting a Node from a Linked List

A big advantage of storing data in a linked list is that we can casily delete nodes
that we no longer need. Deleting a node, like creating a node, involves three steps:

1. Locate the node to be deleted.
2. Alter the previous node so that it “bypasses” the deleted node.
3. Call free to reclaim the space occupied by the deleted node

Step 1 is harder than it looks. If we search the list in the obvious way, we'll end up
with a pointer to the node to be deleted. Unfortunately, we won’t be able to per-
form step 2, which requires changing the previous node.

There are various solutions to this problem, We’ll use the “trailing pointer”
technique: as we search the list in step 1, we'll keep a pointer to the previous node
(prev) as well as a pointer to the current node (cur). If 1ist points to the list to
be searched and 1 is the integer to be deleted, the following loop implements step
1:

for (cur = list, prev = NULL;
cur NULL && cur-s>value != n;
prev cur, cur = cur-s>next)

Here we see the power of C’s `for` statement. This rather exotic example, with its
empty body and liberal use of the comma operator, performs all the actions needed
to search for n. When the loop terminates, cur points to the node to be deleted,
while prev points to the previous node (if there is one).

To see how this loop works, let’s assume that 1ist points to a list containing
30, 40. 20, and 10, in that order:

[zl ol e[

Let's say that n is 20, so our goal is to delete the third node in the list. After
cur = list, prev = NULL has been executed, cur points to the first node in
the list:

prev cur

s o[ [F-=[F=1]

The test cur | = NULL && cur->value !=nis true, since cur is pointing to a
node and the node doesn’t contain 20. After prev = cur, cur = cur-snext
has been executed, we begin to see how the prev pointer will trail behind cur:
432 Chapter 17 Advanced Uses of Pointers

list

Again, the test cur != NULL && cur->value !=n is true, so prev = cur,
cur = cur->next is executed once more:

Since cur now points to the node containing 20, the condition cur->value !=
1 is false and the loop terminates.

Next, we'll perform the bypass required by step 2. The statement

Prev->next = cur-snext;
makes the pointer in the previous node point to the node after the current node:

prev cur

e

We're now ready [or step 3, releasing the memory occupied by the current node:

free (cur) ;

The following function, delete from 1list, uses the strategy that we've
Just outlined, When given a list and an integer n, the function deletes the first node
containing n. If no node contains n, delete_from list does nothing. In
either case, the function returns a pointer 1o the list.

struct node *delete from list (struct node *list, int n)
struct node *cur, *prev;
for (cur = list, prev = NULL;

cur NULL && cur-svalue != n;
prev = cur, cur = cur->next)

PROGRAM

17.5 Linked Lists ~ 433

if (cur == NULL)

return list; /* n was not found */
if (prev -= NULL)

list = list-snext; /* n is in the first node */
else

prev->next = cur-snext; /* n is in some othar node */
free(cur) ;

return list;

}

Deleting the first node in the list is a special case. The prev == NULL test checks
for this case, which requires a different bypass step.,

Ordered Lists

When the nodes of a list are kept in order—sorted by the data stored inside the
nodes—we say that the list is ordered. Inserting a node into an ordered list is more
difficult (the node won't always be put at the beginning of the list), but searching is
faster (we can stop looking after reaching the point at which the desired node
would have been located). The following program illustrates both the increased
difficulty of inserting a node and the faster search.

Maintaining a Parts Database (Revisited)

Let’s redo the parts database program of Section 16.3, this time storing the data-
base in a linked list. Using a linked list instead of an array has two major advan-
tages: (1) We don't need to put a preset limit on the size of the database; it can
grow until there’s no more memory to store parts. (2) We can easily keep the data-
base sorted by part number—when a new part is added 1o the database, we simply
insert it in its proper place in the list. In the original program, the database wasn’t
sorted.

In the new program, the part structure will contain an additional member (a
pointer to the next node in the linked list), and the variable inventory will be a
pointer to the first node in the list:

struct part {
int number;
char name [NAME LEN+1] ;
int on_hand;
struct part *next;

struct part *inventory = NULL; /* points to first part */

Most of the functions in the new program will closely resemble their counter-
parts in the original program. The find part and insert functions will be
more complex, however, since we'll keep the nodes in the inventory list sorted
by part number.
434

Chapter 17 Advanced Uses of Pointers

inventory2.c

In the original program, find_part returns an index into the inventory
array. In the new program, find_part will return a pointer to the node that con-
tains the desired part number. If it doesn't find the part number, find_part will
return a null pointer. Since the inventory list is sorted by part number, the new
version of find part can save time by stopping its search when it finds a node
containing a part number that's greater than or equal to the desired part number.
find_part’s search loop will have the form

for (p = inventory;
P != NULL && number > p->number;
D = p->nesxt)

The loop will terminate when p becomes NULL (indicating that the part number
wasn’t found) or when number > p->number is false (indicating that the part
number we're looking for is less than or equal to a number already stored in a
node). In the latter case, we still don’t know whether or not the desired number is
actually in the list, so we'll need another test:

if (p != NULL && number == p >number)
return p;

The original version of insert stores a new part in the next available array
element. The new version must determine where the new part belongs in the list
and insert it there. We'll also have insext check whether the part number is
already present in the list. insert can accomplish both tasks by using a loop sim-
ilar to the one in find_part:

for (cur = inventory, prev = NULL;
cur != NULL & new node->number > cur->numbsr;
prev = cur, cur = cur-snext)

This loop relies on two pointers: cur, which points to the current node, and prev,
which points to the previous node. Once the loop terminates, insert will check
whether cur isn’t NULL and new_node - >numbexr equals cur->number; if
50, the part number is already in the list. Otherwise insext will insert a new node
between the nodes pointed to by prav and cur., using a strategy similar to the one
we employed for deleting a node. (T'his strategy works even if the new part number
is larger than any in the list; in that case, cur will be NULL but prev will point to
the last node in the list.)

Here's the new program. Like the original program, this version requires the
read_line function described in Section 16.3; [ assume that readline.h
contains a prototype for this function.

/* Maintains a parts database (linked list version) */
#include <stdio.h>

#include <stdlib.h>
#include "readline.h"
17.5 Linked Lists ~ 435

#define NAME LEN 25

struct part {
int number;
char name [NAME LEN+1] ;
int on hand;
struct part *next;

i

struct part *inventory = NULL; /* points to first part */

stru part *find part (int number) ;
void insert (void) ;
void search(void) ;
void update (void) ;
void print (void) ;

B B PR
* main: Prompts the user to enter an operation code, *
then calls a function to perform the requested *
action. Repeats until the user enters the 53
command 'q'. Prints an error message if the user *
enters an illegal code. *
e L L L U

int main(void)

ok ow %

/

char code;

for (o)l
printf ("Enter cperation code:
scanf (" %c", &code);

while (getechar() != '\n') /* skips to end of line */
switch (code) {
case 'i': insert();
break;
case 's': search();
break;
case 'u': update();
break;
case 'p': print();
break;

case 'g': return 0;
default: printf("Illegal code\n’);

printf ("\n");

}

R o S Y

* find part: Looks up a part number in the inventory *
= liet. Returns a pointer to the node *
* containing the part number; if the part *
L number is not found, returns NULL. x

xnnna«ﬂmuu*uu“*“unn""."n«"uuu*“uu/

436 Chapter 17 Advanced Uses of Fointers

struct part *find part (int number)

struct part *p;

for (p inventory;
P NULL && number > p->number;
P = p->next)

if (p != NULL & number

P->number)
return p;
return NULL;

}

B
* insert: Prompts the user for information about a new *
* part and then inserts the part into the e
* inventory list; the list remains sorted by *
* part number. Prints an error message and *
. returns prematurely if the part already exists *
¥ or space could not be allocated for the part. *

*

B R P T e

void insert (void)

{

struct part *cur, *prev, *new node;

new_node - malloc (sizeof (struct part));

if (new_node == NULL) {
printf ("Database is full; can't add more parts.\n"
return;

}

printf ("Enter part number: ");
scanf ("%d", &new_node->number) ;

for (cur = inventory, prev = NULL;
cur NULL && new_node->number > cur->number;
pPrev = cur, cur = cur-snext)

if (cur != NULL && new node->number =
printf ("Part already exists.\n");
free (new_node) ;
return;

cur->number) |{

printf ("Enter part name: ") ;

read line(new_ncde->name, NAME LEN) ;
printf ("Enter guantity on hand: ");
scanf ("$d", &new_node-son hand) ;

new_node->next - cur;
if (pxev NULL)
inventory = new node;
else
prev->next = new node;

17.5 Linked Lists = 437

P R R P
+ search: Prompts the user to enter a part number, then *

* locks up the part in the database. If the part ¥
* exists, prints the name and quantity on hand; *
= if not, prints an error message. »

B e

void search(void)

int number;
struct part *p;

printf ("Enter part number: ");
scanf ("2d", &number);
p - find_part (numbex) ;
if (p = NURL) {
printf ("Part name: %s\n", p-=>name);
printf ("Quantity on hand: %d\n", p->on_hand);
} else
printf ("Part not found.\n");

G ST

* update: Prompts the user to erter a part number. *
L4 Prints an error message if the part doesn't :
* exist; otherwise, prompts the user to enter *
* change in quantity on hand and updates the *
f database. *
HEE AR A R KRR AR AR KRR AR KR A XA KRR TR R KRR AR R KRR TR A KRR AR |

void update (void)

int number, change;
struct part *p;

printf ("Enter part number: ");
scanf ("%d", &number) ;
p = find part (number) ;
if (p != NULL) {
printf ("Enter change in quantity on hand: ");
scanf ("%d", &change) ;
p->on_hand += chang
} else
printf ("Part not found.\n");
}

G T P

« print: Prints a listing of all parts in the database, *

* showing the part number, part name, and -
e quantity on hand. Part numbers will appear in *
* ascending order. *

SRR KRRk Kk Rk Rk ke

void print (void)

struct part *p;
438

Chapter 17

Advanced Uses of Pointers

printf ("Part Number Part Name i
"Quantity on Hand\n");
for (p - inventory; p != NULL; p = p->next)
printt ("$7d %-25s%11d\n", p->number, p->name,
p-son_hand) ;

Notice the use of free in the insert function. insert allocates memory
for a part before checking to see if the part already exists. If it does, insert
releases the space to avoid a memory leak.

17.6 Pointers to Pointers

In Section 13.7, we came across the notion of a pointer to a pointer. In that section,
we used an array whose elements were of type char *: a pointer to one of the
array elements itself had type char **. The concept of “pointers to pointers” also
pops up frequently in the context of linked data structures. In particular, when an
argument (o a function is a pointer variable, we'll sometimes want the function (o
be able to modify the variable by making it point somewhere else. Doing so
requires the use of a pointer to a pointer.

Consider the add_to_1ist function of Section 17.5, which inserts a node
at the beginning of a linked list. When we call add_to_list, we pass it a
pointer to the first node in the original list; it then returns a pointer to the first node
in the updated list:

struct node *add to list(struct node *liet, int n)

{

struct node *new_node;

new_node = malloc(sizeof (struct node)) ;

if (new_node == NULL) {
printf ("Error: malloc failed in add to list\n");
exit (EXIT_FAILURE) ;

}

new_node->value = n;

new_node->next = 11

return new node;

}

Suppose that we modify the function so that it assigns new_node to list
instead of returning new_node. In other words, let’s remove the return state-
ment from add_to list and replace it by

list = new node;

Unfortunately, this idea doesn’t work. Suppose that we call add_to 1list in the
following way:

add_to_list(first, 10);
Ar.7

17.7 Pointers to Functions ~ 439

At the point of the call, first is copied into 11ist. (Pointers, like all arguments,
are passed by value.) The last line in the function changes the value of 1ist, mak-
ing it point to the new node. This assignment doesn’t affect first, however.

Getting add_to_list to modify first is possible, but it requires pass-
ing add_to_list a pointer to first. Here's the correct version of the func-
ton:

void add to_list(struct node **list, int n)
struct node *new node;

new_node = malloc(sizeof (struct node)) ;

if (new_node == NULL) (
printf ("Error: malloc failed in add_to_list\n");
exit (EXIT FATLURE) ;

new_node->value = n;
new_node snext = *list;
*1ist = new node;

}

When we call the new version of add_to_1ist, the first argument will be the
address of first:

add_to_list (&first, 10);

Since 1ist is assigned the address of first, we can use *1ist as an alias for
Eirst. In particular, assigning new_node to *1ist will modify first.

Pointers to Functions

We've seen that pointers may point to various kinds of data, including variables,
array eelements, and dynamically allocated blocks of memory. But C doesn’t
require that pointers point only to data; it’s also possible to have pointers to func-
tions. Pointers to functions aren’t as odd as you might think. After all, functions
occupy memory locations, so every function has an address, just as each variable
has an address.

Function Pointers as Arguments

We can use function pointers in much the same way we use pointers to data. In par-
ticular, passing a function pointer as an argument is fairly common in C. Suppose
that we're writing a function named integrate that integrates a mathematical
function f between points a and b. We'd like to make integrate as general as
possible by passing it f as an argument. To achieve this effect in C, we’ll declare f
to be a pointer to a function. Assuming that we want to integrate functions that have
440

Chapter 17 Advanced Uses of Pointers

sin function »23.3

a double parameter and return a double result, the prototype for integrate
will look like this:

double integrate(double (*f) (double), double a, double k) ;

The parentheses around * f indicate that f is a pointer to a funetion, not a function
that returns a pointer. It’s also legal to declare f as though it were a function:

double integrate(double f(double), double a, double b);

From the compiler’s standpoint, this prototype is identical to the previous one.

When we call integrate, we'll supply a function name as the first argu-
ment. For example, the following call will integrate the sin (sinc) function from 0
to m/2:

result = integrate(sin, 0.0, PI / 2);

Notice that there are no parentheses after sin. When a function name isn't fol-
lowed by parentheses, the C compiler produces a pointer to the function instead of
generating code for a function call. In our example, we're not calling sin; instead,
we're passing integrate a pointer to sin. If this scems confusing, think of how
C handles arrays, If a is the name of an array, then a [i] represents one element of
the array, while a by itself serves as a pointer to the array. In a similar way, if f is a
function, C treats f (x) as a call of the function but f by itself as a pointer to the
function.
Within the body of integrate, we can call the function that f points to:

y = (*f) (x);

*f represents the function that f points to; x is the argument to the call. Thus, dur-
ing the execution of integrate (sin, 0.0, PI / 2), each call of *f is actu-
ally a call of sin. As an alternative to (*f) (x), C allows us to write f (x) o
call the function that f points to. Although f (x) looks more natural, I'll stick
with (*f) (x) as a reminder that f is a pointer to a function, not a function name.

The gsort Function

Although it might seem that pointers to functions aren’t relevant to the average
programmer, that couldn’t be further from the truth. In fact, some of the most usc-
ful functions in the C library require a function pointer as an argument. One of
these is gsort, which belongs to the <stdlib. h> header. gsort is a general-
purpose sorting function that’s capable of sorting any array. based on any criteria
that we choose.

Since the elements of the array that it sorts may be of any type—even a struc-
ture or union type—gsor t must be told how to determine which of two array ele-
ments is “smaller”” We'll provide this information to gsort by writing a
comparison function. When given two pointers p and c to array elements, the
comparison function must return an integer that is negative if *p is “less than” *q,

17.7 Pointers to Functions 441

zero if *p is “equal to” *q, and positive if *p is “greater than” *q. The terms “less
than,” “equal to,” and “greater than” are in quotes because it’s our responsibility to
determine how *p and *q are compared.

gsort has the following prototype:

veid gsort (void *base, size t nmemb, size t size,
int (*ccmpar) (const void *, const void *));

base must point to the first element in the array. (If only a portion of the array is
to be sorted, we’ll make base point to the first element in this portion.) In the sim-
plest case, base is just the name of the array, nmemb is the number of elements to
be sorted (not necessarily the number of elements in the array). si ze is the size of
each array element. measured in bytes. compar is a pointer to the comparison
function. When gsoxt is called, it sorts the array into ascending order, calling the
comparison function whenever it needs to compare array elements.

To sort the inventory array of Section 16,3, we'd use the following call of
gsort:

gsort (inventory, num_parts, sizeof (struct part), compare parts);

Notice that the second argument is num_parts, not MAX_PARTS; we don’t want
to sort the entire inventory array, just the portion in which parts are currently
stored. The last argument, compare parts, is a function that compares two
part structures,

Writing the compare_parts function isn't as easy as you might expect.
qsort requires that its parameters have type void *. but we can’t access the
members of a part structure through a void * pointer; we need a pointer of type
struct part * instead. To solve the problem, we’ll have compare_parts
assign its parameters, p and g, to variables of type struct part *, thereby con-
verting them to the desired type. compare parts can now use these variables to
access the members of the structures that p and g point to. Assuming that we want
to sort the inventory array into ascending order by part number. here’s how the
compare_parts function might look:

int compare parts(const void *p, const void *q)

const struct part *pl
const struct part *ql

Pi
qi

if (pl->number < gl->number)
return -1;
else if (pl->number == gl-snumber)
return 0;
else
return 1;
}

The declarations of p1 and g1 include the word const to avoid getting a warning
from the compiler. Since p and g are const pointers (indicating that the objects
442

Chapter 17 Advanced Uses of Pointers

to which they point should not be modified), they should be assigned only to
pointer variables that are also declared to be const.

Although this version of compare parts works, most C programmers
would write the function more concisely. First, notice that we can replace p1 and
g1 by cast expressions:

int compare parts(const void *p, const void *g)
if (((struct part *) p)->number <
((struct part *) g)->number)

return -1;

else if (((estruct part *) p)->number --
((struct part *) g)->number)

return 0;
else

return 1;

}

The parentheses around ( (struct part *) p) are necessary; without them, the
compiler would try to cast p- >number to type Struct part *.
‘We can make compare_parts even shorter by removing the if statements:

int compare parts(const void *p, const void *q)

return ((struct part *) p)->number -
((struct part *) q)->number;

Subtracting q’s part number from p's part number produces a negative result if p
has a smaller part number, zero if the part numbers are equal, and a positive result
if p has a larger part number. (Note that subtracting two integers is potentially
risky because of the danger of overflow. I'm assuming that part numbers are posi-
tive integers, so that shouldn’t happen here.)

To sort the inventory array by part name instead of part number, we'd use
the following version of compare_parts:

int compare parts(const void *p, const void *q|

return stremp (((struct part *) p)->name,
((struct part *) q)->name);

}

All compare parts has to do is call strcmp, which conveniently returns a
negative, zero, or positive result,

Other Uses of Function Pointers

Although I've emphasized the usefulness of function pointers as arguments to
other functions, that’s not all they’re good for. C treats pointers to functions just
like pointers to data; we can store function pointers in variables or use them as ele-
PROGRAM

<math.h header >22.5

17.7 Pointers to Functions 443

ments of an array or as members of a structure or union. We can even write func-
tions that return function pointers.
Here’s an example of a variable that can store a pointer to a function:

vold (*pf) (imt);

pf can point (o any function with an int parameter and a return type of void. If
f is such a function, we can make pf point to f in the following way:

pf = f;

Notice that there’s no ampersand preceding f. Once pf points to f, we can call f
by writing either

(*pE) (L) 7
or
pEE):

Arrays whose elements are function pointers have a surprising number of
applications. For example, suppose that we’re writing a program that displays a
menu of commands for the user to choose from. We can write functions that imple-
ment these commands, then store pointers to the functions in an array:

void (*file cmd[]) (void) = {new_cnd,
open_cmd,
close_cmd,
close_all_emd,
save cmd,
save as cmd,
save_all cmd,

print cmd,
exit_cmd
e

If the user selects command n, where n falls between 0 and 8, we can subscript the
file_cmd array and call the corresponding function:

(*file_cmd([n]) () ; /* or ffile cmdln] (); */

Of course, we could get a similar effect with a `switch` statement. Using an array
of function pointers gives us more flexibility, however, since the elements of the
array can be changed as the program is running.

Tabulating the Trigonometric Functions

The following program prints tables showing the values of the cos, sin, and tan
functions (all threc belong to <math. h>). The program is built around a function
named tabulate that, when passed a function pointer L, prints a table showing
the values of f.
444 Chapter 17 Advanced Uses of Pointers

tabulate.c /* Tabulates values of trigonometric functions */

#include <math.h>
#include <stdio.h>

void tabulate(double (*f) (double), double first,
double last, double iner);

int main(void)

double final, increment, initial;
printf ("Enter initial value: ");
scanf ("%1f", Einitial);

printf ("Enter final value: ");
scanf ("%1f", &final);

printf ("Enter increment: ");
scanf ("$1f", &increment);

printf ("\n x ces(x)"

oy st i e \n") ;
tabulate (cos, initial, final, increment];
printf ("\n % sin(x)"

U e Nt
tabulate(sin, initial, final, increment];
printf ("\n x tan (x) "

B s = ST

tabulate(tan, initial, final, increment);

return 0;

}

void tabulate(double (*f) (double), double first,
double last, double incr)
{

double x;
int i, num intervals;

num_intervals = ceil((last - first) / inmcr);
for (i = 0; i <= num intervals; i++) (

x = first + i * iner;

printf("%10.5f ¥10.5f\n", x, (*f) (x));

}

tabulate uses the ceil function, which also in <math.h>. When given an
argument x of double type, ceil returns the smallest integer that's greater than
or equal to x.

Here’s what a session with tabulate . c might look like;
17.8 Restricted Pointers (C99) 445

Enter initial value
Enter final value
Enter increment:

0.00000 1.00000
0.10000 0.99500
0.20000 0.98007
0.30000 0.95534
0.40000 0.92106
0.50000 0.87758

x 8in(x)
0.00000 0.00000
0.10000 0.09983

0.20000 0.19867
0.30000 0.29552
0.40000 0.38942
0.50000 0.47943

x tan (x)
0.00000 0.00000
0.10000 0.10023
0.20000 0.20271
0.30000 0.30934
0.40000 0.42279
0.50000 0.54630

17.8 Restricted Pointers (C99)

This section and the next discuss two of C99’s pointer-related features. Both are
primarily of interest to advanced C programmers; most readers will want to skip
these sections.

In C99, the keyword restrict may appear in the declaration of a painter:

int * restrict p;

A pointer that’s been declared using restrict is called a restricted pointer. The
intent is that if p points to an object that is later modified, then that object is not
accessed in any way other than through p. (Alternative ways to access the object
include having another pointer to the same object or having p point to a named
variable.) Having more than one way to access an object is often called aliasing.
Let’s look at an example of the kind of behavior that restricted pointers are
supposed to discourage. Suppose that p and g have been declared as follows:

int * restrict p;
int * restrict q;
446 Chapter 17 Advanced Uses of Pointers

extern storage class » 6.2
blocks »10.3

file scope > 10.2

<string,h>header »23.6

Now suppose that p is made to point to a dynamically allocated block of memory:
p = malloc(sizeof (int));

(A similar situation would arise if p were assigned the address of a variable or an
array element.) Normally it would be legal to copy p into g and then modify the
integer through o:

%g = 0; /* causes undefined behavior */

Because p is a restricted pointer, however, the effect of executing the statement
g = is undefined. By making p and g point to the same object, we caused *p
and *q to be aliases.

If a restricted pointer p is declared as a local variable without the extern
storage class, restrict applies only to p when the block in which p is declared
is being executed. (Note that the body of a function is a block.) restrict can be
used with function parameters of pointer type, in which case it applies only when
the function is executing. When restrict is applied to a pointer variable with
file scope, however, the restriction lasts for the entire execution of the program.

The exact rules for using restrict are rather complex; see the C99 stan-
dard for details. There are even situations in which an alias created from a
restricted pointer is legal. For example, a restricted pointer p can be legally copied
into another restricted pointer variable g, provided that p is local to a function and
q is defined inside a block nested within the function’s body.

To illustrate the use of restrict, let’s look at the memepy and memmove
functions, which belong to the <string.h> header. memcpy has the following
prototype in C99:

void *memcpy(void * restrict sl, const void * restrict s2,
size t m);

memcpy is similar to strcpy, except that it copies bytes from one object to
another (strcpy copies characters from one string into another). s2 points to the
data to be copied, s1 points to the destination of the copy. and n is the number of
bytes to be copied. The usc of restrict with both s1 and s2 indicates that the
source of the copy and the destination shouldn’t overlap. (It doesn’t guarantee that
they don’t overlap. however.)

In contrast, restrict doesn't appear in the prototype for memmove:

void *memmove (void *sl, const void *s2, size t n);

memmove does the same thing as memcpy: it copies bytes from one place to
another. The difference is that memmove is guaranteed to work even if the source
and destination overlap. For example, we could use memmove to shift the elements
of an array by one position:

int a[100];
register storage class >18.2

17.9

17.9 Flexible Array Members (C99) 447

memmove (&a [0], &a[l], 99 * sizeof (int));

Prior to C99, there was no way to document the difference between memepy and
memmove. The prototypes for the two functions were nearly identical:

void *memepy (void *sl, const void #s2, size t n);
void *memmove (void *sl1, const void *s2, size_t n);

The use of restrict in the C99 version of memcpy’s prototype lets the pro-
grammer know that s1 and s2 should point to objects that don’t overlap, or else
the function isn’t guaranteed o work.

Although using restrict in function prototypes is useful documentation,
that’s not the primary reason for its existence, restrict provides information to
the compiler that may enable it to produce more efficient code—a process known
as optimization. (The register storage class scrves the same purpose.) Not
every compiler attempts to optimize programs, however, and the ones that do nor-
mally allow the programmer to disable optimization. As a result, the C99 standard
guarantees that restrict has no effect on the behavior of a program that con-
forms to the standard: if all uses of restrict are removed from such a program,
it should behave the same.

Most programmers won't use restrict unless they're fine-tuning a pro-
gram to achieve the best possible performance. Still, it’s worth knowing about
restrict because it appears in the C99 prototypes for a number of standard
library functions.

Flexible Array Members (C99)

Every once in a while, we'll need to define a structure that contains an array of an
unknown size. For example, we might want to store strings in a form that’s differ-
ent from the usual one. Normally, a string is an array of characters, with a null
character marking the end. However, there are advantages to storing strings in
other ways. One alternative is to store the length of the string along with the
string’s characters (but with no null character). The length and the characters could
be stored in a structure such as this one:

struct vstring {

int len;
char chars(N] ;

Here N is a macro that represents the maximum length of a string. Using a fixed-
length array such as this is undesirable, however, because it forces us to limit the
length of the string, plus it wastes memory (since most strings won't need all N
characters in the array).

C programmers have traditionally solved this problem by declaring the length
of chars to be 1 (a dummy value) and then dynamically allocating each string:
448 Chapter 17 Advanced Uses of Pointers

struct vstring {

int len;

char chars(1];
struct vstring *str = malloc(sizeof (struct vstring) + n - 1);
str-slen = n;

We're “cheating" by allocating more memory than the structure is declared to have
(in this case, an extra n — | characters), and then using the memory to store addi-
tional elements of the chars array. This technique has become so common over
the years that it has a name: the “struct hack.”

The struct hack isn’t limited to character arrays: it has a variety of uses. Over
time, it has become popular enough to be supported by many compilers. Some
(including GCC) even allow the chars array to have zero length, which makes
this trick a little more explicit. Unfortunately, the C89 standard doesn’t guarantee
that the struct hack will work, nor does it allow zero-length arrays.

In recognition of the struct hack’s usefulness, C99 has a feature known as the
Slexible array member that serves the same purpose. When the last member of a
structure is an array, its length may be omitted:

struct vstring (
int len;
char chars(]; /* flexible array member - C99 only */

}i

The length of the chars array isn’t determined until memory is allocated for a
vstring structure, normally using a call of malloc:

struct vstring *str = malloc(sizeof (struct vstring) + n);
str->len = n;

In this example, str points to a vstring structure in which the chars array
occupies n characters. The sizeof operator ignores the chars member when
computing the size of the structure. (A flexible array member is unusual in that it
takes up no space within a structure.)

A few special rules apply to a structure that contains a flexible array member.
The flexible array member must appear last in the structure, and the structure must
have at least one other member. Copying a structure that contains a flexible array
member will copy the other members but not the flexible array itself.

A structure that contains a flexible array member is an ircomplete type. An
incomplete type is missing part of the information needed to determine how much
memory it requires. Incomplete types. which are discussed further in one of the
Q&A questions at the end of this chapter and in Section 19.3, are subject to various
restrictions. In particular, an incomplete type (and hence a structure that contains a
flexible array member) can’t be a member of another structure or an element of an
array. However, an array may contain pointers to structures that have a flexible
array member; Programming Project 7 at the end of this chapter is built around
such an array.

*Q:

variable-length argument lsts
261

Q&A 449

Q&A

‘What does the NULL macro represent? [p. 415]

NULL actually stands for 0. When we use 0 in a context where a pointer would be
required, C compilers treat it as a null pointer instead of the integer 0. The NULL
macro is provided merely to help avoid confusion. The assignment

P = 0;

could be assigning the value 0 to a numeric variable or assigning a null pointer to a
pointer variable; we can’t easily tell which. In contrast, the assignment

p = NULL;
makes it clear that p is a pointer.

In the header files that come with my compiler, NULL is defined as follows:
#define NULL (void *) 0

‘What's the advantage of casting 0 to void *?

This trick, which is allowed by the C standard, enables compilers to spot incorrect
uses of the null pointer. For example, suppose that we try to assign NULL to an
integer variable:

i = NULL;

If NULL is defined as 0, this assignment is perfectly legal. But if NUT.T, is defined
as (void *) 0, the compiler can warn us that we're assigning a pointer to an inte-
ger variable.

Defining NULL as (void *) 0 has a second, more important, advantage.
Suppose that we call a function with a variable-length argument list and pass NULL,
as one of the arguments. If NULL is defined as 0, the compiler will incorrectly pass
a zero integer value. (In an ordinary function call, NULL works fine because the
compiler knows from the function’s prototype that it expects a pointer. When a
function has a variable-length argument list, however. the compiler lacks this
knowledge.) If NULL is defined as (void *) 0, the compiler will pass a null
pointer.

To make matters even more confusing, some header files define NULL to be
OL (the long version of 0). This definition, like the definition of NULL as 0, is a
holdover from C’s earlier years, when pointers and integers were compatible, For
most purposes, though, it really doesn't matter how NULL is defined; just think of
it as a name for the null pointer.

Since 0 is used to represent the null pointer, I guess a null pointer is just an
address with all zero bits, right?
450

Chapter 17 Advanced Uses of Pointers

Al

#Q:

Not necessarily. Each C compiler is allowed to represent null pointers in a different
way, and not all compilers use a zero address. For example, some compilers use a
nonexistent memory address for the null pointer; that way, attempting to access
memory through a null pointer can be detected by the hardware.

How the null pointer is stored inside the computer shouldn’t concern us; that’s
a detail for compiler experts to worry about. The important thing is that, when used
in a pointer context, 0 is converted to the proper internal form by the compiler.

Is it acceptable to use NULL as a null character?

Definitely not. NULL is a macro that represents the null pointer, not the null char-
acter. Using NULL as a null character will work with some compilers, but not with
all (since some define NULL as (void *) 0). In any event, using NULL as any-
thing other than a pointer can lead to a great deal of confusion. If you want a name
for the null character, define the following macro:

#define NUL '\0'

When my program terminates, I get the message “Null pointer assignment.”
What does this mean?

This message, which is produced by programs compiled with some older DOS-
based C compilers, indicates that the program has stored data in memory using a
bad pointer (but not necessarily a null pointer). Unfortunately, the message isn’t
displayed until the program terminates, so there’s no clue as to which statement
caused the error. The “Null pointer assignment”” message can be caused by a miss-
ing &in scanf:

scant ("%d", i); /* should have been scanf("$d", &i); */
Another possibility is an assignment involving a pointer that’s uninitialized or null:
*p = i; /* p is uninitialized or null */

How does a program know that a “null pointer assignment” has occurred?
The message depends on the fact that. in the small and medium memory models,
data is stored in a single segment, with addresses beginning at 0. The compiler
leaves a “hole" at the beginning of the data segment—a small block of memory
that's initialized to 0 but otherwise isn’t used by the program. When the program
terminates, it checks to see if any data in the “hole” area is nonzero. If so, it must
have been altered through a bad pointer.

Is there any advantage to casting the return value of malloc or the other
memory allocation functions? [p. 416]

Not usually. Casting the void * pointer that these functions return is unnecessary,
since pointers of type void * are automatically converted to any pointer type
upon assignment. The habit of casting the return value is a holdover from older
versions of C, in which the memory allocation functions returned a char * value,
making the cast necessary. Programs that are designed to be compiled as C-++ code
=Q;

incomplete types > 19,9

Q&A 451

may henefit from the cast, but that’s about the only reason to do it.

In C89, there's actually a small advantage to nor performing the cast. Suppose
that we've forgotten (o include the <stdlib.h> header in our program. When
we call malloc, the compiler will assume that its return type is int (the default
return value for any C function). If we don’t cast the return value of malloc, a
€89 compiler will produce an error (or at least a warning), since we're trying to
assign an integer value to a pointer variable. On the other hand, if we cast the
return value (o a pointer, the program may compile, but likely won’t run properly.
With C99, this advantage disappears. Forgetting to include the <stdlib.hs>
header will cause an error when malloc is called, because CY9 requires that a
function be declared before it’s called.

The calloc function initializes a memory block by setting its bits to zero.
Does this mean that all data items in the block become zero? [p-421)

Usually, but not always. Setting an integer (o zero bits always makes the integer
2ero. Setting a floating-point number to zero bits usually makes the number zero,
but this isn’t guaranteed—it depends on how floating-point numbers are stored.
The story is the same for pointers; a pointer whose bits are zero isn’t necessary a
null pointer.

I'see how the structure tag mechanism allows a structure to contain a pointer
to itself. But what if two structures each have a member that points to the
other? [p. 425]

Here’s how we'd handle that situation:

struct

i /* incomplete declaration of s1 */
struct s2 {

struct sl #p;

}i

struct sl {
atruct 82 *q;

)i

The first declaration of s1 creates an incomplete structure type, since we haven’t
specificd the members of 1. The second declaration of s1 “completes” the type
by describing the members of the structure. Incomplete declarations of a structure
type are permitted in C, although their uses are limited. Creating a pointer to such a
type (as we did when declaring p) is one of these uses.

Calling malloc with the wrong argument—causing it to allocate too much
memory or too little memory—seems to be a common error. Is there a safer
way to usemalloc? [p. 426]
452

Chapter 17 Advanced Uses of Pointers

Al

*Q:

Qs

Yes, there is. Some programmers use the following idiom when calling malloc to
allocate memory for a single object:

= malloc(sizeof (*p)) ;

Since sizcof (*p) is the size of the object to which p will point, this statement
guarantees that the correct amount of memory will be allocated. At first glance.
this idiom looks fishy: it’s likely that p is uninitialized, making the value of *p
undefined. However, sizeof doesn't evaluate *p, it merely computes its size, so
the idiom works even if p is uninitialized or contains a null pointer.

To allocate memory for an array with n elements, we can use a slightly modi-
fied version of the idiom:

p = malloc(n * sizeof (+p));

Why isn’t the gsort function simply named sort? [p. 440]

The name gsort comes from the Quicksort algorithm published by C. A. R.
Hoare in 1962 (and discussed in Section 9.6). Ironically, the C standard doesn’t
require that gsort use the Quicksort algorithm, although many versions of
gsort do.

Isn’t it necessary to cast gsort’s first argument to type void *, as in the fol-
lowing example? [p. 441]

gsort ( (void *) inventory, num parts, sizeof(struct part),
compare_parts);

No. A pointer of any type can be converted to void * automatically.

I want to use gsort to sort an array of integers, but I'm having trouble writ-
ing a comparison function. What's the secret?

Here's a version that works:
int compare_ints(const void *p, const void *g)

return *(int *)p - *(int *)q;

Bizarre, eh? The expression (int *)p casts p to type int *, so * (int *)p
would be the integer that p points to. A word of warning, though: Subtracting two
integers may cause overflow. If the integers being sorted are completely arbitrary,
it’s safer to use `if` statements to compare * (int *) p with * (int *) q.

I needed to sort an array of strings, so I figured I'd just use strcmp as the
comparison function. When I passed it to gsort, however, the compiler gave
me a warning. | tried to fix the problem by embedding strcmp in a compari-
son function:
Section 17.1

Section 17.2

Section 17.3

Section 17.5

Exercises 453

int compare_strings(conct void *p, const void *q)

return strcmp(p, q);

Now my program compiles, but gsort doesn’t seem to sort the array. What
am 1 doing wrong?

First, you can’t pass stremp itself to gsort, since gsort requires a comparison
function with two const void * parameters. Your compare strings func-
tion doesn’t work because it incorrectly assumes that p and q are strings (char *
pointers). In fact, p and g point to array elements containing char * pointers. To
fix compare strings, we'll cast p and g to type char **, then use the *
operator to remove one level of indirection:

int compare_strings(const void *p, const void *q)

return streomp (*(char **)p, *(char **)q);

)

Exercises

Having to check the return value of malloc (or any other memory allocation function)
each time we call it can be an annoyance. Write a function named my_malloc that serves
as a “wrapper” for malloc. When we call my_malloc and ask it to allocate n bytes, it in
turn calls malloc, tests to make sure that malloe doesn't return a null pointer, and then
returns the pointer from malloc. Have my_walloc print an error message and terminate
the program if malloc returns a null pointer.

Write a function named duplicate that uses dynamic storage allocation to create a copy
of a string. For example, the call

p = duplicate(str);
would allocate space for a string of the same length as str, copy the contents of str into

the new string, and return a pointer to it. Have duplicate return a null pointer if the
memory allocation fails.

Write the following function:
int *create array(int n, int initial value);

The function should return a pointer to a dynamically allocated int array with n members,
each of which is initialized to initial value. The return value should be NULL if the
array can't be allocated.

Suppose that the following declarations are in effect;
struct point { int x, y;
struct rectangle { struct point upper left, lower right; };
struct rectangle *p;

454

Chapter 17  Advanced Uses of Pointers

Assume that we want p to point to a rectangle structure whose upper left corner is at
(10, 25) and whose lower right corner is at (20, 15). Write a series of statements that allocate
such a strueture and initialize it as indicated.

Suppose that f and p are declared as follows:

struct {
union {
char a, b;
int ©;
] &
int e[s1;
} f, *p = &f;
‘Which of the following statements are legal?
(@) p->b = ' !
(b) p->e[3] i
(©) (*p)iidia = TeE;
) p->d-sc = 2

Modify the delete_from_1ist function so that it uses only one pointer variable instead
of two (cur and prev).

The following loop is supposed to dclete all nodes from a linked list and release the memory
that they occupy. Unfortunately, the loop is incorrect. Explain what's wrong with it and
show how to fix the bug.
for (p = first; p != NULL; p = p->next)

free(p);

Section 15.2 describes a file, stack.c, that provides functions for storing integers in a
stack. In that section, the stack was implemented as an array. Modify stack.c so that a
stack is now stored as a linked list. Replace the contents and top variables by a single
variable that points to the first node in the list (the “top” of the stack). Write the functions in
stack.c so that they use this pointer. Remove the is_full function, instead having
push return either true (if memory was available to create a node) or false (if not)

True or false: If x is a structure and a is a member of that structure, then (&x) ->a is the
same as x . a. Justify your answer.

Modify the print_part function of Section 162 so that its parameter is a pointer to a
part structure, Use the ~> operator in your answer.

Write the following function:

int count_occurrences(struct node *list, int n);

The 1ist parameter points to a linked list: the function should return the number of times
that n appears in this list. Assume that the node structure is the one defined in Section 17.5.
Write the following function:

struct node *find last(struct node *list, int n);

The 1ist parameter points to a linked list. The function should return a pointer to the last
node that contains n it should return NULL if 1 doesn’t appear in the list. Assume that the
node structure is the one defined in Section 17.5.

The following function is supposed to insert a new node into its proper place in an ordered
list, returning a pointer to the first node in the modified list. Unfortunately, the function
Section 17.6

Section 17.7

14.

@ 15

Q1.
18,

19.

Exercises 455

docesn’t work correctly in all cases. Explain what's wrong with it and show how to fix it.
Assume that the node structure is the one defined in Section 17.5,

struct node *insert_into_ordered list (struct node *list,
{ struct node *new_node)

struct ncde *cur = list, *prev = NULL;

while (cur-»value <= new_node->value) {
prev = cur;

| cur = cur-snext;

}

prev-snext = new_node;

new _node->next - cur;

return list;

}

Modify the delete_from_list function (Section 17.5) so that its first parameter has
type struct node ** (a pointer to a pointer to the first node in a list) and its return type is
void. delete from list must modify its first argument to point to the list after the
desired node has been deleted.

Show the output of the following program and explain what it does.

#include <stdio.h>

int f1(int (*f) (int));
int ff2(int 1i);

int main(void)

printf ("Answer: %d\n", f1(f2));
return 0;

int f1(int (*f) (int))

int n = 0;

while ((*f)(n)) n++;
return n;

}

int ff2(int i)

returm i #ed and = a2,

Write the following function. The call sum (g, i, j) should return g (i) +... +a(j).

int sum{int (*f) (int), int start, int end);

Let a be an array of 100 integers. Write a call of gsort that sorts only the /ast 50 elements
in a_ (You don’t need to write the comparison function)

Modify the compare parts function so that parts arc sorted with their numbers in
descending order.

Write a function that, when given a string as its argument, searches the following array of
structures for 2 matching command name, then calls the function associated with that name.
456

Chapter 17

Advanced Uses of Pointers

struct {

char *cmd name;

void (*emd pointer) (void) ;
} file emd[] =

{{"newn, nev_cmd},
"open', open_cmd},
{"close", close_cmd},
{"close all", close_all_cmd},
{"save", save_cmd},

{"save as", save_as_cmd},
{"save all", save all cmd},
{"print", print_cmd},
{exit", exit omd)

b

Programming Projects

Modify the inventory . c program of Section 16.3 so that the inventory array is allo-
cated dynamically and later reallocated when it fills up. Use malloc initially to allocate
enough space for an array of 10 part structures. When the array has no more room for new
parts, use realloc to double its size. Repeat the doubling step each time the array
becomes full.

Modify the inventory.c program of Section 16.3 so that the p (print) command calls
gsort tosort the inventory array before it prints the parts.

Modify the inventory2.c program of Section 17.5 by adding an e (erase) command
that allows the user to remove a part from the database.

Modify the justify program of Section 15.3 by rewriting the line.c filc so that it
stores the current line in a linked list. Each node in the list will store a single word. The
line array will be replaced by a variable that points to the node containing the first word.
This variable will store a null pointer wherever the line is empty.

Write a program that sorts a series of words entered by the user:

Enter word: fco
Enter word: bar
Enter word: baz
Enter word: guux
Enter word:

In scrted order: bar baz foo gquux

Assume that each word is no more than 20 characters long. Stop reading when the user
enters an empty word (i.e., presses Enter without entering a word). Store each word in a
dynamically allocated string, using an array of pointers to keep track of the strings. as in the
remind2.c program (Section 17.2). After all words have heen read, sort the array (using
any sorting technique) and then use a loop to print the words in sorted order. Hint: Use the
read_line function to rcad cach word, as in remind2. c.

Modify Programming Project 5 so that it uses gsort 1o sort the array of pointers.

(C99) Modify the remind2.c program of Section 17.2 so that each element of the
reminders array is a pointer to a vstring structure (see Section 17.9) rather than a
pointer to an ordinary string
18

18.1

Declarations

Meaking something variable is easy.
Controlling duration of constancy is the trick.

Declarations play a central role in C programming. By declaring variables and
functions, we furnish vital information that the compiler will need in order to
check a program for potential errors and translate it into object code.

Previous chapters have provided examples of declarations without going into
full derails; this chapter fills in the gaps. It explores the sophisticated options that
can be used in declarations and reveals that variable declarations and function dec-
larations have quite a bit in common, It also provides a firm grounding in the
important concepts of storage duration, scope., and linkage.

Section 18.1 examines the syntax of declarations in their most general form,
a topic that we've avoided up to this point. The next four sections focus on the
items that appear in declarations: storage classes (Section 18.2), type qualifiers
(Section 18.3), declarators (Section 18.4), and initializers (Section 18.5). Section
18.6 discusses the inline keyword, which can appear in C99 function declara-
tions,

Declaration Syntax

Declarations furnish information to the compiler about the meaning of identifiers.
‘When we write

int i;

we're informing the compiler that, in the current scope, the name i represents a
variable of type int. The declaration

float f(float);

457
458

Chapter 18 Declarations

declaration

tells the compiler that f is a function that returns a float value and has one argu-
ment, also of type float.
In general, a declaration has the following appearance:

declaration-specifiers declarators ;

Declaration specifiers describe the properties of the variables or functions being
declared. Declarators give their names and may provide additional information
about their properties

Declaration specifiers fall into three categories:

m Storage classes. There are four storage classes: auto, static, extern,
and register. At most one storage class may appear in a declaration; if
present, it should come first.

m Type qualifiers. In CR9, there are only two type qualifiers: const and vol-
atile. C99 has a third type qualifier, restrict. A declaration may con-
tain 7ero or more type qualifiers.

m Type specifiers. The keywords void, char, short, int, long, fleat,
double, signed, and unsigned are all type specifiers. These words may
be combined as described in Chapter 7; the order in which they appear doesn’t
matter (int unsigned long is the same as long unsigned int). Type
specifiers also include specifications of structures, unions, and enumerations
(for example, struct point { int x, y; }, struct { int x, v; },or
struct point). Type names created using typedef are type specifiers as
well,

(C99 has a fourth kind of declaration specifier, the function specifier, which is
used only in function declarations. This category has just one member, the key-
word inline.) Type qualifiers and type specifiers should follow the storage class,
but there are no other restrictions on their order. As a matter of style, I'll put type
qualifiers before type specifiers.

Declarators include identifiers (names of simple variables), identifiers fol-
lowed by [] (array names), identifiers preceded by * (pointer names), and identifi-
ers followed by () (function names). Declarators are separated by commas. A
declarator that represents a variable may be followed by an initializer.

Let’s look at a few examples that illustrate these rules. Here's a declaration
with a storage class and three declarators:

storage class declarators
SN
static float x, y, *p;

type specifier

The following declaration has a type qualifier but no storage class. It also has an
initializer:
18.2 Storage Classes 459

type qualifier declarator
const char month[] = "January";
type specifier initializer

The following declaration has both a storage class and a type qualifier. It also has
three type specifiers; their order isn't important:

storage class typf; specifiers
v (i
extern const unsigned long int a[10];

type qualifier declarator

Function declarations, like variable declarations, may have a storage class, type
qualifiers, and type specifiers. The following declaration has a storage class and a

type specifier:

storage class declarator
v
extern int square(int);
A

type specifier

The next four sections cover storage classes, type qualifiers, declarators, and
initializers in detail.

18.2 Storage Classes

Storage classes can be specified for variables and—to a lesser extent—functions
and parameters. We'll concentrate on variables for now.

Recall from Section 10.3 that the term block refers to the body of a function
(the part enclosed in braces) or a compound statement, possibly containing decla-
rations. In C99, selection statements (if and switch) and iteration statements
(while, do, and for)—along with the “inner” statements that they control—arc
considered to be blocks as well, although this is primarily a technicality.

Bo

Properties of Variables
Every variable in a C program has three properties

m Storage duration. The storage duration of a variable determines when mem-
ory is set aside for the variable and when that memory is released. Storage for
a variable with automatie storage duration is allocated when the surrounding
460

Chapter 18 Declarations

QeA

block is executed: storage is deallocated when the block terminates, causing
the variable to lose its value. A variable with static storage duration stays at
the same storage location as long as the program is running, allowing it to
retain its value indefinitely,

m Scope. The scope of a variable is the portion of the program text in which the
variable can be referenced. A variable can have either block scope (the vari-
able is visible from its point of declaration to the end of the enclosing block)
or file scope (the variable is visible from its point of declaration to the end of
the enclosing file).

w Linkage. The linkage of a variable determines the extent to which it can be
shared by different parts of a program. A variable with external linkage may
be shared by several (perhaps all) files in a program. A variable with internal
linkage is restricted to a single file, but may be shared by the functions in that
file. (If a variable with the same name appears in another file, it’s treated as a
different variable.) A variable with no linkage belongs to a single function and
can’t be shared at all.

The default storage duration, scope, and linkage of a variable depend on where
it's declared:

= Variables declared insicle a block (including a function body) have automatic
storage duration, block scope, and no linkage.

m Variables declared outside any block, at the outermost level of a program, have
static storage duration, file scope, and exzernal linkage.

The following example shows the default properties of the variables i and j:
static storage duration

—— file scope
~ external linkage

void f(void)

__aulomalic slorage duration
block scope

int j;
no linkage

For many variables, the default storage duration, scope, and linkage are satis-
factory. When they aren’t, we can alter these properties by specifying an explicit
storage class: auto, static, extern, or register.

The auto Storage Class

The auto storage class is legal only for variables that belong to a block. An auto
variable has automatic storage duration (not surprisingly), block scope, and no
linkage. The auto storage class is almost never specified explicitly. since it’s the
default for variables declared inside a block.
information hiding > 19.2

18.2 Storage Classes 461

The static Storage Class

The static storage class can be used with all variables, regardless of where
they're declared, but it has a different effect on a variable declared outside a block
than it does on a variable declared inside a block. When used ouzside a block, the
word static specifies that a variable has internal linkage. When used inside a
block. static changes the variable’s storage duration from automatic to static.
The following figure shows the effect of declaring 1 and j to be static:

- static storage duration
file scope
" internal linkage

static int

void f(void)

__ static storage duration

static int j;=_—block scope
o linkage

When used in a declaration outside a block, static essentially hides a vari
able within the file in which it's declared; only functions that appear in the same
file can see the variable. In the following example, the functions f1 and f2 both
have access to 1, but functions in other files don’t:

statie int 1i;

void f1 (void)

{
/* has access to i */
i
void f2(void)
{

/* has access to i */
This use of static can help implement a technique known as information hid-
ing.

A static variable declared within a block resides at the same storage loca-
tion throughout program execution. Unlike automatic variables, which lose their
values each time the program leaves the enclosing block, a static variable will
retain its value indefinitely. static variables have some interesting propertics:

= A static variable in a block is initialized only once, prior to program execu-
tion. An auto variable is initialized every time it comes into existence (pro-
vided, of course, that it has an initializer).

= Each time a function is called recursively. it gets a new set of auto variables.
If it has a static variable, on the other hand, that variable is shared by all
calls of the function.
462

Chapter 18  Declarations

= Although a function shouldn’t return a pointer to an auto variable, there’s
nothing wrong with it returning a pointer to a static variable,

Declaring one of its variables to be static allows a function to retain infor-
mation between calls in a “hidden” area that the rest of the program can’t access.
More often, however, we'll use static to make programs more efficient. Con-
sider the following function:

char digit_to_hex char (int digit)
censt char hex chars[16] = "0123456789ABCDEF";

return hex chars(digit];

)

Each time the digit to hex char function is called, the characters
012345678 9ABCDEF will be copied into the hex chars array to initialize it.
Now, let’s make the array static:

char digit to hex char(int digit)

static const char hex chars[16] = "0123456789ABCDEF";

return hex chars[digit];

Since static variables are initialized only once, we've improved the speed of
digit_to_ hex char.

The extern Storage Class

The extern storage class enables several source files (o share the same variable.
Section 15.2 covered the essentials of using extern, so I won't devote much
space to it here. Recall that the declaration

extern int i;

informs the compiler that 1 is an int variable, but doesn’t cause it to allocate
memory for i. In C terminology, this declaration is not a definition of 1i; it merely
informs the compiler that we need access to a variable that’s defined elsewhere
(perhaps later in the same file, or— more often—in another file). A variable can
have many dectararions in a program but should have only one definition.

There’s one exception to the rule that an extern declaration of a variable
isn’t a definition. An extern declaration that initializes a variable serves as a def-
inition of the variable. For example, the declaration

extern int i = 0;
is effectively the same as

int i = 0;
QzA

182 Storage Classes 483

This rule prevents multiple extern declarations from initializing a variable in
different ways.

A variable in an extern declaration always has static storage duration. The
scope of the variable depends on the declaration’s placement. If the declaration is
inside a block, the variable has block scope: otherwise, it has file scope:

__— static storage duration
extern

void f(void)

__ static storage duration
—— block scope.
~ ? linkage

extern int j;

}

Determining the linkage of an extern variable is a bit harder. If the variable was
declared static carlier in the file (outside of any function definition), then it has
internal linkage. Otherwise (the normal case), the variable has external linkage.

The register Storage Class

Using the register storage class in the declaration of a variable asks the com-
piler to store the variable in a register instead of keeping it in main memory like
other variables. (A register is a storage area located in a computer’s CPU. Data
stored in a register can be accessed and updated faster than data stored in ordinary
memory.) Specifying the storage class of a variable to be register is a request.
not a command. The compiler is free to store a register variable in memory if
it chooses.

The register storage class is legal only for variables declared in a block. A
register variable has the same storage duration, scope, and linkage as an auto
variable. However, a register variable lacks one property that an auto vari-
able has: since registers don't have addresses, it's illegal to use the & operator to
take the address of a register variable. This restriction applies even if the com-
piler has elected to store the variable in memory.

register is best used for variables that are accessed and/or updated fre-
quently. For example, the loop control variable in a `for` statement is a good candi-
date for register treatment:

int sum_array(int a[], int n)

register int i;
int sum =

for (i = 0; 1 <m; it+)
sum += al[i];
return sum;
464

Chapter 18  Declarations

register isn't nearly as popular among C programmers as it once was.
Today’s compilers are much more sophisticated than early C compilers; many can
determine automatically which variables would benefit the most from being kept in
registers. Still, using register provides useful information that can help the
compiler optimize the performance of a program. In particular, the compiler knows
thal 4 register variable can’t have its address taken, and therefore can’t be
modified through a pointer. In this respect. the register keyword is related to
C99's restrict keyword.

The Storage Class of a Function

Function declarations (and definitions), like variable declarations, may include a
storage class, but the only options are extern and static. The word extern
at the beginning of a function declaration specifies that the function has external
linkage, allowing it to be called from other files. static indicates internal link-
age, limiting use of the function’s name to the file in which it’s defined. If no stor-
age class is specified, the function is assumed to have external linkage.

Consider the following function declarations:

extern int f(int i);
static int g(int i);
int h(int i);

f has external linkage, g has internal linkage, and h (by default) has external link-
age. Because it has internal linkage, g can't be called directly from outside the file
in which it’s defined. (Declaring g to be static doesn’t completely prevent it
from being called in another file; an indirect call via a function pointer is still pos-
sible.)

Declaring functions to be extern is like declaring variables to be auto—it
serves no purpose. For that reason, I don't use extern in function declarations.
Be aware, however, that some programmers use extern extensively, which cer-
tainly does no harm.

Declaring functions to be static, on the other hand, is quite useful. In fact, I
recommend using static when declaring any function that isn’t intended to be
called from other files. The benefits of doing so include:

» Easier maintenance. Declaring a function f to be static guarantees that f
isn’t visible outside the file in which its definition appears. As a result, some-
one modifying the program later knows that changes to f won't affect func-
tions in other files. (One exception: a function in another file that’s passed a
pointer to L might be affected by changes to f. Fortunately, that situation is
easy to spot by examining the file in which f is defined, since the function that
passes f must also be defined there.)

u Reduced “name space pollution.” Since functions declared static have
internal linkage, their names can be reused in other files. Although we proba-

Table 18.1
Properties of Variahles
and Parameters.

18.2 Slorage Classes 4865

bly wouldn't deliberately reuse a function name for some other purpose, it can
be hard to avoid in large programs. An excessive number of names with exter-
nal linkage can result in what C programmers call “name space pollution":
names in different files accidentally conflicting with each other, Using
static helps prevent this problem.

Function parameters have the same properties as auto variables: automatic

storage duration, block scope, and no linkage. The only storage class that can be
specified for parameters is register.

Summary

Now that we've covered the various storage classes, let’s summarize what we
know. The following program fragment shows all possible ways to include—or
omit—storage classes in declarations of variables and parameters.

int

aj

extern int b;
static int c;

void f(int d, register int e)

{

auto int g;
int h;

E

tatic int i;

extern int j;
register int k;

}

Table 18.1 shows the properties of cach variable and parameter in this example.

auto has no effect, and modern compi
tant.

Name  Storage Duration ~ Scope  Linkage
a static file external
b static file b
c static file internal
d automatic block none
e automatic block none
-1 automatic block none
h automatic block none
Al static block none
3 static block i
k automatic block  none

The definitions of b and j aren’t shown, 50 it’s not
possible (o determine the linkage of these variables. In
most cases, the variables will be defined in another file
and will have external linkage.

Of the four storage classes, the most important arc static and extern.
rs have made register less impor-

466

Chapter 18 Declarations

18.3
@D

restricted pointers »17.8

Type Qualifiers

There are two type qualifiers: const and volatile. (C99 has a third type qual-
ifier, restrict, which is used only with pointers.) Since the use of volatile
is limited to low-level programming, I'll postpone discussing it until Section 20.3.
const is used to declare objects that resemble variables but are “read-only": a
program may aceess the value of a const object, but can’( change it. For exam-
ple, the declaration

const int n = 10;
creates a const object named i whose value is 10. The declaration
const int tax brackets[] = {750, 2250, 3750, 5250, 7000};

creates a const array named tax_brackets.

Declaring an object to be const has several advantages:

= It’s a form of documentation: it alerts anyone reading the program to the read-

only nature of the object.

= The compiler can check that the program doesn’t inadvertently attempt to

change the value of the object.

= When programs are written for certain types of applications (embedded sys-

tems, in particular), the compiler can use the word const to identify data to
be stored in ROM (read-only memory).

At first glance, it might appear that const serves the same role as the

fidefine directive, which we've used in previous chapters to create names for
constants. There are significant differences between #define and const, how-
cver:

= We can use #define (o create a name for a numerical, character, or string

constant. const can be used (o create read-only objects of any type, including
arrays, pointers, structures, and unions.

const objects are subject to the same scope rules as variables; constants cre-
ated using #define aren’t. In particular, we can’t use #define to create a
constant with block scope.

The value of a const object, unlike the value of a macro, can be viewed in a
debugger.

Unlike macros, const ohjects can’t be used in constant expressions. For
example, we can’t write

const int n = 10;
int a[n]; /*** WRONG #*%%/

since array bounds must be constant expressions. (In C99, this example would
18.4

18.4 Declarators 467

be legal if a has automatic storage duration—it would be treated as a variable-
length array—but not if it has static storage duration.)

u It's legal to apply the address operator (&) to a const object, since it has an
address. A macro doesn't have an address.

There are no absolute rules that dictate when to use #define and when to
use const. I recommend using #def ine for constants that represent numbers or
characters. That way, you'll be able to use the constants as array dimensions, in
`switch` statements, and in other places where constant expressions are required.

Declarators

A declarator consists of an identifier (the name of the variable or function being
declared), possibly preceded by the * symbol or followed by [1 or (). By com-
bining *, [1, and (), we can create declarators of mind-numbing complexity.

Before we look at the more complicated declarators, let's review the declara-
tors that we've seen in previous chapters. In the simplest case, a declarator is just
an identifier, like i in the following example:

int i;
Declarators may also contain the symbols *, [],and ():
= A declarator that begins with * represents a pointer:
int *p;
m A declarator that ends with [] represents an array:
int af[10];

The brackets may be left empty if the array is a parameter, if it has an initial-
izer, or if its storage class is extern:

extern int afll;

Since a is defined elsewhere in the program, the compiler doesn’t need to
know its length here. (In the case of a multidimensional array, only the first set
of brackets can be empty.) C99 provides two additional options for what goes
between the brackets in the declaration of an array parameter. One option is
the keyword static, followed by an expression that specifies the array's
minimum length. The other is the * symbol, which can be used in a function
prototype to indicate a variable-length array argument. Section 9.3 discusses
both C99 features.

m A declarator that ends with () represents a function:
int abs(int i);
void swap(int *a, int *b);
int find largest(int a[l, int n);
468

Chapter 18 Declarations

C allows parameter names to be omitted in a function declaration:

int abs(int);
void swap(int *, int *);
int find largest (int []1, int);

The parentheses can even be left empty:

int abs();
void swap () ;
int find largest();

The declarations in the last group specify the return types of the abs, swap,
and find_largest functions, but provide no information about their argu-
ments. Leaving the parentheses emply isn't the same as putting the word
void between them, which indicates that there are no arguments. The empty-
parentheses style of function declaration has largely disappeared. It's inferior
to the prototype style introduced in C89, since it doesn’t allow the compiler to
check whether function calls have the right arguments.

It all declarators were as simple as these, C programming would be a snap.
Unfortunately, declarators in actual programs often combine the *, [1, and ()
notations. We’ve seen examples of such combinations already. We know that

int *ap[i0];
declares an array of 10 pointers to integers. We know that
float *fp(float);

declares a function that has a float argument and returns a pointer to a float.
And, in Section 17.7, we learned that

void (*pf) (int);

declares a pointer to a function with an int argument and a void return type.

Deciphering Complex Declarations

So far, we haven't had (oo much trouble understanding declarators. But what about
declarators like the one in the following declaration?

int *(*x[10]) (void) ;

This declarator combines *, [}, and (), 50 it’s not obvious whether x is a pointer,
an array, or a function.

Fortunately, there are two simple rules that will allow us to understand any
declaration, no matter how convoluted:

u Always read declaratars from the inside out. In other words, locate the identi-
fier that’s being declared, and start deciphering the declaration from there.
18.4 Declarators 469

u When there’s a choice, always favor [] and () over *. If * precedes the
identificr and [] follows it, the identifier represents an array. not a pointer.
Likewise, if * precedes the identifier and () follows it, the identifier repre-
sents a function, not a pointer. (Of course, we can always use parentheses to
override the normal priority of [] and () over *.)

Let’s apply these rules to our simple examples first. In the declaration
int *ap[10];

the identifier is ap. Since * precedes ap and [] follows it, we give preference to
[1,s0 ap is an array of pointers. In the declaration

float *fp(float);

the identifier is fp. Since * precedes fp and () follows it, we give preference to
(), so fp is a function that returns a pointer.
The declaration

void (*pf) (int);

is a little trickier. Since *pf is enclosed in parentheses, pf must be a pointer. But
(*pf) is followed by (int), so pf must point to a function with an int argu-
ment. The word void represents the return type of this function.

As the last example shows, understanding a complex declarator often involves
zigzagging from one side of the identifier to the other:

void (4pf) (int);
v Type of pt:
1. pointer to

=S 2. function with int argument
3. retumning void

1

3

Let’s use this zigzagging technique to decipher the declaration given earlier:
int *(*x[10]) (void) ;
First, we locate the identifier being declared (x). We see that x is preceded by *
and followed by []: since [] have priority over *, we go right (x is an array).
Next, we go left to find out the type of the elements in the array (pointers). Next,
we go right to find out what kind of data the pointers point to (functions with no

arguments). Finally, we go left to see what each function returns (a pointer to an
int). Graphically, here’s what the process looks like:

int *(*x[10]) (void) ;

Type of x:
1. array of
2. pointers to
3. functions with no arguments
4. returning pointer to int

470

Chapter 18 Declarations

18.5

Mastering C declarations takes time and practice. The only good news is that
there are certain things that can't be declared in C. Functions can't return arrays:

int f(int) [; /*%% WRONG **%/
Functions can’t return functions:

int g(int) (int); /*x** WRONG **+/
Arrays of functions aren’t possible, either:
int a[10] (int); /*** WRONG *%*#*/

In each case, we can use pointers to get the desired effect. A function can’t return an
array, but it can return a peinter to an array. A function can’t return a function, but
it can return a poinzer to a function. Arrays of functions aren't allowed, but an array
may contain peinrers to functions. (Section 17.7 has an example of such an array.)

Using Type Definitions to Simplify Declarations

Some programmers use type definitions to help simplify complex declarations.
Consider the declaration of x that we examined earlier in this section:

int #*(*x[10]) (void);

To make x’s type easier to understand, we could use the following series of type
definitions:

typedef int *Fen(void);

typedef Fen *Fen_ptr;

typedef Fen ptr Fen ptr_array[10];
Fcn_ptr array x;

If we read these lines in reverse order, we see that x has type Fcn_ptr_array.a
Fen_ptr_array is an array of Fen_ptr values, a Fon_ptr is a pointer to
type Fen, and a Fen is a function that has no arguments and returns a pointer to an
int value.

For convenience, C allows us to specify initial values for variables as we’re declar-
ing them. To initialize a variable, we write the = symbol after its declarator, then
follow that with an initializer. (Don’t confuse the = symbol in a declaration with
the assignment operator; initialization isn't the same as assignment.)

We've seen various kinds of initializers in previous chapters. The initializer
for a simple variable is an expression of the same type as the variable:

int i =5 / 2; /* i is initially 2 */
canversion during assignment >-7.4

@@

designated iniializers >6.1. 16.1

18.5 Initializers 471
If the types don't match, C converts the initializer using the same rules as for
assignment:
int j = 5.5; /* converted to 5 */

The initializer for a pointer variable must be a pointer expression of the same type
as the variable or of type void *:

int *p = &i;

The initializer for an array, structure, or union is usually a series of values enclosed
in braces:

Aok alfsl =l 2 374,550

In C99, brace-enclosed initializers can have other forms, thanks to designated ini-
tializers,

To complete our coverage of declarations, let’s take a look at some additional
rules that govern initializers:

= An initializer for a variable with static storage duration must be constant:

#define FIRST 1
#define LAST 100

static int i = LAST - FIRST + 1;

Since LAST and FIRST are macros, the compiler can compute the initial
value of 1 (100~ 1 + 1 = 100). If LAST and FIRST had been variables, the
initializer would be illegal.

m If a variable has automatic storage duration, its initializer need not be con-
stant:

int f(int n)

int last = n - 1;

g

= A brace-enclosed initializer for an array, structure, or union must contain only
constant expressions, never variables or function calls:

#define N 2
int powers(5] = {1, N, N* N, N* N * N, N * N * N * N};

Since N is a constant, the initializer for powers is legal: if N were a variable,
the program wouldn’t compile, In C99, this restriction applies only if the vari-
able has static storage duration.

= The initializer for an automatic structure or union can be another structure or
union:
472

Chapter 18  Declarations

calloc function > 17.3

18.6

void g(struct part partl)

struct part part2 = partl;

S

The initializer doesn’t have to be a variable or parameter name, although it
does need to be an expression of the proper type. For example, part2’s ini-
tializer could be *p, where p is of type struct part *, or f (partl),
where f is a function that returns a part structure.

Uninitialized Variables

In previous chapters, we've implied that uninitialized variables have undefined val-
ues. That's not always true: the initial value of a variable depends on its storage
duration:

= Variables with automatic storage duration have no default initial value. The
initial value of an automatic variable can’t be predicted and may be different
each time the variable comes into existence.

m Variables with static storage duration have the value zero by default. Unlike
memory allocated by calloc, which is simply set to zero bits, a static vari-
able is correctly initialized based on its type: integer variables are initialized to
0, floating variables are initialized to 0.0, and pointer variables contain a null
pointer.

As a matter of style, it’s better to provide initializers for static variables rather
than rely on the fact that they're guaranteed to be zero. If a program accesses a
variable that hasn't been initialized explicitly, someone reading the program later
can’t easily determine whether the variable is assumed to be zero or whether it’s
initialized by an assignment somewhere in the program.

Inline Functions (C99)

C99 function declarations have an additional option that doesn’t exist in C89: they
may contain the keyword inline. This keyword is a new breed of declaration
specifier, distinct from storage classes, type qualifiers, and type specifiers. To
understand the effect of inline, we'll need to visualize the machine instructions
that are generated by a C compiler to handle the process of calling a function and
returning from a function,

At the machine level, several instructions may need to be executed to prepare
for the call, the call itself requires jumping Lo the first instruction in the function,
and there may be additional instructions executed by the function itself as it begins
to execute. If the function has arguments, they'll need to be copied (because C
passes its arguments by value). Returning from a function requires a similar
parameterized macros =14.3

18.6 Inline Functions (C99) 473

amount of effart on both the part of the function that was called and the one that
called it. The cumulative work required to call a function and later return from it is
often referred to as “overhead.” since it's extra work above and beyond what the
function is really supposed to accomplish. Although the overhead of a function call
slows the program by only a tiny amount, it may add up in certain situations, such
as when a function is called millions or billions of times, when an older, slower
processor is in use (as might be the case in an embedded system), or when a pro-
gram has to meet very strict deadlines (as in a real-time system).

In C89. the only way to avoid the overhead of a function call is to use a param-
eterized macro. Parameterized macros have certain drawbacks, though, C99 offers
a better solution to this problem: create an inline function. The word “inline” sug-
gests an implementation strategy in which the compiler replaces each call of the
function by the machine instructions for the function. This technique avoids the
usual overhead of a function call, although it may cause a minor increase in the
size of the compiled program.

Declaring a function to be inline doesn’t actually force the compiler to
“inline" the function, however. It merely suggests that the compiler should try to
make calls of the function as fast as possible, perhaps by performing an inline
expansion when the function is called. The compiler is free to ignore this sugges-
tion, In this respect, inline is similar to the register and restrict key-
words, which the compiler may use to improve the performance of a program but
may also choose to ignore.

Inline Definitions
An inline function has the keyword inline as one of its declaration specifiers:

inline double average(double a, double b)

return (a + b) / 2;

Here's where things get a bit complicated. average has external linkage, so other
source files may contain calls of average. However, the definition of average
isn’'t considered to be an external definition by the compiler (it’s an inline defini-
tion instcad), so attempting to call average from another file will be considered
an error.

There are two ways to avoid this error. One option is to add the word static
to the function definition:

static inline double average (dcuble a, double b)
return (a + b) / 2c
average now has internal linkage, so it can’t be called from other files. Other

files may contain their own definitions of average, which might be the same as
this definition or might be different.
474

Chapter 18 Declarations

The other option is to provide an external definition for average so that calls
are permitted from other files. One way to do this is to write the average func-
tion a second time (without using inline) and put the second definition in a dif-
ferent source file. Doing so is legal, but it's not a good idea to have two versions of
the same function, because we can’t guarantee that they’ll remain consistent when
the program is modified.

Here's a better approach. First, we’ll put the inline definition of average ina
header file (let's name it average . h):

#ifndef AVERAGE H
#define AVERAGE H

inline double average (double a, double b)

 return (a +b) / 2;

+

#endif

Next, we'll create a matching source file, average. c:
#include "average.h"

extern double average (double a, double b);

Now, any file that needs to call the average function may simply include aver-
age . h, which contains the inline definition of average. The average. c file
contains a prototype for average that uses the extern keyword, which causes
the definition of average included from average.h to be treated as an exter-
nal definition in average.c.

The general rule in C99 is that if all top-level declarations of a function in a
particular file include inline but not extern, then the definition of the function
in that file is inline. If the function is used anywhere in the program (including the
file that contains its inline definition), then an external definition of the function
will need to be provided by some other file. When the function is called, the com-
piler may choose to perform an ordinary call (using the function’s external defini-
tion) or perform inline expansion (using the function’s inline definition). There’s no
way to tell which choice the compiler will make, so it's crucial that the two defini-
tions be consistent. The technique that we just discussed (using the average.h
and average. c files) guarantees that the definitions are the same.

Restrictions on Inline Functions

Since inline functions are implemented in a way that’s quite different from ordi-
nary functions, they’re subject to different rules and restrictions. Variables with
static storage duration are a particular problem for inline functions with external
linkage. Consequently. C99 imposes the following restrictions on an inline func-
tion with external linkage (but not on one with internal linkage):
compound literals »9.3, 16.2

= The function may not define a modifiable static variable.
m The function may not contain references to variables with internal linkage.

Such a function is allowed to define a variable that is both static and const,
but each inline definition of the function may create its own copy of the variable.

Using Inline Functions with GCC

Some compilers, including GCC, supported inline functions prior to the C99 stan-
dard. As a result, their rules for using inline functions may vary from the stan-
dard. In particular, the scheme described earlier (using the average.h and
average. c files) may not work with these compilers. Version 4.3 of GCC (not
available at the time this book was written) is expected to support inline func-
tions in the way described in the C99 standard.

Functions that are specified to be both static and inline should work
fine, regardless of the version of GCC. This strategy is legal in C99 as well, so it’s
the safest bet. A static inline function can be used within a single file or
placed in a header file and included into any source file that needs to call the func-
tion.

There’s another way to share an inline function among multiple files that
works with older versions of GCC but conflicts with C99. This technique involves
putting a definition of the function in a header file, specifying that the function is
both extern and inline, then including the header file into any source file that
contains a call of the function. A second copy of the definition—without the words
extern and inline—is placed in one of the source files. (That way, if the com-
piler is unable to “inline” the function for any reason, it will still have a definition.)

A final note about GCC: Functions are “inlined” only when optimization is
requested via the -O command-line option.

Q&A

Why are selection statements and iteration statements (and their “inner”
statements) considered to be blocks in C99? [p. 459]

This rather surprising rule stems from a problem that can occur when compound
literals are used in selection statements and iteration statements. The problem has
to do with the storage duration of compound literals, so let’s take a moment to dis-
cuss that issue first.

The C99 standard states that the object represented by a compound literal has
static storage duration if the compound literal occurs outside the body of a func-
tion. Otherwise, it has automatic storage duration: as a result, the memory occu-
pied by the object is deallocated at the end of the block in which the compound
literal appears. Consider the following function, which returns a point structure
created using a compound literal:
476

Chapter 18 Declarations

struct point create point(int x, int y)

(

return (struct point] {x, v};

This function works correctly, because the object created by the compound literal
will be copied when the function returns, The original object will no longer exist,
but the copy will remain. Now suppose that we change the function slightly:

struct point *create point (int x, int y)

return &(struct point) {x, v}

This version of create point suffers from undefined behavior, because it
returns a pointer to an object that has automatic storage duration and won't exist
after the function returns.

Now let’s return to the question we started with: Why are selection statements
and iteration statements considered to be blocks? Consider the following example:

/* Example 1 - `if` statement without braces */

double *coefficients, value;

if (polynomial selected == 1)
coefficients = (double(3]) {1.5, -3.0, 6.0};
else

coefficients = (double(3]) {4.5, 1.0, -3.5};
value = evaluate polynomial (coefficients);

This program fragment apparently behaves in the desired fashion (but read on).
coefficients will point to one of two objects created by compound literals,
and this object will still exist at the time evaluate_polynomial is called.
Now consider what happens if we put braces around the “inner” statements—the
ones controlled hy the `if` statement:

/* Example 2 - `if` statement with braces */

double *coefficients, value;

if (polynomial_selected == 1)

coefficients (double(3]) {1.5, -3.0, 6.0};
} else {

coefficients = (doukle(3]) {4.5, 1.0, -3.5};
}

value = evaluate polynomial (coefficients);

Now we're in trouble. Each compound literal causes an object to be created, but
that object exists only within the block formed by the braces that enclose the
statement in which the literal appears. By the time evaluate polynomial is
called, coefficients points to an object that no longer exists. The result:
undefined behavior.
Q&A 477

The creators of C99 were unhappy with this state of affairs, because program-
mers were unlikely to expect that simply adding braces within an `if` statement
would cause undefined behavior. To avoid the problem, they decided that the inner
statements would always be considered blocks. As a result, Example 1 and Exam-
ple 2 are equivalent, with both exhibiting undefined behavior.

A similar problem can arise when a compound literal is part of the controlling
expression of a selection statement or iteration statement. For this reason, each
entire selection Statement and iteration statement is considered to be a block as
well (as though an invisible set of braces surrounds the entire statement). So, for
example, an `if` statement with an else clause consists of three blocks: each of
the two inner statements is a block, as is the entire `if` statement.

You said that storage for a variable with automatic storage duration is allo-
cated when the surrounding block is executed. Is this true for C99’s variable-
length arrays? [p. 460]

No. Storage for a variable-length array isn’t allocated at the beginning of the sur-
rounding block, because the length of the array isn’t yet known. Instead, it’s allo-
cated when the declaration of the array is reached during the execution of the
block. In this respect, variable-length arrays are different from all other automatic
variables.

What exactly is the difference between “scope” and “linkage”? [p. 460]

Scope is for the benefit of the compiler, while linkage is for the benefit of the
linker. The compiler uses the scope of an identifier to determine whether or not it’s
legal to refer to the identifier at a given point in a file. When the compiler translates
a source file into object code, it notes which names have external linkage. eventu-
ally storing these names in a table inside the object file. Thus, the linker has access
to names with external linkage; names with internal linkage or no linkage are
invisible to the linker.

1 don’t understand how a name could have block scope but external linkage.
Could you elaborate? [p. 463]

Certainly. Suppose that one source file defines a variable i:

int i;

Let's assume that the definition of i lies outside any function, so i has external

linkage by default. In another file. there's a function f that needs to access i, so
the body of f declares i as extern:

void f (void)
" extern int i;
}

In the first file, i has file scope. Within f, however, i has block scope. If other
functions besides f need access to 1, they'll need to declare it separately. (Or we
478

Chapter 18 Declarations

*Q:

can simply move the declaration of i outside f so that i has file scope.) What's
confusing about this entire business is that each declaration or definition of i
establishes a different scope; sometimes it’s file scope, and sometimes it’s block
scope.

Why can’t const objects be used in constant expressions? const means
“constant,” right? [p. 466]
In C, const means “read-only,” not “constant.” Let’s look at a few examples that
illustrate why const objects can’t be used in constant expressions.

To start with, a const object might only be constant during its /ifetine, not
throughout the execution of the program. Suppose that a const object is declared
inside a function:

void ff(int n)

{

const int m = n / 2;

5

When f is called, m will be initialized to the value of n / 2. The value of m will
then remain constant until f returns. When f is called the next time, m will likely
be given a different value. That’s where the problem arises. Suppose that m appears
in a `switch` statement:

void f (int n)
const int m = n / 2;
switch (.) {

case m: .. /***% WRONG #*#%/

)
pak

The value of m won’t be known until f is called, which violates C’s rule that the
values of case labels must be constant expressions.

Next, let’s look at const objects declared outside blocks. These objects have
external linkage and can be shared among files. If C allowed the use of const
objects in constant expressions, we could casily find ourselves in the following sit-
uation:

extern const int n;
int a[n]; [*** WRONG *+*/

n is probably defined in another file. making it impossible for the compiler to
determine a’s length. (I'm assuming that a is an external variable, so it can’t be a
variable-length array.)
volatile ype qualiier »20.3

Section 18.1

Section 18.2

1.

o 2

Exercises 479

If thats not enough to convince you, consider this; If a const object is also
declared to be volatile, its value may change at any time during execution.
Here’s an example from the C standard:

extern const volatile int real time clock;

The real time clock variable may not be changed by the program (because
it's declared const), yet its value may change via some other mechanism
(because it's declared volatile).

Why is the syntax of declarators so odd?

Declarations are intended to mimic use. A pointer declarator has the form *p,
which matches the way the indirection operator will later be applied to p. An array
declarator has the form a [...] , which matches the way the array will later be sub-
scripted. A function declarator has the form f (...) , which matches the syntax of a
function call. This reasoning extends to even the most complicated declarators.
Consider the file cmd array of Section 17.7, whose elements are pointers to
functions. The declarator for f1le_cmd has the form

(*file cmd(]) (void)
and a call of one of the functions has the form
(*file emd(n]) ();

The parentheses, brackets, and * are in identical positions.

Exercises

For each of the followis
fiers, declarators, and ini
(a) static char **lookup(int level) ;

(b) volatile unsigned long io_flags;

(c) extern char *file_name [MAX FILES], path[];
(d) static const char token buf[] = "";

declarations, identify the storage class, type qualifiers, type speci-
izers.

Answer each of the following questions with auto, extern, register, and/or

static,

(a) Which storage class is used primarily to indicate that a variable or function can be
shared by several files?

(b) Suppose that a variable x is to be shared by several functions in one file but hidden from
functions in other files. Which storage class should x be declured to have?

(c) Which storage classcs can affect the storage duration of a variable?

List the storage duration (static or automatic), scope (block or file), and linkage (internal,
external, or none) of each variable and parameter in the following file:
480 Chapter 18

Section 18.3

Section 18.4

Q s

o 10

Declarations

extern float a;

void f(register double b)

static int c;
auto char d;

}

Let f be the following function. What will be the value of f {10) if f has never been called
before? What will be the valuc of f(10) if f has been called five times previously?

int ff(int i)

static int j = 0y
return i * j++;

State whether each of the following statements is true or false. Justify each answer.
(a) Every variable with static storage duration has file scope.

(b) Every variable declared inside a function has no linkage.

(c) Every variable with internal linkage has static storage duration.

(d) Every parameter has block scope.

The following function is supposed to print an error message. Each message is preceded by
an integer. indicating the number of times the function has been called. Unfortunately, the
function always displays 1 as the number of the error message. Locate the error and show
how to fix it without making any changes outside the function.

void print error(const char *message)

int n 1;
printf ("Error %d: %s\n', n+-, message);

Suppose that we declare x to be a const object. Which onc of the following statements
about x is false?

(a) If x is of type int. it can be uscd as the value of a casc label in a `switch` statement.
(b) The compiler will check that no assignment is made to x.

(c) x is subject to the same scope rules as variables.

{d) x can be of any type.

Write a complete description of the type of x as specified by each of the following declara-
tions.

(a) char (*x[10]) (int);

(b) int (*x(int)) [5];

(c) float *(*x(void)) (int);

(d) void (*x(int, void (*y) (int))) (int);

Use a series of type definitions to simplify each of the declarations in Exercise 8.

Write declarations for the following variables and functions:

(a) P is a pointer o a function with a character pointer argument that returns a character
pointer.
Section 18.5

o 13

Exercises 481

(b) f is a function with two arguments: p, a pointer 10 a structure with tag t, and n, a long
integer. f returns a pointer to a function that has no arguments and returns nothing.

(c) a is an array of four pointers to functions that have no arguments and return nothing.
The elements of a initially point to functions named insert, search, update, and
print.

(d) bis an array of 10 pointers to functions with two int arguments that return structurcs
with tag t.

In Section 18.4, we saw that the following declarations are illegal:

int f(int)[]; /* functions can't return arrays )
int glint) (int); /* functions can't return functions +/
int a[10] (int) ; /* array elements can't be functicns */

We can, however, achieve similar effects by using pointers: a function can return a pointer to
the first element in an array, a function can return a peinter to a function, and the elements
of an array can be pointers to functions. Revise cach of these declarations accordingly.

(a) Write a complete description of the type of the function f, assuming that it’s declared as
follows:

int (*f(float (*) (long), char *)) (double);
(b) Give an example showing how f would be called.

Which of the following declarations are legal? (Assume that PT is a macro that represents
3.14159.)

(@) char c = 65;

() static int i = 5, j = 1 * i;

(c) double d = 2 * PI;

(d) double anglesll = {0, PI / 2, PI, 3 * PI / 2};

Which kind of variables cannot be initialized?
(a) Array variables

(b) Enumcration variables

(c) Suructure variables

(d) Union variables

(e) None of the above

Which property of a variable determines whether or not it has a default initial value?
(a) Storage duration

(b) Scope

(c) Linkage

(d) Type
19

Program Design

Wherever there is modularity there is the potential for misunderstanding:
Hiding information implies a need to check communication.

It’s obvious that real-world programs are larger than the examples in this book, but
you may not realize just how much larger. Faster CPUs and larger main memories
have made it possible to write programs that would have been impractical just a
few years ago. The popularity of graphical user interfaces has added greatly to the
average length of a program. Most full-featured programs today are at least
100,000 lines long. Million-line programs are commonplace, and it's not unheard-
of for a program (o have 10 million lines or more.

Although C wasn’t designed for writing large programs, many large programs
have in fact been written in C. It's tricky, and it requires a great deal of care, but it
can be done. In this chapter, I'll discuss techniques that have proved to be helpful
for writing large programs and show which C features (the static storage class,
for example) are especially useful.

Writing large programs (often called “programming-in-the-large") is quite dif-
ferent from writing small ones—it’s like the difference between writing a term
paper (10 pages double-spaced, of course) and a 1000-page book. A large program
requires more attention to style, since many people will be working on it. It
requires careful documentation. It requires planning for maintenance, since it will
likely be modified many times,

Above all, a large program requires careful design and much more planning
than a small program. As Alan Kay, the designer of the Smalltalk programming
language, puts it, “You can build a doghouse out of anything.” A doghouse can be
built without any particular design, using whatever materials are at hand. A house
for humans, on the other hand, is too complex to just throw together.

Chapter 15 discussed writing large programs in C, but it concentrated on lan-
guage details. In this chapter, we’ll revisit the topic, this time focusing on tech
niques for good program design. A complete discussion of program design issues
is obviously beyond the scope of this book. However. I'll try to cover  briefly

483
484

Chapter 19  Program Design

19.1

some important concepts in program design and show how to use them to create C
programs that are readable and maintainable.

Section 19.1 discusses how to view a C program as a collection of modules
that provide services to each other. We'll then see how the concepts of information
hiding (Section 19.2) and abstract data types (Section 19.3) can improve modules.
By focusing on a single example (a stack data type), Section 19.4 illustrates how
an abstract data type can be defined and implemented in C. Section 19.5 describes
some limitations of C for defining abstract data types and shows how to work
around them.

Modules

When designing a C program (or a program in any other language, for that matter),
it’s often useful to view it as a number of independent modules. A module is a col-
lection of services, some of which are made available to other parts of the program
(the clients). Each module has an interface that describes the available services.
The details of the module—including the source code for the services them-
selves—are stored in the module's implementation.

In the context of C, “services” are functions. The interface of a module is a
header file containing prototypes for the functions that will be made available to
clients (source files). The implementation of a module is a source file that contains
definitions of the module’s functions.

To illustrate this terminology, let’s look at the calculator program that was
sketched in Sections 15.1 and 15.2. This program consists of the file calc.c.
which contains the `main` function, and a stack module, which is stored in the files
stack.hand stack.c (see the figure at the top of the next page). calc.cisa
client of the stack module. stack . h is the inferface of the stack module; it sup-
plies everything the client needs to know about the module. stack.c is the
implementation of the module: it contains definitions of the stack functions as well
as declarations of the variables that make up the stack.

The C library is itself a collection of modules. Each header in the library
serves as the interface to a module. <stdio.h>, for example, is the interface to a
module containing /O functions, while <string.hs is the interface to a module
containing string-handling functions.

Dividing a program into modules has several advantages:

u Abstraction. If modules are properly designed, we can treat them as abstrac-
tions: we know what they do, but we don't worry about the details of how
they do it. Thanks to abstraction, it’s not necessary to understand how the
entire program works in order to make changes to one part of it. What's more,
abstraction makes it easier for several members of a team to work on the
same program. Once the interfaces for the modules have been agreed upon,
the responsibility for implementing each module can be delegated to a partic-
19.1 Modules 485

#include cstdbool.h>

void make_empty(void) ;
bool is_efpty(void)

bool is_full(void);
void push(int i);
int pop (void);

stack.h

» oy

#include "stack.h" | #include "stack.h"
int main(void) int contents[100];

int top = 0;
make_empty () ;

)

void make_empty (void)

bool is_empty(void)
e b

calc.c

bool is full (void)

void push(int i)

int pop(void)
ot

stack.c

ular person. Team members can then work largely independently of one
another.

» Reusability. Any module that provides services is potentially reusable in other
programs. Our stack module, for example, is reusable. Since it’s often hard to
anticipate the future uses of a module, it’s a good idea to design modules for
reusability.

» Maintainability. A small bug will usually affect only a single module imple-
mentation, making the bug easier to locate and fix. Once the bug has been
fixed, rebuilding the program requires only a recompilation of the module
implementation (followed by linking the entirc program). On a larger scale,
we could replace an entire module implementation, perhaps to improve per-
formance or when transporting the program to a different platform.

Although all these advantages are important, maintainability is the most criti-
cal. Most real-world programs are in service over a period of years, during which
bugs are discovered, enhancements are made, and modifications are made to meet
changing requirements, Designing a program in a modular fashion makes mainte-
nance much casicr. Maintaining a program should be like maintaining a car fixing
a flat tire shouldn’t require overhauling the engine.
486 Chapter 19  Program Design

<float .h> header »2

1

<limite.hs header »232

For an example, we need look no further than the inventory program of
Chapters 16 and 17. The original program (Section 16.3) stored part records in an
array. Suppose that, after using this program for a while, the customer objects to
having a fixed limit on the number of parts that can be stored. To satisfy the cus-
tomer, we might switch to a linked list (as we did in Section 17.5). Making this
change required going through the entire program, looking for all places that
depend on the way parts are stored. If we'd designed the program differently in the
first place—with a separate module dealing with part storage—we would have
only needed to rewrite the implementation of that module. not the entire program.

Once we're convinced that modular design is the way to go, the process of
designing a program boils down to deciding what modules it should have, what
services each module should provide, and how the modules should be interrelated.
We’ll now look at these issues briefly. For more information about design, consult
a software engineering text, such as Fundamentals of Software Engineering, Sec-
ond Edition, by Ghezzi, Jazayeri, and Mandrioli (Upper Saddle River, N.J.: Pren-
tice-Hall, 2003).

Cohesion and Coupling

Good module interfaces aren’t random collections of declarations. In a well-
designed program, modules should have two properties:

u High cohesion. The elements of each module should be closely related to one
another; we might think of them as cooperating toward a common goal. High
cohesion makes modules easier to use and makes the entire program easier o
understand,

u Low coupling. Modules should be as independent of each other as possible.
Low coupling makes it easier to modity the program and reuse modules.

Does the caleulator program have these properties? The stack module is
clearly cohesive: its functions represent operations on a stack. There’s little cou-
pling in the program. The calc.c file depends on stack.h (and stack.c
depends on stack.h, of course), but there are no other apparent dependencies.

Types of Modules

Because of the need for high cohesion and low coupling, modules tend to fall into
certain typical categories:

u A data pool is a collection of related variables and/or constants. In C, a mod-
ule of this type is often just a header file. From a design standpoint, putting
variables in header files isn’t usually a good idea, but collecting related con-
stants in a header file can often be useful. In the C library, <float . h> and
<limits. k> are both data pools.

m A library is a collection of related functions. The <string.h> header, for
example, is the interface to a library of string-handling functions.

19.2

static slomgo diass >16.2

19.2 Information Hiding 487

u An abstract object is a collection of functions that operate on a hidden data
structure. (In this chapter, the term “object” has a different meaning than in
the rest of the book. In C terminology, an object is simply a block of mem-
ory that can store a value. In this chapter, however, an object is a collection
of data bundled with operations on the data. If the data is hidden, the object
s “abstract.”) The stack module we’ve been discussing belongs to this cate-
gory.

» An abstract data type (ADT) is a type whose representation is hidden. Client
modules can use the type to declare variables, but have no knowledge of the
structure of those variables. For a client module to perform an operation on
such a variable, it must call a function provided by the abstract data type mod-
ule. Abstract data types play a significant role in modern programming: we’ll
return to them in Sections 19.3-19.5.

Information Hiding

A well-designed module often keeps some information secret from its clients. Cli-
ents of our stack module, for example, have no need to know whether the stack is
stored in an array, in a linked list, or in some other form. Deliberately concealing
information from the clients of a module is known as information hiding. Infor-
mation hiding has two primary advantages:

= Security, If clients don’t know how the stack is stored, they won’t be able to
corrupt it by tampering with its internal workings. To perform operations on
the stack, they’ll have to call functions that are provided by the modulc
itself—functions that we've written and tested.

m Flexibility. Making changes—no matter how large—to a module’s internal
workings won't be difficult. For example, we could implement the stack as
an array at first, then later switch to a linked list or other representation.
We’ll have to rewrite the implementation of the module, of course, but—if
the module was designed properly—we won't have to alter the module’s
interface.

In C, the major tool for enforcing information hiding is the static storage
class. Declaring a variable with file scope to be static gives it internal linkage,
thus preventing it from being accessed from other files, including clients of the
module. (Declaring a function (o be static is also useful—the function can be
directly called only by other functions in the same file.)

A Stack Module

To see the benefits of information hiding, let’s look at two implementations of a
stack module, one using an array and the other a linked list. The module’s header
file will have the following appearance:
488 Chapter 19 Program Design

slack.h #ifndef STACK H
#define STACK H

#include <stdbool.h> /% C99 only */
void make empty (void);

bool is_empty(void) ;

bool is full (void);

void push(int 1);

int pop (void) ;

#endif

I've included C99's <stdbool . h> header so that the is_emptyand is_full
functions can return a bool result rather than an int value.
Let's first use an array to implement the stack:

stackl.c #include <stdio.h>
#include <stdlib.h>
#include "stack.h"

#define STACK SIZE 100

static int contents[STACK STZE] ;
static int top = 0;

static void terminate(const char *message)
printf("%s\n", message);

exit (EXIT_FAILURE) ;

void make empty(void)

{
top = 0;
bool is empty(void)

return top == 0;

bool is_full (void)

return top == STACK SIZE;

!
void push(int i)
if (is_full())

terminate("Error in push: stack is full.");
contents [top++] = i;
stack2.c

19.2 Information Hiding ~ 489

int pop (void)

if (is_empty())
terminate ("Error in pop: stack is empty.");
return contents[--top];

}

The variables that make up the stack (contents and top) are both declared
static, since there’s no reason for the rest of the program to access them
directly. The terminate function is also declared static. This function isn’t
part of the module’s interface; instead, it's designed for use solely within the
implementation of the module.

As a matter of style, some programmers use macros to indicate which func-
tions and variables are “public” (accessible elsewhere in the program) and which
are “private” (limited to a single file):

4define PUBLIC /* empty */
#define PRIVATE static

The reason for writing PRIVATE instead of static is that the latter has more
than one use in C; PRIVATE makes it clear that we're using it to enforce informa-
tion hiding. Here's what the stack implementation would look like if we were to
use PUBLIC and PRIVATE:

PRIVATE int contents [STACK_SIZE] ;
PRIVATE int top = 0;

PRIVATE void terminate(const char *message) { .. }
PUBLIC void make_empty(void) { .. }
PUBLIC bool is_empty(void) { .. }
PUBLIC bool is_full (void) { .. }
PUBLIC void push(int i) { .. }
PUBLIC int pop(void) { .. }
Now we’ll switch to a linked-list implementation of the stack module:
#include <stdio.h>
#include <stdlib.h>
#include "stack.h"
struct node {

int data;
struct node *next;

i

static struct node *top = NULL;
490

Chapter 19 Program Design

static void terminate (const char *message)

{

printf ("$s\n", message);

exit (EXIT_FAILURE) ;

)
void make_empty (void)
{
while (!is_empty())
pop () ;
bool is empty(void)

return top == NULL;

)
bool is full (void)
{

retura false;

void push(int i)

struct node *new node
if (new_node == NULL)
terminate ("Error in

new_node->data = i;
new_node->next = top;
top = new_ncde;

}

int pop (void)

struct node *old top;
SEa b

if (is_empty())
terminate ("Error in

old_top = top;
i = top-»>data;
top = top->next;
free(old top);
return i;

}

= malloc(sizeof (struct node)) ;

push: stack is full.");

pop: stack is empty.");

Note that the is_full function returns false every time it’s called. A linked
list has no limit on its size, so the stack will never be full. It’s possible (but not
likely) that the program might run out of memory, which will cause the push
function 1o fail, but there's no easy way to test for that condition in advance.

Our stack example shows clearly the advantage of information hiding: it
193

19.3 Abstract Data Types 491

doesn’t matter whether we use stackl.c or stack2.c to implement the stack
module. Both versions match the module’s interface, so we can switch from one to
the other without having to make changes elsewhere in the program.

Abstract Data Types

A module that serves as an abstract object, like the stack module in the previous
section, has a serious disadvantage: there’s no way to have multiple instances of
the object (more than one stack, in this case). To accomplish this, we'll need to go
a step further and create a new nype.

Once we’ve defined a Stack type, we'll be able to have as many stacks as we
want. The following fragment illustrates how we could have two stacks in the same
program:

Stack s1, s2;

make empty (&s1);
make empty (&s2) ;
push(&sl, 1);
push(&s2, 2);
if (lis_empty(&sl))
printf ("%%d\n", pop(asi)); /* printg vis +J

We're not really sure what s1 and s2 are (structures? pointers?), but it doesn’t
matter. To clients, 81 and s2 are abstractions that respond to certain operations
(make_empty, i5_empty, is_full, push, and pop).

Let’s convert our stack . h header so that it provides a Stack type, where
Stack is a structure. Doing so will require adding a Stack (or Stack *) param-
eter to each function. The header will now look like this (changes to stack . h are
in bold; unchanged portions of the header aren’t shown):

#define STACK SIZE 100

typedef struct {
int contents [STACK SIZE]:
int top;

} stack;

void make empty (Stack *s);
bool is_empty(conat Stack *s);
bool is_full (const Stack *s);
void push(Stack *s, int i);
int pop(Stack *s);

The stack parameters to make empty, push, and pop need to be pointers, since
these functions modify the stack. The parameter to is_empty and is_full
doesn’t need to be a pointer, but I've made it one anyway. Passing these functions a

Stack pointer instead of a Stack value is more efficient, since the latter would
result in a structure being copied.
492

Chapter 19 Program Design

Encapsulation

Unfortunately, Stack isn’t an abstract data type, since stack .h reveals what
the Stack type really is. Nathing prevents clients from using a Stack variable as
a structure:

Stack sl;

sl.top = 0;
sl.contents [top++] = 1;

Providing access to the top and contents members allows clients to corrupt the
stack. Worse still, we won't be able to change the way stacks are stored without
having to assess the effect of the change on clients.

What we need is a way to prevent clients from knowing how the Stack type
is represented. C has only limited support for encapsulating types in this way.
Newer C-based languages, including C++, Java, and C#. are better equipped for
this purpose.

Incomplete Types

The only tool that C gives us for encapsulation is the incomplete type. (Incomplete
types were mentioned briefly in Section 17.9 and in the Q&A section at the end of
Chapter 17.) The C standard describes incomplete types as “types that describe
objects but lack information needed to determine their sizes.” For example, the
declaration

struct t; /* incomplete declaration of t */

tells the compiler that t is a structure tag but doesn’t describe the members of the
structure. As a result, the compiler doesn’t have enough information to determine
the size of such a structure. The intent is that an incomplete type will be completed
elsewhere in the program.

As long as a type remains incomplete, its uses are limited. Since the compiler
doesn’t know the size of an incomplete type, it can’t be used to declare a variable:

struct t s; /*** WRONG ***/

However, it’s perfectly legal to define a pointer type that references an incomplete
type:

typedef struct t *T;

This type definition states that a variable of type T is a pointer to a structure with
tag ©. We can now declare variables of type T, pass them as arguments to func-
tions, and perform other operations that are legal for pointers. (The size of a
pointer doesn’t depend on what it points to, which explains why C allows this
behavior.) What we can’t do, though, is apply the - > operator to one of these vari-
ables, since the compiler knows nothing about the members of a t structure.
19.4

stackADT.h
(version 1)

19.4 A Stack Abstract Data Type 493

A Stack Abstract Data Type

To illustrate how abstract data types can be encapsulated using incomplete types,
we'll develop a stack ADT based on the stack module described in Section 19.2. In
the process, we’ll explore three different ways to implement the stack.

Defining the Interface for the Stack ADT

First, we'll need a header file that defines our stack ADT type and gives prototypes
for the functions that represent stack operations. Let’s name this file staclk-
ADT. h. The Stack type will be a pointer to a stack _type structure that stores
the actual contents of the stack. This structure is an incomplete type that will be
completed in the file that implements the stack. The members of this structure will
depend on how the stack is implemented. Here’s what the stackADT . h file will
look like:

#ifndef STACKADT_H
#define STACKADT H

#include <stdbool.h> /% C99 only */
typedef struct stack type *Stack;

Stack create (void) ;

void destroy (Stack s);
void make _empty(Stack s);
bool is_empty(Stack s);
bool is full (Stack s);
void push(Stack s, int 1i);
int pop(Stack s);

#endif

Clients that include stackADT.h will be able to declare variables of type
Stack, each of which is capable of pointing to a stack_type structure. Clients
can then call the functions declared in stackADT.h to perform operations on
stack variables. However, clients can’t access the members of the stack type
structure, since that structure will be defined in a separate file.

Note that each function has a Stack parameter or returns a Stack value.
The stack functions in Section 19.3 had parameters of type Stack *. The rea-
son for the difference is that a Stack variable is now a pointer; it points to a
stack type structure that stores the contents of the stack. If a function needs
to modify the stack, it changes the structure itself, not the pointer to the struc-
ture.

Also note the presence of the create and destroy functions, A module
494 Chapter 19 Program Design

stackclient.c

generally doesn't need these functions, but an ADT does. create will dynami-
cally allocate memory for a stack (including the memory required for a
stack_type structure), as well as initializing the stack to its “empty” state.
destroy will release the stack’s dynamically allocated memory.

The following client file can be used to test the stack ADT. It creates two
stacks and performs a variety of operations on them.

#include <stdio.hs
#include "stackADT.h"

int main(void)

{

Stack sl1, s2;

int n;
81 = create();
82 = create();

push(sl, 1);
push(sl, 2);

n = pop(sl);
printf ("Popped %d from sl\n", n);
push(s2, n);
n = pop(sl);
printf ("Popped %d from si\n", n);
push(e2, n);

destroy(sl);

while (lis_empty(s2))
printf ("Popped %d from s2\n", pop(s2));

push(s2, 3);
make_empty(s2) ;
if (is_empty(s2))
printf("s2 is empty\n") ;
else
printf ("s2 is not empty\n");

destroy(s2) ;

return 0;

}

If the stack ADT is implemented correctly, the program should produce the follow-
ing output:

Popped 2 from sl
Popped 1 from si
Popped 1 from s2
Popped 2 from s2
52 is empty
stackADT.c

19.4 A Stack Abstract Data Type 495

Implementing the Stack ADT Using a Fixed-Length Array

There are several ways to implement the stack ADT. Our first approach is the sim-
plest. We'll have the stackADT . c file define the stack_type structure so that
it contains a fixed-length array (to hold the contents of the stack) along with an
integer that keeps track of the top of the stack:

struct stack type {

int contents [STACK SIZE];

int top;
Here’s what stackaDT . c will look like:
#include <stdio.h>

#include <stdlib.h>
#include "stackADT.h"

#define STACK SIZE 100

struct stack type {
int contents [STACK SIZE] ;
int top;

static void terminate (const char *message)

printf ("$s\n", message);
exit (EXIT_ FAILURE) ;

}

Stack create(void)

{

Stack s = malloc(sizeof (struct stack_type));

if (s == NULL)
terminate ("Error in create: stack could not be created.");
s->top = 0;

return s;

]
void destrcy(Stack s)
free(s);

void make_empty (Stack s)

{
s-stop = 0;
}

bool is empty(Stack s)

return s->top == 0;
496

Chapter 19 Program Design

stackADT.h
(version 2)

bool is full(Stack s)

return s->top == STACK SIZE;

}

void push(Stack s, int i)

if (is full(s))
terminate ("Error in push: stack is full.");
s->contents[s->top++] = i;

I

int pop (Stack s)
{

if (is empty(s))
terminate ("Error in pop: stack is empty.");
return s->contents[--s->top];

The most striking thing about the functions in this file is that they use the - > oper-
ator, not the . operator, to access the contents and top members of the
stack_type structure, The s parameter is a pointer to a stack type strue-
ture, not a structure itself, so using the . operator would be illegal.

Changing the Item Type in the Stack ADT

Now that we have a working version of the stack ADT, let’s try to improve it. First,
note that items in the stack must be integers. That's too restrictive; in fact, the item
type doesn’t really matter. The stack items could just as easily be other basic types
(float, double, long, etc.) or even structures, unions, or pointers, for that
matter.

To make the stack ADT easier to modify for different item types. let’s add a
type definition to the stackADT.h header. It will define a type named Item,
representing the type of data to be stored on the stack.

#ifndef STACKADT H
#define STACKADT E

#include <stdbool.h> /% C99 only */
typedef int Ttem;

typedef struct stack type *Stack;
Stack create(void) ;

void destroy(Stack s);

void make_empty (Stack s);

bool is_empty(Stack s);
bool is_full(Stack s);
dynamically allocated aiays > 17.3

19.4 A Slack Abstract Data Type 497

void push(Stack s, Item i);
Item pop(Stack s);

#endif

The changes Lo the file are shown in bold. Besides the addition of the Ttem type,
the push and pop functions have been modified. push now has a parameter of
type Item, and pop returns a value of type Item. We'll use this version of
stackADT . h from now on: it replaces the earlier version.

The stackADT. c file will need to be modified to match the new stack-
ADT. h. The changes are minimal, however. The stack _type structure will now
contain an array whose elements have type Ttem instead of int:

struct stack_type {

Item contents[STACK SIZE];

int top;
¥i
The only other changes are to push (the second parameter now has type Tt.em)
and pop (which returns a value of type Ttem). The bodies of push and pop are
unchanged.

The stackelient.c file can be used to test the new stackADT.h and
stackADT. c to verify that the Stack type still works (it does!). Now we can
change the item type any time we want by simply modifying the definition of the
Item type in stackADT.h. (Although we won't have to change the stack-
ADT. c file, we'll still need to recompile it.)

Implementing the Stack ADT Using a Dynamic Array

Another problem with the stack ADT as it currently stands is that each stack has a
fixed maximum size, which is currently set at 100 items, This limit can be
increased to any number we wish, of course, but all stacks created using the
Stack type will have the same limit. There's no way to have stacks with different
capacities or to set the stack size as the program is running.

There are two solutions to this problem. One is to implement the stack as a
linked list, in which case there’s no fixed limit on its size. We'll investigate this
solution in a moment. First, though, let’s try the other approach, which involves
storing stack items in a dynamically allocated array.

The crux of the latter approach is to modify the stack type structure so
that the cont.ent.s member is a poinier to the array in which the items are stored,
not the array itself:

struct stack type {
Ttem *contents;
int top;
int size;

i
498

Chapter 19 Program Design

stackADT2.c

I've also added a new member, size, that stores the stack’s maximum size (the
length of the array that contents points to). We'll use this member to check for
the “stack full” condition.

The create function will now have a parameter that specifies the desired
maximum stack size:

Stack create(int size);

When create is called. it will create a stack _type structure plus an array of
length size. The contents member of the structure will point to this array.

The stackADT. h file will be the same as before. except that we'll need to
add a size parameter to the create function. (Let's name the new version
stackADT2.h.) The stackADT.c file will need more extensive modification,
however. The new version appears below, with changes shown in bold.

#include <stdio.h>
#include <stdlib.hs
#include "stackaDT2.h"

struct stack type {
Item *contents;
int topr
int size;

b

statie void terminate(const char *message)
{

printf ("$s\n", message);

exit (EXIT_FAILURE) ;

Stack create(int size)

Stack s = malloc(sizeof (struct stack type));
iE (e NULL)

terminate ("Error in create: stack could not be created."
8->contents = malloc(size * sizeof(Item));
if (s->contents == NULL)

free(s);

terminate ("Error in create: stack could not be created.");
}
5->top =
8->size = size;
return s;

)

void destroy(Stack s)
{
free(s->contents) ;
free(s);

1
19.4 A Stack Abstract Data Type 499

void make_empty (Stack s)

{

s->top = 0

bool is_empty(Stack s)

return s->top == 0;

bool is_full (Stack s)

return s->top == s->size;

void push(Stack s, Item i)

_full(s))
terminate ("Error in push: stack is full.");
s->contents[s->top++] = 1i;

Item pop(Stack s)
if (is_empty(s))

terminate ("Error in pop: stack is empty.");
return s->contents[--s->top];

The create function now calls malloc twice: once to allocate a stack _type
structure and once to allocate the array that will contain the stack items. Either call
of malloe could fail, causing terminate to be called. The destroy function
must call free twice to release all the memory allocaled by create.

The stackelient. c file can again be used to test the stack ADT. The calls
of create will need to be changed, however, since create now requires an
argument. For example, we could replace the statements

sl
82

create () ;
create() ;

with the following statcments:

s1 = create(100);
82 = create(200);

Implementing the Stack ADT Using a Linked List

Implementing the stack ADT using a dynamically allocated array gives us more
flexibility than using a fixed-size array. However, the client is still required to spec-
ify a maximum size for a stack at the time it's created. If we use a linked-list imple-
mentation instead, there won't be any preset limit on the size of a stack.
500

Chapter 19 Program Design

stackADT3.c

Our implementation will be similar to the one in the stack2. c file of Sec-
tion 19.2. The linked list will consist of nodes, represented by the following struc-
ture:

struct node {
Item data;
struct node *next;
The type of the data member is now Item rather than int, but the structure is
otherwise the same as before,
The stack type structure will contain a pointer to the first node in the list:

struct stack type {
struct nede *top;

At first glance, the stack type structure seems superfluous; we could just
define Stack to be struct node * and let a Stack value be a pointer to the
first node in the list. However, we still need the stack type structure so that
the interface to the stack remains unchanged. (If we did away with it, any func-
tion that modified the stack would nced a Stack * parameter instead of a
Stack parameter.) Morcover, having the stack type structure will make it
easier to change the implementation in the future, should we decide to store addi-
tional information. For example. if we later decide that the stack_type struc-
ture should contain a count of how many items are currently stored in the stack,
we can easily add a member to the stack_type structure to store this informa
tion,

We won't need to make any changes to the stackADT.h header. (We'll
use this header file. not stackADT2 . h.) We can also use the original stack-
alient.c file for testing. All the changes will be in the stackADT.c file.
Here’s the new version:

#include <stdio.h>
#include <stdlib.h>
#include "stackADT.h"

struct node {
Item data;
struct node *next;

struct stack type {
struct node *top;

static void terminate(const char *message)

printf ("4s\n", message);
exit (EXIT FATLURE);

}
19.4 A Stack Abstract Data Type 501

Stack create (void)

{
Stack s = malloc(sizeof (struct stack_type));
if (s == NULL)
terminate ("BError in create: stack could not be created.");
s->top = NULL;
return s;

}

void destroy(Stack s)
make_empty (s) ;

free((s);

}

void make empty (Stack s)

while (lis_empty(s))
pop (s) ;

bool is_empty(Stack s)

return s->top == NULL;

bool is_full (Stack s)

{
)

return false;

void push(Stack s, Item i

struct node *new node = malloc(sizeof (struct node)) ;
if (new node == NULL)
terminate ("Error in push: stack is full.");

new_node->data = i
new_node->next = s
8->top = new_node;

>top;

tem pop (Stack s)

struct node *old top;
Ttem i;

if (is_empty(s))
terminate ("Exrror in pop: stack is empty.");

old_top = s->top;

i = old_top->data;
s->top = old top- >next;
free (old_top) ;

return i;

}
502

Chapter 19 Program Design

19.5

assert macro»24.1

Note that the destroy function calls make empty (to release the memory
occupied by the nodes in the linked list) before it calls free (to release the mem-
ory for the stack_type structure).

Design Issues for Abstract Data Types

Section 19.4 described a stack ADT and showed several ways to implement it.
Unfortunately, this ADT suffers from several problems that prevent it from being
industrial-strength. Let’s look at each of these problems and discuss possible solu-
tions.

aming Conventions

The stack ADT functions currently have short, easy-to-understand names: cre -
ate, destroy, make_empty, is_empty, is_full, push, and pop. If we
have more than one ADT in a program, name clashes are likely. with functions
in two modules having the same name. (Each ADT will need its own create
function, for example.) Therefore, we'll probably need to use function names
that incorporate the name of the ADT itself, such as stack create instead of
create,

Error Handling

The stack ADT deals with errors by displaying an error message and terminating
the program. That's not a bad thing to do. The programmer can avoid popping an
empty stack or pushing data onto a full stack by being careful to call is_empty
prior to each call of pop and is_full prior to each call of push, so in theory
there’s no reason for a call of push or pop to fail. (In the linked-list implementa-
tion, however, calling is_full isn’t foolproof; a subsequent call of push can
still fail.) Nevertheless, we might want to provide a way for a program to recover
from these errors rather than terminating.

An alternative is to have the push and pop functions return a bool value to
indicate whether or not they succeeded. push currently has a void return type, so
it would be easy to modify it to return true if the push operation succeeds and
false if the stack is full. Modifying the pop function would be more difficult,
since pop currently returns the value that was popped. However, if pop were to
return a pointer to this value, instead of the value itself, then pop could return
NULL to indicate that the stack is empty.

A final comment about error handling: The C standard library contains a
parameterized macro named assert that can terminate a program if a specified
condition isn’t satisfied. We could use calls of this macro as replacements for the
`if` statements and calls of terminate that currently appear in the stack ADT.
19.5 Design Issues for Abstract Data Types ~ 503

Generic ADTs

Midway through Section 19.4, we improved the stack ADT by making it easier Lo
change the type of items stored in a stack—all we had to do was modify the defini-
tion of the Ttem type. It’s still somewhat of a nuisance to do so; it would be nicer
ifa k could accommodate items of any type, without the need to modify the
stack.h file. Also note that our stack ADT suffers from a serious flaw: a pro-
gram can’t create two stacks whose items have different types. It's easy to create
multiple stacks, but those stacks must have items with identical types. To allow
stacks with different item types, we'd have (o make copies of the stack ADT’s
header file and source file and modify one set of files so that the Stack type and
its associated functions have different names.

What we'd like to have is a single “generic” stack type from which we could
create a stack of integers, a stack of strings, or any other stack that we might need.
There are various ways to create such a type in C, but none are completely satisfac-
tory. The most common approach uses void * as the item type, which allows
arbitrary pointers to be pushed and popped. With this technique, the stack-
ADT. h file would be similar to our original version; however, the prototypes of the
push and pop functions would have the following appearance:

void push(Stack s, void *p);

void #*pop(Stack s);

pop returns a pointer to the item popped from the stack; if the stack is empty, it
returns a null pointer.

There are two disadvantages to using void * as the item type. One is that this
approach doesn’t work for data that can’t be represented in pointer form. Items
could be strings (which are represented by a pointer to the first character in the
string) or dynamically allocated structures but not basic types such as int and
double. The other disadvantage is that error checking is no longer possible. A
stack that stores void * items will happily allow a mixture of pointers of different
types; there’s no way to detect an error caused by pushing a pointer of the wrong
type.

ADTs in Newer Languages

The problems that we've just discussed are dealt with much more cleanly in newer
C-based languages, such as C++, Java. and C#. Name clashes are prevented by
defining function names within a class. A stack ADT would be represented by a
stack class; the stack functions would belong to this class, and would only be
recognized by the compiler when applied to a Stack object. These languages
have a feature known as exception handling that allows functions such as push
and pop to “throw" an exception when they detect an error condition. Code in the
client can then deal with the error by “catching” the exception. C++, Java, and C#
also provide special features for defining generic ADTs. In C++, for example, we
would define a stack template, leaving the item type unspecified.
504

Chapter 19  Program Design

Q:
A:

FILE type »22.1

Q&A

You said that C wasn’( designed for writing large programs. Isn’t UNIX a
large program? [p. 483]

Not at the time C was designed. In a 1978 paper. Ken Thompson estimated that the
UNIX kernel was about 10,000 lines of C code (plus a small amount of assembler).
Other components of UNIX were of comparable size; in another 1978 paper, Den

nis Ritchie and colleagues put the size of the PDP-11 C compiler at 9660 lines. By
today’s standards, these are indeed small programs.

Are there any abstract data types in the C library?

Technically there aren't, but a few come close, including the FILE type (defined in
<stdio.h>). Before performing an operation on a file, we must declare a vari-
able of type FILE *:

FILE *fp;

The fp variable will then be passed to various file-handling functions.

Programmers are expected to treat FTLE as an abstraction. It's not necessary
to know what a FILE is in order to use the FILE type. Presumably FILE is a
structure type, but the C standard doesn’t even guarantee that. In fact, it's better not
to know too much about how FILE values are stored, since the definition of the
FILE type can (and often does) vary from one C compiler to another.

Of course, we can always look in the stdio.h file and see what a FILE is.
Having done so, there’s nothing to prevent us from writing code to access the inter-
nals of a FILE. For example, we might discover that FTILE is a structure with a
member named bsize (the file’s buffer size):

typedef struct {
;nt bsize; /* buffer size */
} FILE;
Once we know about the bsize member, there’s nothing to prevent us from
accessing the buffer size for a particular file:
printf ("Buffer size: %d\n", fp->bsize);

Doing so isn’t a good idea, however, because other C compilers might store the
buffer size under a different name, or keep track of it in some entirely different
way. Changing the bsize member is an even worse idea:

fp-sbsize = 1024;

Unless we know all the details about how files are stored, this is a dangerous thing
todo. Even if we do know the details. they may change with a different compiler or
the next release of the same compiler.
Section 19.1

Section 19.2

(Coo )

flexible array members > 17.9

Q:
Al

Exercises 505

What other incomplete types are there besides incomplete structure types? [p.
492]

One of the most common incomplete types occurs when an array is declared with
no specified size:

extern int al[];

Afier this declaration (which we first encountered in Section 15.2), a has an
incomplete type, because the compiler doesn’t know a’s length. Presumably a is
defined in another file within the program; that definition will supply the missing
length. Another incomplete type occurs in declarations that specify no length for
an array but proyide an initializer:

int e e Sl

In this example. the array a initially has an incomplete type, but the type is com-
pleted by the initializer.

Declaring a union tag without specifying the members of the union also cre-
ates an incomplete type. Flexible array members (a C99 feature) have an incom-
plete type. Finally, void is an incomplete type. The void type hus the unusual
property that it can never be completed, thus making it impossible to declare a
variable of this type.

‘What other restrictions are there on the use of incomplete types? [p. 492]

The sizeof operator can't be applied to an incomplete type (not surprisingly.
since the size of an incomplete type is unknown). A member of a structure or
union (other than a flexible array member) can’t have an incomplete type. Simi-
larly, the elements of an array can’t have an incomplete type. Finally, a parameter
in a function definition can't have an incomplete type (although this is allowed in
a function declaration). The compiler “adjusts" each array parameter in a function
definition so that it has a pointer type, thus preventing it from having an incom-
plete type.

Exercises

A queue is similar to a stack, except that items are added at one end but removed from the
other in a FIFO (first-in, first-out) fashion. Operations on a queue might include:

Inserting an item at the end of the queue

Removing an item from the beginning of the queue

Returning the first item in the queue (without changing the queue)

Returning the last item in the queue (without changing the queue)

Testing whether the queue is empty

Write an interface for a queue module in the form of a header file named queue . h.

Modify the stack2 . c file to use the PUBLIC and PRIVATE macros.
506 Chapter 19  Program Design

Section 19.3

Section 19.4

.

Q 4

(a) Write an array based implementation of the queue modulc described in Exercise 1. Use
three integers to keep track of the queue’s status, with one integer storing the position of the
first empty slot in the array (used when an item is inserted), the second storing the position
of the next item to be removed, and the third storing the number of items in the queue. An
insertion or removal that would cause cither of the first two integers to be incremented past
the end of the array should instead reset the variable to zero, thus causing it o “wrap
around” to the beginning of the array.

(b) Write a linked-list implementation of the queue module described in Exercise 1. Use
two pointers, one pointing to the first node in the list and the other pointing to the last node.
When an item is inserted into the queue, add it to the end of the list. When an item is
removed from the queue, delete the first node in the list.

(2) Write an implementation of the Stack type, assuming that Stack is a structure con-
taining a fixed-length array.

(b) Redo the Stack type, this time using a linked-list representation instead of an array.
(Show both stack.hand stack.c.)

Modify the queue . h header of Exercise 1 so that it defines a Queue type, where Queue
is a structure containing a fixed-length array (sce Exercise 3(a)). Modify the functions in
queue . hto take a Queue * parameler.

(a) Add a peek function to stackADT. c. This function will have a parameter of type
Stack. When called, it returns the top item on the stack but doesn’t modify the stack.

(b) Repeat part (a), modifying stackaDT2 . c this time.
(c) Repeat part (a), modifying stackADT3 . c this time.
Modify stackADT2 . c so that a stack automatically doubles in size when it becomes full.
Have the push function dynamically allocate a new array that’s twice as large as the old

one and then copy the stack contents from the old array to the new one. Be sure to have
push deallocate the old array once the data has been copied.

Programming Projects
Modify Programming Project | from Chapter 10 so that it uses the stack ADT described in
Section 19.4. You may use any of the implementations of the ADT described in that section.

Modify Programming Project 6 from Chapter 10 so that it uses the stack ADT described in
Section 19.4. You may use any of the implementations of the ADT described in that section.

Modify the stackADT3. c file of Section 19.4 by adding an int member named len to
the stack_type structure. This member will keep track of how many items are currently
stored in a stack. Add a new function named length that has a Stack parameter and
returns the value of the 1en member. (Some of the existing functions in stackADT3 .c
will need to be modified as well.) Modify stackclient . c so that it calls the length
function (and displays the value that it returns) after each operation that modifies a stack.

Modify the stackADT . h and stackADT3 . c files of Section 19.4 so that a stack stores
values of type void *, as described in Section 19.5; the Item type will no longer be used.
Modify stackelient. c so that it stores pointers to strings in the s1 and s2 stacks.
Programming Projects 507

Starting from the queue . h header of Exercise I, create a file named queueADT .1 that
defines the following Queue type:

typedef struct gueue type *Queue;

queue type is an incomplete structure type. Create a file named queueADT . c that con-
tains the full definition of queue_type as well as definitions for all the functions in
queue. h. Use a fixed-length array to store the items in a queue (see Exercise 3(a)). Create
a file named gqueueclient . c (similar to the stackcelient . c file of Section 19.4) that
creates two queues and performs operations on them. Be sure to provide create and
destroy functions for your ADT.

Modify Programming Project 5 so that the items in a queue are stored in a dynamically allo-
cated array whose length is passed to the create function.

Modify Programming Project S so that the items in a queue are stored in a linked list (see
Exercise 3(b)).
20

20.1

Low-Level Programming

A programming language is low level when its
programs require attention to the irrelevant.

Previous chapters have described C’s high-level, machine-independent features.
Although these features are adequate for many applications, some programs need
to perform operations at the bit level. Bit manipulation and other low-level opera-
tions are especially useful for writing systems programs (including compilers and
operating systems), encryption programs, graphics programs, and programs for
which fast execution and/or efficient use of space is critical.

Section 20.1 covers C’s bitwise operators, which provide easy access to both
individual bits and bit-fields. Section 20.2 then shows how to declare structures
that contain bit-fields. Finally, Section 20.3 describes how certain ordinary C fea-
tures (type definitions, unions, and pointers) can help in writing low-level pro-
grams.

Some of the techniques described in this chapter depend on knowledge of how
data is stored in memory, which can vary depending on the machine and the com-
piler. Relying on these techniques will most likely make a program nonportable, so
it’s best to avoid them unless absolutely necessary. If you do need them, try to limit
their use to certain modules in your program; don't spread them around. And,
above all, be sure to documment what you're doing!

Bitwise Operators

C provides six bitwise operators, which operate on integer data at the bit level.
We'll discuss the two bitwise shift operators first, followed by the four other b
wise operators (bitwise complement, bitwise and. bitwise exclusive or, and bitwise
inclusive or).

509
510 Chapter 20  Low-Level Programming

‘Table 20.1
Bitwise Shift Operators

portability tip

Bitwise Shift Operators

The hitwise shift operators can transform the binary representation of an integer by
shifting its bits to the left or right. C provides two shift operators, which are shown
in Table 20.1.

Symbol  Meaning

<< leftshift
5> right shift

The operands for << and >> may be of any integer type (including char). The
integer promotions are performed on both operands: the result has the type of the
left operand after promotion.

The value of i << j is the result when the bits in i are shifted left by j places.
For each bit that is “shitted off” the left end of 1, a zero bit enters at the right. The
value of 1 5> j is the result when i is shifted right by j places. If 1 is of an
unsigned type or if the value of i is nonnegative, zeros are added at the left as
needed. If i is a negative number, the result is implementation-defined; some
implementations add zeros at the left end, while others preserve the sign bit by
adding ones.

For portability, it’s best 1o perform shifis only on unsigned numbers,

The following examples illustrate the effect of applying the shift operators to
the number 13. (For simplicity, these examples—and others in this section—use
short integers, which are typically 16 bits.)

unsigned short i, j;
13; /* i is now 13 (binary 0000000000001101) */

i<< 2; /* j is now 52 (binary 0000000000110100) */
St 2 /* j is now 3 (binary 0000000000000011) */

As these examples show, neither operator modifies its operands. To modify a vari-
able by shifting its bits, we’d use the compound assignment operators <<= and

>>=!

i=13; /* i is now 13 (binary 0000000000001101) */
? /* i is now 52 (binary 0000000000110100) */
i = 2y /* i is new 13 (binary 0000000000001101) */
The bitwise shift operators have lower precedence than the arithmetic operators,

which can cause surprises. For example, i << 2 + 1 means i << (2 + 1). not
(1cc2) +1.

Table 20.2
Other Bitwise Operators

8>

20.1 Bitwise Operators 511

Bitwise Complement, And, Exclusive Or, and Inclusive Or

Table 20.2 lists the remaining bitwise operators.

Symbol Meaning
~ bitwise complement
& bitwise and

bitwise exclusive or
| bitwise inclusive or

The ~ operator is unary; the integer promotions are performed on its operand. The
other operators are binary; the usual arithmetic conversions are performed on their
operands.

The ~, & %, and | operators perform Boolean operations on all bits in their
operands. The ~ operator produces the complement of its operand, with zeros
replaced by ones and ones replaced by zeros. The & operator performs a Boolean
and operation on all corresponding bits in its two operands. The * and | operators
are similar (both perform a Boolean or operation on the bits in their operands);
however. * produces 0 whenever both operands have a 1 bit, whereas | produces
ik,

Don’t confusc the bitwise operators & and | with the logical operators && and | |
The bitwise operators sometimes producc the same results as the logical operators,
but they’re not equivalent.

“The following examples illustrate the effect of the ~, & *, and | operators:

unsigned short i, i, k;

4 /* i is now 21 (binary 0000000000010101) =/
J /* j is pow 56 (binary 0000000000111000) */
k /* k is now 65514 (binary 1111111111101010) */
k /* k is now 16 (binary 0000000000010000) */
k /* k is now 45 (binary 0000000000101101) */
k /* k is now 61 (binary 0000000000111101) */

The value shown for ~i is based on the assumption that an unsigned short
value occupies 16 bits.

The - operator deserves special mention, since we can use il to help make
even low-level programs more portable. Suppose that we need an integer whose
bits are all 1. The preferred technique is to write ~0, which doesn’t depend on the
number of bits in an integer. Similarly, if we need an integer whose bits are all 1
except for the last five, we could write ~0x1f.
512 Chapter 20 Low-Level Programming

A

table of operators >Appencix 4

Each of the ~, & *, and | operators has a different precedence:

Highest: -
&

Lowest: |

As a result, we can combine these operators in expressions without having to usc
parentheses. For example, we could write i & ~j | kinstcadof (i & (~j)) | k
and 1 * j & ~k instead of i * (5 & (~k) ). Of course, it doesn’t hurt to use
parentheses to avoid confusion.

The precedence of &, *, and | is lower than the precedence of the relational and
equality operators. Consequently, statements like the following one won’t have the
desired effect:

if (status & 0x4000 != 0) ..

Instead of testing whether status & 0x4000 isn't zero, this statement will
evaluate 0x4000 != 0 (which has the value 1), then test whether the value of
status & 1 isn’t zero.

The compound assignment operators &=, *=, and | = correspond to the bit-
wise operators & *, and |

i=21; 7t new 21 (binary 0000000000010101) */
3 56; /%3 new 56 (binary 0000000000111000) */
4 i /* i is now 16 (binary 0000000000010000) */
A5 S /* i is now 40 (binary 0000000000101000) */
3 47 /* i is now 56 (binary 0000000000111000) */

Using the Bitwise Operators to Access Bits

‘When we do low-level programming, we'll often need to store information as sin-
gle bits or collections of bits. In graphics programming, for example, we may want
10 squeeze two or more pixels into a single byte. Using the bitwise operators, we
can extract or modify data that’s stored in a small number of bits.

Let’s assume that 1 is a 16-bit unsigned short variable. Let’s see how to
perform the most common single-bit operations on 1:

m Setting a bit. Suppose that we want to set bit 4 of i. (We'll assume that the
leftmost—or most significant—Dbit is numbered 15 and the least significant is
numbered 0.) The easiest way to set bit 4 is to or the value of i with the con-
stant 0x0010 (a “mask” that contains a | bit in position 4):

i = 0x0000; /* i is now 0000000000000000 */
i |= 0x0010; /* i is now 0000000000010000 */

More generally, if the position of the bit is stored in the variable j, we can use
a shift operator to create the mask:
idiom

idiom

idiom

20.1 Bitwise Operators 513

i]=1 <<3; /* sets bit j */
For example, if j has the value 3, then 1 << j is 0x0008.

= Clearing a bit. To clear bit 4 of 1, we'd use a mask with a 0 bit in position 4
and | bits everywhere else:

i = O0x00ff; /* i is now 0000000011111111 */
i &= -0x0010; /* i is now 0000000011101111 */

Using the same idea, we can easily write a statement that clears a bit whose
position is stored in a variable:

i&= ~(1 <2< j); /* clears bit j */

u Testing a bit. The following `if` statement tests whether bit 4 of 1 is set:
if (1 & 0x0010) . /> tests bit 4 */
To test whether bit j is set, we'd use the following statement:
if (L & 1 << 3) w /* tests bit j */

To make working with bits casicr, we'll often give them names. For example,
suppose that we want bits 0, 1, and 2 of a number to correspond to the colors blue,
green, and red, respectively. First, we define names that represent the three bit
positions:

#define BLUE 1
#define GREEN 2
#define RED 4

Setting, clearing, and testing the BLUE bit would be done as follows:

i |= BLUE; /* sets BLUE bit */
i &= ~BLUE; /* clears BLUE bit */
if (i & BLUE) .. /* tests BLUE bit */

It’s also easy to set. clear, or test several bits at time:

i |= BLUE | GREEN; /* sets BLUE and GREEN bits */
i &= ~(BLUE | GREEN); /* clears BLUE and GREEN bits */
if (1 & (BLUE | GREEN)) .. /* tests BLUE and GREEN bits +/

The `if` statement tests whether either the BLUE bit or the GREEN bit is set.

Using the Bitwise Operators to Access Bit-Fields

Dealing with a group of several consecutive bits (a bit-field) is slightly more com-
plicated than working with single bits. Here are examples of the two most common
bit-field operations:

» Modifying a bit-field. Modifying a bit-field requires a bitwise and (to clear the
bit-field), followed by a bitwise o (to store new bits in the bit-field). The fol-
lowing statement shows how we might store the binary value 101 in bits 46
of the variahle 1
514 Chapter 20 Low-Level Programming

PROGRAM

ASCII character set > Appendix f

input and output redirection »-22. 1

i = i & -0x0070 | 0x0050; /* stores 101 in bits 4-6 */

The & operator clears bits 4-6 of i; the | operator then sets bits 6 and 4.
Notice that i | = 0x0050 by itself wouldn’t always work: it would set bits 6
and 4 but not change bit 5. To generalize the example a little, let’s assume that
the variable i contains the value to be stored in bits 4-6 of i. We'll need to
shift j into position before performing the bitwise or:

i= (1 & ~0x0070) | (4 << 4); /* stores j in bits 4-6 */

The | operator has lower precedence than & and <<, so we can drop the paren-
theses if we wish:

i =4 & -0x0070 | j << 4;

u Retrieving a bit-field. When the bit-field is at the right end of a number (in the
least significant bits), fetching its value is easy. For example, the following
statement retrieves bits 0-2 in the variable 1i:

j = i & 0x0007; /* retrieves bits 0-2 */

If the bit-field isn’t at the right end of of i, then we can first shift the bit-field
to the end before extracting the field using the & operator. To extract bits 4-6
of 1, for example, we could use the following statement:

4 = (4 >> 4) & 0x0007; /* retrieves bits 4-6 */

XOR Encryption

One of the simplest ways to encrypt data is to exclusive-or (XOR) each character
with a secret key. Suppose that the key is the & character. If we XOR this key with
the character z, we'll get the \ character (assuming that we’re using the ASCII
character set):

00100110 (ASCII code for &)
XOR 01111010 (ASCH code for z)
01011100 (ASCII code for \)

To decrypt a message, we just apply the same algorithm. In other words, by
encrypting an already-encrypted message, we'll recover the original message. If
we XOR the & character with the \ character, for example, we’ll get the original
character, z:

00100110 (ASCII code for &)
XOR Q 00 (ASCII code for \)
01111010 (ASCII code for z)

The following program, xor . c, encrypts a message by XORing each charac-
ter with the & character. The original mes can be entered by the user or read
from a file using input redirection; the encrypted message can be viewed on the
screen or saved in a file using output redirection. For example, suppose that the file

isprint funclion »23.5

Xxor.c

20.1 Bitwise Operators 515

msg contains the following lines:

Trust not him with your secrets, who, when left
alone in your room, turns over your papers.
--Johann Kaspar Lavater (1741-1801)

To encrypt the msg file, saving the encrypted message in newmsg, we'd use the
following command;

XOr <msg >newmsg
newmsg will now contain these lines:

rTSUR HIR NOK QORN IST UCETCRU, ONI, QNCH JC@R
GJIHC OH _IST TIIK, RSTHU IPCT _IST VGVCTU.
--1INGHH mGUVGT jGPGRCT (1741-1801)

To recover the original message, we’d use the command
XOr <newmsg

which will display it on the screen.

As the example shows, our program won’t change some characters, including
digits. XORing these characters with & would produce invisible control characters,
which could cause problems with some operating systems. In Chapter 22, we'll see
how to avoid problems when reading and writing files that contain control charac-
ters. Until then. we'll play it safe by using the isprint function to make sure
that both the original character and the new (encrypted) character are printing char-
acters (i.e., not control characters). If either character fails this test, we'll have the
program write the original character instead of the new character,

Here’s the finished program, which is remarkably short:

/* Performs XOR encryption */

#include <ctype.h>
#include <stdio.hs

#define KEY '&'
int main(void)
int orig char, new char;
while ((orig char = getchar()) != EOF)
new_char = orig char " KEY;
if (isprint(orig char) && isprint (new_char))
putchar (new_char) ;

else
putchar (orig char) ;

return 0;
516

Chapler 20 Low-Level Programming

20.2

portability tip

@D

Bit-Fields in Structures

Although the techniques of Section 20.1 allow us to work with bit-fields, these
techniques can be tricky to use and potentially confusing. Fortunately, C provides
an alternative: declaring structures whose members represent bit-fields.

As an example, let’s look at how the MS-DOS operating system (often just
called DOS) stores the date at which a file was created or last modified. Since
days, months, and years are small numbers, storing them as normal integers would
waste space. Instead, DOS allocates only 16 bits for a date, with 5 bits for the day,
4 bits for the month, and 7 bits for the year:

month

TR E T R T e T T ey S W T S e U
Using bit-fields, we can define a C structure with an identical layout:

struct file date {
unsigned int day: 5;
unsigned int mont. 4;
unsigned int year: 7;

The number after each member indicates its length in bits. Since the members all
have the same type, we can condense the declaration if we want:

struct file date {
unsigned int day: 5, month: 4, year: 7;

The type of a bit-field must be either int, unsigned int, or signed int.

Using int is ambiguous; some compilers treat the field's high-order bit as a sign
bit, but others don’t.

Declare all bir-fields to be either unsigned int or signed int.

In C99, bit-fields may also have type _Bool. C99 compilers may allow additional
bit-field types.

We can use a bit-field just like any other member of a structure, as the follow-
ing example shows:

struct ffile date ffd;

fd.day = 28;
fd.month = 12;
fd.year = 8; /* represents 1988 */

Note that the year member is stored relative to 1980 (the year the world began,
20.2 Bit-Fields in Structures 517

according to Microsoft). After these assignments, the fd variable will have the fol-
lowing appearance:

T G S R N T A T O S T R TR

We could have used the bitwise operators to accomplish the same effect; using
these operators might even make the program a little faster. However, having a
readable program is usually more important than gaining a few microseconds.

Bit-fields do have one restriction that doesn’t apply to other members of a
structure. Since bit-fields don’t have addresses in the usual sense, C doesn't allow
us to apply the address operator (&) to a bit-field. Because of this rule, functions
such as scanf can’t store data directly in a bit-field:

scanf ("%d", &fd.day); /%** WRONG %%/

Of course, we can always use scanf to read input into an ordinary variable and
then assign it to fd.day.

How Bit-Fields Are Stored

Let’s take a close look at how a compiler processes the declaration of a structure
that has bit-field members. As we’ll see, the C standard allows the compiler con-
siderable latitude in choosing how it stores bit-fields.

The rules concerning how the compiler handles bit-fields depend on the notion
of “storage units.” The size of a storage unit is implementation-defined; typical
values are 8 bits, 16 bits, and 32 bits. As it processes a structure declaration, the
compiler packs bit-fields one by one into a storage unit, with no gaps between the
[ields, until there's not enough room for the next field. At that point, some compil-
ers skip to the beginning of the next storage unit, while others split the bit-field
across Lhe storage units. (Which one oceurs is implementation-defined.) The order
in which bit-fields are allocated (left to right or right to left) is also implementa-
tion-defined.

Our file_date example assumes that storage units are 16 bits long. (An 8-
bit storage unit would also be acceptable, provided that the compiler splits the
month field across two storage units.) We also assume that bit-fields are allocated
from right to left (with the first bit-field occupying the low-order bits).

C allows us to omit the name of any bit-field. Unnamed bit-fields are useful as
“padding” to ensure that other bit fields are properly positioned. Consider the time
associated with a DOS file, which is stored in the following way:

struct file time {
unsigned int seccnds: 5;
unsigned int minutes: 6;
unsigned int hours: 5;

518

Chapter 20

20.3

Low-Level Programming

(You may be wondering how it’s possible to store the seconds—a number between
0 and 59—in a ficld with only 5 bits. Well, DOS cheats: it divides the number of
seconds by 2, so the seconds member is actually between 0 and 29.) If we’re not
interested in the seconds field, we can leave out its name:

struct file time {
unsigned int : 5; /* not used */
unsigned int minutes: 6;
unsigned int hours: 5;

The remaining bit-fields will be aligned as if the seconds field were still present.
Another trick that we can use to control the storage of bit-fields is to specify 0
as the length of an unnamed bit-field:

struct s {
unsigned int a: 4;
unsigned int : 0; /* 0-length bit-field */
unsigned int b: 8;

A 0-length bit-field is a signal to the compiler to align the following bit-field at the
beginning of a storage unit. If storage units are 8 bits long, the compiler will allo-
cate 4 bits for the a member, skip 4 bits to the next storage unit, and then allocate 8
bits for b. If storage units are 16 bits long, the compiler will allocate 4 bits for a,
skip 12 bits, and then allocate 8 bits for b.

Other Low-Level Techniques

Some of the language features that we’ve covered in previous chapters are used
often in low-level programming. To wrap up this chapter, we’ll take a look at sev-
eral important examples: defining types that represent units of storage, using
unions to bypass normal type-checking, and using pointers as addresses. We’ll also
cover the volatile type qualifier, which we avoided discussing in Section 18.3
because of its low-level nature.

Defining Machine-Dependent Types

Since the char type—by definition—occupies one byte, we'll sometimes treat
characters as bytes, using them to store data that's not necessarily in character
form. When we do so, it’s a good idea to define a BYTE type:

typedef unsigned char BYTE;

Depending on the machine, we may want to define additional types. The x86 archi-
tecture makes extensive use of 16-bit words, so the following definition would be
useful for that platform:
20.3 Other Low-Level Techniques 519

typedef unsigned short WORD;

We’ll use the BYTE and WORD types in later examples.

Using Unions to Provide Multiple Views of Data

Although unions can be used in a portable way—see Section 16.4 for examples—
they’re often used in C for an entirely different purpose: viewing a block of mem-
ory in two or more different ways.

Here’s a simple example based on the file_date structure described in
Section 20.2. Since a file_date structure fits into two bytes, we can think of
any two-byte value as a file_date structure. In particular, we could view an
unsigned short value as a file_date structure (assuming that short inte-
gers are 16 bits long). The following union allows us to easily convert a short intc-
ger (0 a file date or vice versa:

union int_date {
unsigned short i;
struct file_date ffd;

i

With the help of this union, we could fetch a file date from disk as two bytes, then
extract its month, day, and year fields. Conversely, we could construct a date as
afile date structure, then write it to disk as a pair of bytes.

As an example of how we might use the int_date union, here’s a function
that, when passed an unsigned short argument, prints it as a file date:

void print_date(unsigned short n)
unicn int_date u;

u.i = n;
printf ("$d/%d/%d\n", u.fd.month, u.fd.day, u.fd.year + 1980);

Using unions to allow multiple views of data is especially useful when work-
ing with registers, which are often divided into smaller units. x86 processors, for
example, have 16-bit registers named AX, BX, CX, and DX. Each of these regis-
ters can be treated as two 8-bit registers. AX, for example, is divided into registers
named AH and AL. (The H and L stand for “high” and “low.”)

When writing low-level applications for x86-based computers, we may need
variables that represent the contents of the AX, BX, CX, and DX registers. We
want access (o both the 16- and 8-bit registers: at the same time, we need to take
their relationships into account (a change to AX affects both AH and AL; changing
AH or AL modifies AX). The solution is to set up two structures, one containing
members that correspond to the 16-bit registers, and the other containing members
that match the 8-bit registers. We then create a union that encloses the two struc-
tures:
520

Chapter 20 Low-Level Programming

union {
struct {
WORD ax, bx, cx, dx;
} word;
struct {
BYTE al, ah, bl, bh, cl, ch, dl, dh;
} byte;
} regs;

The members of the word structure will be overlaid with the members of the
byte structure; for example, ax will occupy the same memory as al and ah. And

that, of course, is exactly what we wanted. Here’s an example showing how the
regs union might be used:

regs.byte.ah 0x12;
regs.byte.a 0x34;
printf ("AX: $hx\n", regs.word.ax);

Changing ah and al affects ax, so the output will be
BAX: 1234

Note that the byte structure lists al before ah, even though the AL register
is the “low" half of AX and AH is the “high” half. Here's the reason. When a data
item consists of more than one byte, there are two logical ways to store it in mem-
ory: with the bytes in the “natural" order (with the leftmost hyte stored first) or
with the bytes in reverse order (the leftmost byte is stored last). The first alternative
is called hig-endian; the second is known as little-endian. C doesn’t require a spe-
cific byte ordering, since that depends on the CPU on which a program will be exe-
cuted. Some CPUs use the big-endian approach and some use the little-endian
approach. What does this have to do with the byte structure? It turns out that x86
processors assume that data is stored in little endian order, so the first byte of
regs.word.ax is the low byte.

We don't normally need to worry about byte ordering. However. programs that
deal with memory at a low level must be aware of the order in which bytes are
stored (as the regs example illustrates). IUs also relevant when working with files
that contain non-character data.

Be careful when using unions to provide multiple views of data. Data that is valid
in its original format may be invalid when viewed as a different type, causing
unexpected problems.

Using Pointers as Addresses

We saw in Section 11,1 that a pointer is really some kind of memory address,
although we usually don't need to know the details, When we do low-level pro-
gramming, however, the details matter.
PROGRAM

viewmemory.c

20.3 Other Low-Level Techniques 521

An address often has the same number of bits as an integer (or long integer).
Creating a pointer that represents a specific address is easy: we just cast an integer
into a pointer. For example, here’s how we might store the address 1000 (hex) in a
pointer variable:

BYTE +p;

p = (BYTE *) 0x1000; /* p contains address 0x1000 */

Viewing Memory Locations

Our next program allows the user to view segments of computer memory; it relies
on C’s willingness to allow an integer o be used as a pointer. Most CPUs execute
programs in “protected mode,” however, which means that a program can access
only those portions of memory that belong to the program. This prevents a pro-
gram from accessing (or changing) memory that belongs to another application or
to the operating system itself. As a result, we'll only be able to use our program to
view areas of memory that have heen allocated for use by the program itself. Going
outside these regions will cause the program to crash.

The viewmenory.c program begins by displaying the address of its own
`main` function as well as the address of one of its variables. This will give the user
a clue as to which areas of memory can be probed. The program next prompts the
user to enter an address (in the form of a hexadecimal integer) plus the number of
bytes to yiew. The program then displays a block of bytes of the chosen length,
starting at the specified address,

Bytes are displayed in groups of 10 (except for the last group, which may have
fewer than 10 bytes). The address of a group of bytes is displayed at the beginning
of a line, followed by the bytes in the group (displayed as hexadecimal numbers)?
followed by the same bytes displayed as characters (just in case the bytes happen to
represent characters, as some of them may). Only printing characters (as deter-
mined by the isprint function) will be displayed; other characters will be
shown as periods.

We’ll assume that int values are stored using 32 bits and that addresses are
also 32 bits long. Addresses are displayed in hexadecimal, as is customary.

/* Rllows the user to view regions of computer memory */

#include <ctype.hs
#include <stdio.h»

typedef unsigned char BYTE;
int main(void)

unsigned int addr;

int i, n;

BYTE *pty;

printf ("Address of `main` function: %x\n", (unsigned int) main);
printf("Address of addr variable: %x\n", (unsigned int) &addr);
522 Chapter 20  Low-Level Programming

printf ("\nEnter a (hex) address: ");
scanf ("$x", &addr);

printf (*Enter number of bytes to view: ");
scanf ("%d", &n);

printf ("\n) ;

printf (" Address Bytes Characters\n") ;
PEAREL(n SooamE S o oe =~ = \n") ;
ptr = (BYTE *) addr;
for (; n > 0; m -= 10)
printt("$8X ", (unsigned int) ptr);
for (i = 0; 1 < 10 & i < n; i++)
printf("%.2X ", *(ptr + i));
for (; i < 10; i++)
printE(r ")
printf (" ) ;
for (i i< 10 && 1 < n; i++) {

BYTE ch = *(ptr + i);
if (lisprint(ch))
Gh =t 5Ty
printf("sc", ch);
printf ("\n") ;
ptr += 10;
}
. return 0;
}

The program is complicated somewhat by the possibility that the value of n
isn't a multiple of 10, so there may be fewer than 10 bytes in the last group. Two of
the `for` statements are controlled by the condition i < 10 && i < n. This condi-
tion causes the loops to execute 10 times or n times, whichever is smaller. There’s
also a `for` statement that compensates for any missing bytes in the last group by
displaying three spaces for each missing byte. That way, the characters that follow
the last group of bytes will align properly with the character groups on previous
lines.

The %X conversion specifier used in this program is similar to $x, which was
discussed in Section 7.1. The difference is that $X displays the hexadecimal digits
A, B, C, D, E, and F as upper-case letters; $x displays them in lower case.

Here's what happened when I compiled the program using GCC and tested it
on an x86 system running Linux:

Address of `main` function: 804847c
Address of addr variable: bff41154

Enter a (hex) address: 8048000
Enter number of bytes to view: 40

Address Bytes Characters
8048000
804800A
8048014
804801E

20.3 Other Low-Level Techniques 523

I asked the program to display 40 bytes starting at address 8048000, which pre-
cedes the address of the `main` function. Note the 7F byte followed by bytes repre-
senting the letters E, L, and F. These four bytes identify the format (ELF) in which
the executable file was stored. ELF (Executable and Linking Format) is widely
used by UNIX systems, including Linux. 8048000 is the default address at which
ELF executables are loaded on x86 platforms.

Let’s run the program again, this time displaying a block of bytes that starts at
the address of the addxr variable:

Address of `main` function: 804847c
Address of addr variable: bfec5484

Enter a (hex) address: bfec5484
Enter number of bytes to view: 64

Address Bytes Characters
BFEC5484
BFEC548E
BFEC5498
BFEC54A2
BFEC54AC
BFEC54B6 EC BF 3C 55 EC BF 56 11 55 00
BFEC54C0 F4 6F 68 00

Nonc of the data stored in this region of memory is in character form, so it’s a bit
hard to follow. However, we do know one thing: the addr variable occupies the
first four bytes of this region. When reversed, these bytes form the number
BFEC5484, the address entered by the user. Why the reversal? Because x86 pro-
cessors store data in little-endian order, as we saw earlier in this section.

The volatile Type Qualifier

On some computers, certain memory locations are “volatile"; the value stored at
such a location can change as a program is running, even though the program itself
isn’t storing new values there. For example, some memory locations might hold
data coming directly from input devices.

The volatile type qualifier allows us to inform the compiler if any of the
data used in a program is volatile. volatile typically appears in the declaration
of a pointer variable that will point to a volatile memory location:

volatile BYTE *p; /* p will point to a volatile byte */

To see why volatile is needed, suppose that p points to a memory location
that contains the most recent character typed at the user’s keyboard. This location
is volatile: its value changes each time the user enters a character. We might use the
following loop to obtain characters from the keyboard and store them in a buffer
array:
524

Chapter 20

>

Low-Levsl Programming

while (buffernotfull) {
wait for input ;
buffer[i] = *p;
if (buffer[i++] == '\n')
break;

A sophisticated compiler might notice that this loop changes neither p nor *p, so it
could optimize the program by altering it so that *p is fetched just once:
store *p in a regisier;
while (buffer notfull)
wail for input ;

buffer(il = value stored in register;
if (buffer(i++] == '\n')
break;

‘The optimized program will fill the buffer with many copies of the same charac-
ter—not exactly what we had in mind, Declaring that p points to volatile data
avoids this problem by telling the compiler that *p must be fetched from memory
each time it's needed.

Q&A

What do you mean by saying that the & and | operators sometimes produce
the same results as the && and | | operators, but not always? [p. 511]
Let’s compare i & j with i && j (similar remarks apply to | and | |). As long as
1 and j have the value 0 or 1 (in any combination). the two expressions will have
the same value. However, if i and j should have other values, the expressions may
not always match. If 1 is 1 and j is 2, for example, then i & j has the value 0 (i
and j have no corresponding 1 bits), while 1 && j has the value 1. If 1 is 3 and j
is 2, then i & 7j has the value 2, while i && j has the value 1.

Side effects are another difference. Evaluating i & j++ always increments j
as a side effect. whereas evaluating 1 && j++ sometimes increments j.

‘Who cares how DOS stores file dates? Isn’t DOS dead? [p. 516]

For the most part, yes. However, there are still plenty of files created years ago
whose dates are stored in the DOS format. In any event, DOS file dates are a good
example of how bit-fields are used.

Where do the terms “big-endian’ and “little-endian” come from? [p. 520]

In Jonathan Swift's novel Gulliver's Travels, the fictional islands of Lilliput and
Blefuscu are perpetually at odds over whether to open boiled eggs on the big end
or the little end. The choice is arbitrary, of course, just like the order of bytes in a
data item.
Section 20.1

L B

*3.

G

Exercises 525

Exercises

Show the output produced by each of the following program fragments. Assume that 1, 5,
and k are unsigned short variables.
@1i=8;3=29;

printff("%d", i >> 1 + j >> 1);

W)=
printf("%d", i & -i);
() =2

printf
@di=7;3=8;
printf(osdr, &« * j & k);

P
Wowon

0;
S Rl
9

Deseribe a simple way to “toggle” a bit (change it from 0 to | or from 1 to 0). ustrate the
technique by writing a statement that toggles bit 4 of the variable 1.

Explain what effect the following macro has on its arguments. You may assume thal the
arguments have the same type.

f#define M(x,y) ((x)"=(y), (¥)"=(x), (x)*=(y))

In computer graphies, colors are often stored as three numbers, representing red, green, and
blue intensities. Suppose that each number requires cight bits, and we'd like to store all three
values in a single long integer. Write 2 macro named MK_COLOR with three parameters (the
red. green, and blue intensities). MK_COLOR should return a Long in which the last three
bytes contain the red, green, and blue intensities, with the red value as the last byte and the
green value as the next-to-last byte.

Write macros named GET RED, GET GREEN, and GET BLUE that, when given a color as
an argument (see Exercise 4), retur its 8-bit red, green, and blue intensities.

(a) Use the bitwise operators to write the following function:
unsigned short swap_bytes (unsigned short i);

swap bytes should return the number that results from swapping the two bytes in 1.
(Short integers occupy two bytes on most computers.) For example, if i has the value
0x1234 (00010010 00110100 in binary), then swap_bytes should return 0x3412
(00110100 00010010 in binary). Test your function by writing a program that reads a num-
ber in hexadecimal, then writes the number with its bytes swapped:

Enter a hexadecimal number (up to four digits): 1234
Number with bytes swapped: 3412

Hinz: Use the ¥hx conversion to read and write the hex numbers.
(b) Condense the swap_bytes function so that its body is a single statement.

Wiite the following functions:

unsigned int rotate left (unsigned int i, int n);
unsigned int rotate right (unsigned int i, int n);

rotate left should retrn the result of shifting the bits in 1 to the left by n places,
with the bits that were “shifted off” moved to the right end of i. (For example, the call
526 Chapter 20 Low-Level Programming

Section 20.2

Lk

® 14

rotate left (0x12345678, 4) should return 0x23456781 if integers are 32 bits
long.) rotate right is similar, but it should “rotate” bits to the right instead of the left.
Let f be the following function:

unsigned int f(unsigned int i, int m, int n)

return (i >> (m + 1 - n)) & ~(~0 << n);

(2) Whatis the value of ~ (~0 << n)?
(b) What does this function do?

(a) Write the following function:
int count ones(unsigned char ch);
count_ones should return the number of 1 bits in ch.

(b) Write the function in part (a) without using a loop.

Wite the following function:
unsigned int reverse_bits(unsigned int n);

reverse_bits should return an unsigned integer whose bits are the same as those in n
but in reverse order.

Each of the following macros defines the position of a single bit within an integer:

#define SHIFT BIT 1
4define CTRL BIT 2
#define ALT BIT 4
The following statement is supposed to test whether any of the three bits have been set, but it
never displays the specified message. Explain why the statement doesn’t work and show
how to fix it. Assume that key code is an int variable.
if (key_code & (SHIFT BIT | CTRL BIT | ALT BIT) -- 0)
printf ("No modifier keys pressed\n") ;

The following function supposedly combines two bytes to form an unsigned short integer.
Explain why the function doesn’t work and show how to fix it.
unsigned short create short (unsigned char high byte,
unsigned char low byte)
(

return high byte << 8 + low_byte;

If 0 is an unsigned int variable, what effect does the following statement have on the
bits inn?

né&=n- 1;
Hint: Consider the effect on n if this statement is executed more than once.

‘When stored according to the IEEE floating-point standard, a float value consists of a 1
bit sign (the leftmost—or most significant—bit), an 8-bit exponent, and a 23-bit fraction, in
that order. Design a structure type that occupies 32 bits, with bit-tield members correspond-
ing to the sign, exponent, and fraction. Declare the bit-fields to have type unsigned int.
Check the manual for your compiler to determine the order of the bit-ficlds.
Section 20.3

HS.

16.

Programming Projects 527

(a) Assume that the variable s has been declared as follows:

struct {
int flag: 1;
} si

With some compilers, executing the following statements causes 1 to be displayed, but with
other compilers, the output is —1. Explain the reason for this behavior.

s.flag = 1;
printf ("3d\n", s.flag);

(b) How can this problem be avoided?

Starting with the 386 processor, x86 CPUs have 32-bit registers named EAX, EBX, ECX,
and EDX. The second half (the least significant bits) of these registers is the same as AX,
BX, CX, and DX, respectively. Modify the regs union so that it includes these registers as
well as the older ones. Your union should be set up so that modifying EAX changes AX and
modifying AX changes the second half of EAX. (The other new registers will work in a sim-
ilar fashion.) You'll need to add some “dummy" members to the word and by te structures,
corresponding to the other half of EAX, EBX, ECX, and EDX. Declare the type of the new
registers to be DAORD (double word), which should be defined as unsigned 1cng. Don't
forget that the x86 architecture is little-endian.

Programming Projects

Design a union that makes it possible to view a 32-bit value as either a float or the struc-
ture described in Exercise 14. Write a program that stores | in the structure’s sign field, 128
in the exponent field, and 0 in the fraction field, then prints the f1cat value stored in the
union. (The answer should be —2.0 if you’ve set up the bit-fields correctly.)
21

211

D

Table 21.1
Standard Library Headers

The Standard Library

Every program is a part of some oiher prograrn and rarely fits.

In previous chapters we've looked at the C library piccemeal: this chapter focuses
on the library as a whole. Section 21.1 lists general guidelines for using the library.
It also describes a trick found in some library headers: using a macro to “hide” a
function. Section 21.2 gives an overview of cach header in the C89 library; Section
21.3 does the same for the new headers in the C99 library.

Later chapters cover the library’s headers in depth. with related headers
grouped together into chapters. The <stddef . h> and <stdbool . h> headers
are very brief, so I've chosen to discuss them in this chapter (in Sections 21.4 and
21.5. respectively).

Using the Library

The C89 standard library is divided into 15 parts, with each part described by a
header. C99 has an additional nine headers, for a total of 24 (see Table 21.1).

cassert.n»>  <inttypes.hs' <signal.n> <stdlib.h>
<complex.h>' <iso6d6.h>" <stdarg.h> <string.
<ctype.h> <limits.hs> <stdbool.h>' <tgmath.
<errno.h> <locale.h> <stddef.h> <time.h>
<fenv.h>' <math.h> <stdint.h>' <wchar. hs’
<float.h> <setjmp.h> <stdio.h> <wetype.hs!
'c99 only

Most compilers come with a more extensive library that invariably has many
headers that don’t appear in Table 21.1. The extra headers aren’t standard, of

529
530

Chapter 21 The Standard Library

course, 5o we can’t count on them (o be available with other compilers. These
headers often provide functions that are specific on a particular computer or oper-
ating system (which explains why they're not standard). They may provide func-
tions that allow more control over the screen and keyboard. Headers that support
graphics or a window-based user interface are also common.

The standard headers consist primarily of function prototypes, type defini-
tions, and macro definitions. If one of our files contains a call of a function
declared in a header or uses one of the types or macros defined there, we'll need to
include the header at the beginning of the file. When a file includes several stan-
dard headers, the order of #include directives doesn’t matter. It's also legal to
include a standard header more than once.

Restrictions on Names Used in the Library

Any file that includes a standard header must obey a couple of rules. First, it can’t
use the names of macros defined in that header for any other purpose. If a file
includes <stdio.h>, for example, it can’t reuse NULL, since a macro by that
name is already defined in <stdio.h>. Second, library names with file scope
(typedef names, in particular) can’t be redefined at the file level. Thus, if a file
includes <stdio. h>, it can’t define size_t as a identifier with file scope, since
<stdio.h> defines size_t tobe a typedef name.

Although these restrictions are pretty obvious, C has other restrictions that you
might not expect:

w Identifiers that begin with an underscore followed by an upper-case letter or
a second underscore arc reserved for use within the library; programs should
never use names of this form for any purpose.

u [dentifiers that begin with an underscore are reserved for use as identifiers
and tags with file scope. You should never use such a name for your own pur-
poses unless it’s declared inside a function.

u Every identifier with external linkage in the standard library is reserved for
use as an identifier with external linkage. In particular, the names of all stan-
dard library functions are reserved. Thus, even if a file doesn't include
<stdio.hs, it shouldn’t define an external function named printf, since
there’s already a function with this name in the library.

These rules apply to every file in a program, regardless of which headers the file
includes. Although these rules aren’t always enforced, failing to obey them can
lead to a program that’s not portable.

The rules listed above apply not just to names that are currently used in the
library, but also to names that are set aside for future use. The complete description
of which names are reserved is rather lengthy: you'll find it in the C standard under
“future library directions” As an example, C reserves identifiers that begin with
str followed by a lower-case letter, so that functions with such names can be
added to the <string.h> header.
#undef directive > 14.3

212

21.2 C89 Library Overview 531

Functions Hidden by Macros

It’s common for C programmers to replace small functions by parameterized mac-
ros. This practice occurs even in the standard library. The C standard allows head-
ers to define macros that have the same names as library functions, but protects the
programmer by requiring that a true function be available as well. As a result. it’s
not unusual for a library header ta declare a function and define a macro with the
same name.

We’ve already seen an example of a macro duplicating a library function.
getchar is a library function declared in the <stdio.h> header. It has the fol-
lowing prototype:

int getchar(void);
<stdio.h> usually defines getchar as a macro as well:
#define getchar() getc(stdin)

By default, a call of getchar will be treated as a macro invocation (since macro
names are replaced during preprocessing).

Most of the time, we're happy using a macro instead of a true function,
because it will probably make our program run faster. Occasionally, though, we
want a genuine function, perhaps to minimize the size of the executable code.

If the need arises, we can remove a macro definition (thus gaining access to
the true function) by using the #unde f directive. For example, we could undefine
the getchar macro after including <stdio.hs:

#include <stdio.h>
#undef getchar

If getchar isn't a macro, no harm has been done; #undeff has no effect when
given a name that's not defined as a macro.

As an alternative, we can disable individual uses of a macro by putting paren-
theses around its name:

ch = (getchar) (); /* instead of ch = getchar(); */

The preprocessor can't spot a parameterized macro unless its name is followed by
a lell parenthesis. The compiler isn’t so easily fooled, however; it can still recog-
nize getchar as a function.

C89 Library Overview

We'll now take a quick look at the headers in the C89 standard library. This section
can serve as a “road map” to help you determine which part of the library you
need. Each header is described in detail later in this chapter or in a subsequent
chapter.
532 Chapter 21

<assert.h>

<agsert.h> header »24.1

<ctype.h>

<ctype.h=header »20.5

<errno.h>

<errno.h> header »242

<float.h>

<float. > header »23.1

<limits.h>

climits.hs header»23.2

<locale.h>

<locale. h> header»25.1

<math.h>

<matn.hs header »23.3

<setjmp.h>

<setimp. h> header »24.4

The Standard Library

Diagnostics

Contains only the assext macro, which allows us to insert self-checks into a pro-
gram. If any check fails, the program terminates.

Character Handling

Provides functions for classifying characters and for converting letters from lower
10 Upper case or vice versa.

Errors

Provides exrno (“error number”), an Ivalue that can be tested after a call of cer-
tain library functions to see if an error occurred during the call,
Characteristics of Floating Types

Provides macros that describe the characteristics of floating types, including their
range and accuracy.

Sizes of Integer Types

Provides macros that describe the characteristics of integer types (including char-
acter types), including their maximum and minimum values.

Localization

Provides functions to help a program adapt its behavior to a country or other geo-
graphic region. Locale-specific behavior includes the way numbers are printed
(such as the character used as the decimal point), the format of monetary values
(the currency symbol, for example), the character set, and the appearance of the
date and time.

Mathematics

Provides common mathematical functions. including trigonometric, hyperbolic,
exponential, logarithmic, power, nearest integer, absolute value, and remainder
functions.

Nonlocal Jumps

Provides the set jmp and longjmp functions. set jmp “marks" a place in a pro-
gram; longjmp can then be used to return to that place later. These functions
<signal.h>

<gignal .h> header »24.3

<stdarg.h>

<stdarg. h> header »26 1

<stddef.h>

<stddef . h> header » 214

<stdio.h>

<stdio. h>header»22.1-22.8

<stdlib.h>

<stdlib. b header >26.2

<string.h>

<string.h> header >20.6

<time.h>

<time.h> noader =263

21.2 ©89 Library Overview 533
make it possible to jump from one function into another, still-active function,

bypassing the normal function-return mechanism. setjmp and longjmp are
used primarily for handling serious problems that arise during program execution.

Signal Handling
Provides functions that deal with exceptional conditions (signals), including inter-

rupts and run-time errors. The signal function installs a function to be called if a
given signal should occur later. The raise function causes a signal to oceur.

Variable Arguments

Provides tools for writing functions that, like princf and scanf, can have a
variable number of arguments.

Common Definitions

Provides definitions of frequently used types and macros.

Input/Output

Provides a large assortment of input/output functions. including operations on both
sequential and random-access files.

General Utilities

A “catchall” header for functions that don’t fit into any of the other headers. The
functions in this header can convert strings to numbers, generate pseudo-random
numbers, perform memory management tasks, communicate with the operating
system. do searching and sorting, and perform conversions between multibyte
characters and wide characters.

String Handling
Provides functions that perform string operations, including copying, concatena-

tion, comparison, and searching, as well as functions that operate on arbitrary
blocks of memory.

Date and Time

Provides functions for determining the time (and date), manipulating times, and
formatting times for display.
534 Chapter 21  The Standard Library

21.3

<complex.h>

<complex. h> header »>27.4

<fenv.h>

<fenv. h> header » 27.6

<inttypes.h>

<inttypes.ho header »27.2

<iso646.h>

<150646. 1> header 253

C99 Library Changes

Some of the biggest changes in C99 affect the standard library. These changes fall
into three groups;

u Additional headers. The C99 standard library has nine headers that don’t exist
in C89. Three of these (<is0646.h>, <wchar.h>, and <wctype.hs>)
were actually added to C in 1995 when the C89 standard was amended. The
other six (ccomplex.hs, <fenv.hs, <inttypes.h>, <stdbocl.h>,
<stdint.h>, and <tgmath.h>) are new in C99.

m Additional macros and functions. The C99 standard adds macros and func-
tions to several existing headers, primarily <float.hs, <math.h>, and
<stdio.h>. The additions to the emath.h> header are so exlensive that
they're covered in a separate section (Section 23.4).

® Enhanced versions of existing functions. Some existing functions, including
printf and scanf, have additional capabilities in C99.

We'll now take a quick look at the nine additional headers in the C99 standard
library. just as we did in Section 21.2 for the headers in the C89 library.

Complex Arithmetic

Defines the complex and I macros, which are useful when working with com-
plex numbers. Also provides functions for performing mathematical operations on
complex numbers.

Floating-Point Environment

Provides access to floating-point status flags and control modes. For example, a
program might test a flag to see if overflow occurred during a floating-point opera-
tion or sct a control mode to specify how rounding should be done.

Format Conversion of Integer Types

Defines macros that can be used in format strings for input/output of the integer
types declared in <stdint . h>. Also provides functions for working with great-
est-width integers.

Alternative Spellings

Defines macros that represent certain operators (the ones containing the characters
& |, ~, !,and *). These macros are useful for writing programs in an environment
where these characters might not be part of the local character set.
<stdbool.h>

<stdbool . 1> headst >21.5

<stdint.h>

estdint  h> headar »27.1

<tgmath.h>

<tgmacth.h>header »27.5

<wchar.h>

<wchar  hs header »25.5

<wctype.h>

<wetype . h> header »25.6

21.4

21.4 The <stddef . h> Header: Common Definitions ~ 535

Boolean Type and Values

Defines the bool, true, and false macros, as well as a macro that can be used
to test whether these macros have been defined.

Integer Types

Declares integer types with specified widths and defines related macros (such as
macros that specify the maximum and minimum values of each type). Also defines
parameterized macros that construct integer constants with specific types.

Type-Generic Math

In C99, there are multiple versions of many math functions in the <math.h> and
<complex . h> headers. The “type-generic” macros in <tgmath.h> can detect
the types of the arguments passed to them and substitute a call of the appropriate
<math.h> or ccomplex.h> function.

Extended Multibyte and Wide-Character Utilities

Provides functions for wide-character input/output and wide string manipulation.

Wide-Character Classification and Mapping Utilities

The wide-character version of <ctype.hs. Provides functions for classifying
and changing the case of wide characters.

The <stddef.h> Header: Common Definitions

The <stddef .h> header provides definitions of frequently used types and mac-
ros; it doesn’t declare any functions. The types are:

m ptrdiff_t. The type of the result when two pointers are subtracted.
m size t.The type returned by the sizeof operator.

m wchar_t. A type large enough to represent all possible characters in all sup-
ported locales.

All three are names for integer types; ptrdiff_t must be a signed type, while
size_t must be an unsigned type. For more information about wchar_t, see
Section 25.2.

The <stddef . h> header also defines two macros. One of them is NULL,
which represents the null pointer. The other macro, of fsetof. requires two argu-
ments: zype (a structure type) and member-designator (a member of the structure).
536

Chapter 21

fwri te unction >22.6

215

The Standard Library

offsetof computes the number of bytes between the beginning of the structure
and the specified member.
Consider the following structure:

struct s {
char a;
int b[2];
float c;

The value of offsetof (struct s, a) must be 0; C guarantees that the first
member of a structure has the same address as the structure itself. We can't say for
sure what the offsets of b and c are. One possibility is that of fsctof (struct
s, b) is 1 (since a is one byte long), and of fsetof (struct s, c) is 9
(assuming 32-bit integers). However, some compilers leave “holes”—unused
bytes—in structures (see the Q&A section at the end of Chapter 16), which can
affect the value produced by of fsetof. If a compiler should leave a three-byte
hole after a, for example, then the offsets of b and c would be 4 and 12, respec-
tively. But that’s the beauty of of fsetof: it produces the correct offsets for any
compiler, enabling us to write portable programs.

There are various uses for of fsetof. For example, suppose that we want to
save the first two members of an s structure in a file, ignoring the c member.
Instead of having the fwrite function write sizecf (struct s) bytes, which
would save the entire structure, we'll tell it to write only of fsetof (struct s,
c) bytes.

A final remark: Some of the types and macros defined in <stddef .h>
appear in other headers as well. (The NULL macro, for example, is also defined in
<locale.h>, <stdio.h>, <stdlib.h>, <string.h>, and <time.hs,
as well as in the C99 header <wchar.h>.) As a result, few programs need to
include <stddef .h>.

The <stdbool.h> Header (C99): Boolean Type
and Values

The <stdbool . h> header defines four macros:

m bool (defined to be _Bool)

m true (defined to be 1)

m false (defined to be 0)

m _ bool true false are defined (defined tobe 1)
We’ve seen many examples of how bool, true, and false are used. Potential
uses of the bool true false are defined macro are more limited. A
program could use a preprocessing directive (such as #1 f or #1fdef) to test this
macro before attempling to define its own version of bool, true. or false.
Section 21.1

9

#
o

Q&A 537

Q&A

I notice that you use the term “standard header” rather than “standard
header file.” Is there any reason for not using the word “file”?

Yes. According to the C standard, a “standard header” need not be a file. Although
most compilers do indeed store standard headers as files, the headers could in fact
be built into the compiler itself.

Section 14.3 described some disadvantages of using parameterized macros in
place of functions. In light of these problems, isn’t it dangerous to provide a
macro substitute for a standard library function? [p. 531]

According to the C standard, a parameterized macro that substitutes for a library
function must be “fully protected” by parentheses and must evaluate its arguments
exactly once. These rules avoid most of the problems mentioned in Section 14.3.

Exercises

Locate where header files are kept on your system. Find the nonstandard headers and deter-
mine the purpose of each.

Having located the header files on your systemn (see Exercise 1), find a standard header in
which a macro hides a function.

When & macro hides a function, which must come first in the header file: the macro defini-
tion or the function prototype? Justify your answer.

Make a list of all reserved identifiers in the “future library directions" section of the C99
standard. Distinguish between identifiers that are reserved for use only when a specific
header is included versus identifiers that are reserved for usc as external names.

The islower function, which belongs to <ctype.h>, tests whether a character is a
lower-case letter,. Why would the following macro version of islower not be legal,
according to the C standard? (You may assume that the character set is ASCIL)

#define islower(c) ((c) >= 'a' && (c) <= 'z')

The <ctype.h> header usually defines most of its functions as macros as well. These
macros rely on a static array that’s declared in <ctype .h> but defined in a separate file. A
portion of a typical <ctype . h> header appears below. Use this sample to answer the fol-
lowing questions.

(a) Why do the names of the “bit" macros (such as_UPPER) and the _ctype array begin
with an underscore?

(b) Explain what the _ctype array will contain. Assuming that the character set is ASCII,
show the values of the array elements at positions 9 (the horizontal tab character), 32 (the
space character), 63 (the letter A), and 94 (the * charucter). See Section 23.5 for a descrip-
tion of what each macro should return.
538 Chapter 21

Section 21.2

[

The Standard Library

(c) What's the advantage of using an array to implement these macros?

#define UPPER 0x01 /* upper-case letter */
#define _LOWER 0x02 /* lower-case letter */
#define DIGIT 0x04 /* decimal digit */
#define _CONTROL 0x08 /* control character */
#define PUNCT 0x10 /* punctuation character */
#define _SPACE 0x20 /* white-space character */
#define HEX 0x40 /* hexadecimal digit */
#define BLANK 0x80 /* space character */

#define isalnum(c) (_ctypelc] & (_UPPER|_LOWER|_DIGIT))
#define isalpha(c) (_ctypelc] & (_UPPER|_LOWER))
#define iscntrl(e) ( ctypelc] & _CONTROL)
#define iedigit(c) (_ctypelc] & _DIGIT)
#define isgraph(c) ( ctypelc] &
(_PUNCT|_UPPER|_LOWER|_DIGIT))
#define islower(c) ( ctypelc] & _LOWER)
#define isprint(c) ( ctypelc] &
(_BLANK|_ PUNCT| UPPER| LOWER|_DIGIT))
#define ispunct(c) (_ctypelc] & _PUNCT)
#define isspace(c) (_ctypelc] & _SPACE)
fidefine isupper(c) (_ctypelc] & _UPPER)
#define isxdigit(ec) (_ctypelc] & ( DIGIT| HEX))

In which standard header would you expect to find each of the following?

(a) A function that determines the current day of the week.

(b) A function that tests whether a character is a digit

(e) A macro that gives the largest unsigned int value

(d) A function that rounds a floating-point number to the next higher integer
(e) A macro that specifies the number of bits in a character

(f) A macro that specifies the number of significant digits in a double value
(g) A function that searches a string for a particular character

(h) A function that opens a file for reading

Programming Projects

Write a program that declares the s structure (see Section 21.4) and prints the sizes and off-
sets of the a, b, and c members. (Use sizeof (o find sizes; use of fsetof to find off-
sets.) Have the program print the size of the entire structure as well. From this information,
determine whether or not the structure has any holes. If it does, describe the location and
size of each.

22

Input/Output

In man-machine symbiosis, it is man
who must adjust: The machines can't.

C’s input/output library is the biggest and most important part of the standard
Tibrary. As befits its lofty status, we'll devote an entire chapter (the longest in the
book) to the <stdio. h> header. the primary repository of input/output functions.

We've been using <stdio. h> since Chapter 2, and we have experience with
the printf, scanf, putchar, getchar, puts, and gets functions. This
chapter provides more information about these six functions, as well as introduc-
ing a host of new functions, most of which deal with files. Fortunately, many of the
new functions are closely related to functions with which we're already
acquainted. fprintf, for instance, is the “file version" of the printf function.

We'll start the chapter with a discussion of some basic issues: the stream con-
cept, the FTLE type, input and output redirection, and the difference between text
files and binary files (Section 22.1). We'll then turn to functions that are designed
specifically for use with files, including functions that open and close files (Section
22.2). After covering printf, scanf, and related functions for “formatted”
input/output (Section 22.3), we’ll look at functions that read and write unformatted
data;

= getc, putc, and related functions, which read and write one character at a
time (Section 22.4).

® gets, puts, and related funetions, which read and write one /ine at a time
(Section 22.5).

= fread and fwrite, which read and write blocks of data (Section 22.6).

Section 22.7 then shows how to perform random s operations on files.
Finally, Section 22.8 describes the sprintf, snprintf, and sscanf func-
tions, variants of printf and scanf that write to a string or read from a string.
This chapter covers all but cight of the functions in <stdio.h>. One of
these eight, the perror function, is closely related to the <errno. h> header, so

539
540

Chapter 22

D

<wchar.h> header >25.5

22.1

Input/Output

'l postpone it until Section 24.2, which discusses that header. Section 26.1 covers
the remaining functions (vfprintf, vprintf, vsprintf, vsnprintf,
vEscanf, vscant, and vsscant). These functions rely on the va_1list type,
which is introduced in that section.

In C89. all standard input/output functions belong to <stdio.hx. but such is
not the case in C99, where some 1/O functions are declared in the <wchar.h>
header. The <wchar . h> functions deal with wide characters rather than ordinary
characters; the good news is that most of these functions closely resemble those of
<stdio.h>. Functions in <stdioc.h> that read or write data are known as byte
input/output functions; similar functions in <wchar . h> are called wide-charac-
ter inputf/output functions.

Streams

In C, the term stream means any source of input or any destination for output.
Many small programs, like the ones in previous chapters, obtain all their input
from one stream (usually associated with the keyboard) and write all their output to
another stream (usually associated with the screen).

Larger programs may need additional streams. These streams often represent
files stored on various media (such as hard drives, CDs, DVDs, and flash memory),
but they could just as easily be associated with devices that don’t store files: net-
work ports, printers, and the like. We'll concentrate on files, since they’re common
and easy to understand. (I may even occasionally use the term file when 1 should
say stream.) Keep in mind, however, that many of the functions in «<stdio.h>
work equally well with all streams, not just the ones that represent files.

File Pointers

Accessing a stream in a C program is done through a file pointer, which has type
FILE * (the FILE type is declared in <stdio.h=>). Certain streams are repre-
sented by file pointers with standard names; we can declare additional file pointers
as needed. For example, if a program needs two streams in addition to the standard
ones, it might contain the following declaration:

FILE *fpl, *fp2;

A program may declare any number of FILE * variables, although operating sys-
tems usually limit the number of streams that can be open at one time.

Standard Streams and Redirection

<stdio.h> provides three standard streams (Table 22.1). These streams are
ready to use—we don’t declare them, and we don’t open or close them.
Table 22.1
Standard Streams

22,1 Streams 541

File Pointer Stream  Default Meaning
stdin Standard input Keyboard
stdout Standard output Screen
stderr Standard error Screen

The functions that we've used in previous chapters—printf, scanf,
putchar, getchar, puts, and get s—obtain input from stdin and send out-
put to stdout. By default, stdin represents the keyboard; stdout and
stderr represent the screen. However, many operating systems allow (hese
default meanings to be changed via a mechanism known as redirection.

Typically, we can force a program to obtain its input from a file instead of
from the keyboard by putting the name of the file on the command line. preceded
by the < character:

demo <in.dat

This technique, known as input redirection. essentially makes the stdin stream
represent a file (in . dat. in this case) instead of the keyboard, The beauty of redi-
rection is that the demo program doesn’t realize that it's reading [rom in.dat; as
far as it knows, any data it obtains from stdin is being entered at the keyboard.

Output redirection is similar. Redirecting the s=dout stream is usually done
by putting a file name on the command line, preceded by the > character:

demo >out.dat

All data written to stdout will now 20 into the out . dat file instead of appear-
ing on the screen. Incidentally, we can combine output redirection with input redi-
rection:

demo <in.dat sout.dat

The < and > characters don’t have to be adjacent to file names, and the order in
which the redirected files are listed doesn’t matter, so the following examples
would work just as well:

demo < in.dat > out.dat
demo sout.dat <in.dat

One problem with output redirection is that everything wrilten to stdout is
put into a file. If the program goes off the rails and begins writing error messages.
we won't see them until we look at the file. This is where stderr comes in. By
writing error messages to stderr instead of stdout, we can guarantee that
those messages will appear on the screen even when stdout has been redirceted.
(Operating systems ofien allow stderr itself to be redirected, though.)

Text Files versus Binary Files

<stdio.h> supports two Kinds of files: text and binary. The bytes in a text file
represent characters, making it possible for a human (o examine the file or edit it.
542

Chapter 22

llle-sdian order »20.3

Input/Output

The source code for a C program is stored in a text file, for example. In a binary
file, on the other hand, bytes don’t necessarily represent characters; groups of
bytes might represent other types of data, such as integers and floating-point num-
bers, An executable C program is stored in a binary file, as you'll quickly realize if
you try to look at the contents of one.

Text files have two characteristics that binary files don’t possess:

m Texi files are divided into lines. Each line in a text file normally ends with
one or two special characters; the choice of characters depends on the operat-
ing system. In Windows, the end-of-line marker is a carriage-return character
('\x0d') followed immediately by a line-feed character ('\x0a'). In
UNIX and newer versions of the Macintosh operating system (Mac OS), the
end-of-line marker is a single line-feed character. Older versions of Mac OS
use a single carriage-return character.

m Text files may contain a special “end-of-file” marker. Some operating sys-
tems allow a special byte to be used as a marker at the end of a text file. In
Windows, the marker is ' \x1a' (Ctr]-Z), There's no requirement that Ctrl-Z
be present, but if it is, it marks the end of the file; any bytes after Ctrl-Z are to
be ignored. The Ctrl-Z convention is a holdover from DQS, which in turn
inherited it from CP/M, an early operating system for personal computers.
Most other operating systems, including UNIX, have no special end-of-file
character.

Binary files aren’t divided into lines. In a binary file, there are no end-of-line or
end-of-file markers; all bytes are treated equally.

When we write data to a file, we'll need to consider whether to store it in text
form or in binary form. To see the difference, consider how we might store the
number 32767 in a file. One option would be to write the number in text form as
the characters 3, 2, 7, 6, and 7. If the character set is ASCII, we'd have the follow-
ing five bytes:

|

| 00110111 | 00

110 | 00120111

D D

The other option is to store the number in binary, which would take as few as two
bytes:

(The bytes will be reversed on systems that store data in little-endian order.) As
this example shows, storing numbers in binary can often save quite a bit of
space.

When we're writing a program that reads from a file or writes to a file, we
need to take into account whether it's a text file or a binary file. A program that dis-
plays the contents of a file on the screen will probably assume it’s a text file. A file-
22.2

fopen

restrict keyword > 176

A

escape sequences >7.3

22.2 File Operations 543

copying program, on the other hand, can’t assume that the file to be copied is a text
file. If it does, binary files containing an end-of-file character won't be copied
completely. When we can’t say for sure whether a file is text or binary, it's safer to
assume that it’s binary.

File Operations

Simplicity is one of the attractions of input and output redirection; there's no need
to open a file, close a file, or perform any other explicit file operations. Unfortu-
nately, redirection is too limited for many applications. When a program relies on
redirection, it has no control over its files; it doesn’t even know their names. Worse
still, redirection doesn’t help if the program needs to read from two files or write to
two files at the same time

When redirection isn’t enough, we'll end up using the file operations that
<stdio.h> provides. In this section, we'll explore these operations, which
include opening a file, closing a file, changing the way a file is buffered, deleting a
file, and renaming a file.

Opening a File

FILE *fopen(const char * restrict filename,
const char * restrict mode) ;

Opening a file for use as a stream requires a call of the fopen function. fopen’s
first argument is a string containing the name of the file to be opened. (A “file
name” may include information about the file’s location, such as a drive specifier
or path.) The second argument is a “mode string” that specifies what operations we
intend to perform on the file. The string "x ", for instance, indicates that data will
be read from the file, but none will be written to it.

Note that restrict appears twice in the prototype for the fopen function.
restrict, which is a C99 keyword, indicates that f1lename and mode should
point to strings that don’t share memory locations. The C89 prototype for fopen
doesn’t contain restrict but is otherwise identical. restrict has no effect
on the behavior of fopen, 5o it can usually just be ignored. In this and subsequent
chapters, I'll italicize restrict as a reminder that it’s a C9Y feature.

Windows programmers: Be careful when the file name in a call of fopen includes
the \ character, since C treats \ as the beginning of an escape sequence. The call

fopen ("c:\project\testl.dat", "rt)

will fail, because the compiler treats \t as a character escape. (\p isn’t a valid
character escape, but it looks like one. The C standard states that its meaning is
544

Chapter 22

Table 22.2
Maode Strings
for Text Files

QaA

Input/Output
undefined.) There are two ways to avoid the problem. One is to use \ \ instead of
N
fopen (“c:\\project\\testl.dat", "r")
The other technique is even easier—just use the / character instead of \:
fopen("c:/project/testl.dat", "r")

Windows will happily accept / instead of \ as the directory separator.

fopen returns a file pointer that the program can (and usually will) save in a
variable and use later whenever it needs to perform an operation on the file. Here's
a typical call of fopen, where fp is a variable of type FILE *:

fp = fopen("in.dat", "z"l; /* opens in.dat for reading */

When the program calls an input function to read from in.dat later, it will sup-
ply fp as an argument.

When it can’t open a file, fopen returns a null pointer. Perhaps the file
doesn’t exist, or it’s in the wrong place, or we don't have permission to open it.

Never assume that a file can be opened: always test the return value of fopen to
make sure it's not a null pointer.

Modes

‘Which mode string we'll pass to fopen depends not only on what operations we
plan to perform on the file later but also on whether the file contains text or binary
data. To open a text file, we'd use one of the mode strings in Table 22.2.

String Meaning [
"t Open for reading
"w'  Open for writing (file need not exist)

"at  Open for appending (file need not exist)

| "r+"  Open for reading and writing, starting at beginning
"w+"  Open for reading and writing (truncate if file exists)
"a+t  Open for reading and w append if file exists)

When we use fopen to apen a binary file, we'll need to include the letter b in
the mode string. Table 22.3 lists mode strings for binary files.

From Tables 22.2 and 22.3, we see that <stdio.h> distinguishes between
writing data and appending data. When data is written to a file, it normally over-
writes what was previously there. When a file is opened for appending, however,
data written to the file is added at the end, thus preserving the file’s original contents.

By the way, special rules apply when a file is opened for both reading and writ-
ing (the mode string contains the + character). We can’t switch from reading to writ-
Table 22.3
Mode Strings for
Binary Files

file-positioning funclions »22.7

fclose

222 File Operations 545

String Meaning

nrhE Open for reading

"wb" Open for writing (file need not exist)
"ab" Open for appending (file need not exist)

"r+b""or "rb+"  Open for reading and writing, starting at beginning
"w+b" or "wb+"  Open for reading and writing (truncate if file exists)
"a+b" or "ab+"  Open for reading and writing (append if file exists)

ing without first calling a file-positioning function unless the reading operation
encountered the end of the file. Also, we can’t switch from writing to reading with-
out either calling ff1ush (covered later in this section) or calling a file-positioning
function.

Closing a File

int fcloge (FILE *stream);

The fclose function allows a program to close a file that it’s no longer using.
‘The argument to fclose must be a file pointer obtained from a call of fopen or
freopen (discussed later in this section). fclose returns zero if the file was
closed successfully; otherwise, it returns the error code EOF (a macto defined in
<stdio.hs).

To show how fopen and fclose are used in practice, here’s the outline of a
program that opens the file example . dat for reading, checks that it was opened
successfully, then closes it before terminating:

#include <stdioc.h>
#include <stdlib.h>

#define FILE NAME "example.dat!
int main(void)
FILE *fp;
fo = fopen(FILE NAME, "x"];
if (fp == NULL) {
printf("Can't open ¥s\n", FILE NAME);

exit (EXIT FAILURE) ;

)

tclose (tp) ;
return 0;

}

Of course, C programmers being the way they are, it’s not unusual to see the call of
fopen combined with the declaration of fp:

FILE *fp = fopen(FILE_NAME, "r");
548

Chapter 22

freopen

Input/Output

or the test against NULL:

if ((fp = fopen(FILE NAME, "r")) == NULL) ..

Attaching a File to an Open Stream

FILE *freopern(const char * restrict filename,
const char * restrict mode,
FILE * restrict stream);

frecpen attaches a different file 1o a stream thar's already open. The most com-
mon use of freopen is to associate a file with one of the standard streams
(stdin, stdout, or stderr). To cause a program to begin writing to the file
foo, for instance, we could use the following call of freopen:

if (freopen("foo", "w", stdout) == NULL) {
/* error; foo can't be opened */

}

After closing any file previously associated with stdout (by command-line redi-
rection or a previous call of frecpen), freopen will open foo and associate it
with stdout.

frecpen’s normal return value is its third argument (a file pointer). If it can’t
open the new file, freopen returns a null pointer. (Ereopen ignores the error if
the old file can’t be closed.)

C99 adds a new twist, If filename is a null pointer, frecpen attempts to
change the stream’s mode to that specified by the mode parameter. Implementa-
tions aren’t required to support this feature, however: if they do, they may place
restrictions on which mode changes are permitted.

Obtaining File Names from the Command Line

When we’re writing a program that will need to open a file, one problem soon
becomes apparent: how do we supply the file name to the program? Building file
names into the program itself doesn’t provide much flexibility, and prompting the
user to enter file names can be awkward. Often, the best solution is to have the pro-
gram obtain file names from the command line. When we execute a program
named demo, for example, we might supply it with file names by putting them on
the command line:

demo names.dat dates.dat

In Section 13.7, we saw how to access command-line arguments by defining
main as a function with two parameters:

int main(int argc, char *argv(])
PROGRAM

canopen.c

22.2 File Operations 547

arge is the number of command-line arguments; argyv is an array of pointers to
the argument strings. argv (0] points to the program name, argv [1] through
argv [arge-1] point to the remaining arguments, and argv [argc] is a null
pointer. In the example above, arge is 3, argv [0] points (o a string containing
the program name, argv [1] points to the string "names .dat ", and argv [2]
points to the string "dates.dat":

Checking Whether a File Can Be Opened

The following program determines if a file exists and can be opened for reading.
‘When the program is run, the user will give it a file name to check:

canopen file

The program will then print either file can be opened or file can't be
opened. If the user enters the wrong number of arguments on the command line,
the program will print the message usage : canopen filename to remind the
user (hat canopen requires a single file name.

/* Checks whether a file can be opened for reading */

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv(])
FILE *fp;

if (arge I= 2) {
printf ("usage: canopen filename\n');
exit (EXIT_FAILURE) ;

if ((fp = fopen(argv[ll, "r")) == NULL) {
printf("$s can't be opened\n", argv(i]);
exit (EXIT_FAILURE) ;

printf("$s can be opened\n", argv(1]);
felose (fp) ;
return 0;
548

Chapter 22  Input/Output

tmpfile

tmpnam

Note that we can use redirection to discard the output of canopen and simply test
the status value it returns.

Temporary Files

FTTR *tmpfile(void);
char *tmpnam(char *s);

Real-world programs often need to create temporary files—files that exist only as
long as the program is running. C compilers, for instance, often create temporary
files. A compiler might first translate a C program to some intermediate form,
which it stores in a file. The compiler would then read the file later as it translates
the program to object code. Once the program is completely compiled, there’s no
need to preserve the file containing the program’s intermediate form. <stdio.h>
provides two functions, tmpfile and tmpnam, for working with temporary files.

tmpfile creates a temporary file (opened in "wb+" mode) that will exist
until it’s closed or the program ends. A call of tmpfile returns a file pointer that
can be used to access the file later:

FILE *tempptr;

tempptr = tmpfile(); /* creates a temporary file */

If it fails to create a file, tmpfile returns a null pointer.

Although tmpfile is easy to use, it has a couple of drawbacks: (1) we don’t
know the name of the file that tmpfile creates, and (2) we can’t decide later to
make the file permanent. If these restrictions turn out to be a problem, the alterna-
tive is to create a temporary file using fopen. Of course, we don’t want this file to
have the same name as a previously existing file. so we need some way to generate
new file names: that’s where the tmpnam function comes in.

tmpnam generates a name for a temporary file. If its argument is a null
pointer, tmpnam stores the file name in a static variable and returns a pointer to it:

char *filename;

filename = tmpnam(NULL); /* creates a temporary file name %/

Otherwise, tmpnam copies the file name into a character array provided by the
programmer:

char filename [L tmpnam] ;
tmpnam (filename) ; /* creates a temporary file name */

In the latter case, tmpnam also returns a pointer to the first character of this array.
L_tmpnam is a macro in <stdio.h> that specifies how long to make a character
array that will hold a temporary file name.
filush

QaA

222 File Operations 549

Be sure that tmpnam’s argument points to an array of at least _tmpnam charac-
ters. Also, be careful not to call tmpnam too often; the TMP_MAX macro (defined
in <stdio.hs) specifies the maximum number of temporary file names that can
potentially be generated by tmpnam during the execution of a program. If it fails
to generate a file name, tmpnam returns a null pointer.

File Buffering

int fflush(FILE *stream) ;

void setbuf (FILE * restrict stream,
char * restrict buf);

int setvbuf (FILE * restrict stream,
char * restrict buf,
int wode, size t sizej;

Transferring data to or from a disk drive is a relatively slow operation. As a result,
it isn’t feasible for a program to access a disk file directly each time it wants to
read or write a byte. The secret to achieving acceptable performance is buffering:
data written to a stream is actually stored in a buffer area in memory; when it’s full
(or the stream is closed), the buffer is “flushed” (written to the actual output
device). Input streams can be buffered in a similar way: the buffer contains data
from the input device; input is read from this buffer instead of the device itself.
Buffering can result in enormous gains in efficiency, since reading a byte from a
buffer or storing a byte in a buffer takes hardly any time at all. Of course, it takes
time to transfer the buffer contents to or from disk, but one large “block move" is
much faster than many tiny byte moves.

The functions in <stdio.h> perform buffering automatically when it seems
advantageous. The buffering takes place behind the scenes, and we usually don’t
worry about it. On rare occasions, though, we may need to take a more active role.
If so, we can use the functions f f1ush, setbuf, and setvbuf,

When a program writes output to a file, the data normally goes into a buffer
first. The buffer is flushed automatically when it's full or the file is closed. By call-
ing f f1ush, however, a program can flush a file's buffer as often as it wishes. The
call

fflush(fp) ; /* flushes buffer for fp */
flushes the buffer for the file associated with fp. The call
ff1lush (NULL) ; /* flushes all buffers */

flushes all output streams. f f 1ush returns zero if it's successful and ZOF if an
SITOr 0CCUTS.
550 Chapter 22

setvbuf

setbuf

Input/Output

setvbuf allows us to change the way a stream is buffered and to control the
size and location of the buffer. The function’s third argument, which specifies the
kind of buffering desired, should be one of the following macros:

= _IOFBF (full buffering). Data is read from the stream when the buffer is
empty or written to the stream when it’s full.

= _TOLBF (line buffering). Data is read from the stream or written to the stream
one line at a time.

= IONBF (no buffering). Data is read from the stream or written to the stream
directly, without a buffer.

(All three macros are defined in <stdio.h>.) Full buffering is the default for
streams that aren’t connected (o interactive devices.

setvbuf’s second argument (if it's not a null pointer) is the address of the
desired buffer. The buffer might have static storage duration, automatic storage
duration, or even be allocated dynamically. Making the buffer automatic allows its
space to be reclaimed automatically at block exit: allocating it dynamically enables
us to free the buffer when it’s no longer needed. setvbuf’s last argument is the
number of bytes in the buffer. A larger buffer may give better performance; a
smaller buffer saves space.

For example, the following call of setvbuf changes the buffering of
streamto full buffering. using the N bytes in the buf fer array as the buffer:

char buffer[N];

setvbuf (stream, buffer, IOFBF, N);

setvbuf must be called after stream is opened but before any other operations
are performed on it.

It’s also legal to call getvbuf with a null pointer as the second argument,
which requests that setvbuf create a buffer with the specified size. setvbuf
returns zero if it's successful. It returns a nonzero value if the mode argument is
invalid or the request can’t be honored.

setbuf is an older function that assumes default values for the buffering
mode and buffer size. If buf is a null pointer, the call setbuf (stream, buf)
is equivalent to

(void) setvbuf (stream, NULL, _TONBF, 0);
Otherwise, it's equivalent to
(void) setvbuf (stream, buf, IOFBF, BUFSIZ);

where BUFSIZ is a macro defined in <stdio.h>. The setbuf function is con-
sidered obsolete; it’s not recommended for use in new programs.
remove

rename

223

22.3 Formatted I/O 551

When using setvbuf or setbuf, be sure to close the stream before its buffer is
deallocated. In particular, if the buffer is local to a function and has automatic stor-
age duration, be sure to close the stream before the function returns.

Miscellaneous File Operations

int remove (const char *filename);
int rename(const char *old, const char *new);

The functions remove and rename allow a program to perform basic file man-
agement operations. Unlike most other functions in this section, remeve and
rename work with file names instead of file pointers. Both functions return zero
if they succeed and a nonzero value if they fail.

remove deletes a file:

remove ("fool) ; /* deletes the file named "foo! */

If a program uses fopen (instead of tmpfile) to create a temporary file, it can
use remove to delete the file before the program terminates. Be sure that the file
to be removed has been closed: the effect of removing a file that's currently open is
implementation-defined.

rename changes the name of a file:

rename ("foo", "bar"); /* renames "foo" to "bar" */

rename is handy for renaming a temporary file created using fopen if a program
should decide to make it permanent. If a file with the new name already exists, the
effect is implementation-defined.

If the file to be renamed is open, be sure to close it before calling rename: the
function may fail if asked to rename an open file.

Formatted I/O

In this section, we’ll examine library functions that use format strings to control
reading and writing. These functions, which include our old friends printf and
scant, have the ability to convert data from character form to numeric form dur-
ing input and from numeric form to character form during output. None of the
other 1/0 functions can do such conversions.

552

Chapter 22

fprintf
printf

ellipsis »25.1

v..printE functions >26.1

Input/Output
The ..printf Functions

int fprintf (FILE * restrict stream,
const char * restrict format, =)
int printf (const char * restrict format, ...};

The fprintf and printf functions write a variable number of data items
to an output stream, using a format string to control the appearance of the output.
The prototypes for both functions end with the . .. symbol (an ellipsis), which
indicates a variable number of additional arguments. Both functions return the
number of characters written: a negative return value indicates that an error
oceurred,

The only difference between printf and fprintf is that printf always
writes to stdout (the standard output stream), whereas fprintf writes to the
stream indicated by its first argument:

printf ("Total: %d\n", total); /* writes to stdout */
fprintf (fp, "Total: %d\n", total); /* writes to fp */

A call of printf is equivalent to a call of fprintf with stdout as the first
argument.

Don’t think of fprintf as merely a function that writes data to disk files,
though. Like many functions in <stdio.hs, fprintf works fine with any out-
put stream. In fact, onc of the most common uses of Lprintf—writing error
messages to stderr, the standard error stream—has nothing to do with disk files.
Here's what such a call might look like:

fprintf (stderr, "Error: data file can't be opened.\n");

Writing the message to stderr guarantees that it will appear on the screen even
if the user redirects stdout.

There are two other functions in <stdio.h> that can write formatted output
to a stream. These functions, named vfprintf and vprintf, are fairly
obscure. Both rely on the va 1ist type, which is declared in <stdarg.h>, so
they’re discussed along with that header.

..printf Conversion Specifications

Both printf and fprintf require a format string containing ordinary charac-
ters and/or conversion specifications. Ordinary characters are printed as is; conver-
sion specifications describe how the remaining arguments are to be converted to
character form for display. Section 3.1 described conversion specifications briefly,
and we added more details in later chapters. We'll now review what we know
about conversion specifications and fill in the remaining gaps.

A ..printf conversion specification consists of the % character, followed by
as many as five distinct items:
Table 22.4
Flags for .printf
Functions

22.3 Formatted /O 553

conversion
flags precision  specifier
v
[s[#0]12].5]L]g
T
1
minimum lens

field width modifier
Here's a detailed description of these items, which must appear in the order shown:

= Flags (optional; more than one permitted). The - flag causes left justification
within a field: the other flags affect the way numbers are displayed. Table 22.4
gives a complete list of flags.

Flag ~ Meaning |
- Left-justify within field. (The default is right justification.)
+ Numbers produced by signed conversions always begin with + or -. (Normally,

only negative numbers are preceded by a sign.)

space  Nonnegative numbers produced by signed conversions are preceded hy a space.
(The + flag overrides the space flag.)

# Octal numbers begin with 0. nonzero hexadecimal numbers with 0x or 0X.
Floating-point numbers always have a decimal point. Trailing zeros aren’t
removed from numbers printed with the g or G conversions.

0 Numbers are padded with leading zeros up to the field width. The 0 flag is

(zero)  ignored if the conversion is d, i, 0. u, x, or X and a precision is specified. (The

- flag overrides the 0 flag)

= Minimum field width (optional). An item that's too small to occupy this num-
ber of characters will be padded. (By default, spaces are added to the left of
the item, thus right-justifying it within the field.) An item that’s too large for
the field width will still be displayed in its entirety. The field width is either an
integer or the character *. If * is present, the field width is obtained from the
next argument. If this argument is negative, it's treated as a positive number
preceded by a - flag.

= Precision (optional). The meaning of the precision depends on the conversion:

d, i, 0. u, x, X: minimum number of digits
(leading zeros are added if the number has fewer digits)
a. A, e, E, f, F: number of digits after the decimal point
g, Gt number of significant digits
5 maximum number of bytes

The precision is a period (. ) followed by an integer or the character *. Tf * is
present, the precision is obtained from the next argument. (If this argument is
negative, the effect is the same as not specifying a precision.) If only the
period is present, the precision is Zero,
554 Chapter 22 Input/Output

Table 22.5
Length Modifiers for
~.printf Functions

default argumen promotions »9.3

u Length modifier (optional). The presence of a length modifier indicates that
the item to be displayed has a type that’s longer or shorter than is normal for a
particular conversion specification. (For example, %d normally refers to an
int value; $hd is used to display a short int and %1d is used to display a
long int.) Table 22.5 lists each length modifier, the conversion specifiers
with which it may be used, and the type indicated by the combination of the
two. (Any combination of length modifier and conversion specifier not shown
in the table causes undefined behavior.)

Lengti
Modifier  Conversion Specifiers Meaning |
hh' d,i,0,u,%x X signed char, unsigned char
n signed char *
h di.ouxX short int,unsigned short int
n Ty short int * |
1 diouxX Long int. unsigned long int |
(ell) i long int * |
c g wint_t |
s wchar t* i |
no effect o iy |
e long long int, unsigned long long int |
(ell-ell) long long int * |
Il di,0,u%% intmax_t,uintmax_t
n intmax_t *
=zt d,i,0,u,x%X size t
n size t* |
e d i,0.ux% ptrdiff t = i
n ptrdiff c*
L  aheEfFaG longdouble e
799 only

w Conversion specifier. The conversion specifier must be one of the characters
listed in Table 22.6. Notice that f, F, e, E, g, G, a, and A are all designed to
write double values. However, they work fine with float values as well;
thanks to the default argument promotions, float arguments are converted
automatically to double when passed to a function with a variable number of
arguments. Similarly, a character passed to ..printf is converted automati-
cally to int, so the c conversion works properly.

Be careful to follow the rules described here: the effect of using an invalid conver-
sion specification is undefined.

22.3 Formatted I/O 555

Table 22.6 Conversion
Conversion Specifiers for Specifier Meaning

~printf Functions 4,1 Converts an int value to decimal form.

o,u,x X Converts an unsigned int value to base 8 (o), base 10 (u), or base 16
(x, X). x displays the hexadecimal digits a—f in lower case: X displays
them in upper case.

f5F Converts a double value to decimal form, putting the decimal point in
the correct position. If no precision is specified, displz digits after
the decimal point.

e B Converts a double value to scientific notation. If no precision is speci-
fied, displays six digits after the decimal point. If e is chosen, the expo-
nent is preceded by the letter & if B is chosen, the exponent is preceded
by E.

9.6 g converts a double value to either f form or e form, e form is selected
if the number’s exponent is less than —4 or greater than or equal to the
precision. Trailing zeros are not displayed (unless the # flag is used); a
decimal point appears only when followed by a digit. G chooses between
Fand E forms.

a', A Converts a double value to hexadecimal scientific notation using the
form [~10xh . hkhlip=d, where [-] is an optional minus sign, the A’s rep-
resent hex digits, + is either a plus or minus sign, and  is the exponent.
is a decimal number that represents a power of 2. If no precision is speci-
fied. enough digits arc displayed after the decimal point to represent the
exact value of the number (if possible). a displays the hex digits a2—f in
lower case: & displays them in upper case. The choice of a or A also
affects the case of the letters x and p.

Displays an int value as an unsigned character.

Writes the characters pointed to by the argument. Stops writing when the
number of bytes specified by the precision (if present) is reached or a null
character is encountered.

Converts 2 void * value to printable form.

n ‘The corresponding argument must point to an object of type int. Stores
in this object the number of characters written so far by this call of
...printf; produces no output.

¥ Writes the character %.
99 only

o

@ (99 Changes to ..printf Conversion Specifications

The conversion specifications for printf and fprintf have undergone a num-
ber of changes in C99:

u Additional length modifiers. C99 adds the hh, 11, j, z, and t length modifi-

ers. hhand 11 provide additional length options, j allows greatest-width inte-

greatestwidih integers »27.1 gers to be written, and z and t make it easier to write values of type size t
and pcrdiff_t, respectively.
556 Chapter 22

IEEE floating-point standard »23.4

wide charzcters »25.2

Table 22.7
Effect of Flags on
the %d Conversion

Input/Output

w Additional conversion specifiers. C99 adds the F, a, and A conversion specifi-
ers. F is the same as f except for the way in which infinity and NaN (see
below) are written, The a and A conversion specifications are rarely used.
They re related to hexadecimal floating constants, which are discussed in the
Q&A section at the end of Chapter 7.

w Ability to write infinity and NaN. The IEEE 754 floating-point standard
allows the result of a floating-point operation to be infinity, negative infinity,
or NaN (“not a number”). For example, dividing 1.0 by 0.0 yields positive
infinity, dividing —1.0 by 0.0 yields negative infinity, and dividing 0.0 by 0.0
yields NaN (because the result is mathematically undefined). In C99, the a, A,
c, E, f. F, g, and G conversion specifiers are capable of converting these spe-
cial values to a form that can be displayed. a, e. f, and g convert positive
infinity to inf or infinity (either one is legal), negative infinity to -inf
or -infinity, and NaN to nan or -nan (possibly followed by a series of
characters enclosed in parentheses). A, E, F, and G are equivalent to a, e, f,
and g, except that upper-case letters are used (INF, INFINITY, NAN).

u Support for wide characters. Another C99 feature is the ability of fprintf
to write wide characters. The $1c conversion specification is used to write a
single wide character; $1s is used for a string of wide characters.

u Previously undefined conversion specifications now allowed. In C89, the
effect of using %1e, %1E, $1f, $1g, and $1G is undefined. These conversion
specifications are legal in C99 (the 1 length madifier is simply ignored)

Examples of ..printf Conversion Specifications

Whew! It’s about time for a few examples. We've seen plenty of everyday conver-
sion specifications in previous chapters, so we’ll concentrate here on illustrating
some of the more advanced ones. As in previous chapters, I'll use e to represent
the space character.

Let’s start off by examining the effect of flags on the $d conversion (they have

a similar effect on other conversions). The first line of Table 22.7 shows the effect
of $8d without any flags. The next four lines show the effect of the -, +, space,
and 0 flags (the 4 flag is never used with %d). The remaining lines show the effect
of combinations of flags.

Conversion  Result of Applying  Result of Applying
Specification  Conversion to 123 Conversion to —123

%¥8d seene |23

%-8d 123eesce

¥+8d . +123

% 8d . 123

%08d 00000123 -0000123
¥-+8d +123eese ~123eess
¥- 8d *123esee ~123eees
%+08d +0000123 -0000123

% 08d *0000123 -0000123

Table 22.8
Effect of the # Flag

Table 22.9

Effect of Minimum Field
Width and Precision on
the 5 Conversion

Table 22.10
Examples of the
%g Conversion

22.3 Formatted IO

557

Table 22.8 shows the effect of the # flag on the o. %, X, g. and G conversions.

Conversion  Result of Applying  Result of Applying
Specification  Conversion to 123 Conyersion to 123.0
%80
%k80
28x
FHex
28X
FHBX *ee0(X7B
%89 esseel2]
%#Bg =123.000
%BG . *123
$#8G ®123.000

In previous chapters, we've used the minimum ficld width and precision
when displaying numbers, so there’s no point in more examples here. Instead,
Table 22.9 shows the effect of the minimum field width and precision on the %s

conversion.
Result of Applying ~ Result of Applying
Conversion Conversion to Conversion to
Specification "bogus" "buzzword"
%68 sbogus buzzword
$-6s boguse buzzword
%.48 bogu buzz
$6.45 s sbogu esbuzz
%-6.4s boguee buzzee

Table 22.10 illustrates how the %g conversion displays some numbers in &
form and others in % f form. All numbers in the table were written using the % . 4g
conversion specification. The first two numbers have exponents of at least 4, so
they're displayed in %e form. The next eight numbers are displayed in 3f form.
The last two numbers have exponents less than —4, so they’re displayed in %e

form.
Result of Applying % . 49
Number Conversion to Number
123456. 1.235e+05
12345.6 1.235e+04
1234.56 1235
123.456 123.5
12.3456 12.35
1.23456 1.235
123456 0.1235
10123456 0.01235
0.001235
-000123456 0.0001235
.0000123456 1.235e-05
00000123456 1.235e-06

558

Chapter 22

fscanf
scanf

Input/Output

In the past, we've assumed that the minimum field width and precision were
constants embedded in the format string. Putting the * character where either num-
ber would normally go allows us to specify it as an argument after the format
string, For example, the following calls of printf all produce the same output:

printf ("%6.4d", i);
printf("s*. 4ar, 6, i);
printf("¥6.xan, 4, 1);
printE(nie . 2d%,.6,.9, 1 ;

Notice that the values to be filled in for the * come just before the value to be dis-
played. A major advantage of *, by the way, is that it allows us to use a macro to
specify the width or precision:

printf ("$*d", WIDIH, i);
We can even compute the width or precision during program execution:
printf ("$*d", page width / num_cols, i);

‘The most unusual specifications are $p and %n. The %p conversion allows us
to print the value of a pointer:

printf("3p", (void #) ptr); /* displays value of ptr */

Although %p is occasionally useful during debugging, it’s not a feature that most
programmers use on a daily basis. The C standard doesn’t specify what a pointer
looks like when printed using %p, but it's likely to be shown as an octal or hexa-
decimal number.

The %n conversion is used to find out how many characters have been printed
5o far by a call of ..printf. For example, after the call

printf ("$d%n\n", 123, &len);

the value of 1en will be 3, since printf had written 3 characters (123) by the
time it reached %n. Notice that & must precede len (because %n requires a
pointer) and that 1en itself isn't printed.

The ..scanf Functions

int fscanf(FILE * restrict stream,
const char * restrict format, ...);
int scanf(const char * restrict format, ...):

fscanf and scanf read data items from an input stream, using a format string to
indicate the layout of the input. After the format string, any number of pointers—
each pointing to an object—follow as additional arguments. Input items are con-
verted (according to conversion specifications in the format string) and stored in
these objects.
@D

multioyte characters »25.2

idiom

white-space characters »3.2

223 Formatted /O 559

scanf always reads from stdin (the standard input stream), whereas
fscanf reads from the stream indicated by its first argument:

scanf ("3d%d", &i, &j); /* reads from stdin */
fscanf (fp, "$d%d", &i, &3); /* reads from fp */

A call of scanf is equivalent to a call of fscanf with stdin as the first argu-
ment.

The ..scanf functions return prematurely if an input failure occurs (no more
input characters could be read) or if a matching failure occurs (the input charac-
ters didn’t match the format string). (In C99, an input failure can also occur
because of an encoding error; which means that an attempt was made to read a
multibyte character, but the input characters didn’t correspond to any valid multi-
byte character.) Both functions return the number of data items that were read and
assigned to objects; they return EOF if an input failure occurs before any data items
can be read.

Loops that test scanf s return value are common in C programs. The follow-
ing loop, for example, reads a series of integers one by one, stopping at the first
sign of trouble:

while (scanf("%d", &i) == 1) (

e

..scanf Format Strings

Calls of the ..scanf functions resemble those of the ..printf functions. That
similarity can be misleading, however; the ..scanf functions work quite differ-
ently from the ..printf functions. It pays to think of scanf and fscanf as
“pattern-matching” functions. The format string represents a pattern that a
..scanf function attempts to match as it reads input. If the input doesn’t match
the format string. the function returns as soon as it detects the mismatch; the input
character that didn’t match is *‘pushed back” to be read in the future.
A ..scanf format string may contain three things:

w Conversion specifications. Conversion specifications in a ..scanf format
string resemble those in a ..print f format string. Most conversion specifica-
tions skip white-space characters at the beginning of an input item (the excep-
tions are % [, %c, and $n). Conversion specifications never skip trailing white-
space characters, however, If the input contains 1239, the %d conversion
specification consumes o, 1, 2, and 3, but leaves @ unread. (I'm using e to
represent the space character and o to represent the new-line character.)

u White-space characters. One or more consecutive white-space characters in a
..scant format string match zero or more white-space characters in the input
stream.

u Non-white-space characters. A non-white-space characterother than % matches
the same character in the input stream.
560 Chapter 22

Table 22.11
Length Modifiers for
scanf Functions

Input/Output

For example, the format string "ISBN %d-%d-%1d-%d" specifies that the
input will consist of:

the letters ISBN

possibly some white-space characters

an integer

the - character

an integer (possibly preceded by white-space characters)

the - character

a long integer (possibly preceded by white-space characters)

the - character

an integer (possibly preceded by white-space characters)

..scanf Conversion Specifications

Conversion specifications for ..scanf functions are actually a little simpler than
those for..printf functions. A .scanf conversion specification consists of the
character % followed by the items listed below (in the order shown).

m * (optional). The presence of * signifies assignment suppression: an input
item is read but not assigned to an object. Items matched using * aren't
included in the count that ..scanf returns.

u Maximum field width (optional). The maximum field width limits the number
of characters in an input item; conversion of the item ends if this number is
reached. White-space characters skipped at the beginning of a conversion
don’t count,

u Length modifier (optional). The presence of a length modifier indicates that the
object in which the input item will be stored has a type that’s longer or shorter
than is normal for a particular conversion specification. Table 22.11 lists each

length modifier, the conversion specifiers with which it may be used, and the
type indicated by the combination of the two. (Any combination of length mod-
ifier and conversion specifier not shown in the table causes undefined behavior.)

Length x
Madifier  Conversion Specifiers Meaning
| m’  diouxxn signed char *,unsigned char *
= = i short int +, unsigned short int * |
1 long int *, unsigned long int *
(el) 5 A E.fFgG double*
Tcos.or [ wehar_t *
AL d,i,0,u,% %0 long long int *,
ell-ell) unsigned long long int *
it diouxXn intmax t* uintmax t *
P d,i,0,u,% %0 Blbe ety
tf  diouxXn DErdiff t *
L aAeE ZFgG longdouble *

99 only
Table 22.12
Conversion Specifiers for
-..scanf Functions

223 Formatted /O 561

u Conversion specifier. The conversion specifier must be one of the characters
listed in Table 22.12.

Conversion |
Specifier Meaning |
d Matches a decimal integer; the corresponding argument is assumed to
have type int *.
i Matches an integer; the corresponding argument is assumed to have type
int *, The integer is assumed (o be in base 10 unless it begins with 0
(indicating octal) or with 0x or 0X (hexadecimal).
o Matches an octal integer; the corresponding argument is assumed to have
type unsigned int =,
u Matches a decimal integer; the corresponding argument is assumed to
have type unsigned int *.
%K Matches u hexadecimal integer: the corresponding argument is assumed

to have type unsigned int *.
a'.al e B, Matches a floating-point number; the corresponding argument is
f,F,g.G  assumed to have type float *. In C99, the number can be infinity or
" NaN,

(< Matches n characters, where n is the maximum field width, or one char-
acter if no field width is specified. The corresponding argument is
assumed to be a pointer to a character array (or a character object, if no
field width is specified). Doesn’t add a null character at the end.

s Matches a sequence of non-white-space characters, then adds a null char-
acter at the end. The corresponding argument is assumed to be a pointer
to a character array.

[ Matches a nonempty sequence of characters from a scanset, then adds a
null character at the end. The corresponding argument is assumed to be a
pointer to a character array.

P Matches a pointer value in the form that ...printf would have written
it. The corresponding argument is assumed to be a pointer to a void *
object.

n The corresponding argument must point 10 an object of type int. Stores

in this object the number of characters read so far hy this call of
...scanf. No input is consumed and the return value of ...scan isn't
affected.

% Matches the character .
099 only

Numeric data items can always begin with a sign (+ or -). The o, u, x, and X
specifiers convert the item to unsigned form, however, so they’re not normally used
to read negative numbers.

The [ specifier is a more complicated (and more flexible) version of the c
specifier. A complete conversion specification using [ has the form % [ser] or
% [“set], where set can be any set of characters. (If ] is one of the characters in
sef, however. it must come first.) % [ser] matches any sequence of characters in ser
(the scanset), % [*ser] matches any sequence of characters nor in ser (in other
words, the scanset consists of all characters not in ser). For example, % [abc]
562 Chapter 22 Input/Ouiput

numeric convarsion functions »26.2

Table 22.13
Correspondence between
-..scanf Conversion
Specifiers and Numeric
Conversion Functions

A

malches any string containing only the letters a, b, and c, while % [*abc]
matches any string that doesn't contain a, b, or .
Many of the ..scanf conversion specifiers are closely related to the numeric
COIWEA‘aiuu [unctions in <stdlib.hs. These functions convert strings (like
"-297") Lo their equivalent numeric values (~297). The d specifier, for example,
looks for an optional + or - sign, followed by a series of decimal digits; this is
exactly the same form that the strczol function requires when asked to convert a
string to a decimal number. Table 22.13 shows the correspondence between con-
version specificrs and numeric conversion functions.

[ Conversion
Specifier Numeric Conversion Function

d streol with 10 as the base
i strtol with 0 as the base
o strtoul with 8 as the base
u strtoul with 10 as the base

x,X strtoul with 16 as the base

a.A e E f,FgG strtod

Tt pays to be careful when wnung calls of scanf. An invalid conversion specifica-
tion in a scanf format string is just as bad as one in a printf format string;
cither one causes undefined behavior.

C99 Changes to ...scanf Conversion Specifications

The conversion specifications for scanf and fscanf have undergone some
changes in C99, but the list isn’t as extensive as it was for the ..orintf functions:

w Additional length modifiers. C99 adds the hh, 11,7, z, and t length modifi-
ers. These correspond to the length modifiers in..printf conversion specifi-
cations.

= Additional conversion specifiers. C99 adds the 7. a, and A conversion specifi-
ers. They're provided for symmetry with ..printf; the ..scanf functions
treat them the same as e, E, f, g, and G.

= Ability to read infinity and NaN. Just as the ..printf functions can write
infinity and NaN, the ..scanf functions can read these values. To be read
properly, they should have the same appearance as values written by the
~printf functions, with case being ignored. (For example, either INF or
inf will be rcad as infinity.)

= Support for wide characters. The ..scanf functions are able to read multi-
byte characters, which are then converted to wide characters for storage. The
%1c conversion specification is used to read a single multibyte character or a
22.3 Formatted /O 563

sequence of multibyte characters; %1s is used to read a string of multibyte
characters (a null character is added at the end). The %1 [ser] and %1 ["ser]
conversion specifications can also read a string of multibyte characters.

scanf Examples

The next three tables contain sample calls of scanf. Each call is applied to the
input characters shown to its right. Characters printed in steikeeut arc consumed
by the call. The values of the variables after the call appear to the right of the in-
put.

The examples in Table 22.14 show the effect of combining conversion specifi-
cations, white-space characters, and non-white-space characters. In three cases no
value is assigned to 5, so it retains its value from before the call of scang. The
examples in Table 22.15 show the effect of assignment suppression and specifying
a field width. The examples in Table 22.16 illustrate the more esoteric conversion
specifiers (1, [, and n).

Table 22.14 scanf Call Input Variables
scant Examples n - scanf("sdsd", &i, &j);  32e,e348 n:l
(Group 1) i:12
5j: unchanged
n = scanf ("%d, %%d", &i, &j); 13e, 8340 n: |
32 12!
5+ unchanged
n = scanf("%d ,%d", &i, &j); 322e;e34n n:2
112
3:34
n = scanf ("%d, %d", &i, &j); 22e,e340 el
1112
j: unchanged
Table 22,15 scant Call Input
scanf Examples n = scanf ("%*dsd", &i); 1oe340

(Group2)

0 = scanf ("%¥s%s", str); MyePaizeLadyd

n = scanf("%1d%2d%3d", e
&i, &3, &k);

n = scanf ("%2d%2s%2d", 1234560
&i, str, &j); 4512

str: 34"
j: 56

564

Chapter 22

Table 22.16
scanf Examples
(Group 3)

clearerr

Input/Output

scanf Call Input Variables
n = scanf ("$i%i%i", &i, &3, &k); 124012803220 n:3
e
Sl
k: 18
n = scanf ("%[0123456789] ", str); 423abcn ni |
gtri"123%
n = scanf ("$[0123456785] ", str); abcl23m n:0
stri
unchanged
n = scanf("%[%0123456789]", str); abel23o n:l
stx: "abc"
n = scanf ("$*d%d%n", &i, &j); 10820300 n:
i:20 |
325

Detecting End-of-File and Error Conditions

void clearerr (FILE *stream);
int feof (FILE *stream);
int ferror (FILE *stream);

If we ask a ..scanf function to read and store n data items, we expect its return
value to be n. If the return value is less than i, something went wrong, There are
three possibilities:

= End-of-file. The function encountered end-of-file before matching the format
string completely.

= Read error. The function was unable to read characters from the stream.

w Maiching failure. A data item was in the wrong format. For example, the
function might have encountered a letter while searching for the first digit of
an integer.

But how can we tell which kind of failure occurred? In many cases, it doesn’t mat-
ter; something went wrong, and we've got to abandon the program. There may be
times, however, when we'1l need to pinpoint the reason for the failure,

Every stream has two indicators associated with it: an error indicator and an
end-of-file indicator. These indicators are cleared when the stream is opened. Not
surprisingly, encountering end-of-file sets the end-of-file indicator, and a read error
sets the error indicator. (The error indicator is also set when a write error occurs on
an output stream.) A matching failure doesn’t change either indicator.

Once the error or end-of-file indicator is set, it remains in that state until it’s
explicitly cleared, perhaps by a call of the c1earerr function. clearerr clears
both the end-of-file and error indicators:

clearerr (fp) ; /* clears eof and errcr indicators for fp */
QaA
feof
ferror

22.3 Formatted /O 565

clearerr isn't needed often, since some of the other library functions clear one
or both indicators as a side effect.

We can call the feof and ferror functions to test a stream’s indicators to
determine why a prior operation on the stream failed. The call feof (fp) returns
a nonzero value if the end-of-file indicator is set for the stream associated with fp.
The call ferror (fp) returns a nonzero value if the error indicator is set. Both
functions return zero otherwise.

When scant returns a smaller-than-expected value, we can use feof and
ferror to determine the reason. If f2of returns a nonzero value, we've reached
the end of the input file. If ferror returns a nonzero value. a read error occurred
during input. If neither returns a nonzero value, a matching failure must have oc-
curred. Regardless of what the problem was, the return value of scanf tells us
how many data items were read before the problem occurred.

To see how feof and ferror might be used, let’s write a function that
searches a file for a line that begins with an integer. Here's how we intend to call
the function:

n = find_int("foo");

"ffoo'" is the name of the file to be searched. The function returns the value of the
integer that it finds, which is then assigned to 1. If a problem arises—the file can’t
be opened, a read error occurs, o no line begins with an integer—find_int will
return an error code (—1, 2, or =3, respectively). I'll assume that no line in the file
begins with a negative integer.

int find_int(const char *filename)

{
FILE *fp = fopen(filename, "r");
int n;

if (fp == NULL)
return -1; /* can't open file */

while (fscanf(fp, "%d", &n) != 1) {
if (ferror(fp)) {
fclose (fp)
return -2; /* read error %/

}
if (feof (fp)) {

fclose (fp) ;
return -3; /* integer not found */
fscanf (fp, "$*["\nl"): /* skips rest of line */
}
fclose (fp) ;
return n;

}

The `while` loop’s controlling expression calls fscanf in an attempt to read an
integer from the file. If the attempt fails (Escanf returns a value other than 1),
566

Chapter 22

224

putchar

fpute
putc

QzA

Input/Output

find_int calls ferror and feof tosee if the problem was a read error or end-
of-file. If not, fscanf must have failed because of a matching crror, so
find_int skips the rest of the characters on the current line and tries again. Note
the use of the conversion %* [*\n] to skip all characters up to the next new-line.
(Now that we know about scansets, it's time to show off!)

Character I/O

In this section, we'll examine library functions that read and write single charac-
ters. These functions work equally well with text streams and binary streams.

You'll notice that the functions in this section treat characters as values of type
int, not char. One reason is that the input functions indicate an end-of-file (or
error) condition by returning EOF, which is a negative integer constant.

Output Functions

int fputc(int e, FILE *stream);
int putec(int o, FILE *stream);
int putchar(int c):

putchar writes one character to the stdout stream:
putchar (ch) ; /* writes ch to stdout */

fputc and putc are more general versions of putchar that write a character (o
an arbitrary stream:

fputc(ch, fp); /* writes ch to fp */
putc(ch, fp);: /* writes ch to fp */

Although putc and fputc do the same thing, putc is usually implemented
as a macro (as well as a function), while fputc is implemented only as a function.
putchar itself is usually a macro defined in the following way:

#define putchar(e) putc((c), stdout)

It may seem odd that the library provides both putec and fputc. But, as we saw
in Section 14.3, macros have several potential problems, The C standard allows the
putc macro to evaluate the stream argument more than once, which fpute
isn’t permitted to do. Although programmers usually prefer pute, which gives a
faster program, fput.c is available as an alternative.

1f a write error occurs, all three functions set the error indicator for the stream
and return EOF; otherwise, they return the character that was written.
getchar

faete
gete

idiom

22,4 Character /O 567
Input Functions

int fgetc(FILE *stream);

int getc (FILE *stream);

int getchar(void) ;

int ungetc(int c, FILE *stream);

getchar reads a character from the stdin stream:
ch = getchar() ; /* reads a character from stdin */
fgete and getc read a character from an arbitrary stream:

ch = fgetc(fp); /* reads a character from fp */
ch = gete(fp) ; /* reads a character from fp */

All three functions treat the character as an unsigned char value (which is then
converted to int type before it’s returned). As a result, they never return a nega-
tive value other than EQF.

The relationship between getc and fgetc is similar (o that between putc
and fputc. getc is usually implemented as a macro (as well as a function),
while tgetc is implemented only as a function, getchar is normally a macro as
well:

#define getchar() getc (stdin)

For reading characters from a file. programmers usually prefer getc over fgetc.
Since getc is normally available in macro form, it tends to be faster. fgetc can
be used as a backup if getc isn’t appropriate. (The standard allows the getc
macro to evaluate its argument more than once, which may be a problem.)

The fgete, gete, and getchar functions behave the same if a problem
occurs. At end-of-file, they set the stream’s end-of-file indicator and return EOF., If
a read error occurs, they set the stream'’s error indicator and return EOF. To differ-
entiate between the two situations, we can call either feof or ferror.

One of the most common uses of fgetc, gete, and getchar is to read
characters from a file, one by one, until end-of-file occurs. It's customary to use the
following `while` loop for that purpose:

while ((ch = getc(fp)) != EOF) {

-

After reading a character from the file associated with fp and storing it in the vari-
able ch (which must be of type int), the while test compares ch with EOF. If
chisn’t equal to EOF, we're not at the end of the file yet, so the body of the loop is
executed. If ch is equal to EQF, the loop terminates.
568 Chapter 22

ungetc

isdigit function »23.5

fle-positioning functions »22.7

PROGRAM

feopy.c

Input/Output

Always store the return value of fgetc, getc, or getchar in an int variable,
not a char variable. Testing a char variable against 2OF may give the wrong
result.

There's one other character input function, ungete, which “pushes back”
a character read from a stream and clears the stream’s end-of-file indicator.
This capability can be handy if we need a “lookahead” character during input.
For instance, to read a series of digits, stopping at the first nondigit, we could
wrile

while (isdigit(ch = getc(fp))) {

j

ungetc(ch, ffp); /* pushes back last character read */

The number of characters that can be pushed back by consccutive calls of
ungetc—with no intervening read operations—depends on the implementation
and the type of stream involved; only the first call is guaranteed to succeed. Calling
a file-positioning function (fseek, fsetpos, or rewind) causes the pushed-
back characters to be lost.

ungete returns the character it was asked to push back. However, it returns
EOF if an attempt is made to push back EOF or to push back more characters than
the implementation allows.

Copying a File

The following program makes a copy of a file. The names of the original file and
the new file will be specified on the command line when the program is executed.
For example, to copy the file f1.c to f2. c, we'd use the command

fcopy fl.c f2.c

feopy will issue an error message if there aren’t exactly two file names on the
command line or if either file can’t be opened.

/* Copies a file */

#include <stdio.h>
#include <stdlib.h>

int main(int arge, char *argv(])

FILE *source_fp, *dest_fp;
int ch;
22,5

puts

225 Line /O 569

if (axge 1= 3) {
fprintf (stderr, "usage: fcopy source dest\n");
exit (EXIT_FATLURE) ;

if ((source fp = fopen(argv([1], "rb")) =- NULL) {
fprintf (stderr, "Can't open %s\n", argv[i]);
exit (EXIT FAILURE);

if ((dest fp = fopen(argv[2], "wb")) == NULL)
fprintf (stderr, "Can't open %s\n", argv(2]);
fclose (source fp);
exit (EXIT FAILURE) ;

while ((ch = gete (source fp)) != EOF)
putc(ch, dest_fp);

fclose (source_fp) ;

fclose (dest fp);
return 0;

Using "rb" and "wb" as the file modes enables fcopy to copy both text and
binary files. If we used "x" and "w" instead, the program wouldn't necessarily be
able to copy binary files.

Line I/O

We'll now turn to library functions that read and write lines. These functions are
used mostly with text streams, although it's legal t0 use them with binary streams
as well.

Output Functions

int fputs(const char * restrict s,
FILE * restrict stream);
int puts(const char *s);

We encountered the puts function in Section 13.3: it writes a string of characters
to stdout:

puts("Hi, there!"); /* writes to stdout */

After it writes the characters in the string, puts always adds a new-line character.
570

Chapter 22

fputs

gets

fgets

Input/Output

fputs is a more general version of puts. Its second argument indicates the
stream to which the output should be written:

fputs ("Hi, there!", fp); /* writes to fp */

Unlike puts, the fputs function doesn’t write a new-line character unless one is
present in the string.

Both functions return EOF if a write error occurs; otherwise, they return a
nonnegative number.

Input Functions

char *fgets(char * restrict s, int n,
FILE * restrict stream);
char *gets(char *s);

The gets function, which we first encountered in Section 13.3, reads a line of
input from stdin:

gets (str) ; /* reads a line from gtdin */

gets reads characters one by one, storing them in the array pointed to by str,
until it reads a new-line character (which it discards).

fgets is a more general version of gets that can read from any stream.
fgets is also safer than gets, since it limits the number of characters that it will
store. Here’s how we might use fgets, assuming that st is the name of a char-
acter array:

fgets(str, sizeof (str), fp); /* reads a line from fp */

This call will cause fgets to read characters until it reaches the first new-line
character or sizeof (str) - 1 characters have been read, whichever happens
first. If it reads the new-line character, fgets stores it along with the other charac-
ters. (Thus, gets never stores the new-line character, but fgets sometimes does.)

Both gets and fgets return a null pointer if a read error occurs or they
reach the end of the input stream before storing any characters. (As usual, we can
call feof or ferror to determine which situation occurred.) Otherwise, both
return their first argument, which points to the array in which the input was stored.
As you'd expect, both functions store a null character at the end of the string.

Now that you know about fgets, I'd suggest using it instead of gets in
most situations. With gets, there’s always the possibility of stepping outside the
bounds of the receiving array, 50 it's safe to use only when the string being read is
guaranieed 10 fit into the array. When there’s no guarantee (and there usually
isn't), it's much safer to use fgets. Note that fgets will read from the standard
input stream if passed stdin as its third argument:

fgets(stz, sizeof (str), stdin);
22.6

QzA
fwrite

fread

22.6 Block /O 571

Block /O

size t fread(void * restrict ptr,
size t size, size_t nmemb,
FILE * restrict stream);

size t furite(const void * restrict ptr,
size_t size, size t nmemb,
FILE * restrict stream);

The fread and fwrite functions allow a program to read and write large
blocks of data in a single step. fread and furite are used primarily with
binary streams, although—with care—it’s possible to use them with text streams
as well.

fwrite is designed to copy an array from memory to a stream. The first
argument in a call of fwrite is the array’s address, the second argument is the
size of each array element (in bytes), and the third argument is the number of ele-
ments to write, The fourth argument is a file pointer, indicating where the data
should be written. To write the entire contents of the array a, for instance, we
could use the following call of fwrite:

fwrite(a, sizeof (a[0]), sizeof(a) / sizeof(al0]), fp);

There’s no rule that we have to write the entire array; we could just as easily
write any portion of it. fwrite returns the number of elements (no1 bytes) actu-
ally written. This number will be less than the third argument if a write error oc-
curs.

fread will read the elements of an array from a stream. fread’s arguments
are similar to fwrite’s: the array’s address, the size of each element (in bytes),
the number of elements to read, and a file pointer. To read the contents of a file into
the array a, we might use the following call of fread:

n = fread(a, sizeof(a[0]), sizeof(a) / sizeof(al0]), fp);:

It’s important to check fread’s return value, which indicates the actual number of
elements (nor bytes) read. This number should equal the third argument unless the
end of the input file was reached or a read error occurred. The feof and ferror
functions can be used to determine the reason for any shortage.

Be careful not to confuse fread’s second and third arguments. Consider the fol-
lowing call of fread:

fread(a, 1, 100, fp)

We're asking fread to read 100 one-byte elements, so it will return a value
572

Chapter 22

22.7

fseek

Input/Qutput
between 0 and 100. The following call asks fread to read one block of 100
bytes:
fread(a, 100, 1, fp)

fread’s return value in this casc will be either 0 or 1.

fwrite is convenient for a program that needs to store data in a file before
terminating. Later, the program (or another program, for that matter) can use
fread to read the data back into memory. Despite appearances, the data doesn't
need to be in array form; fread and fwrite work just as well with variables of
all kinds. Structures, in particular, can be read by fread or written by fwrite.
To write a structure variable s to a file, for instance, we could use the following
call of fwrite:

fwrite(&s, sizeof(s), 1, fp);

Be carcful when using fwri te to write out structures that contain pointer values;
these values aren’t guaranteed to be valid when read back in.

File Positioning

int fgetpos(FILE * restrict stream,
fpos_t * restrict pos);
int fseek(FILE *stream, long int offset, int whencs);
int fsetpos(FILE *stream, const fpos_t *pos) ;
long int ftell(FILE *stream);
void rewind(FILE *stream);

Every stream has an associated file position. When a file is opened, the file posi-
tion is set at the beginning of the file. (If the file is opened in “append” mode, how-
ever, the initial file position may he at the beginning or end of the file, depending
on the implementation.) Then, when a read or write operation is performed., the file
position advances automatically, allowing us to move through the file in a sequen
tial manner.

Although sequential access is fine for many applications, some programs need
the ability to jump around within a file, accessing some data here and other data
there. I a file contains a series of records, for example, we might want to jump
direetly to a particular record and read it or update it. <stdio.h> supports this
form of access by providing five functions that allow a program to determine the
current file position or to change it

The fseek function changes the file position associated with the first argu-
ment (a file pointer). The third argument specifies whether the new position is to

ftell

exrno variable »24.2

22.7 File Positioning ~ 573

be calculated with respeet to the beginning of the file, the current position, or the
end of the file. <stdio. h> defines three macros for this purpose:

SEEK_SET  Beginning of file
SEEK_CUR  Current file position
SEEK_END  End of file

The second argument is a (possibly negative) byte count. To move to the beginning
of a file, for example, the seek direction would be SEEK_SET and the byte count
would be zero:

foeek (fp, OL, SEEK SET); /* moves to beginning of file */
To move to the end of a file, the seek direction would be SEEK_END:
fseek(fp, OL, SEEK END); /* moves to end of file */

To move back 10 bytes. the seek direction would be SEEK_CUR and the byte count
would be —10:

fseek(fp, -10L, SEEK CUR); /* moves back 10 bytes */
< &

Note that the byte count has type long int, so I've used 0L and -10L as argu-
ments, (0 and -10 would also work, of course, since arguments are converted to
the proper type automatically.)

Normally, fseek returns zero. Il an error oceurs (the requested position
doesn’( exist, [or example), fseek returns a nonzero value.

The file-positioning functions are best used with binary streams, by the way. C
doesn’t prohibit programs from using them with text streams. but care is required
because of operating system differences. fseek in particular is sensitive to
whether a stream is text or binary. For text streams, either (1) of fset (fseek’s
second argument) must be zero or (2) whence (its third argument) must be
SEEK SET and offset a value obtained by a previous call of fLell. (In other
words, we can only use fseek (0 move (0 the beginning or end of a text stream or
to return to a place that was visited previously.) For binary streams, fseek isn't
required to support calls in which whence is SEEK_END.

The ftell function returns the current file position as a long integer. (If an
error oceurs, ftell returns - 1L and stores an error code in exrno.) The value
returned by ftell may be saved and later supplied to a call of fseek, making it
possible to return to a previous file position:

long file pos;

file pos = ftell (fp); /* saves current position */

Eseek (fp, file pos, SEEK_SET); /* returns to old position */

If fp is a binary stream, the call ttell (fp) returns the current file position as a
byte count, where zero represents the beginning of the file. If fp is a text stream,
however, ftell (fp) isn’t necessarily a byte count. As a result, it’s best not to
perform arithmetic on values returned by ftell. For example, it’s not a good
574

Chapter 22 Input/Output

rewind

fgetpos
fsetpos

QsA

PROGRAM

invciear.c

idea to subtract values returned by ftell to see how far apart two file positions
are.

The rewind function sets the file position at the beginning. The call
rewind (fp) is nearly equivalent to fseek (fp, 0L, SEEK SET). The dif-
ference? rewind doesn’t return a value but does clear the error indicator for fp,

fseek and ftell have one problem: they're limited to files whose posi-
tions can be stored in a long integer. For working with very large files, C pro-
vides two additional functions: fgetpos and fsetpos. These functions can
handle large files because they use values of type fpos_t to represent file posi-
tions. An fpos_t value isn’t necessarily an integer: it could be a structure, for
instance.

The call fgetpos (fp, &file pos) stores the file position associated
with fp in the file_pos variable. The call fsetpos (fp, &file_pos) sets
the file position for fp 1o be the value stored in file pos. (This value must have
been obtained by a previous call of fgetpos.) If a call of fgetpos or tsetpos
fails, it stores an error code in exrrno. Both functions return zero when they suc-
ceed and a nonzero value when they fail.

Here's how we might use fgetpos and f setpos to save a file position and
return to it later:

fpos_t file_pos;
fgetpos (fp, &file pos); /* saves current position */

fsetpos (fp, &file pos); /* returns to old position */

Modifying a File of Part Records

The following program opens a binary file containing part structures, reads the
structures into an array, sets the on_hand member of each structure to 0. and then
writes the structures back to the file. Notc that the program opens the file in
"rb+" mode, allowing both reading and writing.

/* Modifies a file of part records by setting the quantity
cn hand to zero for all records */

#include <stdio.hs
#include <stdlib.h>

#define NAME_LEN 25
#define MAX_PARTS 100

struct part {
int number;
char name [NAME_LEN+1] ;
int on_hand;
inventory [MAX PARTS] ;
22.8

22.8 String IO 575

int num_parts;

int main(void)

FILE *fp;
int i;
if ((fp = fopen("inventory.dat", "rb+")) == NULL) {

fprintf (stderr, "Can't open inventory file\n");
exit (EXIT FAILURE);

}

num_parts = fread(inventory, sizeof (struct part),
MAX_PARTS, fp);

for (i = 0; i < num parts;
inventory[i] .on _hand =

di++)

rewind (fp) ;
fwrite (inventory, sizeof(struct part), num parts, fp);
fclose (fp) ;

return 0;

)

Calling rewind is critical, by the way. After the fread call, the file position is at
the end of the file. If we were to call fwrite without calling rewind first,
fwrite would add new data to the end of the file instead of overwriting the old
data,

String I/O

The functions described in this section are a bit unusual, since they have nothing to
do with streams or files. Instead, they allow us to read and write data using a string
as though it were a stream. The sprintf and snprintf functions write charac-
ters into a string in the same way they would be written to a strcam; the sscanf
function reads characters from a string as though it were reading from a stream.
These functions, which closely resemble printf and scanf, are quite useful.
sprintf and enprintf give us access to printf’s formatting capabilities
without actually having to write data to a stream. Similarly, sscanf gives us
access to scanf’s powerful pattern-matching capabilities. The remainder of this
section covers sprintf, snprintf, and sscanf in detail.

Three similar functions (veprintf, vsnprintf, and vsscanf) also
belong to <stdio.h>. However, these functions rely on the va_list type,
which is declared in <stdarg.h>. I'll postpone discussing them until Section
206.1, which covers that header,
576

Chapter 22

sprintf

snprintf

Input/Output
Output Functions

int sprintf (char * restrict s,

const char * restrict format, ...);
int snprintf(char * restrict s, size t n,

const char * restrict format, ...);

Noze: In this and subsequent chapters, the prototype for a function that is new in
99 will be in italics. Also, the name of the function will be italicized when it
appears in the left margin,

The sprintf function is similar to printf and fprintf, except that it writes
output into a character array (pointed to by its first argument) instead of a stream.
sprintf's second argument is a format string identical to that used by printE
and fprintf. For example, the call

sprintf (date, "%d/%d/%d", 9, 20, 2010);

will write "9/20/2010" into date. When it’s finished writing into a string,
sprintf adds a null character and returns the number of characters stored (not
counting the null character). If an encoding error occurs (a wide character could
not be translated into a valid multibyte character), sprintf returns a negative
value.

sprintf has a variety of uses. For example, we might occasionally want to
format data for output without actually writing it. We can use sprintf to do the
formatting, then save the result in a string until it’s time to produce output,
sprintf is also convenient for converting numbers to character form.

The snprintf function is the same as sprintf, except for the additional
parameter . No more than n — | characters will be written to the string. not count-
ing the terminating null character, which is always written unless n is zero. (Equiv-
alently, we could say that snprintf writes at most n characters to the string, the
last of which is a null character.) For example, the call

gnprintf (name, 13, "%s, ¥s", "Einstein", "Albert");

will write "Einstein, Al" into name.

snprintf returns the number of characters that would have been written
(not including the null character) had there been no length restriction. If an encod-
ing error occurs, snprintf returns a negative number. To see if snprintf had
room to write all the requested characters, we can test whether its return value was
nonnegative and less than n.

Input Functions

int sscanf (const char * restrict s,
const char % restrict format, ...);
sscanf

@

Q&A 577

The sscanf function is similar to scanf and fscant, except that it reads from
a string (pointed to by its first argument) instead of reading from a stream.
sscanf’s second argument is a format string identical to that used by scanf and
fscanf,

sscanf is handy for extracting data from a string that was read by another
input function. For example, we might use fgets to obtain a line of input. then
pass the line to sscanf for further processing:

fgets(str, cizcof (str), stdin); /* reads a line of input */
sscanf (str, "$d%d", &i, &i); /* extracts two integers */

One advantage of using sscanf instead of scanf or Fscanf is that we can
examine an input line as many times as needed, not just once. making it easier to
recognize alternate input forms and to recover from errors. Consider the problem
of reading a date that’s written either in the form month/ day/year or month-day-
Yyear. Assuming that stz contains a line of input, we can extract the month, day,
and year as follows:

if (sscanf(str, "$d /%d /%d", &month, &day, &year) == 3)
printf ("Month: %d, day: %d, year: %d\n", month, day, year);
elge if (sscanf(str, "%d -%d -%d", &month, &day, &year) == 3)

printf ("Month: %d, day: %d, year: %d\n", month, day, year);
else
printf("Date not in the proper form\n');

Like the scanf and fscanf functions, sscanf returns the number of data
items successfully read and stored. sscanf returns ZOF if it reaches the end of
the string (marked by a null character) before finding the first item.

Q&A

If I use input or output redirection, will the redirected file names show up as
command-line arguments? [p. 541]

No; the operating system removes them from the command line. Let’s say that we
run a program hy entering

demo foo <in file bar sout file baz

The value of arge will be 4, argv[0] will point to the program name,
argv[1] will point to "foo", argv [2] will point to "bar", and argv [3]
will point to "baz".

I thought that the end of a line was always marked by a new-line character.
Now you're saying that the end-of-line marker varies, depending on the oper-
ating system. How you explain this discrepancy? [p. 542]

C library functions make it appear as though each line ends with a single new-line
578

Chapter 22

Input/Output

character. Regardless of whether an input file contains a carriage-return character,
a line-feed character, or both, a library function such as getc will return a single
new-line character. The output functions perform the reverse translation. If a pro-
gram calls a library function to write a new-line character to a file, the function
will translate the character into the appropriate end-of-line marker. C’s approach
makes programs more portable and easier to write; we can work with text files
without having to worry about how end-of-line is actually represented. Note that
input/output performed on a file opened in binary mode isn’t subject to any char-
acter translation—carriage return and line feed are treated the same as the other
characters.

I’'m writing a program that needs to save data in a file, to be read later by
another program. Is it better to store the data in text form or binary form? [p.
542]

That depends. If the data is all text to start with, there’s not much difference. If the
data contains numbers, however, the decision is tougher.

Binary form is usually preferable, since it can be read and written quickly.
Numbers are already in binary form when stored in memory, so copying them to a
file is easy. Writing numbers in text form is much slower, since each number must
be converted (usually by fprintf) to character form. Reading the file later will
also take more time, since numbers will have to be converted from text form back
to binary. Moreover, storing data in binary form often saves space, as we saw in
Section 22.1.

Binary files have two disadvantages, however. They’re hard for humans to
read, which can hamper debugging. Also, binary files generally aren’t portable
from one system to another, since different kinds of computers store data in differ-
ent ways. For instance, some machines store int values using two bytes but others
use four bytes. There’s also the issue of byte order (big-endian versus little-
endian).

C programs for UNIX never seem to use the letter b in the mode string, even
when the file being opened is binary. What gives? [p. 544]

In UNIX, text files and binary files have exactly the same format, so there's never
any need to use b. UNIX programmers should still include the b, however, so that
their programs will be more portable to other operating systems.

I’ve seen programs that call fopen and put the letter t in the mode string.
What does t mean?

The C standard allows additional characters to appear in the mode string, provided
that they follow r, w. a, b, or +. Some compilers allow the use of t to indicate that
a file is to be opened in text mode instead of binary mode. Of course. text mode is
the default anyway, so t adds nothing. Whenever possible, it’s best to avoid using
t and other nonportable features.

Why bother to call fclose to close a file? Isn’t it true that all open files are
closed automatically when a program terminates? [p. 545]
A

abort funcion »26.2

Q&A 579

That’s usually true. but not if the program calls abort to terminate. Even when
abort isn't used, though, there are still good reasons to call fclose. First, it
reduces the number of open files. Operating systems limit the number of files that
a program may have open at the same time; large programs may bump into this
limit. (The macro FOPEN_MAX, defined in <stdio.hs, specifies the minimum
number of files that the implementation guarantees can be open simultaneously.)
Second, the program becomes easier to understand and modify; by looking for the
call of fclose. it’s easier for the reader to determine the point at which a file is
1o Jonger in use. Third, there's the issue of safety. Closing a file ensures that its
contents and directory entry are updated properly; if the program should crash
later, at least the file will be intact.

I’'m writing a program that will prompt the user to enter a file name. How
long should I make the character array that will store the file name? [p. 546]
That depends on your operating system. Fortunately, you can use the macro
FILENAME MAX (defined in <stdio.hs) to specify the size of the array.
FILENAME MAX is the length of a string that will hold the longest file name that
the implementation guarantees can be opened.

Can fflush flush a stream that was opened for both reading and writing?
[p- 549]

According to the C standard, the effect of calling f f lush is defined for a stream
that (a) was opened for output, or (h) was opened for updating and whose last oper-
ation was not a read. In all other cases, the effect of calling ff1ush is undefined.
When ff1ush is passed a null pointer, it flushes all streams that satisfy either (a)
or (b).

Can the format string in a call of ..printf or ..scanf be a variable?

Sure; it can be any expression of type char *, This property makes the ..printf
and ...scanf functions even more versatile than we’ve had reason to suspect. Con-
sider the following classic example from Kernighan and Ritchie’s The C Program-
ming Language, which prints a program’s command-line arguments, separated by
spaces:

while (--arge > 0)
printf((argc > 1) ? "%s " : "$s", *irargv);
The format string is the expression (arge > 1) ? "%s " : "$s" which evalu-

ates to "&s " for all command-line arguments but the last.

Which library functions other than clearerr clear a stream’s error and
end-of-file indicators? [p. 565]

Calling rewind clears both indicators, as does opening or reopening the stream.
Calling ungetc, fseek, or fsetpos clears just the end-of-file indicator,

I can’t get feof to work; it seems to return zero even at end-of-file. What am
1 doing wrong? [p. 565]
580

Chapter 22

Al

Qs

Input/Output

feof will only return a nonzero value when a previous read operation has failed;
you can't use feof to check for end-of-file before attempting to read. Instead, you
should first attempt to read, then checek the return value from the input function. If
the return value indicates that the operation was unsuccessful. you can then use
feof to determine whether the failure was due to end-of-file. In other words, it's
best not to think of calling feof as a way to detect end-of-file. Instead, think of it
as @ way to confirm that end-of-file was the reason for the failure of a read opera-
tion.

1 still don’t understand why the I/0 library provides macros named putc and
getc in addition to functions named fputc and fgetc. According to Sec-
tion 21.1, there are already two versions of putc and getc (a macro and a
function). If we need a genuine function instead of a macro, we can expose the
putec or gete function by undefining the macro. So why do fputc and
fgetc exist? [p. 566]

Historical reasons. Prior to standardization. C had no rule that there be a true func-
tion to back up each parameterized macro in the library. putc and getc were tra-
ditionally implemented only as macros; fputc and fgetc were implemented
only as functions.

What’s wrong with storing the return value of fgetc, getc, or getchar in
a char variable? I don’t sce how testing a char variable against EOF could
give the wrong answer. [p. 568]

There are two cases in which this test can give the wrong result. To make the fol-
lowing discussion conerete, I'll assume two's-complement arithmetic.

First, suppose that char is an unsigned type. (Recall that some compilers
treat char as a signed type but others treat it as an unsigned type.) Now suppose
that getc returns EOF, which we store in a char variable named ch. If EOF rep-
resents —1 (its typical value), ch will end up with the value 255. Comparing ch (an
unsigned character) with EOF (a signed integer) requires converting ch to a signed
integer (255, in this case). The comparison against EOF fails, since 255 is not equal
to-1.

Now assume that char is a signed type instead. Consider what happens if
getec reads a byte containing the value 255 from a binary stream. Storing 255 in
the ch variable gives it the value —1, since ch is a signed character. Testing
whether ch is equal to EOF will (erroneously) give a true result.

The character input functions described in Section 22.4 require that the Enter
key be pressed before they can read what the user has typed. How can I write
a program that responds to individual keystrokes?

As you've noticed, the getc, fgetc, and getchar functions are buffered: they
don’t start to read input until the user has pressed the Enter key. In order to read
characters as they're entered—which is important for some kinds of programs—
you'll need to use a nonstandard library that's tailored to your operating system. In
UNIX, for example, the curses library often provides this capability.
Q&A 581

‘When I’'m reading user input, how can I skip all characters left on the current
input line?

One possibility is to write a small function that reads and ignores all characters up
to (and including) the first new-line character:

void skip_line (void)

while (getchar() I- '\n')

i

Another possibility is to ask scanf to skip all characters up to the first new-
line character:

scanf ("$* [*\n]"); /* skips characters up to new-line */

scanf will read all characters up to the first new-line character, but not store them
anywhere (the * indicates assignment suppression). The only problem with using
scanf is that it leaves the new-line character unread, so you may have to discard
it separately.

‘Whatever you do, don’t call the ff1ush function:

fflush(stdin); /* effect is undefined */

Although some implementations allow the use of ff1ush to “flush” unread input,
it’s not a good idea to assume that all do. ff1ush is designed to flush outpur
streams; the C standard states that its effect on input streams is undefined.

Why is it not a good idea to use fread and fwrite with text streams?” [p.
571]

One difficulty is that, under some operating systems, the new-line character
becomes a pair of characters when written to a text file (see Section 22.1 for
details). We must take this expansion into account, or else we're likely to lose track
of our data. For example, if we use fwrite to write blocks of 80 characters. some
of the blocks may end up occupying more than 80 bytes in the file because of new-
line characters that were expanded.

Why are there two sets of file-positioning functions (fseek/ftell and
fsetpos/fgetpos)? Wouldn’t one set be enough? [p. 574]

fseek and ftell have been part of the C library for eons. They have one draw-
back, though: they assume that a file position will fit in a long int value. Since
long int is typically a 32-bit type, this means that fseek and ftell may not
work with files containing more than 2,147,483,647 bytes. In recognition of this
problem, fsetpos and fgetpos were added to <stdio.h> when C89 was
created. These functions aren’t required to treat file positions as numbers, so
they're not subject to the long int restriction. But don’t assume that you have to
use fsetpos and fgetpos: if your implementation supports a 64-bit long
int type, fseek and ftell are fine even for very large files.
582 Chapter 22

Section 22.1

Section 22.2

Section 22.3

Q:

AT

11

o 2

® 4

Input/Output

‘Why doesn’t this chapter discuss screen control: moving the cursor, changing
the colors of characters on the screen, and so on?

C provides no standard functions for screen control. The C standard addresses only
issues that can reasonably be standardized across a wide range of computers and
operating systems: screen control is outside this realm. The customary way to
solve this problem in UNIX is to use the curses library, which supports screen
control in a terminal-independent manner.

Similarly, there are no standard functions for building programs with a graphi-
cal user interface. However, you can most likely use C function calls to access the
windowing API (application programming interface) for your operating system.

Exercises

Indicate whether each of the following files is more likely to contain text data or binary
data:

(a) A file of object code produced by a C compiler

(b) A program listing produced by a C compiler

(c) An email message sent from one computer to another

(d) A file containing a graphics image

Indicate which mode string is most likely to be passed to fcpen in each of the following

situations:

(a) A datahase management system opens a file containing records to be updated

(b) A mail program opens a file of saved messages so that it can add additional messages to
the end.

(c) A graphics program opens a file containing a picture to be displayed on the screen,

(d) An operating system command interpreter opens a “shell seript” (or “batch file”) con-
taining commands to be executed

Find the error in the following program fragment and show how to fix it.
FILE *fp;

if (fp = fopen(filename, "r")) {
read characters until end-of-file

fclose (fp) ;

Show how each of the following numbers will look if displayed by printf with
%#012 . 59 as the conversion specification:

(a) 83.7361

(b) 29748.6607

(c) 1054932234.0

(d) 0.0000235218

Is there any difference between the printf conversion specifications % . 4d and $044? If
50, explain what it is.
Section 22.4

@ 6.

7

Exercises 583

‘Write a call of printf that prints

1 widget

if the widget variable (of type int) has the value 1, and
n widgets

otherwise, where z is the value of widget. You are not allowed to use the `if` statement or
any other statement; the answer must be a single call of printf.

Suppose that we call scant as follows:
n = scanf ("$d%f%d", &i, &x, &j);

(1, i, and n are int variables and x is a float variable.) Assuming that the input stream
contains the characters shown, give the values of i, j, n, and x after the call. In addition,
indicate which characters were consumed by the call.

(a) 108200301

(b) 1.0e2.0e3.00

(c) 0.1e0.200.30

() .1e.2e, 30

Tn previous chapters, we've used the scanf format string " %< when we wanted to skip
white-space characters and read a nonblank character. Some programmers use "%1s'"
instead. Are the two techniques equivalent? If not, what are the differences?

‘Which one of the following calls is ot a valid way of reading one character from the stan-
dard input stream?

(a) getch()

(b) getchar()

(c) getc(stdin)

(d) fgetc (stdin)

The Ecopy . c program has one minor flaw: it doesn't check for errors as it's writing to the
destination file. Errors during writing are rare, but do occasionally occur (the disk might
become full, for example). Show how to add the missing error check to the program, assum-
ing that we want it to display a message and terminate immediately if an error occurs.

The following loop appears in the fcopy . c program:

while ((ch = getc(scurce fp)) != EOF)
putc (ch, dest_fp) ;

Suppose that we neglected to put parentheses around ch = getc (source_fp):

while (ch = getc(source fp) != EOF)
putc(ch, dest_fp):

Would the program compile without an error? If so, what would the program do when it's
run?

Find the error in the following function and show how to fix it.

int count periods(const char *filename)

{

FILE *fp;
int n = 0;
584 Chapter 22

Section 22.5

Section 22.7

Section 22.8

13.

O 14

o 15

16,

Input/Output

if ((fp = fopen(filename, "r")) != NULL) {
while (fgetc(fp) EOF)
if (fgetc(fp)
net;
fclose (fp) ;

return n;

}

Write the following function:
int line length(const char *filename, int n);
The function should return the length of line n in the text file whose name is filename

(assuming that the first line in the file is line 1). If the line doesn’t exist, the function should
return 0.

(a) Write your own version of the fgets function. Make it behave as much like the real
fgets function as possible; in particular, make sure that it has the proper return value. To
avoid conflicts with the standard library, don’t name your function fgets

(b) Write your own version of fputs, following the same rules as in part (a).

Write calls of fsesk that perform the following file-positioning operations on a binary file
whose data is arranged in 64-byte “records.” Use fp as the file pointer in each case.

(a) Move to the beginning of record n. (Assume that the first record in the file is record 0.)
(b) Move to the beginning of the last record in the file.

(c) Move forward one record.

(d) Move backward two records.

Assume that str is a string that contains a “sales rank" immediately preceded by the #
symbol (other characters may precede the # and/or follow the sales rank). A sales rank is a
series of decimal digits possibly containing commas, such as the following examples:

989

24,675

1,162,620

‘Write a call of sscant that extracts the sales rank (but not the # symbol) and stores it in a
string variable named sales_rank.

Programming Projects

Extend the canopen . c program of Section 22.2 so that the user may put any number of
file names on the command line:

canopen foo bar baz
The program should print a separate can be opened or can' t be opened message for

each file. Have the program terminate with staus EXIT FATLURE if one or more of the
files can’t be opened.

Write a program that converts all letters in a file to upper case. (Characters other than letters
shouldn’t be changed.) The program should obtain the file name from the command line and
write its output to stdout.
Programming Projects 585

Write a program named fcat that “concatenates" any number of files by writing them to
standard output, one after the other, with no break between files. For example, the following
command will display the files f1.c, f2.c, and f3 . c on the screen:

foat fl.c f2.c f3.C!

fcat should issue an error message if any file can’t be opened. Hinr: Since it has no more
than one file open at a time, fcat needs only a single file pointer variable. Once it’s fin-
ished with a file, fcat can use the same variable when it opens the next file.

(a) Write a program that counts the number of characters in a text file.

(b) Write a program that counts the number of words in a text file. (A “word” is any
sequence of non-white-space characters.)

(c) Write a program that counts the number of lines in a text file.
Have each program obtain the file name from the command line.

The xor . c program of Section 20.1 refuses to encrypt bytes that—in original or encrypted
form—are control characters. We can now remove this restriction. Modify the program so
that the names of the input and output files are command-line arguments. Open both files in
binary mode, and remove the test that checks whether the original and encrypted characters
are printing characters.

Write a program that displays the contents of a file as bytes and as characters. Have the user
specify the file name on the command line. Here’s what the output will look like when the
program is used to display the pun. c file of Section 2.1:

Offset Bytes Characters
0 23 69 6E 63 6C 75 64 65 20 3C #include <
10 73 74 64 69 6F 2E 68 3E OD 0A stdio.h>..
20 0D OA 69 6E 74 20 6D 61 69 6E ..int main
30 28 76 6F 69 64 29 OD OA 7B OD (void)..{.
40 O0A 20 20 70 72 69 6E 74 66 28 . printf(
50 22 54 6F 20 43 2C 20 6F 72 20 "To C, or
60 6E 6F 74 20 74 6F 20 43 3A 20 not to C:
70 74 68 61 74 20 €9 73 20 74 68 that is th
80 65 20 71 75 65 73 74 69 6F 6E e question
90 2E 5C 6E 22 29 3B 0D 0A 20 20 .\n");..
100 72 65 74 75 72 GE 20 30 3B 0D return 0;.
110 0A 7D o)

Each line shows 10 bytes from the file, as hexadecimal numbers and as characters. The
number in the Of fset column indicates the position within the file of the first byte on the
line. Only printing characters (as determined by the isprint function) are displayed;
other characters are shown as periods. Note that the appearance of a text file may vary,
depending on the character set and the operating system. The example above assumes that
pun.c is a Windows file, so 0D and OA bytes (the ASCIT carriage-return and line-feed
characters) appear at the end of each line. Hint: Be sure to open the file in "rb" mode.

Of the many techniques for compressing the contents of a file, one of the simplest and fast-
est is known as run-length encoding. This technique compresses a file by replacing
sequences of identical bytes by a pair of bytes: a repetition count followed by a byte to be
repeated. For example, suppose that the file to be compressed begins with the following
sequence of bytes (shown in hexadecimal):

46 6F 6F 20 62 61 72 21 21 21 20 20 20 20 20
The compressed file will contain the following bytes:
586

Chapter22  Input/Output

*10.

01 46 02 6F 01 20 01 62 01 61 01 72 03 21 05 20

Run-length encoding works well if the original file contains many long sequences of identi-
cal bytes, In the worst case (a file with no repeated bytes), run-length encoding can actually
double the length of the file.

(a) Write a program named compress file that uses run-length encoding to compress
a file. To run compress_file, we'd use a command of the form

compress_file original-file

compress file will write the compressed version of original-file to original-file . xle.
For example, the command

compress_file foo.txt

will cause compress_file to write a compressed version of f00. txt to a file named
foo. txt . rle. Hint: The program described in Programming Project 6 could be useful
for debugging.

(b) Write a program named uncompress_file that reverses the compression performed
by the compress file program. The uncompress file command will have the
form

uncompress_file compressed-file
compressed-file should have the extension . rle. For example, the command
uncompress_file foo.txt.rle

will cause uncompress_file to open the file foo.txt.rle and write an uncom-
pressed version of its contents to foo. txt. uncompress_file should display an error
message if its command-line argument doesn’t end with the . rle extension.

Modify the inventory . c program of Section 16.3 by adding two new operations:
m Save the database in a specified file.
m Load the database from a specified file.

Use the codes d (dump) and r (restore), respectively, to represent these operations. The
interaction with the user should have the following appearance:

Enter operation code: 4
Enter name of output file: inventory.dat

Enter operation code: r

Enter name of input file: inventory.dat
Hint: Use fwrite to write the array containing the parts to a binary file. Use fread to
restore the array by reading it from a file,

Write a program that merges two files containing part records stored by the inventory.c
program (see Programming Project 8). Assume that the records in each file are sorted by
part number, and that we want the resulting file to be sorted as well. If both files have a part
with the same number, combine the quantities stored in the records. (As a consistency
check, have the program compare the part names and print an error message if they don’t
match.) Have the program obtain the names of the input files and the merged file from the
command line.

Modify the inventory2.c program of Section 17.5 by adding the d (dump) and T
(restore) operations described in Programming Project 8. Since the part structures aren’t
stored in an array, the d operation can’t save them all by a single call of fwrite. Instead. it
will need to visit each node in the linked list, writing the part number, part name, and quan-
14.

Programming Projects 587

tity on hand to a file. (Don't save the next pointer; it won't be valid once the program ter-
minates.) As it reads parts from a file, the = operation will rebuild the list one node at a time.

Write a program that reads a date from the command line and displays it in the following
form:
September 13, 2010

Allow the user to enter the date as either 9-13-2010 or 9/13/2010; you may assume
that there are no spaces in the date. Print an error message if the date doesn’t have one of the
specified forms. Hint: Use sscanf to extract the month, day, and year from the command-
line argument.

Modify Programming Project 2 from Chapter 3 so that the program reads a series of items
from a file and displays the data in columns. Each line of the file will have the following
form;

item , price ,mm/dd [ yyyy
For example, suppose that the file contains the following lines:

583,13.5,10/24/2005
3912,599.99,7/27/2008

The output of the program should have the following appearance:

Ttem Unit Purchase
Price Date

583 $' 1350 10/24/2005

3912 j.599.99 7/27/2008

Have the program obtain the file name from the command line.

Modify Programming Project 8 from Chapter 5 so that the program obtains departure and
arrival times from a file named f1ights.dat. Each line of the file will contain a depar-
ture time followed hy an arrival time, with one or more spaces separating the two. Times
will be expressed using the 24-hour clock. For example, here’s what f1ights.dat might
look like if it contained the flight information listed in the original project:

8:00 10:16

21:45 23:58

Modify Programming Project 15 from Chapter 8 so that the program prompts the user o
enter the name of a file containing the message to be encrypted:

Enter name of file to be encrypted: message.txt
Enter shift amount (1-25): 3

The program then writes the encrypted message (0 a file with the same name but an added
extension of .enc. In this example, the original file name is message.txt, so the
encrypted message will be stored in a file named message . txt . enc. There’s no limit on
the size of the file to be encrypted or on the length of each line in the file.

Modify the justify program of Section 15.3 so that it reads from one text file and writes
to another. Have the program obtain the names of both files from the command line.
588

Chapter 22 Input/Output

16.

17.

Modify the fcopy . c program of Section 22.4 so that it uses fread and fwrite to copy
the file in blocks of 512 bytes. (The last block may contain fewer than 512 bytes, of course.)

Write a program that reads a series of phone numbers from a file and displays them in a
standard format. Each line of the file will contain a single phone number, but the numbers
may be in a variety of formats. You may assume that each line contains 10 digits, possibly
mixed with other characters (which should be ignored). For example, suppose that the file
contains the following lines:

404.817.6900
(215) €86-1776
312-746-6000
877 275 5273
6173434200

The output of the program should have the following appearance:

(404) 817-6900
(215) €86-1776
(312) 746-6000
(877) 275-5273
(617) 343-4200

Have the program obtain the file name from the command line.

‘Write a program that reads integers from a text file whose name is given as a command-line
argument. Each line of the file may contain any number of integers (including none) sepa-
rated by one or more spaces. Have the program display the largest number in the file, the
smallest number, and the median (the number closest to the middle if the integers were
sorted). If the file contains an even number of integers, there will be two numbers in the
middle; the program should display their average (rounded down). You may assume that the
file contains no more than 10,000 integers. Hinz: Store the integers in an array and then sort
the array.

(a) Write a program that converts a Windows text filc to a UNIX text file. (See Section 22.1
for a discussion of the differences between Windows and UNIX text files.)
(b) Write a program that converts a UNIX text file to a Windows text file

In each case, have the program obtain the names of both files from the command line. Hint:
Open the input file in "rb" mode and the output file in "wb" mode.
23

23.1

rounding direction »23.4

Library Support for Numbers
and Character Data

Prolonged contact with the computer turns
mathematicians into clerks and vice versa.

This chapter describes the five most important library headers that provide support
for working with numbers, characters, and character strings. Sections 23.1 and
23.2 cover the <float.h> and <limits.h> headers, which contain macros
describing the characteristics of numeric and character types. Sections 23.3 and
23.4 describe the <math . h> header, which provides mathematical functions. Sec-
tion 23.3 discusses the C89 version of <math.h>: Section 23.4 covers the C99
additions, which are so extensive that I've chosen to cover them separately. Sec-
and 23.6 are devoted to the <ctype.h> and <string.h> headers,
which provide character functions and string functions, respectively.

(99 adds several headers that also deal with numbers, characters, and strings.
The <wchar . h> and <wctype . h> headers are discussed in Chapter 25. Chap-
ter 27 covers <complex.hs, <fenv.hs, <inttypes.hs, <stdint.h>,
and <tgmath.h>.

The <float.h> Header: Characteristics of
Floating Types

The <float.h> header provides macros that define the range and accuracy of
the float, double, and long double types. There are no types or functions
in <fleat.h>.

Two macros apply to all floating types. The FLT_ROUNDS macro represents
the current rounding direction for floating-point addition. Table 23.1 shows the
possible values of FLT ROUNDS. (Values not shown in the table indicate imple-
mentation-defined rounding behavior.)

589
590

Table 23.1
Rounding Directions

fesetround funcion »27.6

Table 23.2
Significant-Digit Macros
in<float .h>

‘Table 233
Exponent Macros
in<float.h>

Chapter 23  Library Support for Numbers and Character Data

| Value Meaning

-1 Indeterminable
0 Toward zero
1 To nearest
2 Toward positive infinity
3 ‘Toward negative infinity

Unlike the other macros in <float .h>, which represent constant expressions,
the value of FLT_ROUNDS may change during execution. (The fesetround
function allows a program to change the current rounding direction.) The other
macro, FLT RADIX, specifies the radix of exponent representation; it has a mini-
mum value of 2 (indicating binary representation).

The remaining macros, which I'll present in a series of tables, describe the
characteristics of specific types. Each macro begins with either FLT, DBL, or
LDBL, depending on whether it refers to the float, double, or long double
type. The C standard provides extremely detailed definitions of these macros; my
descriptions will be less precise but easier to understand. The tables indicate maxi-
mum or minimum values for some macros, as specified in the standard.

Table 23.2 lists macros that define the number of significant digits guaranteed
by each floating type.

Name Value Description
FLT_MANT_DIG Number of significant digits (base FLT_RADIX)
DBL_MANT DIG
LDBL_MANT DIG
FLT_DIG 26 Number of significant digits (base 10)
DBL_DIG >10
LDBL_DIG =10

Table 23.3 lists macros having to do with exponents,

Name Value Description
FLT_MIN EXP Smallest (most negative) power to which
DBL_MIN_EXP FLT RADIX can be raised
LDBL_MIN EXP
FLT MIN 10 EXP <37 Smallest (most negative) power to which 10 can be
DBL_MIN 10 EXP <37  raised
LDBL MIN 10 EXP <37
FLT_MAX EXP Largest power to which FLT_RADIX can be raised
DBI,_MAX_EXP
LDBL_MAX EXP
FLT_MAX 10 EXP  2+37 Largest power to which 10 can be raised
DBL_MAX 10 EXP 2437
LDBL _MAX 10_EXP 2437

Table 23.4 lists macros that describe how large numbers can be, how close to
zero they can get, and how close two consecutive numbers can be.
Table 23.4
Max, Min, and Epsilon
Macros in <Float . h>

Table 23.5
Evaluation Methods

23.2

232 The <limits.h> Header: Sizes of Integer Types 591

Name — Value Description
FLT_MAX 210" Largest finite value
DRT,_MAX 210"V
LDBL_MAX 210"
FLT_MIN <107 Smallest positive value
DBL_MIN <10
LDBL_MIN <107
FLT EPSILON  <I0°  Smallest representable difference between two numbers
DBL_EPSILON <10
LDBL EPSILON <10°

C99 provides two other macros, DECTMAL DIG and FLT EVAL_METHOD.
DECIMAL DIG represents the number of significant digits (base 10) in the wid-
est supparted floating type; it has a minimum value of 10. The value of
FIT_EVAL_METHOD indicates whether an implementation will perform float-
ing-point arithmetic using greater range and precision than is strictly nccessary. If
this macro has the value 0, for example, then adding two f Loat values would be
done in the normal way. If it has the value 1, however, then the float values
would be converted to double before the addition is performed. Table 23.5 lists
the possible values of FLT EVAL_METHOD. (Negative values not shown in the
table indicate implementation-defined behavior.)

Value Meaning
-1  Indeterminable

0 Evaluate all operations and constants just to the range and precision of the type

5 Evaluate operations and constants of type float and double to the range
and precision of the double type

2 Evaluate all operations and constants to the range and precision of the long |
double type

Most of the macros in <float . h> are of interest only to experts in numeri-
cal analysis, making it probably one of the least-used headers in the standard
library.

The <limits.h> Header: Sizes of Integer Types

The <1imits.h> header provides macros that define the range of each integer
type (including the character types). <1imits.h> declares no types or functions.
One set of macros in <limits.hs deals with the character types: char,
signed char, and unsigned char. Table 23.6 lists these macros and shows
the maximum or minimum value of each.
The other macros in <limits.h> deal with the remaining integer types:
short int, unsigned short int, int, unsigned int, long int, and
592

Chapter 23  Library Support for Numbers and Character Data

Table 23.6
Character Macros
in<limits.hs

@D

Table 23.7
Integer Macros in
<limits.h>

frerror cirective »14.5

Name Value Description
CHAR_BIT 28  Number of bits per byte
SCHAR_MIN <-127 Minimum signed char value
SCHAR MAX 2+127 Maximum signed char value

| UCHAR MAX 2255 Maximum unsigned char valuc |
CHAR_MIN 1 Minimum char value |
CHAR_MAX 1 Maximum chax value
MB_LEN_MAX 21 Maximum number of bytes per multibyte character

in any supported locale (see Section 25.2)

TCHAR_MIN is equal to SCHAR_MIN if chax is treated as a signed type; otherwise,
CHAR_MIN is 0.

VeHAR_MAX has the same value as either SCHAR. MAX or UCHAR MAX, depending on
whether char is treated as a signed type or an unsigned type.

unsigned long int. Table 23.7 lists these macros and shows the maximum or
minimum value of each; the formula used to compute each value is also given.
Note that C99 provides three macros that describe the characteristics of the Long
long int types.

Name Value Formula Description
SHRT_MIN <-32767 ~(2"-1) Minimum short int value
SHRT_MAX 2432767 2'".1 Maximum short int value
USHRT_MAX 265535 2!5-1  Maximum unsigned
short int value

INT_MIN <32767 —(2"-1) Minimum int value

INT MAX 2432767 251 Maximum int value

UINT MAX 263535 2'%-1 Maximum unsigned int
value

LONG_MIN <-2147483647 ~(2''-1) Minimum long int value |

LONG_MAX 242147483647 2} Maximum long int value |

ULONG_MAX 24294967295  2*-1 Maximumunsignedlong |
int value ‘

LLONG MIN'  <-9223372036854775807 —(2*-1) Minimum long long int
value

LLONG MAX'  249223372036854775807  2%-1 Maximum long long int
value

ULLONG MAX' >18446744073709551615 2%1  Maximum unsigned long
long int value

199 only

The macros in <1imits.h> are handy for checking whether a compiler sup-
ports integers of a particular size. For example, to determine whether the int type
can store numbers as large as 100,000, we might use the following preprocessing
dircctives:

#if INT_MAX < 1000C0
$error int type is too small
#endif

If the int type isn't adequate, the #error directive will cause the preprocessor
to display an error message.
23.3

<errmo.h> header »24.2

nfinity 254

23.3 The <math.h> Header (C89): Mathematics =~ 593

Going a step further, we might use the macros in <limits.h> to help a
program choose how to represent a type. Let’s say that variables of type Quan-
tity must be able to hold integers as large as 100,000. If TNT MAX is at least
100,000, we can define Quantity to be int; otherwise, we’ll need to make it
long int:

#if INT_MAX >= 100000
typedef int Quantity;
flelee

typedef long int Quantity;
#endif

The <math.h> Header (C89): Mathematics

The functions in the C89 version of <math . h> fall into five groups:

Trigonometric functions

Hyperbolic functions

Exponential and logarithmic functions

Power functions

Nearest integer, absolute value, and remainder functions

C99 adds a number of functions to these groups as well as introducing other cate-
gorics of math functions. The C99 changes to <math.h> are so extensive that
I've chosen to cover them in a separate section that follows this one. That way,
readers who are primarily interested in the C89 version of the header—or who are
using a compiler that doesn’t support C99—won’t be overwhelmed by all the C99
additions.

Before we delve into the functions provided by emath h>, let's take a brief
look at how these functions deal with errors.

Errors

The <math . h> functions handle errors in a way that’s different from other library
functions. When an error occurs, most <math . h> functions store an error code in
a special variable named errno (declared in the <errno.h> header). In addi-
tion, when the return value of a function would be larger than the largest double
value, the functions in <math.h> return a special value, represented by the macro
HUGE_VAL (defined in <math.h>). HUGE_VAL is of type double, but it isn’t
necessarily an ordinary number. (The IEEE standard for floating-point arithmetic
defines a value named “infinity"—a logical choice for HUGE_VAL.)
The functions in <math . h> detect two kinds of errors:

u Domain error: An argument is outside a function's domain. If a domain error
occurs, the function’s return value is implementation-defined and EDOM
594

Chapter 23  Library Support for Numbers and Character Data

Nal »23.4

underfiow »23.4

cos
sin
tan

acos
asin
atan

atan2

(“domain error”) is stored in errno. In some implementations of
<math.h>, functions return a special value known as NaN (“not a number”)
when a domain error occurs.

= Range error: The return value of a function is outside the range of double
values. If the return value’s magnitude is too large (overflow), the function
returns positive or negative HUGE_VAL, depending on the sign of the correct
result. In addition, ERANGE (“range error") is stored in errno. If the return
value’s magnitude is too small to represent (underflow), the function returns
zero; some implementations may also store ERANGE in errno.

‘We'll ignore the possibility of error for the remainder of this section. How-
ever, the function descriptions in Appendix D explain the circumstances that lead
to each type of error.

Trigonometric Functions

double acos (double x);
double asin(double x) ;
double atan(double x) ;
double atan2(double y, double x);
double cos(double x);
double sin(double x);
double tan(double x) ;

The cos, sin, and tan functions compute the cosine, sine, and tangent, respec-
tively. If P is defined to be 3.14159265, passing PI/4 to cos, sin, and tan
produces the following results:

cos (PI/4) = 0.707107
sin(PI/4) = 0.707107
tan(PI/4) = 1.0

Note that arguments to cos, sin, and tan arc expressed in radians, not degrees.
acos, asin, and atan compute the arc cosine, arc sine, and arc tangent:

acos{1.0) = 0.0
asin(1.0) = 1.5708
atan(1.0) = 0.785398

Applying acos to a value returned by cos won't necessarily yield the original ‘
argument to cos, since acos always returns a value between 0 and 7. asin and
atan return a value between -1/2 and /2.

atan2 computes the arc tangent of y/x, where y is the function’s first argu-
ment and x is its second. The return value of atan2 is between -7 and 7. The call
atan (x) is equivalent to atan2 (x, 1.0).
cosh
sinh
tanh

exp

log
log10

modf

233 The <math.h> Header (C89): Mathematics 595
Hyperbolic Functions

double cosh(double x);
double sinh(double x);
double tanh(double x);

The cosh, sinh, and tanh functions compute the hyperbolic cosine, sine, and
tangent:

cosh(0.5) = 1.12763
sinh(0.5) = 0.521095
tanh(0.5) = 0462117

Arguments to cosh, sinh, and tanh must be expressed in radians, not degrees.

Exponential and Logarithmic Functions

double exp (double x);

double frexp(double value, int *exp);
double ldexp(double x, int exp);

double log(double x);

double 1logl0 (double x) ;

double modf (double value, double *iptr);

The exp function returns e raised to a power:
exp(3.0) = 20.0855

log is the inverse of exp—it computes the logarithm of a number to the base
c. 1og10 computes the “common” (base 10) logarithm:

log(20.0855) = 3.0
10g10(1000) = 3.0

Computing the logarithm to a base other than e or 10 isn’t difficult. The following
function, for example, computes the logarithm of x to the base b, for arbitrary x
and b:

double log base(dcuble x, double b)
return log(x) / log(b);
The modf and frexp functions decompose a double value into two parts.
modf splits its first argument into integer and fractional parts, It returns the frac-

tional part and stores the integer part in the object pointed to by the second argu-
ment:
596

Chapter 23  Library Support for Numbers and Character Data

frexp

Idexp

pow

sqrt

modf (3.14159, &int_part) = 0.14159 (int_part isassigned 3.0)

Although int part must have type double, we can always cast it to int or
long int later.

The frexp function splits a floating-point number into a fractional part f and
an exponent 7 in such a way that the original number equals f x 2", where either
0.5<f< 1 orf=0. frexp returns fand stores » in the (integer) object pointed to
by the second argument:

frexp(12.0, &exp) = .75 (exp is assigned 4)
frexp(0.25, &exp) = 0.5 (exp is assigned —1)

1dexp undoes the work of frexp by combining a fraction and an exponent
into a single number:

ldexp(.75, 4) = 120
ldexp (0.5, -1) = 0.25

In general, the call 1dexp (x, exp) returns x x 2°*P,
The modf, frexp, and 1dexp functions are primarily used by other func-
tions in <math. h>, They are rarely called directly by programs.

Power Functions

double pow(double x, double y);
double sgrt (double x) ;

The pow function raiscs its first argument to the power specified by its second
argument:

pow (3.0, 2.0) = 9.0
pow(3.0, 0.5) = 1.7320j
pow (3.0, -3.0) = 0.037037

sgrt computes the square root:
sgrt(3.0) = 1.73205

Using sqrt to find square roots is preferable to calling pow, since sqrt is usu-
ally a much faster function,

Nearest Integer, Absolute Value, and Remainder Functions

double ceil (double x);
double fabs (double x);
double floor (double x);
double fmod(double x, double y);
ceil
floor

fabs

fmod

23.4

234 The <math.h> Header (C99): Mathematics ~ 597

The ceil (“ceiling”) function returns—as a double value—the smallest integer
that’s greater than or equal to its argument. f1oor returns the largest integer that’s
less than or equal to its argument:

aed 1@ ) = =80
ceil (7.9) = 80
cell(=7-1) sy 0
celd(-7.9)" = 70
floor (7 )= il
Fleor(7.9) === 7.0
floor(-7.1) = 8.0

floor(-7.9) = -8.0

In other words, ceil “rounds up” to the nearest integer, while f1oor “rounds
down.” C89 lacks a standard function that rounds to the nearest integer, but we can
easily use ceil and flcor to write our own:

double round nearest (double x)

return x < 0.0 2 ceililx - 0.5) : floor(x + 0:5);

C99 provides several functions that round to the nearest integer, as we'll see in the
next section.
fabs computes the absolute value of a number:

E&BelT. L8 =5 7.1
fabs(-7.1}) = 7.1

fmod returns the remainder when its first argument is divided by its second
argumcnl:

fmod (5.5, 2 2] = 1]

C doesn’t allow the % operator to have floating-point operands, but fmod is a
more-than-adequate substitute.

The <math.h> Header (C99): Mathematics

The C99 version of the <math. h> header includes the entire C89 version, plus a
host of additional types, macros, and functions. The changes to this header are so
numerous that I've chosen to cover them separately. There are several reasons why
the standards committee added so many capabilities to <math.h>:

w Provide better support for the IEEE floating-point standard. C99 doesn’t
mandate the use of the IEEE standard; other ways of representing floating-point
598 Chapter 23 Library Support for Numbers and Character Data

numbers are permitted. However, it’s safe to say that the vast majority of C pro-
grams are executed on systems that support this standard.

s Provide more control over floating-point arithmetic. Better control over
floating-point arithmetic may allow programs to achieve greater accuracy and
speed.

u Make C more attractive to Fortran programmers. The addition of many math
functions, along with enhancements elsewhere in C99 (such as support for
complex numbers), was intended to increase C's appeal to programmers who
might have used other programming languages (primarily Fortran) in the past.

Another reason that I've decided to cover C99’s <math . h> header in a sepa-
rate section is that it's not likely to be of much interest to the average C programimer.
Those using C for its traditional applications, which include systems programming
and embedded systems, probably won't need the additional functions that C99 pro-
vides. However, programmers developing engineering, mathematics, or science
applications may find these functions to be quite useful.

IEEE Floating-Point Standard

One motivation for the changes to the <math.h> header is better support for
IEEE Standard 754, the most widely used representation for floating-point num-
bers. The full title of the standard is “IEEE Standard for Binary Floating-Point
Arithmetic” (ANSI/IEEE Standard 754-1985). It's also known as IEC 60559,
which is how the C99 standard refers to it.

Section 7.2 described some of the basic properties of the IEEE standard, We
saw that the standard provides two primary formats for floating-point numbers:
single precision (32 bits) and double precision (64 bits). Numbers arc stored in a
form of scientific notation, with each number having three parts: a sign, an expo-
nent, and a fraction. That limited knowledge of the IEEE standard is enough to use
the C89 version of <math.h> effectively. Understanding the C99 version, how-
ever, requires knowing more about the standard, Here's some additional informa-
tion that we'll need:

u Positive/negative zero. One of the bits in the IEEE representation of a floal-
ing-point number represents the number’s sign. As a result, the number zero
can be either positive or negative, depending on the value of this bit. The fact
that zero has two representations may sometimes require us to treat it differ-
ently from other floating-point numbers

= Subnormal numbers. When a floating-point operation is performed, the result
may be too small to represent, a condition known as underflow. Think of what
happens if you repeatedly divide a number using a hand calculator: eventually
the result is zero, because it becomes too small to represent using the calcula-
tor’s number representation. The IEEE standard has a way to reduce the
impact of this phenomenon. Ordinary floating-point numbers are stored in a
“normalized” format, in which the number is scaled so that there’s exactly one

FLT_EVAL METHOD >23.7

23.4 The <math.h> Header (C99): Mathematics 599

digit to the left of the binary point. When a number gets small enough, how-
ever, it’s stored in a different format in which it's not normalized. These sub-
normal numbers (also known as denormalized numbers or denormals) can
be much smaller than normalized numbers: the trade-off is that they get pro-
gressively less accurate as they get smaller.

w Special values. Fach floating-point format allows the representation of three
special values: positive infinity, negative infinity, and NaN (“not a number”).
Dividing a positive number by zera produces positive infinity. Dividing a neg-
ative number by zero yields negative infinity. The result of a mathematically
undefined operation, such as dividing zero by zero, is NaN. (It's more accurate
to say “the result is  NaN” rather than “the result is NaN.” because the IEEE
standard has multiple representations for NaN. The exponent part of a NaN
value is all 1 bits, but the fraction can be any nonzero sequence of bits.) Spe-
cial values can be operands in subsequent operations. Infinity behaves just as
it does in ordinary mathematics. For example, dividing a positive number by
positive infinity yields zero. (Note that an arithmetic expression could produce
infinity as an intermediate result but have a noninfinite value overall.) Per-
forming any operation on NaN gives NaN as the result.

w Rounding direction. When a number can’t be stored exactly using a floating-
point representation, the current rounding direction (or rounding mode)
determines which floating-point value will be selected to represent the num-
ber. There are four rounding directions: (1) Round toward nearest. Rounds to
the nearest representable value. If a number falls halfway between two values,
it is rounded to the “even” value (the one whose least significant bit is zero).
(2) Round toward zero. (3) Round toward positive infinity. (4) Round toward
negative infinity. The default rounding direction is round toward nearest,

m Exceptions. There are five types of floating-point exceptions: overflow, under-
flow. division by zero, invalid operation (the result of an arithmetic operation
was NaN), and inexact (the result of an arithmetic operation had to be
rounded). When one of these conditions is detected, we say that the exception
is raised.

Types

C99 adds two types, float_t and double t.to <math.h>. The float _t
type is at least as “wide” as the float type (meaning that it could be the float
type or any wider type, such as double). Similarly, double_t is required to be
at least as wide as the double type. (It musl also be at least as wide as
float_t.) These types are provided for the programmer who's trying to maxi-
mize the performance of floating-point arithmetic, float_t should be the most
efficient floating-point type that's at least as wide as float; double_t should
be the most efficient floating-point type that's at least as wide as double.

The float t and double_t types are related to the FLT_EVAL_METHOD
macro, as shown in Table 23.8.
600 Chapter 23  Library Support for Numbers and Character Data

Table 23.8
Relationship between
FLT_EVAL_METHOD
and the float_t and
double_t Types

Value of 2 Meaning of Meaning of
FLT EVAL METHOD float t double t
0 float double
1 double double
L Long double long double
Other Implementation-defined  Implementation-defined

Macros

C99 adds a number of macros to <math.h>. I'll mention just two of them at this
point. INFINITY represents the float version of positive or unsigned infinity.
(If the implementation doesn’t support infinity, then INFINITY represents a
float value that overflows at compile time.) The NAN macro represents the
float version of “not a number.” More specifically, it represents a “quiet” NaN
(one that doesn't raise an exception if used in an arithmetic expression). If quiet
NaNs aren’t supported, the NAN macro won't be defined.

T'll cover the function-like macros in <math.hs later in the section, along
with ordinary functions. Macros that are relevant only (o a specific function will be
described with the function itself.

Errors

For the most part, the C99 version of <math.h= deals with errors in the same
way as the C89 version. However, there are a few twists that we’ll need to discuss,

First, C99 provides several macros that give implementations a choice of how
errors are signaled: via a value stored in errno, via a floating-point exception, or
both. The macros MATH_ERRNO and MATH ERREXCEPT represent the integer
constants | and 2, respectively. A third macro, math errhandling, represents
an int expression whose value is either MATH ERRNO, MATH_ERREXCEPT, or
the bitwise OR of the two values. (It's also possible that math errhandling
isn't really a macro; it might be an identifier with external linkage.) The value of
math errhandling can’t be changed within a program.

Now, let’s see what happens when a domain error oceurs during a call of one
of the functions in <math.hs>. The C89 standard says that EDOM is stored in
errno. The C99 standard, on the other hand, states that if the cxpression
math_errhandling & MATE ERRNO is nonzero (i.e., the MATH_ERRNO bit is
set), then EDOM is stored in errno. If the expression math_errhandling &
MATH_ERREXCEPT is nonzero, the invalid floating-point exception is raised.
Thus, either or both actions are possible, depending on the value of
math errhandling.

Finally, let’s tum to the actions that take place when a range error is detected
during a function call. There are two cases, based on the magnitude of the func-
tion’s return value,

Overflow. 1f the magnitude is t0o large, the C89 standard requires the function
to return positive or negative HUGE_VAL, depending on the sign of the correct
234 The <math.h> Header (C99): Mathematics ~ 601

result. In addition. ERANGE is stored in errno. The C99 standard describes a
more complicated set of actions when overflow occurs:

= If default rounding is in effect or if the return value is an “exact infinity” (such
as 1og (0. 0) ), then the function returns either HUGE VAL, HUGE VALF, or
HUGE_VALL, depending on the function’s return type. (HUGE_VALF and
HUGE_VALL—the float and long double versions of HUGE_VAL—are
new in C99. Like HUGE VAL, they may represent positive infinity.) The value
returned has the sign of the correct result.

» If the value of math_errhandling & MATH_ERRNO is nonzero, ERANGE
is stored in errno.

u If the value of math_errhandling & MATH_ERREXCEPT is nonzero, the
divide-by-zero floating-point exception is raised if the mathematical result is
an exact infinity. Otherwise, the overflow exception is raised.

Underflow. If the magnitude is too small to represent, the C89 standard
requires the function to return zero; some implementations may also store
ERANGE in errno. The C99 standard prescribes a somewhat different set of
actions:

» The function returns a value whose magnitude is less than or equal to the
smallest normalized positive number belonging to the function’s return type.
(This value might be zero or a subnormal number.)

u If the value of math_errhandling & MATH_ERRNO is nonzero, an imple-
mentation may store ERANGE in errno.

= If the value of math_errhandling & MATH_ERREXCEPT is nonzero, an
implementation may raise the underflow floating-point exception.

Notice the word “may” in the latter two cases. For reasons of efficiency, an imple-
mentation is not required to modify errno or raise the underflow cxception.

Functions

We're now ready to tackle the functions that C99 adds to <math . h>. I'll present the
functions in groups, using the same categories as the C99 standard. These categories
differ somewhat from the ones in Section 23.3, which came from the C89 standard.

One of the biggest changes in the C99 version of <math.h> is the addition
of two more versions of most functions. In C89, there’s only a single version of
each math function: typically, it takes at least one argument of type double and/
or returns a double value. In C99, however. there are two additional versions:
one for float and one for long double. The names of these functions are
identical to the name of the original function except for the addition of an f or 1
suffix. For example, the original sqrt function, which takes the square root of a
double value, is now joined by sqrtE (the float version) and sgrtl (the
long double version). I'll list the prototypes for the new versions (in italics, as
is my custom for functions that are new in C99). I won't describe the functions
further, though, since they’re virtually identical to their C89 counterparts.
602 Chapter 23  Library Support for Numbers and Character Data

foclassify

Table 23.9
Number-Classification
Macros

isfinite
isinf
isnan
isnormal

signbit

The C99 version of <math.h> also includes a number of completely new
functions (and function-like macros). I'll give a brief description of each one. As in
Section 23.3, T won't discuss error conditions for these functions, but Appendix
D—which lists all standard library functions in alphabetical order—provides this
information. I won't list the names of all the new functions in the left margin;
instead, I'll show just the name of the primary function. For example, there are
three new functions that compute the arc hyperbolic cosine: acosh, acoshf, and
acoshl. I'll describe acosh and display only its name in the left margin,

Keep in mind that many of the new functions are highly specialized. As a
result, the descriptions of these functions may seem sketchy. A discussion of what
these functions are used for is outside the scope of this book.

Classification Macros

int fpclassify (real-floating x) ;
int isfinite (real-floating x) ;
int isinf (real-floating x) ;

int isnan (real-floating x) ;

int isnormal (real-floating x) ;
int signbit (real-floating x) ;

Our first category consists of function like macros that arc used to determine
whether a floating-point value is a “normal” number or a special value such as
infinity or NaN. The macros in this group are designed to accept arguments of any
real floating type (float, double, or Tong double).

The fpclassify macro classifies its argument, returning the value of one
of the number-classification macros shown in Table 23.9. An implementation may
support other classifications by defining additional macros whose names begin
with FP_ and an upper-case letter.

Name Meaning
FP_INFINITE Infinity (positive or negative)
FP_NAN Not a number
FP_NORMAL Normal (not zero, subnormal, infinite, or NaN)
FP_SUBNORMAL Subnornial
FP_ZERO Zero (positive or negative)

The isfinite macro returns a nonzero value if its argument has a finite
value (zero, subnormal, or normal, but not infinite or NaN). isinf returns a non-
zero value if its argument has the value infinity (positive or negative). isnan
returns a nonzero value if its argument is a NaN value. isnormal returns a non-
zero value if its argument has a normal value (not zero, subnormal, infinite, or
NaN).

The last classification macro is a bit different from the others. signbit
returns a nonzero value if the sign of its argument is negative. The argument need
not be a finite number; signbit also works for infinity and NaN.
234 The <math.h> Header (C99): Mathematics 603

Trigonometric Functions

float acosf(float x); see acos
long double acosl (long double x); See acos
float asinf(float x); see asin
long double asinl (long double x); see asin
float atanf (float x); see atan
long double atanl (long double x); see atan
float atan2f(float y, float x); see atan2
long double atan2l(long double y,

long double x): Ssee atan2
float cosf (float x); see cos
long double cosl (long double x); see cos
float sinf(float x); see sin
long double sinl (long double x); see sin
float tanf(float x); see tan
long double tanl (long double x); see tan

The only new trigonometric functions in C99 arc analogs of C89 functions. For
descriptions, see the corresponding functions in Section 23.3.

Hyperbolic Functions

double acosh(double x);
float acoshf (float x);
long double acoshl (long double x);

double asinh(double x);
float asinhf (float x);
long double asinhl (long double x);

double atanh(double x);
float atanhf (float x);
long double atanhl (long double x);

float coshf (float x); see cosh
long double coshl (long double x); see cosh
float sinhf (float x); see sinh
long double sinhl (long double x); see sinh
float tanhf (float x); see tanh

long double tanhl (long double x) ; see tanh
604 Chapter 23  Library Support for Numbers and Character Data

acosh  Six functions in this group correspond to the C89 functions cosh, sinh, and

asinh  tanh, The new functions are acosh, which computes the arc hyperbolic cosine:

atanh 254 nh, which computes the arc hyperbolic sine; and atanh, which computes the
arc hyperbolic tangent.

Exponential and Logarithmic Functions

float expf(float x); see exp
long double expl (long double x); see exp

double exp2(double x);
float exp2f(float x);
long double exp2l(long double x);

double expml (double x);
float expmlf(float x);
long double expmll (long double x);

float frexpf(float value, int *exp); see frexp
long double frexpl (long double value,
int *exp): see frexp

int ilogb(double x);
int ilogbf (float x);
int ilogbl (long double x);

tloat ldexpf(float x, int exp); see 1dexp
long double ldexpl(long double x, int exp); see ldexp
float logf (float x); see log
long double logl (long double x); see log
float loglof(float x); see 1ogl0
long double logldl (long double x); see 1ogl10

double logip(double x);
float loglpf (float x);
long double logipl(long double x);

double log2(double x);
float log2f (float x);
long double log2l(long double x);

double loghb (double x) ;
float logbf (float x);
long double logbl (long double x);

fleoat modff (float value, float *iptr); see modf
long double modfl(long double value,
long double *iptr); see modf
exp2
expm1

0zA]
logb
ilogh
log1p
log2

scalbn
scalbin

cbrt

234 The <math.h> Header (C99): Mathematics ~ 605

double scalbn(double x, int n);

float scalbnf (float x, int n);

long double scalbnl (long double x, int n);
double scalbln(double x, long int n);

float scalblnf(float x, long int n);

long double scalblnl (long double x, long int n);

In additional to new versions of exp, frexp, 1dexp, log, logl0, and modf,
there are several entircly new functions in this category. Two of these, exp2 and
expml, are variations on the exp function. When applied to the argument x, the
exp2 function returns 2%, and expml returns e* — 1.

The logb function returns the exponent of its argument. More precisely, the
call logb (x) returns log (Ixl), where r is the radix of floating-point arithmetic
(defined by the macro FLT RADIX, which typically has the value 2). The ilogb
function returns the value of 1ogb after it has been cast to int type. The loglp
function returns In(1 + x) when given x as its argument. The 1og2 function com-
putes the base-2 logarithm of its argument.

The scalbn function returns x X FLT RADIX", which it computes in an
efficient way (not by explicitly raising FLT RADIX to the nth power). scalbln
is the same as scalbn, except that its second parameter has type long int
instead of int.

Power and Absolute Value Functions

double cbrt (double x);
float cbrtf(float x);
long double cbrtl (long double x);

float fabsf (float x); see fabs
long double fabsl (long double x); see fabs

double hypot (double x, double y);
float hypotf (float x, float y);
long double hypotl(long double x, long double y);

float powf (float x, float y); see pow
long double powl (long double x,

long double y); see pow
float sqrtf(float x); See sqrt
long double sqgrtl(long double x); see sqrt

Several functions in this group are new versions of old ones (fabs, pow, and
sqgxrt). Only the functions cbrt and hypot (and their variants) are entirely new.

The cbrt function computes the cube root of its argument. The pow function
can also be used for this purpose, but pow is unable to handle negative arguments
606 Chapter 23  Library Support for Numbers and Character Data

hypot

erf
erfc

lgamma
tgamma

QzA

(a domain error oceurs). ebrt, on the other hand, is defined for both positive and
negative arguments. When its argument is negative, cbr L returns a negalive result,

‘When applied to arguments x and y. the hypot function returns /2 + y2. In
other words, this function computes the hypotenuse of a right triangle with legs x
and y.

Error and Gamma Functions

double erf (double x);
float erff(float x);
long double erfl (long double x);

double erfc(double x);
float erfef(float x);
long double erfcl(long double x);

double lgamma(double x);
float lgammaf(float x);
long double lgammal (long double x);

double tgamma(double Xx);
float tgammaf (float x);
long double tgammal (long double x);

The exf function computes the error function erf (also known as the Gaussian
error function), which is used in probability, statistics and partial differential
equations. The mathematical definition of erf is

-
erf(x) = l’_f{’ dr
N0

erfc computes the complementary error function, erfe(x) = | — erf(x).

The gamma function T is an extension of the factorial function that can be
applied to real numbers as well as to integers. When applied to an integer n, T'(n) =
(n=1)!; the definition of " for nonintegers is more complicated. The tgamma func-
tion computes I'. The 1gamma function computes In(IF(x))), the natural logarithm
of the absolute value of the gamma function. 1gamma can sometimes be more use-
ful than the gamma function itself, because I" grows so quickly that using it in cal-
culations may cause overflow.

Nearest Integer Functions

float ceilf (float x); see ceil
long double ceill (long double x) ; see ceil
float floorf(float x); see floor

long double floorl(long double x); see floor
nearbyint
rint

Irint
Mirint

round

23.4 The <math.h> Header (C99): Mathematics 607

double nearbyint(double x);
float nearbyintf (float x);
long double nearbyintl(long double x);

double rint (double x);
float rintf(float x);
long double rintl (long double x);

long int lrint (double x);

long int lrintf(float x);

long int lrintl(long double X);

long long int llrint(double x);

long long int llrintf(float x);

long long int 1lrintl (long double x);

double round (double x);
float roundf (float x);
long double roundl (long double x);

long int Ilround (double x);

long int lroundf(float x);

long int lroundl (long double x);

long long int llround(double x);

long long int llroundf (fleat x);

long long int llroundl (long double x);

double trunc (double x);
float truncf(float X);
long double truncl(long double x);

Besides additional versions of ceil and floor, C99 has a number of new func-
tions that convert a floating-point value to the nearest integer. Be careful when
using these functions: although all of them return an integer, some functions
return it in floating-point format (as a float, double, or long double
value) and some return it in integer format (as a long int or long long int
value).

The nearbyint function rounds its argument to an integer, returning it as a
floating-point number. nearbyint uses the current rounding direction and does
not raise the inexact floating-point exception. rint is the same as nearbyint,
except that it may raise the inexact floating-point exception if the result has a dif-
ferent value than the argument.

The 1rint function rounds its argument to the nearest integer, according to
the current rounding direction. 1xint returns a long int value. 11rint is the
same as 1rint, except that it returns a Long long int value.

The round function rounds its argument to the nearest integer value, return-
ing it as a floating-point number. round always rounds away from zero (so 3.5 is
rounded to 4.0, for example).
608 Chapter 23  Library Support for Numbers and Character Data

Iround
liround

trunc

remainder

remquo

The 1round function rounds its argument to the nearest integer value, return-
ing it as a long int value. Like round, it rounds away from zero. 11round is
the same as 1round, except that it returns a long long int value.

The trunc function rounds its argument to the nearest integer not larger in
magnitude. (In other words, it truncates the argument toward zero.) trunc returns
the result as a floating-point number.

Remainder Functions

float fmodf (float x, float y); see fmod
long double fmodl(long double X,
long double y); see fmod

double remainder(docuble x, double y);

float remainderf (float x, float y);

long double remainderl (long double x,
long double y);

double remguo(double x, double y, int *gquo);

float remguof (float x, float y, int *quo);

long double remquol (long double x, long double y,
int #*quo);

Besides additional versions of fmod. this category includes new remainder func-
tions named remainder and remquo.

The remainder function returns x REM y, where REM is a function defined
in the IEEE standard. For y # 0, the value of x REM y is r = x — ny, where n is the
integer nearest the exact value of x /y. (If x/y is halfway between two integers, n
is even.) If » = 0, it has the same sign as x.

The remguo function returns the same value as remainder when given the
same first two arguments. In addition, remgquo modifies the object pointed to by
the quo parameter so that it contains z low-order bits of the integer quotient Ix/vl,
where n depends on the implementation but must be at least three. The value stored
in this object will be negative if x /v < 0.

Manipulation Functions

double copysign(double x, double y);
float copysignf (float x, float y):
long double copysignl(long double x, long double y);

double nan(const char *tagp);
float nanf (const char *tagp);
long double nanl (const char *tagp);

double nextafter (double x, double y);
float nextafterf (float x, float y);
copysign

nan

sLeLod function >26.2

nextafter

nexttoward

234 The <math.h> Header (C99): Mathematics ~ 609

long double nextafterl (long double x, long double y);

double nexttoward(double x, long double y);
float nexttowardf (float x, long double y);
long double nexttowardl (long double x,

long double y);

The mysteriously named “manipulation functions" are all new in C99. They pro-
vide access to the low-level details of floating-point numbers.

The copysign function copies the sign of one number to another number.
The call copysign (x, y) returns a value with the magnitude of x and the sign
of y.

The nan function converts a string to a NaN value. The call nan ( "n-char-
sequence") is equivalent to strtod ("NAN (n-char-sequence) ", (char**)
NULL) . (See the discussion of strtod for a deseription of the format of »#-char
sequence.) The call nan (" ") is equivalent to strtod ("NAN ()", (char**)
NULL). If the argument in a call of nan doesn’t have the value "n-char-
sequence" or " ", the call is equivalent to strtod ("NAN", (char**) NULL).
If quiet NaNs aren’t supported, nan returns zero. Calls of nanf and nanl are
equivalent to calls of strtof and strtold, respectively. This function is used
to construct a NaN value containing a specific binary pattern. (Recall from earlier
in this section that the fraction part of a NaN value is arbitrary.)

The nextafter function determines the next representable value of a num-
ber x (if all values of x’s type were listed in order, the number that would come
just before or just after x). The value of y determines the direction: if y < x, then
the function returns the value just before x; if x < v, it returns the value just after x.
If x and y are equal, nextafter returns y.

The nexttoward function is the same as nextafter, except that the y
parameter has type long double instead of double, If x and y are equal,
nexttoward returns y converted to the function’s return type. The advantage of
nexttoward is that a value of any (real) floating type can be passed as the second
argument without the danger of it being incorrectly converted to a narrower type.

Maximum, Minimum, and Positive Difference Functions

double fdim{double x, decuble y);
float fdimf(float x, fleat y);
long double fdiml (long double x, long double y);

double fmax(double x, dcuble y);
float fmaxf (float x, fleoat y);
long double fmaxl (long double x, long double y);

double fmin(double x, double y);
float fminf (float x, flocat y);
long double fminl (long double x, long double y);

610

Chapter 23  Library Support for Numbers and Character Data

fdim

fmax
fmin

fma

The fdim function computes the positive difference of x and y:

x-y ifx>y
+0 ifx<y

The fmax function returns the larger of its two arguments. ffmin returns the
value of the smaller argument.

Floating Multiply-Add

double fma(double x, double y, double z);

float fmaf(float x, float y, float z);

long double fmal(long double x, long double y,
long double z);

The fma function multiplies its first two arguments, then adds the third argument.
In other words, we could replace the statement

a=b*ca+d;
with
a = fma(b, c, d);

This function was added to C99 because some newer CPUs have a “fused multi-
ply-add” instruction that both multiplies and adds. Calling fma tells the compiler
to use this instruction (if available), which can be faster than performing separate
multiply and add instructions. Moreover, the fused multiply-add instruction per-
forms only one rounding operation, not two, so it may produce a more accurate
result. It's particularly useful for algorithms that perform a series of multiplications
and additions, such as the algorithms for finding the dot product of two vectors or
multiplying two matrices.

To determine whether calling the fma function is a good idea, a C99 program
can test whether the FP_FAST FMA macro is defined. If it is, then calling fma
should be faster than—or at least as fast as—performing separate multiply and add
operations. The FP_FAST FMAF and FP_FAST FMAL macros play the same
role for the fmaf and fmal functions, respectively.

Performing a combined multiply and add is an example of what the C99 stan-
" where two or more mathematical operations are combined
and performed as a single operation. As we saw with the fma function, contraction
often leads to better speed and greater accuracy. However, programmers may wish
to control whether contraction is done automatically (as opposed to calls of fma,
which are explicit requests for contraction), since contraction can lead to slightly
different results, In extreme cases, contraction can avoid a float-point exception
that would otherwise be raised.

#pragma directive > 74.5

isgreater
isgreaterequal
isless
islessequal

Islessgreater

isunordered

234 The <math.h> Header (C99): Mathematics ~ 611

C99 provides a pragma named FP_CONTRACT that gives the programmer
control over contraction. Here's how the pragma is used:

#pragma STDC FP_CONTRACT on-off-switch

The value of on-off-switch is either ON, OFF, or DEFAULT. If ON is selected, the
compiler is allowed to contract expressions: if OFF is selected, the compiler is pro-
hibited from contracting expressions. DEFAULT is useful for restoring the default
setting (which may be either ON or OFF). If the pragma is used at the outer level of
a program (outside any function definitions), it remains in effect until a subsequent
FP_CONTRACT pragma appears in the same file, or until the file ends. If the
pragma is used inside a compound statement (including the body of a function), it
must appear first, before any declarations or statements; il remains in effect until
the end of the statement, unless overridden by another pragma. A program may
still call fma to perform an explicit contraction even when FP_CONTRACT has
been used to prohibit automatic contraction of expressions.

Comparison Macros

int isgreater (real-floating x, real-floating y) ;

int isgreaterequal (real-floating x, real-floating y) ;
int isless (real-floating x, real-floating y) ;

int islessequal (real-floating x, real-floaiing y) ;
int islessgreater (real-floating x, real-floating y) ;
int isunordered (real-floating x, real-floaiing y) ;

Our final category consists of function-like macros that compare two numbers.
These macros are designed to accept arguments of any real floating type.

The comparison macros exist because of a problem that can arise when float-
ing-point numbers are compared using the ordinary relational operators such as <
and >. If either operand (or both) is a NaN, such a comparison may cause the
invalid floating-point exception to be raised. because NaN values—unlike other
floating-point values—are considered to be unordered. The comparison macros
can be used to avoid this exception. These macros are said to be “quiet” versions of
the relational operators because they do their job without raising an exception.

The isgreater, isgreaterequal, isless, and islesseqgual mac-
ros perform the same operation as the >, >=, <, and <= operators, respectively,
except that they don’t cause the invalid floating-point exception to be raised when
the arguments are unordered.

The call islessgreater (x, y) is equivalent to (x) < (y) || (x) >

(y), except that it guarantees not to evaluate x and y twice, and—like the previ-
ous macros—doesn’t cause the invalid floating-point exception to be raised when
x and y are unordered

The isunordered macro returns | if its arguments are unordered (at least

one of them is a NaN) and 0 otherwise.
612

Chapler 23  Library Support for Numbers and Character Data

23.5

locales >25.1

The <ctype.h> Header: Character Handling

The «<ctype. h> header provides two kinds of functions: character-classification
functions (like isdigit, which tests whether a character is a digit) and character
case-mapping functions (like toupper, which converts a lower-case letter to
upper case).

Although C doesn’t require that we use the functions in <ctype . h> to test
characters and perform case conversions, it’s a good idea to do so. First, these
functions have been optimized for speed (in fact, many are implemented as mac-
10s). Second, we’ll end up with a more portable program, since these functions
work with any character set. Third, the <ctype.h> functions adjust their behav-
ior when the locale is changed, which helps us write programs that run properly in
different parts of the world.

The functions in <ctype.h> all take int arguments and return int val-
ues. In many cases, the argument is already stored in an int variable (often as a
result of having been read by a call of fgetc, getc, or getchar). If the argu-
ment has char type, however, we need to be careful. C can automatically con-
vert a char argument to int type; if char is an unsigned type or if we're
using a seven-bit character set such as ASCII, the conversion will go smoothly.
But if chay is a signed type and if some characters require eight bits. then con-
verting such a character from char to int will give a negative result. The be-
havior of the <ctype . h> functions is undefined for negative arguments (other
than EOF), potentially causing serious problems. In such a situation, the argu-
ment should be cast to unsigned char for safety. (For maximum portability,
some programmers always cast a char value to unsigned char when pass-
ing it to a <ctype . h> function.)

Character-Classification Functions

int isalnum(int
int isalpha (int
int isblank(int c
int iscntrl (int c
int isdigit (int c
int isgraph(int c
int islower(int c
int isprint(int c
int ispunct(int c)
int isspace(int c)
int isupper(int c);
int isxdigit(int c);
Table 23.10
Character-Classification
Functions

D

PROGRAM

telassify.c

235 The <ctype.h~ Header: Character Handling 613

Each character-classification function returns a nonzero value if its argument has a
particular property. Table 23.10 lists the property that each function tests.

Function Test
isalnum(c)  Isc alphanumeric?
isalpha(c) Is c alphabetic?
isblank(c) Is c a blank?"

isentrl (c) Is c a control charueter?’

isdigit(c) Is c a decimal digit?

isgraph (c) Is c a printing character (other than a space)?
islower (c) Is c a lower-case letter?

isprint(c) Is c a printing character (including a space)?
ispunct (c)  Isc punctuation?'"!

isspace(c) Is c a white-space character?' !

isupper (c) Is c an upper-case letter?

isxdigit(e) Is c a hexadecimal digit?

"Ihe standard blank characters are space and horizontal tab (\t ). This
function is new in C99,

#11n ASCIL the control characters are \x00 through \x1f plus \x7f.
T7All printing characters except those for which isspace or i salnum
are true are considered punctuation.

7" The white-space characters are space, form feed (\ f), new-line (\n),
iage return (\ ), horizontal tab (\t), and vertical tab (\v),

o

The C99 definition of ispunct is slightly different than the one in C89. In
C89, ispunct (cc) tests whether c is a printing character but not a space or a
character for which isalnum(c) is true. In C99, ispunct (c) tests whether
c is a printing character for which neither isspace (c) nor isalnum(c) is
true.

Testing the Character-Classification Functions

The following program demonstrates the character-classification functions (with
the exception of isblank, which is new in C99) by applying them to the charac-
ters in the string "azAZ0 [\t".

/* Tests the character-classification functions */

#include <ctype.h>
#include <stdio.h>

jdefine TEST(L) printf(W 4c W, f(*p) 2 Ix! 1 1)
int main(void)
char *p;
printf (" alnum cntrl graph print"
L space xdigit\n"

" alpha digit lower punct "
" upper\n") ;
614

Chapter 23  Library Support for Numbers and Character Data

tolower
toupper

PROGRAM

for (p = "azaz0 i\t"; *p i= '\0'; Dp++) (
if (isentrl (*p))
printf (*\\x%02x:", *p);
else
printf("  %c:v, *p);
TEST (isalnum) ;
TEST (isalpha) ;
TEST (iscntrl) ;
TEST (isdigit) ;
TEST (isgraph) ;
TEST (iglower) ;
TEST (isprint) ;
TEST (ispunct) ;
TEST (isspace) ;
TEST (isupper) ;
TEST (isxdigit) ;
printf ("\n") ;

}
return 0;
)
The program produces the following output:
alnum cntrl graph print space xdigit
alpha digit lower punct upper
at x x x x x
5 T 5 x % x
A x x ES x x x
AL x x x x
0: x x x x x
x x
i x x x
\x09: x x

Character Case-Mapping Functions
int tolewer(int c);
int toupper(int c);

The tolower function returns the lower-case version of a letter passed to it as an
argument, while toupper returns the upper-case version. If the argument to
either function is not a letter, it returns the character unchanged.

Testing the Case-Mapping Functions

The following program applies the case-mapping functions to the characters in the
string "aA0!".
tcasemap.c

23.6

23.6 The <string.h> Header: String Handling

/% Tests the case-mapping functions */

#include <ctype.h>
#include <stdio.hs

int main(void)

(

char *p;

for (p = "aA01"; *p 1= '\0'; pt+] {
printf ("tolower('tc!) is Sc'; v, 4p,
printf("toupper('sc') is 'tc'\n", *p,

)

return 0;

}

The program produces the following output:

tolower('a') is 'a'; toupper('a’) is 'A’
tolower ('A') is 'a'; toupper('A') ig 'A
tolower('0') is '0'; toupper('0') is '0'
tolower('!') is '!'; toupper('!') ie '

tolower (*p)) ;
toupper (*p)) ;

The <string.h> Header: String Handling

615

We first encountered the <string.h> header in Section 13.5, which covered the
most basic string operations: copying strings, concatenating strings, comparing
strings, and finding the length of a string. As we'll see now, there are quite a few
string-handling functions in <string.h>, as well as functions that operate on
character arrays that aren’t necessarily null-terminated. Functions in the latier cate
gory have names that begin with mem, to suggest that these functions deal with
blocks of memory rather than strings. These memory blocks may contain data of
any type, hence the arguments to the mem functions have type void * rather than

char *,
<string.h> provides five kinds of functions:

= Copying functions. Functions that copy characters from one place in memory

to another place.

n Concatenation functions. Functions that add characters to the end of a string.
u Comparison functions. Functions that compare character arrays.
» Search functions. Functions that search an array for a particular character, a

set of characters, or a string.

pute the length of a string.

We'll now discuss these functions, one group at a time.

Miscellaneous functions. Functions that initialize a memory block or com-
616

Chapter 23

memcpy
memrmove

strepy
strnepy

Library Support for Numbers and Character Data
Copying Functions

void *memcpy(void * restrict sl,

const void * restrict s2, size t n)j;
void *memmove(void *sl, const void *s2, size t n);
char *strcpy(char * restrict si,

const char * restrict s2);
char *strncpy(char * restrict si,

const char * restrict s2, size t n);

The functions in this category copy characters (bytes) from one place in memory
(the “source") to another (the “destination"). Each function requires that the first
argument point to the destination and the second point to the source. All copying
functions return the first argument (a pointer to the destination).

memcpy copies n characters from the source to the destination, where n is the
function’s third argument. If the source and destination overlap, the behavior of
memcpy is undefined. memmove is the same as memcpy, except that it works cor-
rectly when the source and destination overlap.

strepy copies a null-terminated string from the source to the destination.
strnepy is similar 10 strcpy, but it won’t copy more than n characters, where
1 is the function’s third argument. (If n is too small, strnepy won't be able to
copy a terminating null character.) If it encounters a null character in the source,
strncepy adds null characters to the destination until it has written a total of n
characters. st repy and strncpy, like memepy, aren’t guaranteed to work if the
source and destination overlap.

The following examples illustrate the copying functions: the comments show
which characters are copied.

chat sonree [)F s Rty o METENG € SEET, de ) atl;
char dest[7];

memcpy (dest, source, 3); J% h, o,k v
memepy (dest, source, 4); /% By ot N0 X/
memcpy (dest, source, 7); /% H, oy t, \0,; &, & a &4
memmove (dest, source, 3); /* h, o, t f/
memmove (dest, source, 4); VA e i 4.
memmove (dest, source, 7); /* h, o, t, \0, t, e, a it
strcpy (dest, source); ik v ona s ] L
strncpy(dest, source, 3); /* h, o, t L
strncpy (dest, source, 4); s, o, XA A
strncpy (dest, source, 7); /* 1., g, t, \0, \0, \0g, \o */

Note that memepy, memmove, and strnepy don’t require a null-terminated
string: they work just as well with any block of memory. The strcpy function, on
the other hand, doesn’t stop copying until it reaches a null character, so it works
only with null-terminated strings.
streat

strncat

23.6 The <string.h> Header: String Handling ~ 617

Section 13.5 gives examples of how strcpy and strncpy are typically
used. Although neither function is completely safe, strncpy at least provides a
way o limit the number of characters it will copy.

Concatenation Functions

char *strcat(char * restrict sil,
const char * restrict s2);
char *strncat(char * restrict sl,
const char * restrict s2, size t n);

strcat appends its second argument to the end of the first argument. Both argu-
ments must be null-terminated strings; strcat puts a null character at the end of
the concatenated string. Consider the following example:

char str[7] = "tea";
strcat (str, "bag"); /* adds b, &, g, \0 to end of stx */

The letter b overwrites the null character atter the a in "tea", so that str now
contains the string "teabag". strcat retumns its first argument (a pointer).

strncat is the same as strcat, except that its third argument limits the
number of characters it will copy:

char str[7] = "tea";

strncat (str, "bag", 2); /* adds b, a, \0 to str */
strnecat (str, "bag", 3); /* adds b, a, g, \0 to str */
strncat (str, "bag", 4); /* adds ‘b, a, g, \0 to str */

As these examples show, strncat always leaves the resulting string properly
null-terminated.

In Section 13.5, we saw that a call of strncat often has the following ap-
pearance:

strncat (strl, str2, sizeof(strl) - strlen(strl) - 1);

The third argument calculates the amount of space remaining in strl (given by
the expression sizeof (strl) - strlen(strl)) and then subtracts 1 to
ensure that there will be room for the null character.

Comparison Functions

int memcmp (const void *sl, const void *s2, size_t n);
int strcmp(const char *sl, const char *s2);
int strecoll (const char *sl, const char *s2);
int strnemp(const char *sl, const char *s2,
aize t m);
size t strxfrm(char * restrict si,
const char * restrict s2, size_t n);
618

Chapter 23  Library Support for Numbers and Characler Dala

ocales 25,1
memcmp
stremp
strnecmp

streoll

strxfrm

The comparison functions fall into two groups. Functions in the first group (mem
cmp, stremp, and strnemp) compare the contents of two character arrays.
Functions in the second group (strcoll and strxfrm) are used if the locale
needs to be taken into account.

The mememp, stremp. and strnemp functions have much in common. All
three expect to be passed pointers to character arrays. The characters in the first
array are then compared one by one with the characters in the sccond array. All
three functions return as soon as a mismatch is found. Also, all three return a nega-
tive, zero, or positive integer, depending on whether the stopping character in the
first array was less than, equal to, or greater than the stopping character in the sec-
ond.

The differences among the three functions have to do with when to stop com-
paring characters if no mismatch is found. The memcmp function is passed a third
argument, i, that limits the number of comparisons performed: it pays no particu-
lar attention to null characters, strcmp doesn’t have a preset limit, stopping
instead when it reaches a null character in either array. (As a result, strcmp
works only with null-terminated strings.) strncmp is a blend of memcmp and
strcmp: it stops when n comparisons have been performed or a null character is
reached in either array.

The following examples illustrate mememp, stremp, and st rncmp:

char s1[]
char s2(]

OSR CHEl Cles B
{'b', 'it, tg', '"\0', 'c', 'a', 't'};

if (memcmp(si,
if (memcmp (81,
if (memcmp(sl,

/* true */
[ true #/
/* false */

if (stremp(sl, s2) == 0) .. /% true */

if (strnemp(sl,
if (strncmp(si, s2, 4)
if (strncmp(sl, s2, 7)

82, 3) == 0) .. /* true */
0) — /% trus &/
0) S K Erue S )

The strcoll function is similar to strcmp, but the outcome of the compar-
ison depends on the current locale.

Most of the time, strcoll is fine for performing a locale-dependent string
comparison. Occasionally, however, we might need to perform the comparison
more than once (a potential problem, since strcoll isn't especially fast) or
change the locale without affecting the outcome of the comparison. In these situa-
tions, the strxfrm (“string transform”) function is available as an alternative to
strcoll.

strxfrm transforms its second argument (a string), placing the result in the
array pointed to by the first argument. The third argument limits the number of
characters written to the array, including the terminating null character. Calling
stremp with two transformed strings should produce the same outcome (nega-
tive, zero, or positive) as calling stxrcoll with the original strings.
strchr

memchr

23.6 The <string.h> Header: String Handling ~ 619

strxfrm returns the length of the transformed string. As a result, it’s typi-
cally called twice: once to determine the length of the transformed string and once
to perform the transformation. Here’s an example:

sige t len;
char *transformed;

len = strxfrm(NULL, original, 0);
transformed = malloc(len + 1);
strxfrm(transformed, original, len);

Search Functions

void *memchr (const veid *s, int c, size t n);
char *strchr(const char *s, int c);
size_t strcspn(const char *sl, const char *s2);
char *strpbrk(const char *sl, const char *s2);
char *strrchr(const char *s, int c);
size_t strspn(const char %sl, const char *s2);
char *strstr(const char *sl1, const char *s2);
char *strtok(char * restrict si,

const char * restrict s2);

The strchr function searches a string for a particular character. The following
example shows how we might use strchr to search a string for the letter f.

char *p, stx[] = "Form follows function.';
p = strchr(str, 'f'); /* finds first 'ff' %/

strchr returns a pointer to the first occurrence of f in stx (the one in the word
follows). Locating multiple occurrences of a character is easy; for example, the
call

P = strehre(p 1, fEr): /* finds next 'f' */

finds the second f in stx (the one in function). If it can’t locate the desired
character, st rchr returns a null pointer.

memchr is similar to strchr, but it stops searching after a set number of
characters instead of stopping at the first null character. memchx’s third argument
limits the number of characters it can examine—a useful capability if we don’t
want to search an entire string or if we're searching a block of memory that’s not
terminated by a null character. The following example uses memchr to search an
array of characters that lacks a null character at the end:

char *p, str([22] = "Form follows function.";

p = memchr(str, 'f', sizeof (str));
620

Chapter 23  Library Support for Numbers and Character Data

strrchr

strpbrk

strspn
strespn

strstr

striok

Like the strchr function, memchr returns a pointer to the first occurrence of the
character. If it can’t find the desired character, memchr returns a null pointer.
strrchr is similar to strchr, but it searches the string in reverse order:

char *p, str[] = "Form follows function.";
p = strrchr(str, 'f'); /* finds last 'f' */

In this example, strrchr will first search for the null character at the end of the
string, then go backwards to locate the letter f (the one in function). Like
strchr and memchr, strrchr returns a null pointer if it fails to find the
desired character.

strpbrk is more general than strchr; it returns a pointer to the leftmost
character in the first argument that matches any character in the second argument:

char +p, str(] = "Form follows function.";
p = strpbrk(str, "mn*); /* finds first 'm' or 'n' */

In this example, p will point to the letter m in Form. strpbrk returns a null
pointer if no match is found.

The strspn and strcspn functions, unlike the other search functions,
return an integer (of type size_t), representing a position within a string. When
given a string to search and a set of characters to look for, strspn returns the
index of the first character that's not in the set. When passed similar arguments,
strcspn returns the index of the first character that’s in the set. Here are exam-
ples of both functions:

size_t n;
char str[] = "Form follows function.";

n = strspn(str, "morF"); /*n =4 %/
n = strspn(str, " \t\n"); /*n =0 %/
n = strcspn(str, "morf"); Yxin mtgiay
n = strespn(str, " \t\n"); /* n =4 %/

strstr searches its first argument (a string) for a match with its second
argument (also a string). In the following example, strstr searches for the word
fun:

char *p, str(] = "Form follows function.
p = strstr(str, "fum"); /* locates "fun" in str */

strstr returns a pointer to the first occurrence of the search string; it returns a
null pointer if it can’t locate the string. After the call above, p will point to the let-
ter f in function.

strtok is the most complicated of the search functions. It’s designed to
search a string for a “token”—a sequence of characters that doesn’t include certain
delimiting characters. The call strtok (s1, s2) scans the s1 string for a non-
empty sequence of characters that are not in the s2 string. stxtok marks the end
23.6 The <string.h> Header: String Handling 621

of the token by storing a null character in s1 just after the last character in the
token; it then returns a pointer to the first character in the token.

What makes strtok especially useful is that later calls can find additional
tokens in the same string. The call strtok (NULL, s2) continues the search
begun by the previous strtok call. As before, strtok marks the end of the
token with a null character, then returns a pointer to the beginning of the token.
The process can be repeated until strtok returns a null pointer, indicating that no
token was found.

To see how st rtok works, we'll use it to extract a month, day, and year from
a date written in the form

month day, year

where spaces and/or tabs separate the month from the day and the day from the
vear. In addition, spaces and tabs may precede the comma, Let’s say that the string
str has the following appearance to start with:

After the call
p = strtok(str, " \t");

str will have the following appearance:

L]

p points to the first character in the month string, which is now terminated by a
null character. Calling st tok with a null pointer as its first argument causes it to
resume the search from where it left off:

p = strtok(NULL, " \t,");

After this call, p points to the first character in the day:

str

A final call of strtok locates the year:

p = BLrtok(NULL, " \t"):
622

Chapter 23  Library Support for Numbers and Character Data

memset

strlen

strerror function »24.2

After this call, stx will have the following appearance:

When strtok is called repeatedly to break a string into tokens, the second argu-
ment isn’t required to be the same in each call. In our example, the second call of
strtok has the argument " \t, " insteadof " \t",

strtok has several well-known problems that limit its usefulness; I'll men-
tion just a couple. First, it works with only one string at a time; it can’t conduct
simultaneous searches through two different strings. Also, strtok treats a
sequence of delimiters in the same way as a single delimiter, making it unsuitable
for applications in which a string contains a series of fields separated by a delimiter
(such as a comma) and some of the fields are empty.

Miscellaneous Functions

void *memset(void *s, int c, size t n);
size_t strlen(const char *s);

memseL stores multiple copies of a character in a specified area of memory. If p
points to a block of N bytes, for example, the call

memset(p, ' ', N);

will store a space in every byte of the block. One of memset’s uses is initializing
an array to zero bits:

memset (a, 0, sizeof(a));

memset returns its first argument (a pointer).

strlen returns the length of a string, not counting the null character. See
Section 13.5 for examples of strlen calls.

There’s one other miscellaneous string function, strerror, which is coy-
ered along with the cerrno. h> header,

Q&A

Why does the expml function exist, since all it does is subtract 1 from the
value returned by the exp function? [p. 605]

When applied to numbers that are close to zero, the exp function returns a value
that’s very close to 1. The result of subtracting 1 from the value returned by exp
may not be accurate because of round-off error. expm1 is designed to give a more
aceurate result in this situation.
Section 23.3

o

L.

Exercises 623

The 1og1lp function exists for a similar reason. For values of x that are close
to zero, loglp (x) should be more accurate than 1og (1 + x) .

Why is the function that computes the gamma function named tgamma
instead of just gamma? [p. 606]

At the time the C99 standard was being written, some compilers provided a func-
tion named gamma, but it computed the log of the gamma function. This function
was later renamed 1gamma. Choosing the name gamma for the gamma function
would have conflicted with existing practice, so the C99 committee decided on the
name tgamma (“true gamma’) instead.

Why does the deseription of the nextafter function say that if x and y are
equal, nextafter returns y? If x and y are equal, what’s the difference
between returning x or y? [p. 609]

Consider the call nextafter(-0.0, +0.0), in which the arguments are
mathematically equal. By returning y instead of x, the function has a return value
of +0.0 (rather than -0.0, which would be counterintuitive). Similarly, the call
nextafter (+0.0, -0.0) returns -0.0.

‘Why does <string.h> provide so many ways to do the same thing? Do we
really need four copying functions (memcpy, memmove, strcpy, and
strncpy)? [p. 616]

Let’s start with memcpy and strcpy. These functions are used for different pur-
poses. strepy will only copy a character array that's terminated with a null char-
acter (a string, in other words); memcpy can copy a memory block that lacks such
a terminator (an array of integers, for example).

The other functions allow us to choose between safety and performance.
strnepy is safer than st repy, since it limits the number of characters that can be
copied. We pay a price for safety, however, since strncpy is likely to be slower
than strepy. Using memmove involves a similar trade-off. memmove will copy
bytes from one region of memory into a possibly overlapping region. memcpy isn’t
guaranteed to work properly in this situation; however, if we can guarantee no over-
lap, memcpy is likely to be faster than memmove.

Why does the strspn function have such an odd name? [p. 620]

Instead of thinking of strspn’s return value as the index of the first character
that's not in a specified set, we could think of it as the length of the longest “span”
of characters that are in the set.

Exercises

Extend the round_nearest function so that it rounds a floating-point number x to n dig-
its afler the decimal point. For example, the call round nearest (3.14159, 3) would
624  Chapter 23 Library Support for Numbers and Character Data

Section 23.4

Section 23.5

Section 23.6

o 6

@ 10.

return 3.142. Hint: Multiply x by 10", round to the nearest integer, then divide by 10”. Be
sure that your function works correctly for both positive and negative values of x.

(C99) Write the following function:
double evaluate polynomial (double a(], int n, double x);

The function should return the value of the polynomial @, " + a,_ ' + ... + a,, where the
a;'s are stored in corresponding elements of the array a, which has length n + 1. Have the
function use Homer’s Rule to compute the value of the polynomial

(o ((@X + Gy )X+ @y )X+ DX+ ag)x +ag
Use the fma function to perform the multiplications and additions.

(C99) Check the documentation for your compiler to s
mietic expressions and, if so, under what circumstances.

if it performs contraction on arith-

Using isalpha and isalnum, write a function that checks whether a string has the syn-
tax of a C identifier (it consists of letters, digits, and underscores, with a letter or underscore
at the beginning).

Using isxdigit, write a function that checks whether a string represents a valid hexadec-
imal number (it consists solely of hexadecimal digits). If so, the function returns the value of
the number as a Long int. Otherwise, the function returns —1.

In each of the following cases, indicate which function would he the best to use: memepy,
memmove, strepy, or strnepy. Assume that the indicated action is to be performed by a
single function call,

(a) Moving all elements of an array “down” one position in order to leave room for a new
element in position 0,

(b) Deleting the first character in a null-terminated string by moving all other characters
back onc position.

(c) Copying a string into a character array that may not be large enough to hold it, If the
array is too small, assume that the string is to be truncated; no null character is ncees-
sary at the end.

(d) Copying the contents of one array variable into another.

Section 23.6 explains how to call strchr repeatedly to locate all oceurrences of a charac-
ter within a string. Is it possible to locate all occurrences in reverse order by calling
strrchr repeatedly?

Use strchr to write the following function:

int numchar (const char *s, char ch);

numchax returns the number of times the character ch occurs in the string s.

Replace the test condition in the following if statement by a single call of strchr:
if (ch == 'a' || ch == 'b! || ch == ‘tc!)

Replace the test condition in the following `if` statement by a single call of straty:

if (strcmpl(str, "foo") 0 || strcmp(str, "bar") == 0 ||
strcmp(str, "baz") == 0) ..

Hint: Combine the string literals into a single string, separating them with a special charac-
ter. Does your solution assume anything about the contents of str?
@ 1.

Programming Projects 625

‘Write a call of memeet that replaces the last nn characters in a null-terminated string s with
| characters.

Many versions of <string.h> provide additional (nonstandard) functions, such as those
listed below. Write each function using only the features of the C standard.

(a) strdup (g) — Returns a pointer to a copy of s stored in memory obtained by calling
malloc. Returns a null pointer if enough memory couldn’t be allocated.

(b) stricmp(sl, s2) — Similar to stremp, but ignores the case of letters.

(c) strlwr (s) — Converts upper-case letters in s to lower case, leaving other characters
unchanged; returns s.

(d) strrev(s) — Reverses the characters in s (except the null character); returns s.

(e) strset (s, ch) —Fills s with copies of the character ch; returns s.

If you test any of these functions, you may nced to alter its name. Functions whose names

begin with st are reserved by the C standard.

Use strtok to write the following function:
int count_words (char *sentence);

count_words returns the number of words in the string sentence, where a “word” is
any sequence of non-white-space characters. count words is allowed to modify the
string.

Programming Projects
‘Write a program that finds the roots of the equation c + bx + c = 0 using the formula

_ —bt/b2—4ac

2a

G

Have the program prompt for the values of a, b, and c, then print both values of x. (If b2
4ac is negative, the program should instcad print a message to the effect that the roots are
complex.)

‘Write a program that copies a text file from standard input to standard output, removing all
white-space characters from the beginning of each line. A line consisting entirely of white-
space characters will not be copied.

Write a program that copies a text file from standard input to standard output, capitalizing
the first letter in each word.

Write a program that prompts the user to enter a series of words separated by single spaces,
then prints the words in reverse order. Read the input as a string, and then use strtok to
break it into words.

Suppose that money is deposited into a savings account and left for 7 years. Assume that the
annual interest rate is » and that interest is compounded continuously. The formula A(z) =
Pe" can be used to calculate the final value of the account, where P is the original amount
deposited. For example, $1000 left on deposit for 10 years at 6% interest would be worth
$1000 x e"10 = j1000 x e® = $1000 x 1.8221188 = $1,822.12. Write a program that dis-
plays the result of this calculation after prompting the user to enter the original amount
deposited, the interest rate, and the number of years.
626  Chapter 23 Library Support for Numbers and Character Data

6.

Write a program that copies a text file from standard input to standard output, replacing each
control character (other than \n) by a question mark.

Write a program that counts the number of sentences in a text file (obtained from standard
input). Assume that each sentence ends with a ., 2, or ! followed by a white-space charac-
ter (including \n).
24

Error Handling

There are two ways to wiite error-free
programs; only the third one works.

Although student programs often fail when subjected to unexpected input, com-
mercial programs need to be “bulletproof”—able to recover gracefully from errors
instead of crashing. Making programs bulletproof requires that we anticipate
errors that might arise during the execution of the program, include a check for
each one, and provide a suitable action for the program to perform if the error
should occur.

This chapter describes two ways for programs to check for errors: by using
the assert macro and by testing the errno variable. Section 24.1 covers the
<assert.h> header, where assert is defined. Section 24.2 discusses the
<errno.h> header, to which the errno variable belongs. This section also
includes coverage of the perror and strerror functions. These functions,
which come from <st@io.h> and <string.hs, respectively, are closely re-
lated to the exrno variable.

Section 24.3 explains how programs can detect and handle conditions known
as signals, some of which represent errors. The functions that deal with signals are
declared in the <signal.h> header.

Finally, Scction 24.4 explores the setjmp/longjmp mechanism, which is
often used for responding to errors. Both setjmp and longjmp belong to the
<setjmp.h> header.

Error detection and handling aren’t among C's strengths. C indicates run-time
errors in a variety of ways rather than in a single, uniform way. Furthermore, it’s
the programmer’s responsibility to include code to test for errors. IU's easy to over-
look potential errors; if one of these should actually occur, the program often con
tinues running, albeit not very well. Newer languages such as C++, Java, and C#
have an “exception handling” feature that makes it easier to detect and respond to
erTors.

627
628

Chapter 24  Error Handling

241

assert

stdery stream »22.1
abort function »26.2

The <assert.h> Header: Diagnostics

void assert (scalar expression) ;

assert, which is defined in the cassert . 1> header, allows a program to mon-
itor its own hehavior and detect possible problems at an early stage.

Although assert is actually a macro, it's designed to be used like a func-
tion. It has one argument, which must be an “assertion”—an expression that we
expect to be truc under normal circumstances. Each time assext is executed, it
tests the value of its argument. If the argument has a nonzero value, assert does
nothing. If the argument’s value is zero, assert wriles a message to stderr
(the standard error stream) and calls the abort function to terminate program
execution.

For example, let’s say that the file demo. c declares an array a of length 10.
We're concerned that the statement

ali]l = o;

in demo . c might cause the program to fail because i isn’t between 0 and 9. We
can use assert to check this condition beforc we perform the assignment to
alil:

assert (0 <= i && i < 10); /* checks subscript first */

alil =.0; /* now does the assignment */

If 1’ value is less than 0 or greater than or equal to 10, the program will terminate
after displaying a message like the following one:

Zesertion failed: 0 <= i && i < 10, file demo.c, line 109

C99 changes assert in a couple of minor ways. The C89 standard states that
the argument to assert must have int type. The C99 standard relaxes this
requirement, allowing the argument to have any scalar type (hence the word scalar
in the prototype for assert). This change allows the argument to be a floating-
point number or a pointer, for example. Also, C99 requires that a failed agsers
display the name of the function in which it appears. (C89 requires only that
assert display the argument—in text form—along with the name of the source
file and the source line number). The suggested form of the message is

Assertion failed: expression, function abe, file xyz, line nnn.

The exact form of the message produced by assert may vary from one com-
piler to another, although it should always contain the information required by the
ndard. For example, the GCC compiler produces the following message in the
uation described earlier:

a.out: demo.c:109: main: Assertion "0 <= i && i < 10' failed.
24.2

Ivalues >4.2

Aert: function »23.3

24.2 The <errno.h> Header: Errors 629

assert has one disadvantage: it slightly increases the running time of a pro-
gram because of the extra check it performs. Using assert once in a while prob-
ably won't have any great effect on a program’s speed, but even this small time
penalty may be unacceptable in critical applications. As a result, many program-
mers use assert during testing, then disable it when the program is finished.
Disabling assert is easy: we need only define the macro NDEBUG prior to
including the <assert . h> header:

#define NDEBUG
#include <assert.h>

The value of NDEBUG doesn’t matter, just the fact that it’s defined. If the program
should fail later, we can reactivate assert by removing NDEBUG's definition.

Avoid putting an expression that has a side effect—including a function call
inside an assert: if assert is disabled at a later date, the expression won't be
evaluated. Consider the following example:

assert ((p = mallcc(n)) != NULL);

If NDEBUG is defined, assert will be ignored and malloc won't be called.

The <errno.h> Header: Errors

Some functions in the standurd library indicate failure by storing an error code (a
positive integer) in errno, an int variable declared in <exrno.h>. (errno
may actually be a macro. If so, the C standard requires that it represent an Ivalue,
allowing us to use it like a variable.) Most of the functions that rely on errno
belong to <math . h>, but there are a few in other parts of the library.

LeU’s say that we need to use a library function that signals an error by storing
a value in errno. After calling the function, we can check whether the value of
errno is nonzero; if so, an error occurred during the function call. For example,
suppose that we want to check whether a call of the sqrt (square root) function
has failed. Here's what the code would look like:

errno = 0;

y = sgrt(x);

if (erzmo != 0) {
fprintf (stderr, 'sgrt error; program terminated.\n") ;
exit (EXIT_FATIURE) ;

}

When errno is used to detect an error in a call of a library [unction, it’s important
to store zero in errnao before calling the function. Although errno is zero at the
beginning of program execution, it could have been altered by a later function call.
Library functions never clear exrno; that’s the program’s responsibility.

630

Chapter 24  Error Handling

exp function »23.5

(Coo)

<wchax . h> header >25.5
encoding error >22.3

perror

stdery stream »22.1

The value stored in errno when an error oceurs is often either EDOM or
ERANGE. (Both are macros defined in <errno.h>.) These macros represent the
two kinds of errors that can occur when a math function is called:

u Domain errors (EDOM): An argument passed to a function is outside the func-
tion's domain. For example, passing a negative number to sgrt causes a
domain error.

u Range errors (ERANGE): A function’s return value is too large to be repre-
sented in the function’s return type. For example, passing 1000 to the exp
function usually causes a range error, because c'° is too large to represent as
a double on most computers.

Some functions can experience both kinds of errors; by comparing errno to
EDOM or ERANGE, we can determine which crror occurred.

C99 adds the E1LSEQ macro to <errno.hs. Library functions in certain
headers—especially the <wchar.hs header—store the value of ETLSEQ in
errno when an encoding error oceurs.

The perror and strerror Functions

void perror (const char *s
char *strerror (int errnum

)3 from <stdio.h>
) s Jfrom <string.h>
We'll now look at two functions that are related to the exrrno variable, although
neither function belongs to <errno.hs.

‘When a library function stores a nonzero value in errno, we may want o
display a message that indicates the nature of the error. One way to do this is to call
the perror function (declared in <stdio.hs), which prints the following
items, in the order shown: (1) its argument, (2) a colon, (3) a space, (4) an error
message determined by the value of exrrno, and (5) a new-line character. perror
writes to the stderr stream, not to standard output.

Here's how we might use perror:

errnc - 0;

y = sqrt(x);

if (errno != 0)
perror ("sgrt error');
exit (EXIT FAILURE) ;

If the call of sqrt fails because of a domain error, perror will generate the fol-
lowing output:

sgrt error: Numerical argument cut of domain

The error message that perror displays after sqrt error is implementation-
defined. In this example, Numerical argument out of domain is the mes-
strerror

24.3

24.3 The <signal.h> Header: Signal Handling ~ 631

sage that corresponds to the EDOM error. An ERANGE error usually produces a dif-
ferent message, such as Numerical result out of range.

The strerror function belongs to <string.h>. When passed an error
code, strerror returns a pointer to a string describing the error. For example,
the call

puts (strerror (EDOM) ) ;
might print
Numerical argument out of domain

The argument to strerror is usually one of the values of errno, but
strerror will return a string for any integer passed to it.

strerror is closely related to the perror function. The error message that
perror displays is the same message that strerror would return if passed
errno as its argument.

The <signal.h> Header: Signal Handling

The <signal.h> header provides facilities for handling exceptional conditions,
known as signals. Signals fall into two categories: run-time errors (such as division
by zero) and events caused outside the program. Many operating systems, for
example, allow users to interrupt or kill running programs; these events are treated
as signals in C. When an error or external event occurs, we say that a signal has
been raised. Many signals are asynchronous: they can happen at any time during
program execution, not just at certain points that are known to the programmer.
Since signals may occur at unexpected times, they have to be dealt with in a unique
way.

This section covers signals as they re described in the C standard. Signals play
amore prominent role in UNIX than you might expect from their limited coverage
here. For information about UNIX signals, consult one of the UNIX programming
books listed in the bibliography.

Signal Macros

<signal.h> defines a number of macros that represent signals; Table 24.1 lists
these macros and their meanings. The value of each macro is a positive integer
constant. C implementations are allowed to provide other signal macros, as long as
their names begin with STG followed by an upper-case letter. (UNIX implementa-
tions, in particular, provide a large number of additional signal macros.)

The C standard doesn’t require that the signals in Table 24.1 be raised auto-
matically, since not all of them may be meaningful for a particular computer and
operating system. Most implementations support at least some of these signals
632 Chapter 24  Error Handling

Table 24.1
Signals

signal

abort function »26.2

static siorage curation >18.2

Name Meaning
SIGABRT  Abnormal termination (possibly caused by a call of abort)
SIGFPE Error during an arithmetic operation (possibly division by zero
or overtlow)
SIGILL  Invalid instruction
SIGINT Interrupt
SIGSEGV Invalid storage access
SICTERM Termination request

The signal Function

void (*signal(int sig, void (*func) (int))) (int);

<signal.h> provides two functions: raise and signal. We'll start with
signal, which installs a signal-handling function for use later if a given signal
should occur. signal is much easier to use than you might expect from its rather
intimidating prototype. Its first argument is the code for a particular signal; the sec-
ond argument is a pointer to a function that will handle the signal if it's raised later
in the program. For example, the following call of signal installs a handler for
the STGINT signal:

signal (SIGINT, handler);

handler is the name of a signal-handling function. If the SICINT signal occurs
later during program execution, handlexr will be called automatically.

Every signal-handling function must have an int parameter and a return type
of void. When a particular signal is raised and its handler is called, the handler
will be passed the code for the signal. Knowing which signal caused it to be called
can be useful for a signal handler; in particular, it allows us to use the same handler
for several different signals.

A signal-handling function can do a variety of things. Possibilities include
ignoring the signal, performing some sort of error recovery, or terminating the pro-
gram. Unless it’s invoked by abort or raise. however, a signal handler
shouldn’t call a library function or attempt to use a variable with static storage
duration. (There are a few exceptions to these rules, however.)

If a signal-handling function returns, the program resumes executing from the
point at which the signal occurred, except in two cases: (1) If the signal was
SIGABRT. the program will terminate (abnormally) when the handler returns. (2)
The effect of returning from a function that has handled SIGFPE is undefined. (In
other words, don’t do it.)

Although signal has a return value, it's often discarded. The return value, a
pointer to the previous handler for the specified signal, can be saved in a variable if
desired. In particular, if we plan to restore the original signal handler later, we need
to save signal’s return value:

void (%orig handler) (int); /* function pointer variable */
24.3 The <signal.h> Header: Signal Handling ~ 633

orig handler = signal (SIGINT, handler);

This statement installs handler as the handler for SIGINT and then saves a
pointer to the original handler in the orig_handler variable. To restore the
original handler later, we’d write

signal (SIGINT, orig_handler); /* restores original handler */

Predefined Signal Handlers

Instead of writing our own signal handlers, we have the option of using one of the
predefined handlers that <signal . h> provides. There are two of these, each rep-
resented by a macro:

® SIG DFL. SIG_DFL handles signals in a “default” way. To install
SIG_DFL, we'd use a call such as

signal (STGINT, SIG_DFL); /* use default handler */

The effect of calling SIG_DFL is implementation-defined, but in most cases it
causes program termination.

m SIG IGN. The call
signal (SIGINT, SIG_IGN); /* ignore SIGINT signal */
specifies that STGTNT is to be ignored if it should be raised later.

Tn addition to SIG_DFL and SIG_IGN, the <signal.h> header may provide
other signal handlers; their names must begin with STG_ followed by an upper-
case letter. At the beginning of program execution, the handler for each signal is
initialized to either SIG_DFL or SIG_IGN, depending on the implementation.

<signal.h> defines another macro, SIG_ERR, that looks like it should be
a signal handler. SIG_ERR is actually used to test for an error when installing a
signal handler. If a call of signal is unsuccessful—it can't install a handler for
the specified signal—it returns 3IG ERR and stores a positive value in errno.
Thus, to test whether signal has failed, we could write

if (signal (SIGINT, handler) == STIG_ERR) {
perror ("signal (SIGINT, handler) failed");

}

There’s one tricky aspect to the entire signal-handling mechanism: what hap-
pens if a signal is raised by the function that handles that signal? To prevent infinite
recursion, the C89 standard prescribes a two-step process when a signal is raised
for which a signal-handling function has been installed by the programmer. First,
cither the handler for that signal is reset to SIG_DFL (the default handler) or else
the signal is blocked from occurring while the handler is executing. (SIGILL is a
special case; neither action is required when SIGILL is raised.) Only then is the
handler provided by the programmer called.

634

Chapter 24  Error Handling

A

raise.

PROGRAM

tsignal.c

After a signal has been handled, whether or not the handler needs to be reinstalled
is implementation-defined. UNIX implementations typically leave the signal han-
dler installed afier it’s been used, but other implementations may reset the handler
o STG_DFL. In the latter case, the handler can reinstall itself by calling signal
before it returns.

C99 changes the signal-handling process in a few minor ways. When a signal
is raised, an implementation may choose (o disable not just that signal but others as
well. If a signal-handling function returns from handling a SIG1LL or STGSEGV
signal (as well as a SIGFPE signal), the effect is undefined. C99 also adds the
restriction that if a signal occurs as a result of calling the abort function or the
raise function, the signal handler itself must not call raise.

The raise Function

int raise(int sig);

Although signals usually arise from run-time errors or external events, it’s occa-
sionally handy for a program to cause a signal to occur. The raise function does
just that. The argument to raise specifics the code for the desired signal.

raise (SIGABRT) ; /* raises the SIGABRT signal */

The return value of raise can be used to test whether the call was successful:
zero indicates success, while a nonzero value indicates failure.

Testing Signals

The following program illustrates the use of signals. First, it installs a custom han-
dler for the STGINT signal (carefully saving the original handler), then calls
raise_sig to raise that signal. Next, it installs SIG IGN as the handler for the
SIGINT signal and calls raise_sig again. Finally, it reinstalls the original han-
dler for SIGINT, then calls raise sig one last time.

/* Tests signals */

#include <signal.hs
#include <stdio.hs>

void handler (int sig);
void raise_siqg(void);

int main(void)

void (*orig handler) (int);
24.4 The <setjmp.h> Header: Nonlocal Jumps 635

printf ("Installing handler for signal %d\n", SIGINT);
orig handler = signal (SIGINT, handlex);
raise sig();

printf ("Changing handler to SIG IGN\n");
signal (SIGINT, SIG_IGN);
raise sig();

printf ("Restoring original handler\n");
signal (SIGINT, crig handler);
raise sig();

printf ("Program terminates normally\n");
return 0;

}

void handler (int sig)

{

printf ("Handler called for signal %d\n", sig);

}

void raise_sig(void)

{
}

raise (SIGINT) ;

Incidentally, the call of raise doesn’t need to be in a separate function. 1
defined raise sig simply to make a point: regardless of where a signal is
raised—whether it’s in main or in some other function—it will be caught by the
most recently installed handler for that signal.

The output of this program can vary somewhat. Here's one possibility:

Installing handler for signal 2
Handler called for signal 2
Changing handler to SIG_IGN
Restoring original handler

From this output, we see that our implementation defines SIGINT to be 2 and that
the original handler for SIGINT must have been SIG_DFL. (If it had been
SIG_IGN, we'd also see the message Program terminates normally.)
Finally, we observe that STG DFL caused the program to terminate without dis-
playing an error message.

24.4 The <setjmp.h> Header: Nonlocal Jumps

int setjmp(jmp_buf env);
void longjmp (jmp buf env, int val);
636

Chapter 24  Error Handling

`goto` statement » 6.4

setjimp
QaA

longjmp

A

PROGRAM

tsetimp.c

Normally, a function returns to the point at which it was called. We can’t use a
`goto` statement to make it go elsewhere, because a goto can jump only to a label
within the same function. The <setjmp.h> header, however, makes it possible
for one function to jump directly to another function without returning.

The most important items in <setjmp.h> are the setjmp macro and the
longjmp function. setjmp “marks” a place in a program; longjmp can then
be used to return to that place later. Although this powerful mechanism has a vari-
ety of potential applications, it’s used primarily for error handling.

To mark the target of a future jump, we call set3mp, passing it a variable of
type jmp_buf (declared in <setjmp.h>). setjmp stores the current “environ-
ment” (including a pointer to the location of the setjmp itself) in the variable for
later use in a call of longjmps; it then returns zero.

Returning to the point of the set jmp is done by calling Longjmp, passing it
the same jmp_buf variable that we passed to setjmp. After restoring the envi-
ronment represented by the jmp_buf variable, longjmp will—here’s where it
gets tricky—return from the setimp call. setjmp's return value this time is
val, the second argument to longjmp. (If val is 0, setjmp returns 1.)

Be sure that the argument to longjmp was previously initialized by a call of
setjmp. It's also important that the function containing the original call of set-
jmp must not have returned prior to the call of longjmp. If either restriction is
violated, calling longjmp results in undefined behavior. (The program will prob-
ably crash.)

To summarize, set jmp returns zero the first time it’s called; later, long3jmp
transfers control back to the original call of setimp, which this time returns a
nonzero value. Got it? Perhaps we need an example...

Testing setjmp/longjmp

The following program uses setimp to mark a place in main; the function f2
later returns (o that place by calling Longjmp.

/* Tests setjmp/longimp */

#include <setjmp.h>
#include <stdio.h>

jmp_buf env;

void f1(void) ;
void f2(void);

int main(void)

if (setjmp(env) == 0)
printf ("setjmp returned 0\n");
Q&A 637

else {
printf ("Program terminates: longjmp called\n");
return 0;

i

f1();
printf ("Program terminates normally\n");
return 0;

void f1(void)

{
printf("f1 begins\n");
f20);
printf("fl returns\n");

void f2(void)

{
printf ("f2 begins\n") ;
longjmp (env, 1);
printf ("f2 returns\n');

The output of this program will be
setjmp returned 0
f1 begins

f2 begins
Program terminates: longjmp called

The original call of setjmp returns 0, so main calls f1. Next, f1 calls f2,
which uses Longjmp to transfer control back to main instead of returning to f1.
When longjmp is executed, control goes back to the setjmp call. This time,
setimp returns 1 (the value specified in the longjmp call).

Q&A

You said that it’s important (o store zero in errno before calling a library
function that may change it, but I’ve seen UNIX programs that test errno
without ever setting it to zero. What's the story? [p. 629]

UNIX programs often contain calls of functions that belong to the operating sys-
tem. These system calls rely on exrno, but they use it in a slightly different way
than described in this chapter. When such a call fails, it returns a special value
(such as 1 or a null pointer) in addition to storing a value in errno. Programs
don’t need to store zero in errno before such a call, because the function’s return
value alone indicates that an error occurred. Some functions in the C standard
library work this way as well, using exrno not so much to signal an error as to
specify which error it was.
638 Chapler 24 Error Handling

Q:

Az

A

@D

_`exit` function »26.2

*Q:

volat: le type quallfier »20.3

My version of <errno.h> defines other macros besides EDOM and ERANGE.
Is this practice legal? [p. 630]

Yes. The C standard allows macros that represent other error conditions, provided
that their names begin with the letter E followed by a digit or an upper-case letter.
UNIX implementations typically define a huge number of such macros.

Some of the macros that represent signals have cryptic names, like STGFPE
and SIGSEGV. Where do these names come from? [p. 631]

The names of these signals date back to the carly C compilers, which ran on a DEC
PDP-11. The PDP-11 hardware could detect errors with names like “Floating Point
Exception” and *“Segmentation Violation.”

OK, I'm curious. Unless it’s invoked by abort or raise, a signal handler
shouldn’t call a standard library function, but you said there were exceptions
to this rule. What are they? [p. 632]

A signal handler is allowed to call the signal function, provided that the first
argument is the signal that it's handling at the moment. This proviso is important,
because it allows a signal handler to reinstall itself. In C99, a signal handler may
also call the abort function or the _`exit` function.

Following up on the previous question, a signal handler normally isn’t sup-
posed to access variables with static storage duration. What’s the exception to
this rule?

That one’s a bit harder. The answer involves a type named sig_atomic_t that’s
declared in the <signal . h> header. sig_atomic t is an integer type that can
be accessed “as an atomic entity,” according to the C standard. In other words, the
CPU can fetch a sig atomic t value from memory or store one in memory
with a single machine instruction, rather than using two or more machine instruc-
tions, eig_atomic_t is often defined to be int, since most CPUs can load or
store an int value in one instruction.

That brings us to the exception to the rule that a signal-handling function isn't
supposed to access static variables. The C standard allows a signal handler to store
avalue in a sig_atomic_t variable—even one with static storage duration—
provided that it’s declared volatile. To see the reason for this arcane rule, con-
sider what might happen if a signal handler were to modify a static variable that’s
of a type that's wider than sig_atomic_t. If the program had fetched part of
the variable from memory just before the signal occurred, then completed the fetch
after the signal is handled, it could end up with a garbage value. sig_atomic_t
variables can be fetched in a single step, so this problem doesn’t occur. Declaring
the variable to be volatile warns the compiler that the variable’s value may
change at any time. (A signal could suddenly be raised, invoking a signal handler
that modifies the variable.)

The tsignal.c program calls printf from inside a signal handler. Isn’t
that illegal?
Section 24.1

PO

=)

Exercises 639

A signal-handling function invoked as a result of raise or abort may call
library functions. tsignal . c uses raise to invoke the signal handler.

How can setjmp modify the argument that’s passed to it? I thought that C
always passed arguments by value. [p. 636]

The C standard says that jmp_buf must be an array type, so setjmp is actually
being passed a pointer.

I'm having trouble with setjmp. Are there any restrictions on how it can be
used?

According to the C standard, there are only two legal ways to use setjmp:

= As the expression in an expression statement (possibly cast to void).

= As part of the controlling expression in an if, switch, while, do, or for
statement. The entire controlling expression must have one of the following
forms, where constexpr is an integer constant expression and op is a relational
or equality operator:
setjmp (..)
lsetjmp (..)

constexpr op setimp (..)
setimp () op constexpr

Using set jmp in any other way causes undefined behavior,

After a program has executed a call of longjmp, what are the values of the
variables in the program?

Most variables retain the values they had at the time of the longimp. However, an
automatic variable inside the function that contains the set imp has an indetermi-
nate value unless it was declared volatile or it hasn't been modified since the
setjmp was performed.

Is it legal to call Longjmp inside a signal handler?

Yes, provided that the signal handler wasn't invoked because of a signal raised dur-
ing the execution of a signal handler. (C99 removes this restriction.)

Exercises

(a) Assertions can be used to test for two kinds of prablems: (1) problems that should never
oceur if the program is correct, and (2) problems that are beyond the control of the program.
Explain why assert is best suited for problems in the first category.

(b) Give three examples of problems that are beyond the control of the program.

Write a call of assert that causes a program to terminate if a variable named top has the
value NULL.
640 Chapter 24  Error Handling

Section 24.2

Section 24.4

B!

® 4

® s

Modify the stackADT2. c file of Section 19.4 so that it uses assert to test for errors
instead of using 1`if` statements. (Note that the terminate function is no longer necessary
and can be removed.)

(a) Write a “wrapper” function named try math fen that calls a math function
(assumed to have a double argument and return a double value) and then checks
whether the call succeeded. Here’s how we might use try math fen:

y = try math_fen(sqrt, x, "Srror in call of sqrt");

If the call sqrt (x) is successful, try math fen returns the value computed by sqrt.
1f the call fails, try_math_fen calls perror to print the message Error in call of
sqrt, then calls exit to terminate the program.

(h) Write a macro that has the same effect as try math_fen but builds the error mes-
sage from the function’s name;

Yy = TRY_MATH_FCN(sqrt, x);

If the call of sqrt fails, the message will be Exror in call of sqrt. Hint: Have
TRY_MATH FCNecall try math_fen.

In the inventory.c program (see Section 16.3), the `main` function has a `for` loop that
prompts the user to enter an operation code, reads the code, and then calls cither insert.
search, update, or print. Add a call of setjmp to main in such a way that a subse-
quent call of Longjmp will return to the `for` loop. (After the Longimp, the user will be
prompted for an operation code, and the program will continue normally.) setjmp will
need a jmp_buf variable: where should it be declared?
25

International Features

If your computer speaks English
it was probably made in Japan.

For many years, C wasn’l especially suitable for use in non-English-speaking
countries. C originally assumed that characters were always single bytes and that
all computers recognized the characters #, [, \, 1, *, {, |, }, and ~, which are
needed to write programs. Unfortunately, these assumptions aren't valid in all parts
of the world. As aresult, the experts who created C89 added language features and
libraries in an effort to make C a more international language.

In 1994, Amendment 1 to the ISO C standard was approved, creating an
enhanced version of C89 that’s sometimes known as C94 or C95. This amendment
provides additional library support for international programming via the digraph
language feature and the <1s0646.h>, <wchar.h>, and <wctype. h> head-
ers. C99 adds even more support for internationalization in the form of universal
character names. This chapter covers all of C’s international features, whether they
come from C89, Amendment 1, or C99. I'll flag the Amendment | changes as C99
changes, although they actually predate C99.

The <locale.h> header (Section 25.1) provides functions that allow a pro-
gram to tailor its behavior (o a particular “locale"—often a country or other geo-
graphical area in which a particular language is spoken. Multibyte characters and
wide characters (Section 25.2) enable programs to work with large character sets
such as those found in Asian countries. Digraphs, trigraphs, and the <is0646 .h>
header (Section 25.3) make it possible to write programs on computers that lack
some of the characters normally used in C programming. Universal character
mames (Section 25.4) allow programmers (o embed characters from the Universal
Charucter Set into the source code of a program. The <wchar . h> header (Section
25.5) supplies functions for wide-character input/output and wide-string manipula-
tion. Finally, the <wctype.h> header (Section 25.6) provides wide-character
classification and case-mapping functions.

641
642 Chapter 25

25.1

<string.h»> header »236

<ctype. > header »23.5

numeric conversion functions 26,2

strEtine funcion >26.3

@D

wesftime funotion »25.5

International Features

The <locale.h> Header: Localization

The <locale.h> header provides functions to control portions of the C library
whose behavior varies from one locale to another. (A locale is typically a country
or a region in which a particular language is spoken.)

Locale-dependent aspects of the library include:

Formatting of numerical quantities. In some locales, for example, the deci-
mal point is a period (297.48), while in others it’s a comma (297,48).
Formatting of monetary quantities. For example, the currency symbol varies
from country to country.

Character set. The character set often depends on the language in a particular
locale. Asian countries usually require a much larger character set than West-
ern countries.

Appearance of date and time. In some locales, it’s customary to put the month
first when writing a date (8/24/2012); in others, the day goes first (24/8/2012).

Categories

By changing locale, a program can adapt its behavior to a different area of the
world. But a locale change can affect many parts of the library, some of which we
might prefer not to alter. Fortunately, we're not required to change all aspects of a
locale at the same time. Instead, we can use one of the following macros to specify
a category:

LC_COLLATE. Affects the behavior of two string-comparison functions,
strecoll and strxfrm. (Both functions are declared in <string.h>).
LC_CTYPE. Affects the behavior of the functions in <ctype.h> (except
isdigit and isxdigit). Also affects the multibyte and wide-character
functions discussed in this chapter.

LC_MONETARY. Affects the monetary formatting information returned by the
localeconv function.

LC_NUMERLC. Affects the decimal-point character used by formatted /O
functions (like printf and scanf) and the numeric conversion functions
(such as strtod) in <stdlib.h>. Also affects the nonmonetary format-
ting information returned by localeconv.

LC_TIME. Affects the behavior of the strftime function (declared in
<time.h>), which converts a time into a character string. In C99, also
affects the behavior of the weeftime function.

Implementations are free to provide additional categories and define LC_ macros
not listed above. For example, most UNIX systems provide an LC_MESSAGES
category, which affects the format of alfirmative and negative system responses.
setlocale

getenv unction »26.2

25.1 The <locale.h> Header: Localization 643
The setlocale Function

char *setlocale(int category, const char ¥locale);

The setlocale function changes the current locale, either for a single category
or for all categories. If the first argument is one of the macros .C COLLATE,
LC _CTYPE, LC MONETARY, LC NUMERIC, or LC_TIME, a call of set-
locale affects only a single category. If the first argument is LC_ALL, the call
affects all categories. The C standard defines only two values for the second argu-
ment: "C" and "". Other locales, if any, depend on the implementation.

At the beginning of program execution, the call

setlocale (LC_ALL, "C");

occurs behind the scenes. In the "C" locale, library functions behave in the “nor-
mal” way, and the decimal poinl is a period,

Changing locale after the program has begun execution requires an explicit
call of setlocale. Calling setlocale with "" as the second argument
switches to the native locale, allowing the program to adapt its behavior to the
local environment. The C standard doesn’t define the exact effect of switching to
the native locale. Some implementations of setlocale check the execution
environment (in the same way as getenv) for an environment variable with a par-
ticular name (perhaps the same as the category macro). Other implementations
don’t do anything at all. (The standard doesn’t require setlocale to have any
effect, Of course, a library whose version of set Locale does nothing isn’t likely
to sell wo well in some parts of the world.)

Locales

Locales other than "c" and ** vary from one compiler to another. The GNU C
library, known as glibc, provides a "POSIX" locale, which is the same as the "C"
locale. glibe, which is used by Linux, allows additional locales to be installed if
desired. These locales have the form

language [ _territory] [ . codeset] [ amodifier]

where each bracketed item is optional. Possible values for /anguage are listed in a
standard known as ISO 639, territory comes from another standard (ISO 3166), and
codeset specifies a character set or an encoding of a character set. Here are a few
examples:

"swedish"

"en_GB" (English — United Kingdom)
"en_IE" (English - Ireland)
"fr_cH" (French — Switzerland)

There are several variations onthe "=n_TE" locale, including "en_TE@euro" (using
the euro currency), "en TE.isc88591" (using the ISO/IEC 8859-1 character set),
644

Chapter 25

UTF8 »25.2

localeconv

International Features

"en IE.is0885915@euro" (usingthe ISO/IEC 8859-15 character setand the euro
currency), and "en_IE.utf8" (using the UTF-8 encoding of the Unicade character
set).

Linux and other versions of UNIX support the 1ocale command, which can be
used to get locale information. One use of the 1ocale command is to get a list of
all available locales, which can be done by entering

locale -a

at the command line.

Because locale information is becoming increasingly important, the Unicode
Consortium created the Common Locale Data Repository (CLDR) project to estab-
lish a standard set of locales. More information about the CLDR project can be
found at www.unicode.org/cldr/.

When a call of setlocale succeeds, it returns a pointer to a string associ-
ated with the category in the new locale. (The string might be the locale name
itself, for example.) On failure, set locale returns a null pointer.

setlocale can also be used as a query function. If its second argument is a
null pointer, setlocale returns a pointer to a string associated with the category
in the current locale. This feature is especially useful if the first argument is
LC_ALL, since it allows us to fetch the current settings for all categories. A string
returned by setlocale can be saved (by copying it into a variable) and then
used in a later call of setlocale.

The localeconv Function

struct lconv *localeconv(void);

Although we can ask setlocale about the current locale, the information that it
returns isn’t necessarily in the most useful form. To find out highly specific infor-
mation about the current locale (What's the decimal-point character? What's the
currency symbol?), we need localeconv, the only other function declared in
<locale.hs.

localeceonv returns a pointer to a structure of type struct lconv. The
members of this structure contain detailed information about the current locale.
The structure has static storage duration and may be modified by a later call of
localeconv or setlocale. Be sure to extract the desired information from
the 1conv structure before it's wiped out by one of these functions.

Some members of the 1conv structure have char * type: other members
have char type. Table 25.1 lists the char * members. The first three members
describe the formatting of nonmonetary quantities, while the others deal with mon-
etary quantities. The table also shows the value of each member in the " C" locale
(the default); a value of " * means “not available.”

The grouping and mon_grouping members deserve special mention.
‘Table 25.1
char * Members of
lconv Structure

D

Table 25.2

char Members of
lconv Structure
(Local Formatting)

25.1 The <locale.h> Header: Localization 645
Value in
Name “c* Locale Description

decimal point Ll
thousands_sep

n

grouping

Nonmonetary

Decimal-point character

Character used to separate groups of
digits before decimal point

Sizes of digit groups

mon_decimal_point
mon_thousands_sep Ub

mon_grouping
positive_sign
negative sign
currency_symbol

Monetary

Decimal-point character
Character used to separate groups of
digits before decimal point

Sizes of digit groups

String indicating nonnegative quantity
String indicating negative quantity
Local currency symbol

n International currency symbol’

int_curr_symbol

TA three-letter abbreviation followed by a separator (often a space or a period). For example, the
international currency symbols for Switzerland, the United Kingdom, and the United States are
"CHF *, "GBP ",and "USD ", respectively.

Each character in these strings specifies the size of one group of digits. (Grouping
takes place from right to left, starting at the decimal point.) A value of CHAR MAX
indicates that no further grouping is to be performed; 0 indicates that the previous
element should be used for the remaining digits. For example, the string "\3" (\3
followed by \0) indicates that the first group should have 3 digits. then all other
digits should be grouped in 3's as well.

The char members of the 1conv structure are divided into two groups. The
members of the first group (Table 25.2) affect the local formatting of monetary
quantities. The members of the second group (Table 25.3) affect the international
formatting of monetary quantities. All but one of the members in Table 25.3 were
added in C99. As Tables 25.2 and 25.3 show, the value of each chax member in
the "C" locale is CHAR _MAX, which means “not available.”

Value in
Name ncr Locale Description
frac_digits CHAR MAX  Number of digits after decimal point
p_cs_precedes  CHAR_MAX | if currency symbol precedes
nonnegative quantity; 0 if it succeeds quantity
n_cs precedes CHAR MAX | if currency_symbol precedes negative
quantity; 0 if it succeeds quantity
p_scp_by_space CHAR MAX Separation of currency symbol and sign
string from nonnegative quantity (see Table
254)
n_sep_by space CHAR_MAX Separation of currency_ symwbol and sign
string from negative quantity (see Table 25.4)
p_sign posn CHAR MAX Position of positive sign for
nonnegative quantity (see Table 25.5)
n_sign_posn CHAR MAX Position of negative sign for negative
quantity (see Table 25.5)
646 Chapter 25  International Features

Table 25.3

char Members of
lconv Structure
{International Formatting)

Table 25.4

Values of
..5ep_by_space
Members

Table 25.5
Values of

-.8ign_posn
Members

Value in
Name wew Locale Description
int frac digits CHAR_MAX  Number of digits after decimal point

int p cs_precedes' CHAR MAX 1ifint_curr symbol precedes
nonnegative quantity; 0 if it succeeds
quantity

int n_cs_precedes’  CHAR MAX |ifint_curr_symbol precedes
negative quantity; 0 if it succeeds
quantity

int_p sep by space' CHAR MAX Separation of int_curr symbol
and sign string from nonnegative
quantity (see Table 25.4)

int_n_sep by space’ CHAR MAX Separationof int curr symbol
and sign string from negative quantity

(see Table 25.4)
int p sign posn’ CHAR MAX Position of positive_sign for
nonnegative quantity (see Table 25.5)
int_n_sign_posn CHAR MAX Position of negative sign for

negative quantity (see Table 25.5)

7099 only

‘Table 25.4 explains the meaning of the values of the p_sep by space,
n_sep by space, int p sep by space, and int n _sep by space
members. The meaning of p_sep_by_space and n_sep_by_space has
changed in C99. In C89, there are only two possible values for these members: |
(if there’s a space between currency_symbol and a monetary quantity) or 0 (if
there’s not).

Value Meaning
0 No space separates currency symbol and quantity.
=l If currency symbol and sign are adjacent, a space separates them from
quantity; otherwise, a space separates currency symbol from quantity.
2 Ifcurrency symbol and sign are adjacent, a space separates them;
otherwise, a space separates sign from quantity.

Table 25.5 explains the meaning of the values of the p_sign posn,
n_sign posn,int p sign posnand int_n_sign_posn members.

Value Meaning

Parentheses surround quantity and currency symbol
Sign precedes quantity and currency symbol
Sign succeeds quantity and currency symbol
Sign immediately precedes currency symbol
Sign immediately succeeds currency symbol

B LN HO

To see how the members of the 1conv structure might vary from one locale to
another, let’s look at two examples. Table 25.6 shows typical values of the monetary
lconv members for the U.S.A. and Finland (which uses the euro as its currency).
Table 25.6

Typical Values of
Monetary 1cony
Members for
U.S.A. and Finland

25.2

Latin1 »7.3

25.2  Multibyte Characters and Wide Characters 647

Member U.S.A. Finland

won_decimal point "0
mon_thousands_sep L) non
mon_grouping "3 " n\3n
positive sign nn o
negative_sign e non
currency_symbol wgn WEUR"
frac_digits 2
p_cs_precedes
n_cs_precedes
p_sep by space
n_sep_ by space
p_sign_posn

n_sign posn
int_curr_symbol
int frac_digits
int_p_cs_precedes
int_n cs precedes
int_p_ sep by _space
int n sep by space
int p _sign_posn
int 0 sign_posn

TH OO
sHHNMNOON

USD " EOR "

FRHEpPp BN
HHMNMOON

Here’s how the monetary quantity 7593.86 would be formatted in the two
locales, depending on the sign of the quantity and whether the formatting is local
or international:

US.A. Finland
Local format (positive) $7,593.86 7 593,86 EUR
Local format (negativc) -$7,593.86 - 7 593,86 EUR
International format (positive) USD 7,593.86 7 593,85 EUR
International format (negative) -USD 7,592.86 = 7593 ,86 EUR

Keep in mind that none of C’s library functions are able to format monetary quan-
tities automatically. It's up to the programmer to use the information in the 1conv
structure to accomplish the formatting.

Multibyte Characters and Wide Characters

One of the biggest problems in adapting programs to different locales is the char-
acter-set issue. ASCII and its extensions, which include Latin-1, are the most pop-
ular character sets in North America. Elsewhere, the situation is more complicated.
In many countries, computers employ character sets that are similar to ASCIL but
lack certain characters; we’ll discuss this issue further in Section 25.3. Other coun-
tries, especially those in Asia, face a different problem: written languages that
require a very large character set, usually numbering in the thousands.
648

Chapter 25

International Features

Changing the meaning of type chax to handle larger character sets isn’t pos-
sible, since chaxr values are—by definition—Tlimited to single bytes. Instead, C
allows compilers to provide an extended character set. This character set may be
used for writing C programs (in comments and strings, for example), in the envi-
ronment in which the program is run, or in both places. C provides two techniques
for encoding an extended character set: multibyte characters and wide characters.
It also supplies functions that convert from one kind of encoding to the other.

Multibyte Characters

In a multibyte character encoding, each extended character is represented by a
sequence of one or more bytes. The number of bytes may vary, depending on the
character. C requires that any extended character set include certain essential char-
acters (letters, digits, operators, punctuation, and white-space characters); these
characters must be single bytes. Other bytes can be interpreted as the beginning of
amultibyte character.

Japanese Character Sets

The Japanese employ several different writing systems. The most complex, kanji,
consists of thousands of symbols—far too many to represent in a one-byte encod-
ing. (Kanji symbols actually come from Chinese, which has a similar problem with
large character sets.) There's no single way to encode kanji: common encodings
include JIS (Japanese Industrial Standard), Shift-JIS (the most popular encoding),
and EUC (Extended UNIX Code).

Some multibyte character sets rely on a state-dependent encoding. In this
kind of encoding, each sequence of multibyte characters begins in an initial shift
state. Certain bytes encountered later (known as a shift sequence) may change the
shift state, affecting the meaning of subsequent bytes. Japan's JIS encoding, for
example, mixes one-byte codes with two-byte codes; “escape sequences” embed-
ded in strings indicate when to switch between one-byte and two-byte modes. (In
contrast, the Shift-JIS encoding is not state-dependent. Each character requires
either one or two bytes, but the first byte of a two-byte character can always be dis-
tinguished from a one-byte character.)

In any encoding, the C standard requires thal a zero byte always represent a
null character, regardless of shift state. Also, a zero byte can’t be the second (or
later) byte of a multibyte character.

The C library provides two macros, MB_LEN_MAX and MB_CUR_MAX, that
are related to multibyte characters. Both macros specify the maximum number of
bytes in a multibyte character. MB_LEN_ MAX (defined in <1imits.h>) gives the
maximum for any supported locale; MB_CUR_MAX (defined in <stdlib.hs)
gives the maximum for the current locale. (Changing locales may affect the inter-
pretation of multibyte characters.) Obviously, ME_CUR_MAX can’t be larger than
MB_LEN_MAX.
256.2  Multibyte Characters and Wide Characters 649

Any string may contain multibyte characters, although the length of such a
string (as determined by the strlen function) is the number of bytes in the string,
not the number of characters. In particular, the format strings in calls of the
~printf and ..scanf functions may contain multibyte characters. As a result,
the C99 standard defines the term multibyte string to be a synonym for string.

Wide Characters

The other way to encode an extended character set is (o use wide characters. A
wide character is an integer whose value represents a character. Unlike multibyte
characters, which may vary in length, all wide characters supported by a particular
implementation require the same number of bytes. A wide string is a string con-
sisting of wide characters, with a null wide character at the end. (A null wide char-
acter is a wide character whose numerical value is zero.)

Wide characters have the type wechar _t (declared in <stddef . h> and cer-
tain other headers), which must be an integer type able (o represent the largest
extended character set for any supported locale. For example, if two bytes are
enough to represent any extended character set, then wchar _t could be defined
as unsigned short int.

C supports both wide character constants and wide string literals. Wide char-
acter constants resemble ordinary character constants but are prefixed by the letter
L;

L'a'
Wide string literals are also prefixed by L:
L'abc"

This string represents an array containing the wide characters L'a', L'b", and
L'c!, followed by a null wide character.

Unicode and the Universal Character Set

The differences between multibyte characters and wide characters become appar-
ent when discussing Unicode. Unicode is an enormous character set developed by
the Unicode Consortium, an organization established by a group of computer man-
ufacturers to create an international character set for computer use. The first 256
characters of Unicode are identical to Latin-1 (and therefore the first 128 charac-
ters of Unicode match the ASCII character set). However, Unicode goes far
beyond Latin-1, providing the characters needed for nearly all modern and ancient
languages. Unicode also includes a number of specialized symbols, such as those
used in mathematics and music. The Unicode standard was first published in 1991.

Unicode is closely related to international standard ISO/IEC 10646, which
defines a character encoding known as the Universal Character Set (UCS). UCsS
was developed by the International Organization for Standardization (ISO), start-
ing at about the same time that Unicode was initially defined. Although UCS orig-
inally differed from Unicode, the two character sets were later unified. ISO now
650

Chapter 25  International Features

QaA

Table 25.7
UTF-8 Encoding

works closely with the Unicode Consortium to ensure that ISO/IEC 10646 remains
consistent with Unicode. Because Unicode and UCS are so similar, I'll use the two
terms interchangeably.

Unicode was originally limited to 65,536 characters (the number of characters
that can be represented using 16 bits). That limit was later found to be insufficient;
Unicode currently has over 100,000 characters. (For the most recent version, visit
www.unicode.org.) The first 65,536 characters of Unicode—which include the
most frequently used characters—are known as the Basic Multilingual Plane
(BMP).

Encodings of Unicode

Unicode assigns a unique number (known as a cede point) to each character. There
are a number of ways to represent these code points using bytes: I'll mention two
of the simpler techniques. One of these encodings uses wide characters: the other
uses multibyte characters.

UCS-2 is a wide-character encoding in which each Unicode code point is
stored as two bytes. UCS-2 can represent all the characters in the Basic Multilin-
gual Plane (those with code points between 0000 and FFFF in hexadecimal), but it
is unable to represent Unicode characters that don’t belong to the BMP.

A popular alternative is the 8-bit UCS Transformation Format (UTF-8),
which uses multibyte characters. UTF-8 was devised by Ken Thompson and his
Bell Labs colleague Rob Pike in 1992. (Yes, that's the same Ken Thompson who
designed the B language, the predecessor of C.) UTF-8 has the useful property that
ASCII characters look identical in UTF-8: each character is one byte and has the
same binary encoding. Thus, software designed to read UTF-8 data can also handle
ASCII data with no change. For these reasons, UTF-8 is widely used on the Inter-
net for text-based applications such as web pages and email.

In UTF-8, each code point requires between one and four bytes. UTF-j is
organized so that the most commonly used characters require fewer bytes, as
shown in Table 25.7.

Code Point Range UTF-8 Byte Sequence
|  (Hexadecimal) (Binary)

000000-00007F  OxxxXXXXX

000080-0007FF 110XXXXX 10XXXXXX

000800-00FFFF 1110xxxx 10xxxxxX 10XXXXXX
010000-1CFFFF 11110xxx 10xxxxxX 10xxxxxx 10XXXXXX

UTE-R takes the bits in the code point value, divides them into groups (repre-
sented by the x’s in Table 25.7), and assigns each group to a different byte. The
simplest case is a code point in the range 0~7F (an ASCII character), which is rep-
resented by a 0 followed by the seven bits in the original number.

A code point in the range 80-7FF (which includes all the Latin-1 characters)
would have its bits split into groups of five bits and six bits. The five-bit group is
25.2 Multibyte Characters and Wide Characters 651

prefixed by 110 and the six-bit group is prefixed by 10. For example, the code
point for the character c is E4 (hexadecimal) or 11100100 (binary). In UTE-8, it
would be represented by the two-byte sequence 11000011 10100100. Note how
the underlined portions, when joined together, spell out 00011100100.

Characters whose code points fall in the range 800-FFFF, which includes the
remaining characters in the Basic Multilingual Plane, require three bytes. All other
Unicode characters (most of them rarely used) are assigned four bytes.

UTF-8 has a number of useful properties:

m Each of the 128 ASCII characters is represented by one byte. A string consist-
ing solely of ASCII characters looks exactly the same in UTF-8.

= Any byte in a UTF-8 string whose leftmost bit is 0 must be an ASCII charac-
ter, because all other bytes begin with a 1 bit.

= The first byte of a multibyte character indicates how long the character will be.
If the number of 1 bits at the beginning of the byte is two, the character is two
bytes long. If the number of 1 bits is three or four, the character is three or four
bytes long, respectively.

= Every other byte in a multibyte sequence has 10 as its leftmost bits.

The last three properties are especially important, because they guarantee that no
sequence of bytes within a multibyte character can possibly represent another valid
multibyte character. This makes it possible to search a multibyte string for a partic-
ular character or sequence of characters by simply doing byte comparisons.

So how does UTF-8 stack up against UCS-2? UCS-2 has the advantage that
characters are stored in their most natural form. On the other hand, UTF-8 can han-
dle all Unicode characters (not just those in the BMP), often requires less space
than UCS-2, and retains compatibility with ASCIT. UCS-2 isn't nearly as popular
as UTE-8, although it was used in the Windows NT operating system. A newer
version that uses four bytes (UCS-4) is gradually taking its place. Some systems
extend UCS-2 into a multibyte encoding by allowing a variable number of byte
pairs to represent a character (unlike UCS-2, which uses a single byte pair per
character). This encoding, known as UT'F-16, has the advantage that it's compati-
ble with UCS-2.

Multibyte/Wide-Character Conversion Functions

int mblen(const char *s, size t n); from <stdlib.h>
int mbtowc (wchar t * restrict pwc,

const char * restrict s,

size t n); from <stdlib.h>
int wctomb(char *s, wchar t wc); Jfrom <stdlib.h>

Although the C89 standard introduced the concepts of multibyte characters and
wide characters, it provides only five functions for working with these kinds of
652

Chapter 25 International Features

mblen

mbtowe

characters. We'll now describe these functions, which belong to the <stdlib.h>
hecader. C99’s <wchar.h> and <wctype.h> headers, which are discussed in
Sections 25.5 and 25.6, supply a number of additional multibyte and wide-character
functions.

CR9’s multibyte/wide-character functions are divided into two groups. The
first group converts single characters from multibyte form to wide form and vice
versa. The behavior of these functions depends on the LC_CTYPE category of the
current locale. If the multibyte encoding is state-dependent, the behavior also
depends on the current conversion state. The conversion state consists of the cur-
rent shift state as well as the current position within a multibyte character. Calling
any of these functions with a null pointer as the value of its char * parameter
sets the function’s internal conversion state to the initial conversion state, signify-
ing that no multibyte character is yet in progress and that the initial shift state is
in effect. Later calls of the function cause its internal conversion state to be
updated.

The mblen function checks whether its first argument points to a series of
bytes that form a valid multibyte character. If so, the function returns the number
of bytes in the characler: if not, it returns —1. As a special case, mblen returns 0 if
the first argument points to a null character. The second argument limits the num-
ber of bytes that mblen will examine; typically, we’ll pass MB_CUR_MAX.

The following function, which comes from P. I. Plauger’s The Standard C
Library, uses mblen to determine whether a string consists of valid multibyte
characters. The function returns zero if s points to a valid string.

int mbcheck (const char *s)

int n;
for (mblen(NULL, 0); : s += n)
if ((n = wblen(s, MB CUR_MAX)) <= 0)
return n;

1

Two aspects of the mbcheck function deserve special mention. First, there’s the
mysterious call mblen (NULL, 0), which sets mblen's internal conversion state
to the initial conversion state (in case the multibyte encoding is state-dependent).
Second, there’s the matter of termination. Keep in mind that s points to an ordi-
nary character string, which is assumed to end with a null character. mblen will
return zero when it reaches this null character, causing mbcheck to retum.
mbcheck will return sooner if mblen returns —1 because of an invalid multibyte
character.

The mbtowe function converts a multibyte character (pointed to by the sec-
ond argument) into a wide character. The first argument points to a wchar_t vari-
able into which the function will store the result. The third argument limits the
number of bytes that mbtowc will examine. mbtowc returns the same value as
mblen: the number of bytes in the multibyte character if it’s valid, -1 if it’s not,
and zero if the second argument points to a null character.
wetomb

mbstowcs

25.2 Multibyte Characters and Wide Characters ~ 653

The wetomb function converts a wide character (the second argument) into a
multibyte character, which it stores into the array pointed to by the first argument.
wctomb may store as many as MB_LEN_MAX characters in the array, but doesn’t
append a null character. wetomb returns the number of bytes in the multibyte
character or —1 if the wide character doesn’t correspond to any valid multibyte
character. (Note that wetomb returns 1 if asked to convert a null wide character.)

The following function (also from Plauger’s The Standard C Library) uses
wctomb to determine whether a string of wide characters can be converted to
valid multibyte characters:

int wecheck (wehar t *wcs)

char buf [MB_LEN MAX] ;
int n;

for (wctomb(NULL, 0); ; ++wcs)
if ((n = wectomb(buf, *wecs)) <= 0)

return -1; /* invalid character */
else if (buf[n-1] -= '\0')
return 0; /* all characters are valid */

Incidentally, all three functions—mblen, mbtowe, and wetomb—can be
used to test whether a multibyte encoding is state-dependent. When passed a null
pointer as its char * argument, each function returns a nonzero value if multibyte
characters have state-dependent encodings or zero if they don’t.

Multibyte/Wide-String Conversion Functions

size t mbstowcs(wchar t * restrict pwcs,

const char * restrict s,

gize t n); from <stdlib.h>
size t wcstombs(char * restrict s,

const wchar t * restrict pwes,

size t n); Jfrom <stdlib.h>

The remaining C89 multibyte/wide-character functions convert a string containing
multibyte characters to a wide-character string and vice versa, How the conversion
is performed depends on the LC_CTYPE category of the current locale.

The mbstowes function converts a sequence of multibyte characters into
wide characters. The second argument points to an array containing the multibyte
characters to be converted. The first argument points to a wide-character array; the
third argument limits the number of wide characters that can be stored in the array.
mbstowes stops when it reaches the limit or encounters a null character (which it
stores in the wide-character array). It returns the number of array elements modi-
fied, not including the terminating null wide character, if any. mbstowcs returns
—1 (cast to type size_t)if it encounters an invalid multibyte character.
654

Chapter 25

westombs

25.3

Table 25.8
Trigraph Sequences

International Features

The westombs function is the opposite of mbstowcs: it converts a
sequence of wide characters into multibyte characters. The second argument points
to the wide-character string, The first argument points to the array in which the
multibyte characters are to be stored. The third argument limits the number of
bytes that can be stored in the array. westombs stops when it reaches the limit or
encounters a null character (which it stores). It returns the number of bytes stored,
not including the terminating null character, if any. westombs returns —1 (cast to
type size_t) if it encounters a wide character that doesn’t correspond to any
multibyte character.

The mbstowcs function assumes that the string to be converted begins in the
initial shift state, The string created by westombs always begins in the initial
shift state.

Digraphs and Trigraphs

Programmers in certain countries have traditionally had trouble entering C pro-
grams because their keyboards lacked some of the characters that are required by C.
This has been especially true in Europe, where older keyboards provided the accent(-
ed characters used in European languages in place of the characters that C needs,
suchas #, [, \, 1, %, {, |. }, and ~. C89 introduced trigraphs—three-character
codes that represent problematic characters—as a solution to this problem. Tri-
graphs proved to be unpopular, however, so Amendment 1 to the standard added
two improvements: digraphs, which are more readable than trigraphs, and the
<is0646 .h> header, which defines macros that represent certain C operators.

Trigraphs

A trigraph sequence (or simply, a trigraph) is a three-character code that can be
used as an alternative to an ASCII character. Table 25.8 gives a complete list of tri-
graphs. All trigraphs begin with 2?2, which makes them, if not exactly attractive, at
least easy 1o spot.

Trigraph Ascr
Sequence  Equivalent

#

L
\
L
{
|
)

e
tokens »2.8

Table 25.9
Digraphs

25.3 Digraphs and Trigraphs 655

Trigraphs can be freely substituted for their ASCII equivalents. For example,
the program

#include <stdio.h>
int main(void)

printf("hello, world\n");
return 0;

}
could be written
??=include <stdio.h>

int main(void)

?0<
printf ("hello, world??/m");
return 0;

27>

Compilers that conform to the C89 or C99 standards ae required to accept tri-
graphs, even though they’re rarely used. Occasionally, this feature can cause prob-
lems.

Be careful about putting 2?2 in a string literal—it’s possible that the compiler will
treat it as the beginning of a trigraph. If this should happen. turn the second 2 char-
acler into an escape sequence by preceding it with a \ character. The resulting 2\ ?
combination can’t be mistaken for the beginning of a trigraph.

Digraphs

Acknowledging that trigraphs are difficult to read, Amendment 1 to the C89 stan-
dard added an alternative notation known as digraphs. As the name implies, a
digraph requires just two characters instead of three. Digraphs are available as sub-
stitutes for the six tokens shown in Table 25.9.

Digraph  Token
< [
o i|
<% {
%> }
%: #

%$:%: #4

Digraphs—unlike trigraphs—are foken substitutes, not character substitutes.
Thus, digraphs won’t be recognized inside a string literal or character constant. For
example, the string "< : : >" has length four; it contains the characters: <, :, 1,
656

Chapter 25

Table 25.10
Macros Defined in
<i80646.h>

25.4

International Features

and >, not the characters [ and . In contrast, the string "2? (22) " has length
two, because the compiler replaces the trigraph 2?2 ( by the character [ and the tri-
graph 2?) by the character ] .

Digraphs are more limited than trigraphs. First, as we’ve seen, digraphs are of
no use inside a string literal or character constant; trigraphs are still needed in these
situations. Second, digraphs don’t solve the problem of providing allernate repre-
sentations for the characters \, *, |, and ~. The <is0646 .h> header, described
next, helps with this problem.

The <is0646.h> Header: Alternative Spellings

The <is0646 .h> header is quite simple. It contains nothing but the definitions
of the eleven macros shown in Table 25.10. Each macro represents a C operator
that contains one of the characters &, |, ~, !, or *, making it possible to use the
operators listed in the table even when these characters are absent from the key-
board.

xor_eq

The name of the header comes from ISO/IEC 646, an older standard for an
ASClIlI-like character set. This standard allows for “national variants,” in which
countries substitute local characters for certain ASCII characters, thereby causing
the problem that digraphs and the <is0646 . h> header are trying to solve.

Universal Character Names (C99)

Section 252 discussed the Universal Character Set (UCS), which is closely related
to Unicode. C99 provides a special feature, universal character names, that allows
us to use UCS characters in the source code of a program,

A universal character name resembles an escape sequence. However, unlike
ordinary escape sequences, which can appear only in character constants and string
literals, universal character names may also be used in identifiers. This feature
allows programmers to use their native languages when defining names for vari-
ables, functions, and the like.
25.5

EOF macro »22.2

255 The <wchar.h> Header (C99) 657

There are two ways to write a universal character name (\udddd and
\Udddddddd), where each d is a hexadecimal digit. In the form \Udddddddd, the
d's form an eight-digit hexadecimal number that identifics the UCS code point of
the desired character. The form \udddd can be used for characters whose code
points have hexadecimal values of FFFF or less, which includes all characters in
the Basic Multilingual Plane.

For example, the UCS code point for the Greek letter f is 000003B2, so the
universal character name for this character is \U000003B2 (or \U000003b2,
since the case of hexadecimal digits doesn’t matter). Recause the first four hexa-
decimal digits of the UCS code point are 0, we can also use the \u notation, writ-
ing the character as \u03B2 or \u03b2. The code point values for UCS (which
match those for Unicode) can be found at www.unicode.org/charts/.

Not all universal character names may be used in identifiers: the C99 standard
contains a list of which ones are allowed. Also, an identifier may not begin with a
universal character namc that represents a digit.

The <wchar.h> Header (C99)
Extended Multibyte and Wide-Character Utilities

The <wchar . h> header provides functions for wide-character input/output and
wide-string manipulation. The vast majority of functions in <wchar.h> are
wide-character versions of functions from other headers (primarily <stdio.h>
and <string.hs).
The <wchar . h> header declares several types and macros, including the fol-
lowing:
= mbstate t — A value of this type can be used to store the conversion state
when a sequence of multibyte characters is converted to a sequence of wide
characters or vice versa.
= wint_t — Aninteger type whose values represent extended characters.
= WEOF — A macro representing a wint_t value that’s different from any
extended character. WEOF is used in much the same way as EOF, typically to
indicate an error or end-of-file condition

Note that <wchar . h> provides functions for wide characters but not multi-
byte characters. That's because C’s ordinary library functions are capable of deal-
ing with multibyte characters, so no special functions are needed. For example, the
fprintf function allows its format string to contain multibyte characters.

Most wide-character functions behave the same as a function that belongs to
another part of the standard library. Usually, the only changes involve arguments
and return values of type wchar_t instead of char (or wehar t * instead of
char *). In addition, arguments and return values that represent character
counts are measured in wide characters rather than bytes. In the remainder of this
section, I'll indicate which other library function (if any) corresponds to each
658

Chapter 25

standard streams »22.1

freopen funclion > 222

exrrno vasiable >24.2

fgetpos tunction »22.7

faetpos function »22.7

International Features

wide-character function. I won't discuss the wide-character function further un-
less there’s a significant difference between it and its “non-wide” counterpart.

Stream Orientation

Before we look at the input/output functions provided by <wchar . hs, it's impor-
tant to understand stream orientation, a concept that doesn’t exist in C89.

Every stream is either byte-oriented (the traditional orientation) or wide-
oriented (data is written to the stream as wide characters). When a stream is first
opened. it has no orientation. (In particular, the standard streams stdin, stdout,
and stderr have no orientation at the beginning of program execution.) Perform-
ing an operation on the stream using a byte input/output function causes the stream
to become byte-oriented; performing an operation using a wide-character input/
output function causes the stream to become wide-oriented. The orientation of a
stream can also be selected by calling the fwide function (described later in this
section). A stream retains its orientation as long as it remains open. Calling the
freopen function to rcopen the stream will remove its orientation.

When wide characters are written to a wide-oriented stream, they are con-
verted to multibyte characters before being stored in the file that is associated with
the stream. Conversely, when input is read from a wide-oriented stream, the multi-
byte characters found in the stream are converted to wide characters. The multibyte
encoding used in a file is similar to that used for characters and strings within a
program, excepl that encodings used in files may contain embedded null hytes

Each wide-oriented stream has an associated mbstate_t object, which keeps
track of the stream’s conversion state. An encoding error occurs when a wide char-
acter written to a stream doesn’t correspond to any multibyte character, or when a
sequence of characters read from a stream doesn’t form a valid multibyte character.
In either casc, the value of the ETLSEQ macro (defined in the <errno ., h> header)
is stored in the errno variable to indicate the nature of the error.

Once a stream is byte-oriented, it's illegal to apply a wide-character input/out-
put function to that stream. Similarly, it's illegal to apply a byte input/output func-
tion to a wide-oriented stream. Other stream functions may be applied to streams
of either orientation, although there are a few special considerations for wide-ori-
ented streams:

s Binary wide-oricnted streams are subject to the file-positioning restrictions of
both text and hinary streams.

= After a file-positioning operation on a wide-oriented stream, a wide-character
output function may end up overwriting part of a multibyte character. Doing
50 leaves the rest of the file in an indeterminate state.

m Calling fgetpos for a wide-oriented stream retrieves the stream’s
mbstate_t object as part of the fpos_t object associated with the stream,
A later call of fsetpos using this fpos_t object will restore the
mbstate t object to its previous value.
255 The <wchar.h> Header (C99)

Formatted Wide-Character Input/Output Functions

int

int

int

int

int
int

fwprintf (FILE * restrict stream,

const wchar t * restrict format, ...);

fwscanl (FILE * restrict stream,

const wechar_t * restrict format, ...)

swprintf (wchar t * restrict s, size t n,

7

const wchar t * restrict format, ...)

swscanf (const wchar t * restrict s,

const wchar t * restrict format, ...)

vEwprintf (FILE * restrict stream,
const wchar t * restrict format,
va list arg);
vifwscanf (FILE * restrict stream,
const wchar t * restrict format,
va list arg);
vswprintf (wchar t * restrict s, size t n,
const wchar t * restrict format,
va_list arg);
vswscanf (const wchar t * restrict s,
const wchar t * restrict format,
va_list arg);
vwprintf (const wchar_t * restrict format,
va_list arg);
vwscanf (const wchar t * restrict format,
va list arg);

wprintf (const wchar_t * restrict format, ...);

wscanf (const wchar_t * restrict format, ...);

659

The functions in this group are wide-character versions of the formatted input/out-
put functions found in <stdio.h> and described in Section 22.3. The
<wchar . h> functions have arguments of type wchar_t * instead of char #,
but their behavior is mostly the same as the <stdio.h> functions. Table 25.11
shows the correspondence between the <stdio.hs functions and their wide-
character counterparts. Unless mentioned otherwise, each function in the left col-
umn behaves the same as the function(s) to its right.

All functions in this group share several characteristics:

= All have a format string, which consists of wide characters.

m ..printf functions, which return the number of characters written, now
return the count in wide characters.

m The %n conversion specifier refers to the number of wide characters written so
far (in the case of a ..printf function) or read so far (in the case of a
..scanf function).
660 Chapter 25

Table 25.11

Formatted Wide-Character
Input/Outpur Functions
and Their <stdio.h>
Equivalents

International Features

<wchaz.h> Fuaction  <stdio.h> Equivalent
Fuprintf fprintf
fwscanf focanf
swprintf snprintf, sprintf
swscanf sscanf
vEuprintf viprintf
vEwscant vEscanf
vewprintf venprintf, vsprintf
vswscang vsscanf
vwprintf vprintf
vwscanf vecanf
wprintf printf
wscanf scanf

fwprintf Additional differences between fwprintf and fprintf include the fol-

fwscanf

swprintf

lowing:

= The %c conversion specifier is used when the corresponding argument has
type int. [f the 1 length modifier is present (making the conversion 21c), the
argument is assumed to have type wint_t. In either case, the corresponding
argument is written as a wide character.

= The %s conversion specifier is used with a pointer to a character array, which
may contain multibyte characters. (fprintE has no special provision for
multibyte characters.) If the 1 length modifier is present, as in $1s, the corre-
sponding argument should be an array containing wide characters. In either
case, the characters in the array are written as wide characters. (With
fprintf, the $1s specification also indicates an array of wide characters,
but they're converted to multibyte characters before being written.)

Unlike fecant, the fwscant function reads wide characters. The $c, $s,
and % [ conversions require special mention. Each of these causes wide characters
to be read and then converted to multibyte characters before being stored in a char-
acter array. fwscanf uses an mbstate_t object to keep track of the state of the
conversion during this process; the object is set to zero at the beginning of each
conversion. If the 1 length modifier is present (making the conversion %1c, $1s,
or %1 [), then the input characters are not converted but instead are stored directly
inan array of wchar_t elements. Thus, it’s necessary to use $1s when reading a
string of wide characters if the intent is to store them as wide characters. If %s is
used instead, wide characters will be read from the input stream but converted to
multibyte characters before being stored.

swprintf writes wide characters into an array of wehar_t elements. It's
similar to sprintf and snprintf but not identical to either one. Like
snprintf, it uses the parameter n to limit the number of (wide) characters that it
will write. However, sworintc returns the number of wide characters actually
written, not including the null character. In this respect, it resembles sprintf
rather than snprintf, which returns the number of characters that would have
been written (not including the null character) had there been no length restriction.
vswprintf

Table 25.12
‘Wide-Character Input/
Output Functions and
Their <stdio.h>
Equivalents

25.5 The <wchar.h> Header (C99) 661

swprintf returns a negative value if the number of wide characters to be written
is n or more, which differs from the behavior of both sprintf and snprintf.
vswprintf is equivalent to swprintf, with arg replacing the variable
argument list of swprintf. Like swprintf, which is similar—but not identi-
cal—to sprintf and snprintf, the vswprintf function is a combination of
vsprintf and vsnprintf If an attempt is made to write n or more wide char-
acters, vewprintf returns a negative integer, in a manner similar to swprintf.

Wide-Character Input/Output Functions

wint_t fgetwc (FILE *stream);
wchar t *fgetws(wchar t * restrict s, int m,
FILE * regtrict stream);

wint_t fputwe(wchar t c, FiLk *stream);

int fputws(const wchar t * restrict s,
FILE * restrict stream);

int fwide (FILE *stream, int mode);

wint t getwc (FILE #*stream);

wint_t getwchar (void) ;

wint t putwc (wchar t c, FILE *stream);

wint_t putwchar(wchar t c);

wint t ungetwc(wint t c, FILE *stream);

The functions in this group are wide-character versions of the character input/out-
put functions found in <stdio.h> and described in Section 22.4. Table 25.12
shows the correspondence between the <stdio.h> functions and their wide-
character counterparts. As the table shows, fwide is the only truly new function.

<wchar.h> Function  <stdio.h> Equivalent ‘

fgetwc fgetc

fgetws fgets

fputwe fpute

fputws fputs

fwide =

getwe gete
getwchar getchar |

putwe putc
putwchar putchar
ungetwe ungetc |

Unless otherwise indicated, you can assume that each <wchar.hs> function
listed in Table 25.12 behaves like the corresponding <stdio. h> function. How-
ever, one minor difference is common to most of these functions. To indicate an
error or end-of-file condition, some <stdic.h> character I/O functions return
EOF. The equivalent <wchar . h> functions return WEOF instead.
662

Chapter 25 International Features

fgetwe
getwe
getwehar
fgetws

foutwe
putwe
putwehar
foutws

fwide

There’s another twist that affects the wide-character input functions. A call of
a function that reads a single character (Egetwe, getwe, and getwchar) may
fail because the bytes found in the input stream don’t form a valid wide character
or there aren’t cnough bytes available. The result is an encoding error, which
causes the function to storc EILSEQ in errno and return WEOF. The fgetws
function, which reads a string of wide characters, may also fail because of an
encoding error, in which case it returns a null pointer.

Wide-character output functions may also encounter encoding errors. Functions
that write a single character (Eputwe, putwe, and putwchar) store EILSEQ in
errno and return WEOE if an encoding error occurs. However, the fputws func-
tion, which writes a wide-character string, is different: it returns EOF (not WEOF) if
an encoding error oceurs.

The fwide function doesn’t correspond {o any C89 function. Fwide is used
to determine the current orientation of a stream and, if desired, attempt to set its
orientation. The mode parameter determines the behavior of the function:

= mode > 0. Attempts to make the stream wide-oriented if it has no orientation.
= mode < (. Attempts to make the stream byte-oriented if it has no orientation.
= mode = 0. The orientation is not changed.

fwide doesn’t change the orientation if the stream already has one.

The value returned by fwide depends on the orientation of the stream affer
the call. The return value is positive if the stream has wide orientation, negative if
it has byte orientation, and zcro if it has no orientation.

General Wide-String Utilities

The <wchar . h> header provides a number of functions that perform operations
on wide strings. These are wide-character versions of functions that belong to the
<s8tdlib.h>and <string.h> headers.

Wide-String Numeric Conversion Functions

double westod (const wchar t * restrict nptr,
wchar t ** restrict endptr);
float wecstof (const wchar t * restrict nptr,
wehar t ** restrict endptr);
long double wcstold (const wchar t * restrict nptr,
wehar t ** restrict endptr);
long int westol (const wchar t * restrict nptr,
wchar t *+ restrict endptr,
int base) ;
long long int wcstoll (const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base);
255 The <wchar.h> Header (C98) 663

unsigned long int westoul (
const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;

unsigned long long int wcstoull (
const wchar_t * restrict nptr,
wchar t ** restrict endptr,
int base);

The functions in this group are wide-character versions of the numeric conversion
functions found in <stdlib.h> and described in Section 26.2. The <wchar . h>
functions have arguments of type wchar_t * and wechar_t ** instead of char
* and char **, but their behavior is mostly the same as the <stdlib.h> func-
tions. Table 25.13 shows the correspondence between the <stdlib.h> functions
and their wide-character counterparts.

Table 25.13 | <wehar.n> Function _ <std1ib.h> Equivalent

Wide-String Numeric EHEad e
Conversion Functions and westof strtof
Their <stdlib.h> westold strtold
Equivalents westol strtol

westoll strtoll

westoul strtoul

weetoull strtoull

Wide-String Copying Functions

wchar_t *wcscpy(wchar t * restrict si,
const wchar t * restrict s2);
wchar t *wcsnecpy(wchar t * restrict si1,
const wchar t * restrict s2,
size t n);
wchar t *wmemcpy (wchar_t * restrict sl,
const wchar t * restrict s2,
size t m);
wchar t *wmemmove (wchar t *s1, const wchar t *s2,
gize t m);

The functions in this group are wide-character versions of the string copying func-
tions found in <string.h> and described in Section 23.6. The <wchar.h>
functions have arguments of type wehazr L * instead of chax *, but their behavior
is mostly the same as the <string.hs> functions. Table 25.14 shows the corre-
spondence between the <string. h> functions and their wide-character counter-
parts.
664 Chapter 25

Table 25.14
Wide-String Copying
Functions and Their
<string.hs
Equivalents

Table 25.15

Wide-String Concatenation
Functions and Their
<string.h> Equivalents

International Features

<wchar.h> Function  <string.h> Equivalent
wescpy strcpy
wesnepy strncpy
wmemepy memcpy
wmemmcvq memmove i

Wide-String Concatenation Functions

wchar t *wcsecat (wehar_t * restrict sl,
const wehar_t * restrict s2);
wehar t *wcsncat (wchar t * restrict &1,
const wchar_t * restrict sz,
gsizest B);

The functions in this group are wide-character versions of the string concatenation
functions found in <string.hs and described in Section 23.6. The <wchar . h>
functions have arguments of type wehar_t * instead of chaxr *, but their behavior
is mostly the same as the <string.hs functions. Table 25.15 shows the corre-
spondence between the <string.h> functions and their wide character counter-
parts.

<wchar.h> Function <string.h> qut;ivaleul ‘
wescat strcat
wesneat strncat o

Wide-String Comparison Functions

int wececmp (const wchar t *sl, const wchar t *s2);
int wcscoll (const wchar t *sl, comst wchar t *s2);
int wcsncmp (const wchar, f *s1, const wchar t *s2,
glize i)
size_t wesxtrm(wchar t * restrict si,
const wchar t * restrict s2,
size t n);
int wmemcmp (const wchar t * gi, const wchar t * s2,
size t a);

The functions in this group are wide-character versions of the string comparison
functions found in <string.h> and described in Section 23.6. The
<wchar . h> functions have arguments of type wchar t * instead of char *,
but their behavior is mostly the same as the <string. h> functions. Table 25.16
shows the correspondence between the <string.h> functions and their wide-
character counterparts.
Table 25.16
Wide-String Comparison
Functions and Their
<string.h>
Lquivalents

Table 25.17
Wide-String Search
Functions and Their
<string.h>
Equivalents

wostok

255 The <wchar.h> Header (C99) 665

<wchar.h> Function <string.h> FEquivalent
wesemp stremp
wescoll strcoll
wesnemp strnemp
wesxfrm strxfrm
wmememp memcmp

Wide-String Search Functions

wchar t *weschr(const wchar t *s, wchar t c);
size t wescspn(const wchar t #*s1, const wchar t *s2);
wchar t *wcspbrk(const wchar t *sl1,

const wchar t *s2);
wechar t *wesrchr(const wchar t *s, wchar t c);
size t wesspn(const wchar t *sl, const wchar t *s2);
wchar t *wcsstr(const wchar t *si,

const wchar t *s2);
wchar_t *wecstok(wchar t * restrict si,

const wchar t * restrict s2,

wechar t *#* restrict ptr);
wchar_t *wmemchr (const wchar t *s, wchar t c,

gize t n);

The functions in this group are wide-character versions of the string search func
tions found in <string.h> and described in Section 23.6. The <wchar.h>
functions have arguments of type wehar_t * and wehar_t ** instead of char
* and char *#, but their behavior is mostly the same as the <string.h> func-
tions. Table 25.17 shows the correspondence between the <string. h> functions
and their wide-character counterparts.

<wchar.h> Function <string.h> Equivalent
weschr strchr
wescspn strespn
wespbrk strpbrk
wesrehr strrchr
wesspn strspn
wesstr strstr
westok strtok
wmemchr memchr

The westok function serves the same purpose as strtok, but is used some-
what differently, thauks to its third parameter. (strtok has only two parameters.)
To understand how westok works, we'll first need to review the hehavior of
strtok.
666

Chapter 25

International Features

We saw in Section 23.6 that strtok searches a string for a “token”—a
sequence of characters that doesn't include certain delimiting characters. The call
strtok(sl, s2) scans the s1 string for a nonempty sequence of characters
that are not in the s2 string. st.rtok marks the end of the token by storing a null
character in s1 just after the last character in the token: it then returns a pointer to
the first character in the token.

Later calls of strtck can find additional tokens in the same string. The call
strtok (NULL, s2) continues the search begun by the previous strtok call.
As before, st.rtok marks the end of the token with a null character, and then
returns a pointer to the beginning of the token. The process can be repeated until
strtok returns a null pointer, indicating that no token was found.

One problem with stxtok is that it uses a static variable to keep track of a
search, which makes it impossible to use strtok to conduct simultaneous
searches on two or more strings. Thanks fo its extra parameter, westok doesn't
have this problem,

The first two parameters o westok are the same as for strtok (except that
they point to wide strings, of course). The third parameter, ptr, will point to a
variable of type wchar_t *. The function will save information in this variable
that enables later calls of westok to continue scanning the same string (when the
first argument is a null pointer). When the search is resumed by a subsequent call
of westok, a pointer to the same variable should be supplied as the third argu-
ment; the value of this variable must not be changed between calls of westok.,

To see how westok works, let’s redo the example of Section 23.6. Assume
that str, p, and c are declared as follows:
wchar t str[] = L" April 28,1998";
wchar t #p, *q;

Our initial call of westok will pass str as the first argument:
p = westok(str, L" \t", &g);

P now points to the first character in April, which is followed by a null wide
character. Calling westok with a null pointer as its first argument and &q as the
third argument causes it to resume the search from where it left off:

p = westok (NULL, L" \t,", &g);

After this call, p points (o the first character in 28, which is now terminated by a
null wide character. A final call of westok locates the year:

P = westok (NULL, L" \t", &q);

D now points to the first character in 1998.
Miscellaneous Functions

size t woslen(const wehar t *s);
wchar t *wmemset (wchar t *s, wchar t c, size t n);
Table 25.18
Miscellancous Wide-String
Functions and Their
<string.h> Equivalents

wesftime

255 The <wchar.h> Header (G99) 667

The functions in this group are wide-character versions of the miscellaneous
string functions found in <string.h> and described in Section 23.6. The
<wchar . h> functions have arguments of type wchar_t * instead of char *,
but their behavior is mostly the same as the <string. h> functions. Table 25.18
shows the correspondence between the <string.h> functions and their wide-
character counterparts.

<wchar.h> Function <string.h> Equivalent

weslen strlen
wmemset memset

Wide-Character Time-Conversion Functions

size t wceftime(wchar_t * restrict s, size t maxsize,
const wchar t * restrict format,
const struct tm * restrict timeptr);

The wesftime function is the wide-character version of strftime, which
belongs to the <t ime . h=> header and is described in Section 26.3.

Extended Multibyte/Wide-Character Conversion Ultilities

We'll now examine <wchar.h> functions that perform conversions between
multibyte characters and wide characters. Five of these functions (mbrlen,
mbrtowe, wertomb, mbsrtowes, and wesrtombs) correspond to the multi-
byte/wide-character and multibyte/wide-string conversion functions declared in
<stdlib.h>. The <wchar.h> functions have an additional parameter, a
pointer to a variable of type mbstate_t. This variable keeps track of the state of
the conversion of a multibyte character sequence to a wide-character sequence (or
vice versa), based on the current locale. As a result, the <wchar . h> functions are
“restartable”; by passing a pointer to an mbstate_t variable modified by a previ-
ous function call, we can “restart” the function using the conversion state from that
call. One advantage of this arrangement is that it allows two functions to share the
same conversion state, For example, calls of mbrtowe and mbsrtowcs that are
used to process a single multibyte character string could share an mbstate t
variable.

The conversion state stored in an mbstate t variable consists of the current
shift state plus the current position within a multibyie character. Setting the bytes
of anmbstate_t variable to zero puts it in the initial conversion state, signifying
that no multibyte character is yet in progress and that the initial shift state is in
effect:

mbstate_t state;

memset (&state, '\0', sizeof (state));
668

Chapter 25

btowe

wetob

mbsinit

International Features

Passing &state to one of the restartable functions causes the conversion to begin
in the initial conversion state. Once an mbstate_t variable has been altered by
one of these functions. it should not be used to convert a different multibyte char-
acter sequence. nor should it be used to perform a conversion in the opposite direc-
tion. Attempting to perform either action causes undefined behavior. Using the
variable after a change in the LC_CTYPE category of a locale also causes unde-
fined behavior.

Single-Byte/Wide-Character Conversion Functions

wint_t btowc(int c);
int wctob(wint t c);

The functions in this group convert single-byte characters to wide characters and
vice versa,

The btowe function returns WEOF if c is equal to EOF or if c (when cast to
unsigned char) isn't a valid single-byte character in the initial shift state. Oth-
erwise, btowc returns the wide-character representation of c.

The wetob function is the oppasite of btowe. It returns EOF if c doesn’t
correspond to one multibyte character in the initial shift state. Otherwise, it returns
the single-byte representation of c.

Conversion-State Functions

int mbsinit (const mbstate t *ps);

This group consists of a single function, mbeinit, which returns a nonzero value
if ps is a null pointer or it points to an mbstate_t variable that describes an ini-
tial conversion state.

Restartable Multibyte/Wide-Character Conversion Functions

size t mbrlen(const char * restrict s, size_t n,
mbstate t * restrict ps);

size t mbrtowc (wchar t * restrict pwc,
const char * restrict s, size t n,
mbstate t * restrict ps);

size t wertomb(char * restrict s, wchar_t we,
mbstate t * restrict ps);

The functions in this group are restartable versions of the mblen, mbtowe, and
wetomb functions, which belong to <stdlib.h> and are discussed in Section
25.2. The newer mbrlen, mbrtowe, and wertomb tunctions differ from their
<stdlib.h> counterparts in several ways:
mbrlen

mbriowc

wertomb

25.5 The <wchar.h> Header(C99) 669

® mbrlen, mbrtowe, and wertomb have an additional parameter named ps.
When one of these functions is called. the corresponding argument should
point to a variable of type mbstate _t; the function will store the state of the
conversion in this variable. If the argument corresponding to ps is a null
pointer, the function will use an internal variable to store the conversion state.
(At the beginning of program execution, this variable is set to the initial con-
version state.)

= When the s parameter is a null pointer, the older mblen, mbtowc, and
wetomb functions return a nonzero value if multibyte character encodings
have state-dependent encodings (and zero otherwise). The newer functions
don’t have this behavior.

= mbrlen, mbrtowe, and wertomb return a value of type size t instead of
int, the return type of the older functions.

A call of mbrlen is equivalent to the call
mbrtowe (NULL, s, n, ps)

except that if ps is a null pointer, then the address of an internal variable is used
instead,
If s is a null pointer, a call of mbrtowc is equivalent to the call

mbrtowe (NULL, "", 1, ps)

Otherwise, a call of mbrtowe examines up to n bytes pointed to by s to see if they
complete a valid multibyte character, (Note that a multibyte character may already
be in progress prior to the call, as tracked by the mbstate_t variable to which
ps points.) If so, these bytes are converted into a wide character. The wide charac-
ter is stored in the location pointed to by pwe as long as pwe isn’t null. If this char-
acter is the null wide character, the mbstate t variable used during the call is
left in the initial conversion state.

mbrtowe has a variety of possible return values. It returns 0 if the conversion
produces a null wide character. It returns a number between | and n if the conver-
sion produces a wide character other than null, where the value returned is the
number of bytes used to complete the multibyte character. It returns —2 if the n
bytes pointed to by s aren’t enough to complete a multibyte character (although
the bytes themselves were valid). Finally, it returns —1 if an encoding error occurs
(the function encounters bytes that don't form a valid multibyte character). In the
last case, mbrtowc also stores EILSEQ in errno.

If s is a null pointer, a call of wer Lomb is equivalent to

wertomb (buf, L'\0', ps)

where buf is an internal buffer. Otherwise, wertomb converts we from a wide
character into a multibyte character, which it stores in the array pointed to by s.
If we is a null wide character, wertomb stores a null byte, preceded by a shift
sequence if one is necessary (o restore the initial shift state. In this case, the
670

Chapter 25

mbsrtowcs
wesrtombs

International Features

mbstate t variable used during the call is left in the initial conversion state.
wcrtomb returns the number of bytes that it stores, including shift sequences. If
we isn’t a valid wide character, the function returns —1 and stores EILSEQ in
errno.

Restartable Multibyte/Wide-String Conversion Functions

size_t mbsrtowcs(wchar t * restrict dst,
const char ** restrict src,
gize t'len,
mbstate t * restrict ps);
size t wesrtombs(char * restrict dst,
const wchar t ** restrict src,
size t lenm,
mbstate t * restrict ps);

The mbsrtowcs and wcsrtombs functions are restartable versions of
mbstowcs and westombs, which belong to <std1lib. h> and are discussed in
Section 25.2. mbsrtowes and wesrtombs are the same as their <std: .h>
counterparts, except for the following differences:

= mbsrtowcs and wesrtombs have an additional parameter named ps.
When one of these functions is called, the corresponding argument should
point to a variable of type mbstate t; the function will store the state of the
conversion in this variable. If the argument corresponding to ps is a null
pointer, the function will use an internal variable to store the conversion state.
(At the beginning of program execution, this variable is set to the initial con-
version state.) Both functions update the state as the conversion proceeds. If
the conversion stops because a null character is reached, the mbstate_t
variable will be left in the initial conversion state.

m The src parameter, which represents the array containing characters to be
converted (the source array), is a pointer to a pointer for mbsrtowes and
wesrtombs. (In the older mbstowcs and westombs functions, the corre-
sponding parameter was simply a pointer.) This change allows mbsrtowcs
and wesrtombs to keep track of where the conversion stopped. The pointer
to which sxrc points is set to null if the conversion stopped because a null
character was reached. Otherwise, this pointer is set to point just past the last
source character converted.

= The dst parameter may be a null pointer. in which case the converted charac-
ters aren’t stored and the pointer to which src points isn’t modified.

= When either function encounters an invalid character in the source array, it
stores EILSEQ in errno (in addition to returning —1, as the older functions
do).
25.6

<ctype.n> header »23.5

25.6 The <wctype.h> Header (C99) 671

The <wctype.h> Header (C99)
Wide-Character Classification and Mapping Uti

es

The <wctype.h> header is the wide-character version of the <ctype.h>
header. <ctype.h> provides two kinds of functions: character-classification
functions (like 1sdigit, which tests whether a character is a digit) and character
case-mapping functions (like toupper, which converts a lower-case letter to
upper case). <wctype.h> provides similar functions for wide characters,
although it differs from <ctype.h> in one important way: some of the functions
in <wetype . h> are “extensible,” meaning that they can perform custom charac-
ter classification or case mapping.

<wctype.h> declares three types and a macro. The wint_t type and the
WECF macro were discussed in Section 25.5. The remaining types are wetype t,
whose values represent locale-specific character classifications, and wetrans_t,
whose values represent locale-specific character mappings

Most of the functions in <wctype.hs> require a wint t argument. The
value of this argument must be a wide character (a wchar_t value) or WEOFE.
Passing any other argument causes undefined behavior.

The behavior of the functions in <wctype . h> is affected by the LC_CTYPE
category of the current locale.

Wide-Character Classification Functions

int iswalnum(wint_t wc);
int iswalpha (wint_t wc);
int iswblank(wint_t wec);
int iswentrl (wint t wc);
int iswdigit (wint t wc);
int iswgraph(wint t wc);
int iswlower (wint t wc);
int iswprint (wint_t wc);
int iswpunct (wint_t wc);
int iswspace (wint_t wc);
int iswupper (wint t we);
int iswxdigit (wint t we);

Each wide-character classification function returns a nonzero value if its argument
has a particular property. Table 25.19 lists the property that each function tests.
The descriptions in Table 25.19 ignore some of the subtleties of wide charac-
ters. For example, the definition of iswgraph in the C99 standard states that it
“tests for any wide character for which iswprint is true and iswspace is false,”

672  Chapter25 International Features

Table 25.19
‘Wide-Character
Classification Functions

wetype

Function Test
iswalnum(we)  Is we alphanumeric?
iswalpha (we) Is we alphabetic?
iowblank (we)  Isweablank?®
iswentrl (we) Is we a control character?
iswdigit (wc) Is we a decimal digit?
iswgraph (wc) Is we a printing character {other than a space)?
igwlower (wc) Is we a lower case letter?
iswprint (wc) Is we a printing character (including a space)?
iswpunct (we)  Is we punctuation?
iswspace (wc) Is we a white-space character?
iswupper (wc) Is we an upper-casc letter?
iswxdigit (we)  Is we a hexadecimal digit?

*"The standard blank wide charcters are space (L' ) and horizontal tab
(©i\E).

leaving open the possibility that more than one wide character is considered to be a
“space.” See Appendix D for more detailed descriptions of these functions,

In most cascs, the wide-character classification functions are consistent with
the corresponding funetions in <ctype . h>: if a <ctype . h> function returns a
nonzero value (indicating “true”) for a particular character, then the corresponding
<wetype. h> function will return true for the wide version of the same character.
The only exception involves white-space wide characters (other than space) that
are also printing characters, which may be classified differently by iswgraph
and iswpunct than by isgraph and ispunct. For example, a character for
which isgraph returns true may cause iswgraph to return false.

Extensible Wide-Character Classification Functions

int iswetype (wint_t we, wctype t desc);
wctype t wetype (const char *property);

Each of the wide-character classification functions just discussed is able (o test a
single fixed condition. The wetype and iswctype functions—which are de-
signed to be used together—make it possible to test for other conditions as well.

The wetype function is passed a string describing a class of wide characters:
it returns a wetype _t value that represents this class. For example, the call

wetype ("uppex")

returns a wetype_t value representing the class of upper-case letters. The C99
standard requires that the following strings be allowed as arguments to wetype:

*alnum" “alpha" "blank" ‘'cntrl" "digit" "graph"
"lower" Mprint" ‘’punct" ‘"space! ‘upper! ‘'xdigit"

Additional strings may be provided by an implementation. Which strings are legal
arguments Lo wetype at a given time depends on the LC_CTYPE category of the
iswctype

towlower
towupper

wetrans

256 The <wetype.h> Header (C99) 673

current locale: the 12 strings listed above are legal in all locales. If wetype is
passed a string that’s not supported in the current locale, it returns zero.

A call of the Lswetype function requires two parameters: we (a wide char-
acter) and desc (a value returned by wetype). iswctype returns a nonzero
value if we belongs to the class of characters corresponding to desc. For example,
the call

iswctype (we, wetype ("alnum'))
is equivalent to
iswalnum(we)

wotype and iswctype are most useful when the argument to wetype is a
string other than the standard ones listed above.

Wide-Character Case-Mapping Functions

wint t towlower(wint t wc);
wint_ t towupper (wint t we);

The cowlower and towupper functions are the wide-character counterparts of
tolewer and toupper. For example, towlower returns the lower-case ver-
sion of its argument, if the argument is an upper-case letter; otherwise, it returns
the argument unchanged. As usual, there may be quirks when dealing with wide
characters. For example, more than one lower-case version of a letter may exist in
the current locale, in which case towlower is allowed to return any one of them.

Extensible Wide-Character Case-Mapping Functions

wint t towctrans(wint t wc, wctrans t desc);
wctrans t wctrans(const char *property);

The wetrans and towctrans functions are used together to support general-
ized wide-character mapping.

The wctrans function is passed a string describing a character mapping; it
returns a wetrans_t value that represents the mapping. For example, the call

wetrans ("tolower")

returns a wetrans_t value representing the mapping of upper-case letters to low-
er case, The C99 standard requires that the strings "tolower" and "toupper"
be allowed as arguments to wetrans. Additional strings may be provided by an
implementation. Which strings are legal arguments to wetrans at a given time
depends on the I.C CTYPE category of the current locale; "tolower" and
"toupper" are legal in all locales. If wetrans is passed a string that’s not sup-
ported in the current locale, it returns zero,
674

Chapter 25 Inlernational Features

towctrans

A call of the towctrans function requires two parameters: we (a wide char-
acter) and desc (a value returned by wctrane). towctrans maps wc (o
another wide character based on the mapping specified by desc. For example, the
call

towctrans (we, wetrans("tolower"))
is equivalent to
towlower (wc)

towctrans is most useful in conjunction with implementation-defined map-
pings.

Q&A

How long is the locale information string returned by setlocale? [p. 644]
There’s no maximum length, which raises a question: how can we set aside space
for the string if we don’t know how long it will be? The answer, of course, is
dynamic storage allocation. The following program fragment (based on a similar
example in Harbison and Steele’s C: A Reference Manual) shows how to deter-
mine the amount of memory needed, allocate the memory dynamically, and then
copy the locale information into that memory:

char *temp, *old locale;

temp = setlocale(LC ALL, NULL);
if (temp == NULL) {
/* locale information not available */

old locale = malloc(strlen(temp) + 1);
if (old locale == NULL)
/* memory allocation failed */

strepy (old locale, temp);
We can now switch to a different locale and then later restore the old locale:
setlocale (LC_ALL, ""); /* switches to native locale */

setlocale (LC_ALL, old_locale); /* restores old locale */

Why does C provide both mulfibyte characters and wide characters?
Wouldn’t either one be enough by itself? [p. 648]

The two encodings serve different purposes. Multibyte characters are handy for
input/output purposes, since /O devices are often byte-oriented. Wide characters,
on the other hand, are more convenient to work with inside a program, since
every wide character occupies the same amount of space. Thus, a program might
Section 25.1

Section 25.2

58

Exercises 675

read multibyte characters, convert them to wide characters for manipulation
within the program, and then convert the wide characters back to multibyte form
for output.

Unicode and UCS seem to be pretty much the same. What’s the difference
between the two? [p. 650]

Both contain the same characters, and characters are represented by the same code
points in both. Unicode is more than just a character set, though. For example, Uni-
code supports “bidirectional display order.” Some languages, including Arabic and
Hebrew. allow text to be written from right to left instead of left to right. Unicode
is capable of specifying the display order of characters, allowing text to contain
some characters that are to be displayed from left to right along with others that go
from right to left.

Exercises

Determine which locales are supported by your compiler.

The Shift-JIS encoding for kanji requires either one or two bytes per character. If the first
byte of a character is between 0x81 and 0x9f or between Oxe0 and Oxef, a second byte
is required. (Any other byte is treated as a whole character.) The second byte must be
between 0x40 and 0x7e or between 0%80 and 0xfe. (All ranges are inclusive.) For each
of the following sings, give the value that the mbcheck function of Section 25.2 will
return when passed that string as its argument, assuming that multibyte characters are
encoded using Shift-JIS in the current locale.

(a) "\x05\x87\x80\x36\xed\xaa"

(b) "\%20\xed4\x50\x88\x3f"

(c) "\xde\xad\xbe\xef"

(d) "\x8a\x60\x92\x74\x41"

One of the useful properties of UTF-8 is that no sequence of bytes within a muliibyte char-
acter can possibly represent another valid multibyte character. Does the Shift-JIS encoding
for kanji (discussed in Exercise 2) have this property?

Give a C string literal that represents each of the following phrases. Assume that the charac-
ters &, &, €, &, 1, 6, 0, and ii are represented by single-byte Latin-1 characters. (You'll need to
look up the Latin-1 code points for these characters.) For example, the phrase déja vu could
be represented by the string "d\x297\xe0 wvu".

(a) Core d'Azur

(b) créme brilée

(c) créme fraiche

(d) Fahrvergniigen

(e) téte-a-téle

Repeat Exercise 4, this time using the UTF-8 multibyte encoding. For example. the phrase
déja vu could be represented by the string "d\xc3\xa%7 \xe3\xa0 vu"
676 Chapter 25

Section 25.3

@ o

International Features

Modify the following program fragment by replacing as many characters as possible by tri-
graphs.
while ((orig char = getchar()) |= EOF) {
new_char = orig _char * KEY;
if (dsprint (orig char) && isprint(new char))
putchar (new_char) ;
else
putchar (orig_char) ;
}

(C99) Modify the program fragment in Exercise 6 by replacing as many tokens as possible
by digraphs and macros defined in <180646 .h>.

Programming Projects

Wrile a program that tests whether your compiler’s " (native) locale is the same as its "C"
locale.

‘Write a program that obtains the name of a locale from the command line and then displays
the values stored in the corresponding 1conv structure. For example, if the locale is
wfi FIv (Finland), the output of the program might look like this:

decimal point =
thousande sep =
grouping = 3
mon_decimal_point = ", "
mon_thousands_sep =
mon_grouping = 3
positive sign = "
negative sign = "-"
currency symbol = "EUR"
frac digits = 2

p_cs precedes = 0
n_cs_precedes = 0
p_sep_by_space = 2

n_sep by space = 2
p_sign_posn = 1
n_sign _posn = 1
int curr symbol = "EUR "
int_frac_digite =

2
int_p es_precedes = 0
int n cs precedes = 0
int p sep_by space = 2
int_n_sep by space = 2

int p sign posn = 1

int n sign posn = 1

For readability, the characters in grouping and mon_grouping should be displayed as
decimal numbers.
26

26.1

Miscellaneous Library
Functions

Itis the user who should parametrize
procedures, not their creators.

<stdarg.h>, <stdlib.h>, and <time.h>—the only C89 headers that
weren't covered in previous chapters—are unlike any others in the standard library.
The <stdarg.h> header (Section 26.1) makes it possible to write functions with
a variable number of arguments. <stdlib.h> (Section 26.2) is an assortment of
functions that don’t fit into one of the other headers, The <time . h> header (Sec-
tion 26.3) allows programs to work with dates and times.

The <stdarg.h> Header: Variable Arguments

type va_arg(va list ap, type);

void va_copy(va list dest, va list src);
void va end(va list ap);

void va start(va list ap, parmN);

Functions such as printf and scanf have an unusual property: they allow any
number of arguments. The ability to handle a variable number of arguments isn't
limited to library functions. as it turns out. The «stdarg. h> header provides the
tools we'll need to write our own functions with variable-length argument lists.
<stdarg.h> declares one type (va_1list) and defines several macros. In C89,
there are three macros, named va_startc, va_arg, and va_end, which can be
thought of as functions with the prototypes shown above. C99 adds a function-like
macro named va_copy.

677
678

Chapter 26 Miscellaneous Library Functions

va_start

va_arg

To see how these macros work, we'll use them to write a function named
max_int that finds the maximum of any number of integer arguments. Here’s
how we might call the function:

max_int (3, 10, 30, 20)

The first argument specifics how many additional arguments will follow. This call
of max_int will return 30 (the largest of the numbers 10, 30, and 20).
Here’s the definition of the max_int function:

int max int(int n, ...) /* n must be at least 1 */

(
va_list ap;
int i, current, largest;

va_start(ap, n);
largest = va_arg(ap, int);

for (i = 1; i < nj i++) {
current = va_arg(ap, int);
if (current > largest)
largest = current;

va_end (ap) ;
return largest;

3

The ... symbol in the parameter list (known as an ellipsis) indicates that the
parameter n is followed by a variable number of additional parameters.

The body of max_int begins with the declaration of a variable of type
va_list:

va_list ap;

Declaring such a variable is mandatory for max_int to be able to access the argu-
ments that follow n.
The statement

va_start (ap, n);

indicates where the variable-length part of the argument list begins (in this case,
after n). A function with a variable number of arguments must have at least one
“normal” parameter; the cllipsis always goes at the end of the parameter list, after
the last normal parameter.

The statement

largest = va_arg(ap, int);

fetches max_int’s second argument (the one after n), assigns it to largest,
and automatically advances to the next argument. The word int indicates that we
expect max_int’s second argument to have int type. The statement
va_end

va_copy

A

defaut argument promotions »9.3

26.1 The <stdarg.h> Header: Variable Arguments 679

current = va_arg(ap, int);

fetches max_int’s remaining arguments, one by one, as it is executed inside a
loop.

Don’t forget that va_arg always advances to the next argument after fetching the
current one. Because of this property, we couldn’t have written max_int’s loop in
the following way:

for (1 = 1; i < n; i++)
if (va arg(ap, int) > largest) /*** WRONG **=*/
largest = va_arg(ap, int);

The statement
va_end(ap) ;

is required to “clean up"” before the function returns. (Or. instead of returning, the
function might call va_start and traverse the argument list again.)

The va_copy macro copies src (a va_list value) into dest (also a
va_list). The usefulness of va_copy lies in the fact that multiple calls of
va_arg may have been made using sxc before it's copied into dest, thus pro-
cessing some of the arguments. Calling va_copy allows a function to remember
where it is in the argument list so that it can later return to the same point to reex-
amine an argument (and possibly the arguments that follow it).

Each call of va_start or va_copy must be paired with a call of va_end,
and the calls must appear in the same function. All calls of va_arg must appear
between the call of va_start (or va_copy) and the matching call of va_end.

When a function with a variable argument list is called, the compiler performs the
default argument promotions on all arguments that match the ellipsis. In particular,
char and short arguments are promoted to int, and float values are pro-
moted to double. Consequently, it doesn’t make sense to pass types such as
char, short, or float to va_arg, since arguments—after promotion—will
never have one of those types.

Calling a Function with a Variable Argument List

Calling a function with a variable argument list is an inherently risky proposition.
As far back as Chapter 3, we saw how dangerous it can be to pass the wrong argu-
ments to printf and scanf. Other functions with variable argument lists are
equally sensitive. The primary difficulty is that a function with a variable argument
list has no way to determine the number of arguments or their types. This informa-
tion must be passed into the function and/or assumed by the function. max_int
relies on the first argument to specify how many additional arguments follow; it
680

Chapter 26  Miscellaneous Library Functions

viprintf
vprintf
vsprintf

D

assumes that the arguments are of type int. Functions such as printf and
scanf rely on the format string, which describes the number of additional argu-
ments and the type of each.

Another problem has to do with passing NULL as an argument. NULL is usu-
ally defined to represent 0. When 0 is passed to a function with a variable argu-
ment list, the compiler assumes that it represents an integer—there's no way it can
tell that we want it to represent the null pointer. The solution is to add a cast, writ-
ing (void *) NULL or (void *) 0 instead of NULL. (See the Q&A section at
the end of Chapter 17 for more discussion of this point.)

The v..printf Functions

int vfprintf (FILE * restrict stream,
const char * restrict format,

va_list axg); from <stdio.h>
int vprintf (const char * restrict format,
va_list arg); Jfrom <stdio.h>

int vspprintf(char * restrict s, size t n,

const char % restrict format,

va_list arg); Jfrom <stdio.h>
int vesprintf(char * restrict s,

const char * restrict format,

va_list arg); from <stdio.h>

The vEprintf, vprintf, and vsprintf functions (the “v..printf func-
tions”) belong to <stdio.h>. We're discussing them in this section because
they’re invariably used in conjunction with the macros in <stdarg.h>. C99 adds
the vsnprintf function.

The v..printf functions are closely related to fprintf, printt, and
sprintf. Unlike these functions, however, the v..printf functions have a
fixed number of arguments. Each function’s last argument is a va_11ist value,
which implies that it will be called by a function with a variable argument list. In
practice, the v..printf functions are used primarily for writing “wrapper” func-
tions that accept a variable number of arguments, which are then passed to a
v..printf function.

As an example, let’s say that we're working on a program that needs to display
error messages from time to time. We’d like each message to begin with a prefix of
the form

** Error n:

where n is 1 for the first error message and increases by one for each subsequent
error. To make it casicr to produce error messages, we'll write a function named
errorf that’s similar to printf, but adds ** Error a: to the beginning of
venprintf

D

vfscanf
vscanf
vsscanf

26.1 The <stdarg. h> Header: Variable Arguments 681

its output and always writes to stdexrx instead of stdout. We'll have errorf
call vEprintf to do most of the actual output. Here's what exrorf might look
like:

int errorf(const char *format;, ...)

static int num errors = 0;
int n;
va_list ap;

num_errors++;
fprintf (stderr, "** Error %d: ", num errors);
va_start (ap, format) ;

n vfprintf (stderr, format, ap);

va_end(ap) ;

tprintE(stders; 1 \nh)

return n;

The wrapper function—errort, in our example—is responsible for calling
va_start prior to calling the v..printf function and for calling va_end after
the v..printf function returns. The wrapper function is allowed to call va_arg
one or more times before calling the v..printf function.

The venprintf function was added to the C99 version of <stdio.h>. It
corresponds to snprintf (discussed in Section 22.8), which is also a C99 func-
tion.

The v..scanff Functions

int vfscanf (FILE * restrict stream,
const char * restrict format,

va_list arg); Jrom <stdio.h>
int vscanf (const char * restrict format,
va_list arg); Jfrom <stdio.h>

int vsscanf (const char * restrict s,
const char * restrict format,
va_list arg); Jfrom =stdio.h>

(C99 adds a set of “v..scanf functions” to the <stdio.h> header. viscanf
vscanf, and vsscanf are equivalent to fscanf, scanf, and ssca
respectively, except that they have a va_1ist parameter through which a variable
arguiment list can be passed. Like the v..orint f functions, each v..scanf func-
tion is designed to be called by a wrapper function that accepts a variable number
of arguments, which it then passes to the v..scanf function. The wrapper func-
tion is responsible for calling va_start prior to calling the v...scant function
and for calling va_end after the v..scanf function returns.

682  Chapler 26 Miscellaneous Library Functions

26.2 The <stdlib.h> Header: General Utilities

<stdlib.h> serves as a catch-all for functions that don’t fit into any of the other
headers. The functions in <etdlib.h> fall into eight groups:

Numeric conversion functions

Pseudo-random sequence generation functions
Memory-management functions
Communication with the environment
Searching and sorting utilities

Integer arithmetic functions
Multibyte/wide-character conversion functions
Multibyte/wide-string conversion functions

‘We'll look at each group in turn, with three exceptions: the memory management
functions, the multibyte/wide-character conyersion functions, and the multibyte/
wide-string conversion functions.

The memory-management functions (malloc, calloc, realloc, and
free) permit a program to allocate a block of memory and then later release it or
change its size. Chapter 17 describes all four functions in some detail.

The multibyte/wide-character conversion functions are used to convert a
multibyte character to a wide character or vice-versa. The multibyte/wide-string
conversion functions perform similar conversions between multibyte strings and
wide strings. Both groups of functions are discussed in Section 25.2.

Numeric Conversion Functions

double atof (const char *nptr);

int atoi(const char *nptr);
long int atol (const char *nptz);
long long int atoll(const char *mptr);

double strtod(const char * restrict nptr,
char ** restrict endptr);
float strtof (const char * restrict nptr,
char ** restrict endptr);
long double strtold(const char * restrict nptr,
char ** restrict endptr);

long int strtol(const char * restrict nptr,
char ** restrict endptr, int base);
atof
atoi
atol

eryno variable »24.2

striod
striol
strtoul

HUGE_VAL macro »233

26.2 The <stdlib.h> Header: General Utilities ~ 683

long long int strtoll (const char * restrict nptr,
char ** restrict endptr,
int base) ;
unsigned long int strtoul(
const char * restrict nptr,
char **% restrict endptr, int base);
unsigned long long int strtoull(
const char * restrict nptr,
char ** restrict endptr, int base);

The numeric conversion functions (or “string conversion functions,” as they're
known in C89) convert strings containing numbers in character form to their
equivalent numeric values. Three of these functions are fairly old, another three
were added when the C89 standard was created, and five morc were added in
C99.

All the numeric conversion functions—whether new or old—work in much
the same way. Each function attempts to convert a string (pointed to by the nptr
parameter) to a number. Each function skips white-space characters at the begin-
ning of the string, treats subsequent characters as part of a number (possibly begin-
ning with a plus or minus sign), and stops at the first character that can’t be part of
the number. In addition, each function returns zero if no conversion can be per-
formed (the string is empty or the characters following any initial white space
don’t have the form the function is looking for).

The old functions (atof, atoi, and atol) convert a string to a double,
int, or long int value, respectively. Unfortunately, these functions lack any
way 1o indicate how much of the string was consumed during a conversion. More-
over, the functions have no way to indicate that a conversion was unsuccessful.
(Some implementations of these functions may modify the exrno variable when a
conversion fails, but that’s not guaranteed.)

The C89 functions (strtod, strtol, and strtoul) are more sophisti-
cated. For one thing, they indicate where the conversion stopped by modifying the
variable that endptr points to. (The second argument can be a null pointer if
we're not interested in where the conversion ended.) To check whether a function
was able to consume the entire string, we can just test whether this variable points
to a null character. If no conversion could be performed, the variable that endptx
points to is given the value of nptr (as long as endptr isn’t a null pointer).
What's more, strtol and strtoul have a base argument that specifies the
base of the number being converted. All bases between 2 and 36 (inclusive) are
supported.

Besides being more versatile than the old functions, strtod, strtol, and
strtoul are better at detecting errors. Each function stores ERANGE in errno
if a conversion produces a value that’s outside the range of the function’s return
type. In addition, the stxrtod function returns plus or minus HUGE_VAL; the
684 Chapter 26 Miscellaneous Library Functions

<limits.h>macros »232
atoll

strtof

strtold

strtoll

strioull

PROGRAM

tnumconv.c

strtol and strtoul functions return the smallest or largest values of their
respective return types. (strtol returns either LONG MIN or LONG_MAX, and
strtoul returns ULONG_MAX.)

C99 adds the atoll, strtof, strtold, strtoll, and strtoull
functions. atoll is the same as the atol function, except that it converts a
string to a long long int value. strtof and strtold are the same as
strtod, except that they convert a string to a float or long double value,
respectively. stxtoll is the same as strtol, except that it converts a string to
a long long int value. strtoull is the same as strtoul, except that it
converts a string to an unsigned long long int value. C99 also makes a
small change to the floating-point numeric conversion functions: the string passed
to strtod (as well as its newer cousins, strtof and strtold) may containa
hexadecimal floating-point number, infinity, or NaN.

Testing the Numeric Conversion Functions

The following program converts a string to numeric form by applying each of the
six numeric conversion functions that exist in C89. After calling the strtod,
strtol, and strtoul functions, the program also shows whether cach conver-
sion produced a valid result and whether it was able to consume the entire string.
The pragram ohtains the input string from the command line.

/* Tests CB9 numeric conversion functicns */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

#define CHK VALID printf (" %s %s\n",
errno {= ERANGE ? "Yeg" : '"No ",
#ptr == '\0' ? "Yes" : "No')

\
\

int main(int argc, char *argv(])

{

char *ptr;

2) [
printf ("usage: tnumconv string\n");
exit (EXIT_FAILURE) ;

printf ("Function Return Value\n");

printE (- - - -\n") ;
printf(atof %g\n", atof (argv(l])):
printf (Yatoi %d\n", atoil(argvii]));
printf("atol %1ld\n\n", atcl(argv(il)):

printf ("Function Return Value Valid? Y
"String Consumed?\n"
26.2 The <stdlib.h> Header: General Utilities ~ 685

errno = 0;
printf ("strtod %-12g", strtod(argv([i], &ptr));
CHK_VALID;

errno = 0;
printf ("strtol %-121d", strtol (argv(l], &ptr, 10));
CHK_VALID;

errno = 0;
printf ("strtoul %-121u", strtoul (argv([l], &ptr, 10));
CHK_VALID;

return 0;

If 3000000000 is the command-line argument, the output of the program
might have the following appearance:

Function Return Value

atof 3e+09
atoi 2147483647
atel 2147483647

Function Return Value Valid? String Consumed?

strtod 3e+09 Yes Yes
strtol 2147483647 No Yes
strtoul 3000000000 Yes Yes

On many machines, the number 3000000000 is too large to represent as a long
integer, although it’s valid as an unsigned long integer. The atci and atol func-
tions had no way to indicate that the number represented by their argument was out
of range. In the output shown, they returned 2147483647 (the largest long integer),
but the C standard doesn't guarantee this behavior. The strtoul function per-
formed the conversion correctly; strtol returned 2147483647 (the standard
requires it to return the largest long integer) and stored ERANGE in errno.
If 123 . 456 is the command-line argument, the output will be

Function Return Value

atof 123.456
atoi 123
atol 123

Function Return Value Valid? String Consumed?
strtod 123.456 Yes Yes

strtol 123 Yes No

strtoul 123 Yes No
686 Chapter 26 Miscellaneous Library Functions

rand

srand

time funcion »26.3

All six functions treated this string as a valid number, although the integer func-
tions stopped at the decimal point. The strtol and strtoul functions were
able to indicate that they didn’t completely consume the string.

If fco is the command-line argument, the output will be

Function Return Value

atof
atoi
atol

Function Return Value Valid? String Consumed?

strtod 0 Yes No
strtol ] Yes No
strtoul o Yes No

All the functions looked at the letter f and immediately returned zero. The str...
functions didn’t change exrrno, but we can tell that something went wrong from
the fact that the functions didn’t consume the string.

Pseudo-Random Sequence Generation Functions

int rand(void) ;
void srand(unsigned int seed);

The rand and srand functions support the generation of pseudo-random num-
bers. These functions are useful in simulation programs and game-playing pro-
grams (to simulate a dice roll or the deal in a card game, for example).

Each time it’s called, xand returns a number between 0 and RAND_MAX (a
macro defined in <stdlib.h=>). The numbers returned by rand aren’t actually
random; they're generated from a “seed” value. To the casual observer, however,
rand appears to produce an unrelated sequence of numbers.

Calling srand supplies the seed value for rand. If rand is called prior to
srand, the seed value is assumed to be 1. Each seed value determines a particular
sequence of pseudo-random numbers; srand allows us to select which sequence
we want,

A program that always uscs the same seed value will always get the same
sequence of numbers from rand. This property can sometimes be useful: the pro-
gram behaves the same way each time it’s run, making testing easier. However, we
usually want rand to produce a different sequence each time the program is run.
(A poker-playing program that always deals the same cards isn't likely to be popu-
lar.) The easiest way to “randomize” the seed values is to call the time function,
which returns a number that encodes the current date and time. Passing time’s
return value to srand makes the behavior of rand vary from one run to the next.
See the guess. c and guess2. c programs (Section 10.2) for examples of this
technigue.
PROGRAM

trand.c

26.2 The <stdlib.h> Header: General Utilities 687

Testing the Pseudo-Random Sequence Generation Functions

‘The following program displays the first five values returned by the rand func-
tion. then allows the user to choose a new seed value. The process repeats until the
user enters zero as the seed.

/* Tests the pseudo-random sequence generation functions */

H#include <stdio.h>
#include <stdlib.h>

int main(void)
int i, seed;

printf ("This program displays the first five values of "
"rand.\n");

for S (77N
for (1 = 0; 1 « 5; d++)
printf("%d ", rand());
printf("\n\n") ;
printf ("Enter new seed value (0 to terminate): ");
scanf ("%d", &seed);
if (seed Q)
break;
srand (seed) ;

}

return 0;

1
Here's how a session with the program might look:

This program displays the first five values of rand.
1804289383 846930886 1681692777 1714636915 1957747793

Enter new seed value (0 to terminate): 100
677741240 611911301 516687479 1039653884 807009856

Enter new seed value (0 to terminate): 1

1804289363 846930886 1681692777 1714636915 1957747793
Enter new seed value (0 to terminate): 0

There are many ways to write the rand function, so there’s no guarantee that
every version of rand will generate the numbers shown here. Note that choosing 1
as the seed gives the same sequence of numbers as not specifying the seed at all.

Communication with the Environment

void abort (void) ;
int atexit(void (*func) (void));
688

Chapter 26 Miscellaneous Library Functions

exit

QsA

atexit

_Exit

signal function »24.3

abort

QaA
getenv

void exit(int status);
void _Exit (int status);
char *getenv(const char ¥name) ;
int system(const char *string);

The funetions in this group provide a simple interface to the operating system,
allowing programs to (1) terminate, either normally or abnormally, und return a
status code to the operating system, (2) fetch information from the user’s enyiron-
ment, and (3) execute operating system commands, One of the functions, _Exit,
is a C99 addition.

Performing the call exit (n) anywhere in a program is normally cquivalent
to executing the statement return 2; in main: the program terminates, and # is
returned to the operating system as a status code. <stdl1ib.h> defines the mac-
105 EXIT_FAILURE and EXIT_SUCCESS, which can be used as arguments to
exit. The only other portable argument to exit is 0, which has the same mean-
ing as EXTT_SUCCESS. Returning status codes other than these is legal but not
necessarily portable to all operating systems.

When a program terminates, it usually performs a few final actions behind the
scenes, including flushing output buffers that contain unwritten data, closing open
streams, and deleting temporary files. We may have other “clean-up" actions that
we'd like a program to perform at termination. The at`exit` function allows us to
“register” a funetion to be called upon program termination. To register a function
named cleanup, for example, we could call atexit as follows:

atexit (cleanup) ;

When we pass a function pointer to atexit, it stores the pointer away for future
reference. If the program later terminates normally (via a call of exit or a
`return` statement in the `main` function). any function registered with atexit
will be called automatically. (If two or more functions have been registered, they're
called in the reverse of the order in which they were registered.)

The _`exit` function is similar to exit. However, Exit doesn’t call func-
tions that have been registered with atexit, nor does it call any signal handlers
previously passed to the signal function. Also, _Exit doesn’t necessarily flush
output buffers, close open streams, or delete temporary files—whether these
actions are performed is implementation-defined.

abort is also similar to exit, but calling it causes abnormal program termi-
nation. Functions registered with atexit aren’t called. Depending on the imple-
mentation, it may be the case that output buffers containing unwritten data aren’t
flushed, streams aren’t closed, and temporary files aren’t deleted. abort returns
an implementation-defined status code indicating unsuccessful termination,

Many operating systems provide an “environment”: a sel of strings that
deseribe the user’s characteristics. These strings typically include the path to be
searched when the user runs a program, the type of the user's terminal (in the case
of a multi-user system), and so on. For example, a UNIX search path might look
system

bsearch

26.2 The <stdlib.h> Header: General Utilities ~ 689

something like this:
PATH=/usr/local/bin:/bin: fusr/bin;.

getenv provides access to any string in the user’s environment, To find the cur-
rent value of the PATH string, for example, we could write

char *p = getenv("PATH");

p now points to the string " /usr /1local/bin: /bin: /usr/bin: . ". Becare-
ful with getenv: it returns a pointer to a statically allocated string that may be
changed by a later call of the function.

The systen function allows a C program to run another program (possibly
an operating system command). The argument to system is a string containing a
command, similar to one that we'd enter at the operating system prompt. For
example, suppose that we’re writing a program that needs a listing of the files in
the current directory. A UNIX program would call system in the following way:

system("ls >myfiles");

This call invokes the UNITX command 1s and asks it to write a listing of the cur-
rent directory into the file named myfiles.

The return value of system is implementation-defined. system typically
returns the termination status code from the program that we asked it to run; test-
ing this value allows us to check whether the program worked properly. Calling
system with a null pointer has a special meaning: the function returns a nonzero
value if a command processor is available.

Searching and Sorting Utilities

void *bsearch(const void *key, const void *base,
size t nmemb, size t size,
int (*compar) (const void *,
const void *));
void gsort (void *base, size_t nmemb, size t size,
int (*compar) (const void *, comst void *));

The bseazch function searches a sorted array for a particular value (the “key").
When bsearch is called, the key parameter points to the key, base points to the
array, nmemb is the number of elements in the array, size is the size of each ele-
ment (in bytes), and compar is a pointer to a comparison function. The compari-
son function is similar to the one required by gsort: when passed pointers to the
key and an array element (in that order), the function must return a negative, zero,
or positive integer depending on whether the key is less than, equal to, or greater
than the array element. bsearch returns a pointer to an element that matches the
key: if it doesn’t find a match, bsearch returns a null pointer.
690

Chapter 26  Miscellaneous Library Functions

gsort

PROGRAM

airmiles.c

Although the C standard doesn’t require it lo, bsearch normally uses the
binary search algorithm to search the array. bsearch first compares the key with
the element in the middle of the array: if there’s a match, the function returns. If
the key is smaller than the middle element, bsearch limits its scarch to the first
half of the array; if the key is larger, bsearch searches only the last half of the
array. bsearch repeats this strategy until it finds the key or runs out of elements
to search. Thanks to this technique, bsearch is quite fast—searching an array of
1000 elements requires only 10 comparisons at most; searching an array of
1,000,000 elements requires no more than 20 comparisons.

Secction 17.7 discusses the gsort function, which can sort any aray.
bsearch works only for sorted arrays, but we can always use gsort to sort an
array prior to asking bsearch to search it.

Determining Air Mileage

Our next program computes the air mileage from New York City to various inter
national cities. The program first asks the user to enter a city name, then displays
the mileage to that city:

Enter city name: Shanghai
Shanghai is 7371 miles from New York City.

The program will store city/mileage pairs in an array. By using bscarch to
search the array for a city name, the program can easily find the corresponding
mileage. (Mileages are from Infoplease.com.)

/* Determines air mileage from New York to other cities */

#include <stdio.h>
ftinclude <stdlib.h>
#include <string.h>

struct city info {
char *city;
int miles;

}i

int compare cities(const void *key ptr,
const void *element ptx);

int main(void)

char city_name[81] ;

struct city info *ptr;

const struct city info mileage[] =
{{"Berlin", 3965}, {"Buenos Aires", 5297},
{"cairo", 5602}, {"Calcutta", 7918},
{"Cape Town", 7764}, {"caracas", 2132},
{"chicago", 713}, {"Hong Kong", 8054},
{ "Honolulu", 4964}, {"Istanbul®, 4975},
abs
labs

div

26.2 The <stdlib.h> Header: General Ulilities
{"Lisbon", 3364}, ("London", 3458},
{"Los Angeles", 2451}, {"Manila", 8498},
{"Mexico City", 2094}, ("Montreal®, 320},
{ "Moscow" , 4665}, {"Paris", 3624},
{"Ric de Janeiro", 4817}, {"Rome", 4281},
{"San Francisco", 2571}, {"Shanghaiv, 7371},
{"stockholm", 3924}, {"sydney", 9933},
{"Tokyo", 6740}, {"Warsaw", 4344},
{"washington", 205}};

printf ("Enter city name: ");
scanf ("%80([*\n] ", city name);
ptr = bsearch(city name, mileage,
sizeof (mileage) / sizeof (mileage[0]),
sizeof (mileage[0]), compare cities);
if (ptr != NULL)
printf("%s is %d miles from New York City.\n",
city name, ptr->miles);
else
printf("3s wasn't found.\n", city name);

return 0;

}

int compare_cities(const void *key ptr,
const void *element ptr)
{

return strcmp((char *) key ptr,
((struct city info *) element ptr)->city);

}
Integer Arithmetic Functions

int abs(int j);
long int labs(long int j);
long long int llabs(long long int j);

div_t div(int numer, int denom);
ldiv_t ldiv(long int numer, long int denom) ;
11div_t 11ldiv(long long int numer,

long long int denom),

691

The abs function returns the absolute value of an int value; the 1abs function

returns the absolute value of a long int value.

The div function divides its first argument by its second, returning a div_t
value. div_t is a structure that contains both a quotient member (named guot)
and a remainder member (rem). For example, if ans is a div_t variable, we

could write

ans = div(5, 2);
printf ("Quotient: %d Remainder: %d\n", ans.quot, ans.rem);
692

Chapter26 Miscellaneous Library Functions

Idiv

llabs
lidiv

26.3

Table 26.1
Members of the
tm Structure

The 1div function is similar but works with long integers; it returns an 1div_t
structure, which also has quot and rem members. (The div_t and 1div_t types
are declared in <stdlib.hs.)

C99 provides two additional functions. The 11abs function returns the abso-
lute value of a long long int value. 11diwv is similarto div and 1div, except
that it divides two long long int values and returns an 11div t structure.
(The 11div _t type was also added in C99.)

The <time.h> Header: Date and Time

The <time.h> header provides functions for determining the time (including the
date), performing arithmetic on time values, and formatting times for display.
Before we explore these functions, however, we need to discuss how times are
stored. <time.h> provides three types, each of which represents a different way
to store a time:

m clock t: A time value measured in “clock ticks.”
m time_t: A compact, encoded time and date (a calendar time).

®m struct tm: A time that has been divided into seconds, minutes, hours, and
so on, A value of type struct tmis often called a broken-down time. Table
26.1 shows the members of the tm structure. All members are of type int.

Minimum — Maximum
Descriprion Value Value

Seconds after the minute 0 61

Minutes after the hour 0 59

Hours since midnight 0 23
tm_mday Day of the month 1 31
tm_mon Months since January 0 11
tm year  Years since 1900 0 =
tm_wday  Days since Sunday 0 6
tm_yday  Days since January | 0 365

_tm_isdst Daylight Saving Time flag

' Allows for two extra “leap seconds” In C99, the maximum value is 60.
"Tpositive if Daylight Saving Time is in effect, zero if it's not in effect, and
negative if this information is unknown.

These types are used for different purposes. A clock_t value is good only
for representing a time duration; time_t and struct tm values can store an
entire date and time. time_t values are tightly encoded, so they occupy little
space. struct tm values require much more space, but they're often easier to
work with. The C standard states that clock t and time_t must be “arithmetic
types.” but leaves it at that. We don’t even know if clock _t and cime_t values
are stored as integers or floating-point numbers.

We're now ready to look at the functions in <t ime.hs>, which fall into two
groups: time manipulation functions and time conyersion functions.
clock

time

26.3 The <time.h> Header: Date and Time 693

Time Manipulation Functions

clock_t eclock(void);

double difftime(time L timel, time t time0);
time_t mktime(struct tm *timeptr) ;

time t time(time t *timer);

The clock function returns a clock t value representing the processor time
used by the program since execution began. To convert this value to seconds, we
can divide it by CLOCKS_PER_SEC, a macro defined in <time.h>.

When c1ock is used to determine how long a program has been running, it’s
customary to call it twice: once at the beginning of main and once just before the
program terminates:

#include <stdio.h>
#include <time.h>

int main (void)
clock_t start_clock = clock();

printf ("Processor time used: ¥g sec.\n",
(clock() - start_clock) / (double) CLOCKS PER SEC);
return O;

}

The reason for the initial call of clock is that the program will use some proces-
sor time before it reaches main, thanks to hidden “start-up" code. Calling clock
at the beginning of main determines how much time the start-up code requires so
that we can subtract it later.

The C89 standard says only that clock_t is an arithmetic type; the type of
CLOCKS_PER_SEC is unspecified. As a result, the type of the expression

(clock() - start clock) / CLOCKS_PER_SEC

may vary from one implementation to another, making it difficult to display using
printf. To solve the problem, our example converts CLOCKS PFR_SEC to
double, forcing the entire expression to have type double. In C99, the type of
CLOCKS_PER_SEC is specified to be clock_t. but clock_t is still an imple-
mentation-defined type.

‘The time function returns the current calendar time. If its argument isn't a
null pointer, time also stores the calendar time in the object that the argument
points to. time's ability to return a time in two different ways is an historical
quirk, but it gives us the option of writing either

cur_time = time (NULL) ;

or
694

Chapter 26  Miscellaneous Library Functions

difftime

mktime

time (&cur time) ;

where cur_time isa variable of type time t.

The difftime function returns the difference between time0 (the earlier
time) and time1, measured in seconds. Thus, to compute the actual running time
of a program (not the processor time), we could use the following code:

#include <stdio.h>
#include <time.hs>

int main(void)

time_t start_time = time (NULL);

printf ("Running time: %g sec.\n",
difftime (time(NULL), start_time));

return 0;

The mktime function converts a broken-down time (stored in the structure
that its argument points to) into a calendar time, which it then returns. As a side
effect, mktime adjusts the members of the structure according to the following
rules:

» miktime changes any members whose values aren’t within their legal ranges
(see Table 26.1). Those alterations may in turn require changes to other mem-
bers. If tm_sec is too large, for example, mktime reduces it to the proper
range (0-59), adding the extra minutes to tm_min. If tm_min is now too
large, mict ime reduces it and adds the extra hours to tm hour. If necessary,
the process will continue to the tm_mday, tm_mon, and tm year mem-
bers.

u After adjusting the other members of the structure (if necessary), mktime
sets tm_wday (day of the week) and tm_yday (day of the year) to their cor-
rect values. There’s never any need to initialize the values of tm_wday and
tm_yday before calling mktime; it ignores the original values of these
members.

mktime’s ability to adjust the members of a tm structure makes it useful for
time-related arithmetic. As a example, let’s use mktime to answer the following
question: If the 2012 Olympics begin on July 27 and end 16 days later, what is the
ending date? We'll start by storing July 27, 2012 in a tm structure:

struct tm t;
t.tm mday = 27;

t.tm mon = 6; /* July */
t.tm_year = 112; /% 2012 */

‘We'll also initialize the other members of the structure (except tm_wday and
tm_yday) to ensure that they don’t contain undefined values that could affect the
answer:
26.3 The <time.h> Header: Date and Time 695

.tm_sec = 0;

.tm_hour = 0;
.tm_isdst = -1;

oot

Next, we'll add 16 to the tm mday member:
t.tm_mday += 18;

That leaves 43 in tm_mday, which is out of range for that member. Calling
mktime will bring the members of the structure back into their proper ranges:

mktime (&) ;

We'll discard mktime’s return value, since we're interested only in the function’s
effect on t. The relevant members of t now have the following values:

Member Value  Meaning
tm_mday 12 12
tm_mon q August
tm_year 112 2012
tm_wday 0 Sunday

tm_yday 224 225th day of the year

Time Conversion Functions

char *asctime(const struct tm *timeptr);

char *ctime(const time t *timer);

struct tm *gmtime (const time_t *timer);

struct tm *localtime(const time t *timer);

size_t strftime(char * restrict s, size t maxsize,
const char * restrict format,
const struct tm * restrict timeptr);

The time conversion functions make it possible to convert calendar times to bro-
ken-down times. They can also convert times (calendar or broken-down) to string
form. The following figure shows how these functions are related:

: <« mktime
Calendar time _______» Broken-down time
t: gmtime struct tm
localtime
crime"_  asctime,” “strftime
N 4 -
\ i

‘ Character string I
696

Chapter 26  Miscellaneous Library Functions

gmtime
localtime

QzA

asctime

ctime

strftime

Eprintf unction »22.8

Tocales 25,1

@ 0

The figure includes the mktime function, which the C standard classifies as a
“manipulation” function rather than a “conversion” function.

The gmtime and localtime functions are similar. When passed a pointer
1o a calendar time, both return a pointer to a structure containing the equivalent
broken-down time. localtime produces a local time, while gmtime’s return
value is expressed in UTC (Coordinated Universal Time). The return value of
gmtime and localtime points to a statically allocated structure that may be
changed by a later call of either function.

The asctime (ASCII time) function returns a pointer to a null-terminated
string of the form

Sun Jun 3 17:48:34 2007\n

constructed from the broken-down time pointed to by its argument.
The ctime function returns a pointer to a string describing a local time. If
cur_time isa variable of type time_t, the call

ctime (&cur_time)
is equivalent to
asctime (localtime (scur time))

The return value of asctime and ctime points to a statically allocated string
that may be changed by a later call of either function.

The strftime function, like the asctime function, converts a broken-
down time to string form. Unlike asctime, however, it gives us a great deal of
control over how the time is formatted. In fact, strftime resembles sprintf
in that it writes characters into a string s (the first argument) according 1o a for-
miat string (the third argument). The format string may contain ordinary characters
(which are copied into s unchanged) along with the conversion specifiers shown
in Table 26.2 (which are replaced by the indicated strings). The last argument
points to a tm structure, which is used as the source of date and time information.
The second argument is a limit on the number of characters that can be stored in
s,

The strftime function, unlike the other functions in <time.h>, is sensi-
tive to the current locale. Changing the LC_TTME category may affect the behav-
ior of the conversion specifiers. The examples in Table 26.2 are strictly for the "C"
locale: in a German locale, the replacement for A might be Dienstag instead of
Tuesday.

The ('99 standard spells out the exact replacement strings for some of the con-
version specifiers in the *C* locale. (C89 didn't go into this level of detail.) Table
26.3 lists these conversion specifiers and the strings they re replaced by.

C99 also adds a number of strftime conversion specifiers, as Table 26.2
shows. One of the reasons for the additional conversion specifiers is the desire to
support the ISO 8601 standard.

Table 26.2
Conversion Specifiers for
the strftime Function

Table 26.3
Replacement Strings for
strftime Conversion

Specifiers in the
""" Locale

697

26.3 The <time.h> Header: Date and Time
Conversion Replacement
%a Abbreviated weekday name (e.g., Sun)
2A Full weekday name (e.g.. Sunday)
%b Abbreviated month name (e.g., Jun)
%B Full month name (e.g., June)
%c Complete day and time (c.g., Sun Jun 3 17:48:34 2007)
acf Year divided by 100 and truncated to an integer (00-99)
%d Day of month (01-31)
Eholl Equivalent to $m/%d/%y
ze’ Day of month (1-31); a single digit is preceded by a space
yr! Equivalent to Y- $m-%d
3g! Last two digits of 1SO 8601 week-based year (00-99)
LTel 1SO 8601 week-based year
sht Equivalent to $b
&H Hour on 24-hour clock (00-23)
%1 Hour on 12-hour clock (01-12)
%] Day of year (001-366)
&m Month (01-12)
M Minute (00-55)
2ot New-line character
%D AM/PM designator (AM or PM)
3r! 12-hour clock time (e.g., 05:48:34 PM)
$rY Equivalent to $H: $M
f Second (00-61); maximum value in C99 is 60
LT Horizontal-tab character
] Equivalent to $H: 3M: $5
sul 180 8601 weekday (1-7): Monday is 1
3U Week number (00-53); first Sunday is beginning of week 1
gv' 1SO 8601 week number (01-53)
Fw Weekday (0-6); Sunday is O
W Week number (00-53): first Monday is beginning of week |
x Complete date (e.g., 06/03/07)
X Complete time (e.g.. 17:48:34)
y Last two digits of year (00-99)
Y Year
32t Offset from UTC in ISO 8601 format (e.g., -0530 or +0200)
%2 Time zone name or abbreviation (c.g., EST)
¥ %
Tc99 onty
Conversion Replacement
%a First three characters of $A
%A One of "Sunday", "Monday". ..., "Saturday"
3b First three characters of $B
%B One of "January", "February", ..., "December"
%c Equivalentto "%a %b %e %T %Y
$p One of "AM" or "PM"
3r Equivalentto "fI:%M:%S %p"
8x Equivalent to "4m/%d/4y"
X Equivalent 10 $T
%7 Implementation-defined

698

Chapter 26  Miscellaneous Library Functions

PROGRAM

150 8601

ISO 8801 is an international standard that describes ways of representing dates
and times. It was originally published in 1988 and later updated in 2000 and 2004.
According to this standard, dates and times are entirely numeric (i.e., months are
not represented by names) and hours are expressed using the 24-hour clock.

There are a number of ISO 8601 date and time formats, some of which are
directly supported by strftime conversion specifiers in C99. The primary 1SO
8601 date format (YYYY~MM-DD) and the primary time format (hh:mm:ss) corre-
spond to the %F and %T conversion specifiers, respectively.

1SO 8601 has a system of numbering the weeks of a year; this system is sup-
ported by the %g, %G, and ¥V conversion specifiers. Weeks begin on Monday, and
week 1 is the week containing the first Thursday of the year. Consequently, the first
few days of January (as many as three) may belong to the last week of the previous
year. For example, consider the calendar for January 2011:

January 2011
Mo Tu We Th Fr Sa Su Year  Week

i i 2 000 52

3 4 5 6 7 8 9 2011 1
eSS b e SE 011 2
1708 wigoniiol 208 g3l 90H, 3
94 51 @5 270 198 90 30/ 2011 4
31 2011 5

January 6 is the first Thursday of the vear, so the week of January 3-9 is week 1.
January 1 and January 2 belong to the last week (week 52) of the previous year. For
these two dates, st rftime will replace %g by 10, %G by 2010, and %V by 52. Note
that the last few days of December will sometimes belong to week 1 of the following
year; this happens whenever December 29, 30, or 31 is a Monday.

The %z conversion specifier corresponds to the 1ISO 8601 time zone specifica-
tion: ~hhmm means that a time zone is i1k hours and mm minutes behind UTC; the
string +hhmm indicates the amount by which a time zone is ahead of UTC.

C99 allows the use of an E or O character to modify the meaning of certain
strftime conversion specifiers. Conversion specifiers that begin with an E or 0
modifier cause a replacement to be performed using an alternative format that
depends on the current locale. If an alternative representation doesn’t exist in the
current locale, the modificr has no effect. (In the "C" locale, E and O are ignored.)
Table 26.4 lists all conversion specifiers that are allowed to have E or © modifiers

Displaying the Date and Time

Let’s say we need a program that displays the current date and time. The program’s
first step, of course, is to call the time function to obtain the calendar time. The
Table 26.4

E- and O-Modified
Conversion Specifiers
for the strftime
Function (C99 only)

26.3 The <time.h> Header: Date and Time 699

Conversion Replacement

%Ec Alternative date and time representation

$EC Name of base year (period) in alternative representation

$EX Alternative date representation

SEX Alternative time representation

SEy Offset from $EC (year only) in alternative representation

$EY Full alternative year representation

%0d Day of month, using alternative numeric symbols (filled with leading
zeros or with leading spaces if there is no alternative symbol for zero)

%0e Day of month, using alternative numeric symbols (filled with leading
spaces)

%OH Hour on 24-hour clock, using alternative numeric symbols

%01 Hour on 12-hour clock, using alternative numeric symbols

som Month, using alternative numeric symbols

$OM Minute, using alternative numeric symbols

08 Second, using alternative numeric symbols

%0u ISO 8601 weekday as a number in alternative representation,
where Monday is 1

%0U ‘Week number, using alternative numeric symbols

S0V IS0 8601 week number, using alternative numeric symbols

0w ‘Weekday as a number, using alternative numeric symbols

| sow Week number, using alternative numeric symbols
| %0y Last two digits of year, using alternative numeric symbols

second step is to convert the time to string form and print it. The easiest way to do
the second step is to call ctime, which returns a pointer to a string containing a
date and time, then pass this pointer to puts or printf.

So far, so good. But what if we want the program to display the date and time
in a particular way? Let’s assume that we need the following format, where 06 is
the month and 03 is the day of the month:

06-03-2007 5:48p

The ctime function always uses the same format for the date and time, so it's no
help. The strftime function is better; using it, we can almost achieve the
appearance that we want. Unfortunately, strftime won’t let us display a one-
digit hour without a leading zero. Also, strftime uses AM and PM instead of a
and p.

When strftime isn't good enough, we have another alternative: convert the
calendar time to a broken-down time, then extract the relevant information from
the tm structure and format it ourselves using printf or a similar function. We
might even use strftime to do some of the formatting before having other func-
tions complete the job.

The following program illustrates the options. It displays the current date and
time in three formats: the one used by ct ime, one close to what we want (created
using strfrime), and the desired format (created using printf). The ctime
version is easy to do, the strftime version is a little harder. and the printf
version is the most difficult
700

Chapter 26  Miscellaneous Library Functions

datetime.c

/* Displays the current date and time in three formats */

#include <stdio.h>
#include <time. h>

int main(void)

time t current - time(NULL);
struct tm *ptr;

char date time[21];

int hour;

char am_or pm;

/* Print date and time in default format */
puts (ctime (gcurrent) ) ;

/* Print date and time, using strftime to format */
strftime (date time, sizeof(date time),

"¥m-%d-%¥Y $I:3M3p\n", localtime (&kcurrent)) ;
puts (date_time) ;

/* Print date and time, using printf to format */
ptr = localtime (&current) ;
hour = ptr->tm hour;
if (hour <= 11)
am or pm = ‘a';
elee {
hour -= 12;
am_or_pm =

if (hour == 0)
hour = 12;
printf ("%.2d-%.2d-%d %2d:%.2d%c\n", ptr->tm mon + 1,
ptr->tm mday, ptr->tm year + 1900, hour,
ptr->tm min, am or_ pm) ;

return 0;

The output of datetime . c will have the following appearance:
Sun Jun 3 17:4B8:34 2007
06-03-2007 05:48PM

06-03-2007 5:48p

Q&A

Although <gtdlib.h> provides a number of functions that convert strings
to numbers, there don’t appear to be any functions that convert numbers to
strings. What gives?
sprintf function >228

Qs

nan function »23.4

*Q:

A:

automalic storage duration > 7.2

setvbuf function »22.2

@@

Q&A 701

Some C libraries supply functions with names like itoa that convert numbers to
strings. Using these functions isn’t a great idea, though: they aren’t part of the C
standard and won't be portable. The best way to perform this kind of conversion is
to call a function such as sprintf that writes formatted output into a string:

char str(20];
i Ealc )

sprintf (stx, "%d", i); /* writes i into the string str */

Not only is sprintf portable, but it also provides a great deal of control over the
appearance of the number.

The description of the strtod function says that C99 allows the string argu-
ment to contain a hexadecimal floating-point number, infinity, or NaN. What
is the format of these numbers? [p. 684]

A hexadecimal floating-point number begins with 0x or 0X, followed by one or
more hexadecimal digits (possibly including a decimal-point character), and then
possibly a binary exponent. (See the Q&A at the end of Chapter 7 for a discus-
sion of hexadecimal floating constants, which have a similar—but not identical—
format.) Infinity has the form INF or INFINITY; any or all of the letters may be
lower-case. NaN is represented by the string NAN (again ignoring case), possibly
followed by a pair of parentheses. The parentheses may be empty or they may
contain a series of characters, where each character is a letter, digit, or under-
score. The characters may be used to specify some of the bits in the binary repre-
sentation of the NaN value, but their exact meaning is implementation-defined.
The same kind of character sequence—which the C99 standard calls an n-char-
sequence—is also used in calls of the nan function.

You said that performing the call exit (#) anywhere in a program is nor-
mally equivalent to executing the statement return u; in main. When would
it not be equivalent? [p. 688]

There are two issues. First, when the `main` function returns, the lifetime of its
local variables ends (assuming that they have automatic storage duration, as they
will unless they're declared to be static), which isn’t true if the `exit` function
is called. A problem will occur if any action that takes place at program termina-
tion—such as calling a function previously registered using atexit or flushing
an output stream buffer—requires access to one of these variables. In particular, a
program might have called setvbuf and used one of main’s variables as a
buffer. Thus, in rare cases a program may behave improperly if it attempts to return
from main but work if it calls exit instead.

The other issue occurs only in C99, which makes it legal for main to have a
return type other than int if an implementation explicitly allows the programmer
to do so. In these circumstances, the call exit (n) isn’t necessarily equivalent to
executing return #; in main. In fact, the statement return n; may be illegal
(if main is declared to return void, for example).
702 Chapter 26  Miscellaneous Library Functions

#Q:

A:

signal function »24.3

Longjmp function »24.4

Section 26.1

Q:

Az

A

Is there a relationship between the abort function and SIGAERT signal? [p.
688]

Yes. A call of abort actually raises the SIGABRT signal. If there’s no handler for
SIGABRT, the program terminates abnormally as described in Section 26.2. If a
handler has been installed for SIGABRT (by a call of the signal function), the
handler is called. If the handler returns, the program then terminates abnormally.
However, if the handler doesn’t return (it calls longjmp, for example), then the
program doesn’t terminate.

Why do the div and 1div functions exist? Can’t we just use the / and %
operators? [p. 692]

div and 1div aren’t quite the same as / and %. Recall from Section 4.1 that
applying / and % to negative operands doesn’t give a portable result in C89. If i or
3 is negative, whether the value of i / j is rounded up or down is implementation-
defined, as is the sign of i % j. The answers computed by div and 1div, on the
other hand, don’t depend on the implementation. The quotient is rounded toward
zero; the remainder is computed according to the formulan = g X d + r, where n is
the original number, c is the quotient, d is the divisor, and r is the remainder. Here
are a few examples:

n d q r

A 3 2 1
7 3 2 -
73 =2 1
=7 3 2 -

In C99, the / and % operators are guaranteed to produce the same result as div
and 1diwv.

Efficiency is the other reason that div and 1div exist. Many machines have
an instruction that can compute both the quotient and remainder, so calling div or
1div may be faster than using the / and % operators separately.

‘Where does the name of the gmtime function come from? [p. 696]

The name gmt ime stands for Greenwich Mean Time (GMT), referring to the local
(solar) time at the Royal Observatory in Greenwich, England. In 1884, GMT was
adopted as an international reference time, with other time zones expressed as
hours “behind GMT"” or “ahead of GMT.” In 1972, Coordinated Universal Time
(UTC)—a system based on atomic clocks rather than solar observations—replaced
GMT as the international time reference. By adding a “leap second” once every
few years, UTC is kept synchronized with GMT to within 0.9 second, so for all but
the most precise time measurements the two systems are identical.

Exercises

Rewrite the max_int function so that, instead of passing the number of integers as the first
argument, we must supply 0 as the last argument. Hin; max_int must have at least one
Section 26.2

o

Q7

o 9

Exercises 703

“normal” parameter, so you can’t remove the parameter n. Instead, assume that it represents
one of the numbers to be compared.

‘Write a simplified version of printf in which the only conversion specification is %4, and
all arguments after the first are assumed to have int type. If the function encounters a %
character that’s not immediately followed by a d character, it should ignore both characters.
‘The function should use calls of putchar to produce all output. You may assume that the
format string doesn’t contain escape sequences.

Extend the function of Exercise 2 so that it allows two conversion specifications: $d and
%s. Each %4 in the format string indicates an int argument, and each %s indicates a chax
= (string) argument,

Write a function named di splay that takes any number of arguments. The first argument
must be an integer. The remaining arguments will be strings, The first argument specifies
how many strings the call contains. The function will print the strings on a single line, with
adjacent strings separated by one space. For example, the call

display(4, "Special", "Agent", "Dale", "Cooper"):
will produce the following output:

Special Agent Dale Cooper

Write the following function:

char *vstrcat (const char *first, ...):

All arguments of vstrcat are assumed to be strings, except for the last argument, which
must be a null pointer (castto char * type). The function returns a pointer to a dynamically
allocated string containing the concatenation of the arguments. vstrcat should return a
null pointer if not enough memory is available. Hint: Have vstreat go through the argu-
ments twice: once to determine the amount of memory required for the returned string and
once to copy the arguments into the string.

‘Write the following function:
char *max_pair(int num pairs, ...);

The arguments of max_pair are assumed to be “pairs” of integers and strings; the value of
num_pairs indicates how many pairs will follow. (A pair consists of an int argument
followed by a char * argument). The function searches the integers to find the largest one:
it then returns the string argument that follows it. Consider the following call:

max_pair(5, 180, "Seinfeld", 180, "I Love Lucy",
39, "The Honeymooners", 210, "All in the Family",
86, "The Sopranos")

The largest int argument is 210, so the function returns "A11 in the Family", wh
follows it in the argument list.

Explain the meaning of the following statement, assuming that value is a variable of type
long int and p is a variable of type char *:

value = strtol(p, &p, 10);
‘Write a statement that randomly assigns one of the numbers 7, 11, 15, or 19 to the variable n.
‘Write a function that returns a random double value d in the range 0.0 <d < 1.0.

Convert the following calls of atoi, atol, and atoll into calls of strtol, strtol,
and strtoll, respectively.
704 Chapter 26 Miscellaneous Library Functions

Section 26.3 12.

(a) atoi (str)
(b) atol (str)
(c) atoll(str)

Although the bseaxrch function is normally used with a sorted array, it will sometimes
work correctly with an array that is only partially sorted. What condition must an array sat-
isly to guurantee that bsearch works properly for a particular key? Hint: The answer
appears in the C standard.

Write a function that, when passed a year, returns a time_t value representing 12:00 a.m.
on the first day of that year.

Section 26.3 described some of the ISO 8601 date and time formats. Here are a few more:

(a) Year followed by day of year: YYYY-DDD, where DDD is a number between 001 and
366

(b) Year. week, and day of week: YYYY-Www—D, where wiv is a number between 01 and
53, and D is a digit between 1 through 7, beginning with Monday and ending with Sun-
day

(c) Combined datc and time: ¥YYY-MM-DDThh:mm:ss

Give strftime strings that correspond to each of these formats.

Programming Projects

(a) Write a program that calls the rand function 1000 times, printing the low-order bit of
each value it returns (0 if the return value is even, 1 if it’s odd). Do you see any patterns?
(Often, the last few bits of xand’s return value aren’t especially random. )

(b) How can we improve the randomness of rand for generating numbers within a small
range?

‘Write a program that tests the at`exit` function. The program should have two functions
(in addition to main), one of which prints That 's all, and the other folks!. Use the
at`exit` function to register both (o be called at program termination. Make sure they're
called in the proper order, so that we see the message That's all, folks! on the
sereen.

‘Write a program that uses the clock function to measure how long it takes gsort to sort
an array of 1000 integers that are originally in reverse order. Run the program for arrays of
10000 and 100000 integers as well.

Write a program that prompts the user for a date (month, day, and year) and an integer n,
then prints the date that's n days later.

Write a program that prompts the user to enter two dates, then prints the difference between
them, measured in days. Hint: Use the mktime and difftime functions.

Write programs that display the current date and time in each of the following formats. Use
strftime to do all or most of the formarting.

(a) Sunday, June 3, 2007 05:48p

() sun, 3 Jun 07 17:48

(c) 06/03/07 5:48:34 BM
27

271

Additional C99 Support for
Mathematics

Simplicity does not precede complexity, but follows it

This chapter completes our coverage of the standard library by describing five
headers that are new in C99. These headers, like some of the older ones, provide
support for working with numbers. However, the new headers are more specialized
than the old ones. Some of them will appeal primarily to engineers, scientists, and
mathematicians, who may need complex number: well as greater control over
the representation of numbers and the way floating-point arithmetic is performed.

The first two sections discuss headers related to the integer types. The
<stdint.h> header (Section 27.1) declares integer types that have a specified
number of bits. The <inttypes.h> header (Section 27.2) provides macros that
are useful for reading and writing values of the <stdint. h> types.

The next two sections describe C99's support for complex numbers. Scction
27.3 includes a review of complex numbers as well as a discussion of C99's com-
plex types. Section 27.4 then covers the <complex.hs header, which supplies
functions that perform mathematical operations on complex numbers.

The headers discussed in the last two sections are related to the floating types.
The <tgmath.h> header (Section 27.5) provides type-generic macros that make
it easier to call library functions in <complex.h> and <math.h>. The func-
tions in the <fenv.h> header (Section 27.6) give programs access to floating-
point status flags and control modes,

The <stdint.h> Header (C99): Integer Types

The <stdint.h> header declares integer types containing a specified number
of bits. In addition, it defines macros that represent the minimum and maxi-
mum values of these types as well as of integer types declared in other headers,

705
706 Chapter 27  Additional C99 Support for Mathematics

<limits.h>header »232

sign bit >7.1

(These macros augment the ones in the <1imits.h> header) <stdint.h>
also defines parameterized macros that construct integer constants with specific
types. There are no functions in <stdint .h>.

The primary motivation for the <stdint .h> header lies in an observation
made in Section 7.5, which discussed the role of type definitions in making pro-
grams portable. For example, if 1 is an int variable, the assignment

i = 100000;

is fine if int is a 32-bit type but will fail if int is a 16-bit type. The problem is
that the C standard doesn’t specify exactly how many bits an int value has. The
standard does guarantee that the values of the int type must include all numbers
between —32767 and +32767 (which requires at least 16 bits), but that’s all it has to
say on the matter. In the case of the variable i, which needs to be able to store
100000, the traditional solution is to declare 1 to be of some type T, where T is a
type name created using typedef. The declaration of T can then be adjusted
based on the sizes of integers in a particular implementation. (On a 16-bit machine,
T would need to be Long int, but on a 32-bit machine, it can be int.) This is the
strategy that Section 7.5 discusses.

If your compiler supports C99, there's a betler technique. The <stdint.h>
header declares names for types based on the width of the type (the number of bits
used to store values of the type. including the sign bit, if any). The typedef
names declared in <stdint .h> may refer to basic types (such as int, un-
signed int, and long int)or to extended integer types that are supported by a
particular implementation.

<stdint.h> Types
The types declared in <stdint . h> fall into five groups:

u Exact-width integer types. Each name of the form intN_t represents a
signed integer type with IV bits, stored in two’s-complement form. (Two's
complement, a technigue used to represent signed integers in binary, is nearly
universal among modern computers.) For example, a value of type int16 t
would be a 16-bit signed integer. A name of the form uintN_t represents an
unsigned integer type with N bits. An implementation is required to provide
both intN_t and uintN t for N =8, 16, 32, and 64 if it supports integers
with these widths.

» Minimum-width integer types. Each name of the form int_leastN_t rep-
resents a signed integer type with at least N bits, A name of the form
uint_leastN_t represents an unsigned integer type with N or more bits.
<stdint.h> is required to provide at least the following minimum-width
types:
int_least8_t uint_least8_t
int_leastl6_t uint leastlé_t

27.1 The <stdint.h> Header (C99): Integer Types 707

int_least32 t uint least32 t
int leasté4 t uint leasté4_t

u Fastest minimum-width integer fypes. Each name of the form
int fastN_t represents the fastest signed integer type with at least N bits.
(The meaning of “fastest” is up to the implementation. If there's no reason to
classify a particular type as the fastest, the implementation may choose any
signed integer type with at least N bits.) Each namc of the form
uint_fastN_t represents the fastest unsigned integer type with N or more
bits. <stdint.h> is required to provide at least the following fastest mini-
mum-width types:

int_fasts_t uint_fast8_t

int fastl6 t uint fastié_t
int_ fast32 t uint fast32 t
int_fasté4_t uint_fasté64_t

m Integer types capable of holding object pointers. The intptr_t type repre-
sents a signed integer type that can safely store any void * value. More pre-
cisely, if a void * pointer is converted to intptx_t type and then back to
void *, the resulting pointer and the original pointer will compare equal. The
uintptr_t type is an unsigned integer type with the same property as
intptr_t. The <stdint .h: header isn’t required to provide either type.

u Greatest-width integer types. intmax_t is a signed integer type that
includes all values that belong to any signed integer type. uintmax t is an
unsigned integer type that includes all values that belong to any unsigned inte-
ger type. <stdint.h> is required to provide both types, which might be
wider than long long int.

The names in the first three groups are declared using cypedef.

An implementation may provide exact-width integer types, minimum-width
integer types, and fastest minimum-width integer types for values of N in addition
to the ones listed above. Also, N isn’t required to be a power of 2 (although it will
normally be a multiple of 8). For example, an implementation might provide types
named int24 tanduint24 t.

Limits of Specified-Width Integer Types

For each signed integer type declared in <stdint . h>, the header defines macros
that specify the type’s minimum and maximum values. For each unsigned integer
type, <stdint . h> defines a macro that specifies the type’s maximum value. The
first three rows of Table 27.1 show the values of these macros for the exact-width
integer types. The remaining rows show the constraints imposed by the C99 stan-
dard on the minimum and maximum values of the other <stdint . h> types. (The
precise values of these macros are implementation-defined.) All macros in the
table represent constant expressions.
708 Chapter 27  Additional C99 Support for Mathematics

Table 27.1
<stdint.h> Limit
Macros for Specified-
Width Integer Types

<stddef .h> header »21.4
<signal .h header »243
<wchar > header»255

Integar constants >7.1

intoger promations »-7.4

Name Value Description
INTN_MIN —(2"1)  Minimum intA_t value
INTN_MAX 2% Maximum intN_t value
UINTN_MAX 2% Maximum uintN_t value
INT LEASTN_MIN  <~(2"'_1) Minimum int_leastN_t value
INT LEASTN_MAX >%1]  Maximum int_leastN_t value
UINT LEASTN MAX >0¥ | Maximum uint_leastN_t value
INT_FASTN_MIN < (2'' 1) Minimum int_fastN_t value
INT_FASTN_MAX 22%1_|  Maximum int_fasth_t value
UINT_FASTN_MAX Maximum uint_fastN_t value
INTPTR MIN Minimum intptr t value
INTPTR_MAX Maximum intptr_t value
UINTPTR_MAX Maximum uintptr_t value

| vTMAX_MIN <" 1) Minimum intmax_t valee
INTMAX MAX 220 Maximum intmax_t value
UINTMAX_MAX 22%-1 Maximum uintmax_t value
Limits of Other Integer Types

When the C99 committee created the <stdint .h> header, they decided that it
would be a good place to put macros describing the limits of integer types besides
the ones declared in <stdint. h» itself. These types are ptrdiff t,size t,
and wehar_t (which belong to <stddef.h>), sig_atomic_t (declared in
<signal.h>), and wint_t (declared in <wchar.h>). Table 27.2 lists these
macros and shows the value of cach (or any constraints on the value imposed by
the C99 standard). In some cases, the constraints on the minimum and maximum
values of a type depend on whether the type is signed or unsigned. The macros in
Table 27.2, like the ones in Table 27.1, represent constant expressions

Macros for Integer Constants

The <stdint . h> header also provides function-like macros that are able to con-
vert an integer constant (expressed in decimal, octal, or hexadecimal, but without a
U and/or L suffix) into a constant expression belonging to a minimum-width inte-
ger type or greatest-width integer type.

For each int_leastN t type declared in <stdint.h>, the header
defines a parameterized macro named INTN_C that converts an integer constant to
this type (possibly using the integer promotions). For each uint leastN t
type, there's a similar parameterized macro named UINTN_C. These macros are
useful for initializing variables, among other things. For example, if 1 is a variable
of type int_least32_t, writing
Table 27.2
<stdint.h> Limit
Macros for Other
Integer Types

272

QzA

27.2 The <inttypes.h> Header (C99) 709

Name Value Description
PTRDIFF_MIN <-65535 Minimum ptrdiff_t value
PTRDIFF_MAX 2465535 Maximum ptrdiff t value

<127 (if signed)
0 (if unsigned)

24127 (if signed)
>255 (if unsigned)
SIZE_MAX 265535 Maximum size t value
<-127 (if signed)

STG_ATOMIC MIN Minimum sig_atomic_t value

SIG ATOMIC_MAX Maximum sig atomic t value

WCHAR_MIN 0/ i nsigrod) Minimum wchar_t value
5 2+127 (if signed) 5
WCHAR MAX 2255 (if unsigned) Maximum wchar _t value
WINT MIN Sl Minimum wint_t value
-~ 0 (if unsigned) ]
WINT_MAX 2432767 (if signed)  npirmum wine c valve

265535 (if unsigned)

i = 100000;

is problematic, because the constant 100000 might be too large to represent using
type int (if int is a 16-bit type). However, the statement

i = INT32_C(100000) ;

issafe. If int_least32_t represents the int type, then INT32_C(100000)
has type int. But if int_least32_ t corresponds to long int, then
INT32_C(100000) hastype long int.

<stdint .h> has two other parameterized macros. INTMAX_C converts an
integer constant to type intmax_t, and UINTMAX_C converts an integer con-
stant to type uintmax_t.

The <inttypes.h> Header (C99)
Format Conversion of Integer Types

The <inttypes.h> header is closely related to the <stdint .h= hcader, the
topic of Section 27.1. In fact, <inttypes.h> includes <stdint.h>, so pro-
grams that include <inttypes.h> don’t need to include <stdint .h> as well
The <inttypes.h> header extends <stdint . h> in two ways. First, it defines
macros that can be used in ..printf and ..scanf format strings for input/output
of the integer types declared in <stdint .h>. Second, it provides functions for
working with greatest-width integers.
710

Chapter 27 Additional C99 Support for Mathematics

Macros for Format Specifiers

The types declared in the <stdint . h> header can be used to make programs more
portable, but they create new headaches for the programmer. Consider the problem
of displaying the value of the variable 1, where i has type int_least32 t.The
statement

printf (v = ¥a\n", i);

may not work, because i doesn't necessarily have int type. If int_least32 t
is another name for the long int type, then the correct conversion specification is
%1d, not %d. In order to use the ..printf and ..scanf functions in a portable
manner, we need a way to write conversion specifications that correspond to each
of the types declared in <stdint .h>, That's where the <inttypes . h> header
comes in. For each <stdint.h> type, <inttypes.h> provides a macro that
expands into a string literal containing the proper conversion specifier for that type.
Each macro name has three parts:

w The name begins with either PRT or SCN, depending on whether the macro
will be used in a call of a..printf function or a ..scanf function.

= Next comes a one-letter conversion specifier (d or 1 for a signed type: o, u, %,
or X for an unsigned type).

w The last part of the name indicates which <stdint . h> type is involved. For
example, the name of a macro that corresponds to the int_leastN_t type
would end with LEASTN.

Let’s return to our previous example, which involved displaying an integer of
type int_least32_t. Instead of using d as the conversion specifier, we'll
switch to the PRIALEAST32 macro. To use the macro, we'll split the printf
format string into three pieces and replace the d in %d by PRIALEAST32:

printf("i = %" PRIALEAST32 LA i

The value of PRIALEAST32 is probably either "d" (if int_least32 t isthe
same as the int type) or "1d" (if int_least32_t is the same as long int).
Let’s assume that it’s "1d" for the sake of discussion. After macro replacement,
the statement becomes

printf(ri = %" *1d" "\a", i);

Once the compiler joins the three string literals into one (which it will do automat-
ically), the statement will have the following appearance:

printf ("i = %1d\n", i);

Note that we can still include flags, a field width, and other options in our conver-
sion specification; PRIALEAST32 supplies only the conversion specifier and pos-
sibly a length modifier, such as the letter 1.

Table 27.3 lists the <inttypes . h> macros.
Table 27.3
Format-Specifier Macros
in<inttypes.hs

imaxabs
Imaxdiv

<5tdlib.h> header »25.2

27.2 The <inttypes.h> Header (C99) 711

~printf Macros for Signed Inieg:;s
PRIAN PRIALEASTN PRIAFASTN PRIAMAX PRIAPTR
PRIIN PRIALEASTN PRILFASTN PRIiMAX PRIiPTR
«printf Macras for Unsigned Integers
PRION PRTGLEASTN PRIOFASTN PRIOMAX PRIOPTR
PRIUN PRIULEASTN PRIUFASTN PRIUMAX PRIuPTR
PRIXN PRIXLEASTN PRIXFASTN PRIXMAX PRIXPTR
PRIXN PRIXLEASTN PRIXFASTN PRIXMAX PRIXPTR
.scanf Maoros for Signed Integers
SCNAV  SCNALEASTN SCNAFASTN SCNAMAX  SCNAPTR
SCNiN SCNiLEASTN SCNiFASTN SCNiMAX SCNiPTR
..acanf Macros for Unsigned Integers
SCNoN SCNoLEASTN SCNOFASTN SCNOMAX  SCNOPTR
SCNuN SCNuLEASTN SCNuFASTN SCNUMAX SCNuPTR
SCNxN  SCNXLEASTN SCNXFASTN  SCNxMAX  SCNXPTR

Functions for Greatest-Width Integer Types

intmax t imaxabs(intmax t j);

imaxdiv_t imaxdiv(intmax t numer, intmax t denom);

intmax_t strtoimax(const char * restrict nptr,
char ** restrict endptr,
int base);

uincmax_t strtoumax(const char * restrict nptr,
char ** restrict endptr,
int base);

intmax t westoimax(const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base);

uintmax _t westoumax(const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base);

In addition to defining macros, the <inttypes . h> header provides functions for
working with greatest-width integers, which were introduced in Section 27.1. A
greatest-width integer has type intmax_t (the widest signed integer type sup-
ported by an implementation) or uintmax_t (the widest unsigned integer type).
These types might be the same width as the long long int type, but they could
be wider. For example, long long int might be 64 bits wide and intmax_t
and uintmax_t might be 128 bits wide.

The imaxabe and imaxdiv functions are greatest-width versions of the
integer arithmetic functions declared in <stdlib.h>. The imaxabs function
returns the absolute value of its argument. Both the argument and the return value
have type intmax_t. The imaxdiv function divides its first argument by its
712

Chapter 27 Additional C99 Support for Mathematics

strtoimax
strtoumax

westoimax
westoumax

<wchar . 1> header »25.5

27.3

second, returning an imaxdiv_t value. imaxdiv_t is a structure that contains
both a quotient member (named quot) and a remainder member (rem): both
members have type intmax_t.

The strtoimax and strtoumax functions are greatest-width versions of
the numeric conversion functions of <stdlib.h>. The strtoimax function is
the same as strtol and strtoll, except that it returns a value of type int
max_t. The strtoumax function is equivalent to strtoul and strtoull,
except that it returns a value of type uintmax_t. Both strtoimax and stxr-
toumax return zero if no conversion could be performed. Both functions store
ERANGE in errno if a conversion produces a value that’s outside the range of the
function’s return type. In addition, strtoimax returns the smallest or largest
intmax_t value (INTMAX_MIN or INTMAX MAX): strtoumax returns the
largest uintmax_t value, UINTMAX MAX.

The westoimax and westoumax functions are greatest-width versions of
the wide-string numeric conversion functions of <wchar.h>. The westoimax
function is the same as westol and westoll, except that it returns a value of
type intmax_t. The westoumax function is equivalent to westoul and wee-
toull, except that it returns a value of type uintmax_t. Both westoimax and
westoumax return zero if no conversion could be performed. Both functions
store ERANGE in exrrno if a conversion produces a value that's outside the range
of the function’s return type. In addition, weetoimax returns the smallest or larg-
est intmax_t value (INTMAX MIN or INTMAX MAX); wecstoumax remurns
the largest uintmax_t value, UINTMAX MAX.

Complex Numbers (C99)

Complex numbers are used in scientific and engineering applications as well as
in mathematics. C99 provides several complex types, allows operators to have
complex operands, and adds a header named <complex.h> to the standard
library. There’s a catch, though: complex numbers aren’t supported by all im-
plementations of C99. Section 14.3 discussed the difference between a hosted
C99 implementation and a freestanding implementation. A hosted implementa-
tion must accept any program that conforms to the C99 standard, whereas a
freestanding implementation doesn’t have to compile programs that use com-
plex types or standard headers other than <float .h>, <is0646.h>, <lim-
its.h>, <stdarg.h>, <stdbocl.hs>, <stddef.h>, and <stdint.h>.
Thus. a freestanding implementation may lack both complex types and the
<complex. h> header.

We'll start with a review of the mathematical definition of complex numbers
and complex arithmetic. We'll then look at C99’s complex types and the operations
that can be performed on values of these types. Coverage of complex numbers con-
tinues in Section 27.4, which describes the «complex . h> header.
27.3 Complex Numbers (C99) 73

Definition of Complex Numbers

Let i be the square root of —1 (a number such that i* =—1), i is known as the imagi-
nary unit; engineers often represent it by the symbol ; instead of i. A complex
number has the form a + bi, where a and b are real numbers. a is said to be the real
part of the number, and b is the émaginary part. Note that the complex numbers
include the real numbers as a special case (when b = 0).

Why are complex numbers useful? For one thing, they allow solutions to prob-
lems that are otherwise unsolvable. Consider the equation x” + 1 = 0, which has no
solution if x is restricted to the real numbers. If complex numbers are allowed,
there are two solution: jand x=—i,

Complex numbers can be thought of as points in a two-dimensional space
known as the complex plane. Each complex number—a point in the complex
plane—is represented by Cartesian coordinates, where the real part of the number
corresponds to the x-coordinate of the point, and the imaginary part corresponds
to the y-coordinate. For example, the complex numbers 2 + 2.5, 1 — 3i, =3 — 2i,
and —3.5 + 1.5/ can be plotted as follows:

Imaginary
axis
4
3L
*2+2.51
3515 .
e
[t et
| S
T
3 el=3

An alternative system known as polar coordinates can also be used to specify
a point on the complex plane. With polar coordinates, a complex number z is repre-
sented by the values rand €, where 7 is the length of a line segment from the origin
10 z, and @is the angle between this segment and the real axis:

Imaginary
axis

Real
axis

714 Chapter 27  Additional C99 Support for Mathematics

r is called the absolute value of z. (The absolute value is also known as the norm,
modulus, or magnitude.) @ is said to be the argument (or phase angle) of z. The
absolute value of a + bi is given by the following equation;

[aiebil = AP

For additional information about converting from Cartesian coordinates to
polar coordinates and vice versa, see the Programming Projects at the cnd of the
chapter.

Complex Arithmetic

The sum of two complex numbers is found by separately adding the real parts of
the two numbers and the imaginary parts. For example,

G-20+15+3)=B+1.5)+(2+3i=45+i

The difference of two complex numbers is computed in a similar manner, by sepa-
rately subtracting the real parts and the imaginary parts. For example,

(B-2)-(15+3)=3-15)+(-2-3)i=15-5i

Multiplying complex numbers is done by multiplying each term of the first
number by each term of the second and then summing the products:

(3-2i) x (1.5 +30) = (3 x 1.5) + (3 30) + (-2 X 1.5) + (-2i x 3i)
=4.5+9i-3i-6"=105+6i

Note that the identity i*=—1 is used to simplify the result.

Dividing complex numbers is a bit harder. First, we need the concept of the
complex conjugate of a number, which is found by switching the sign of the num-
ber’s imaginary part. For example, 7 - 4i is the conjugate of 7 + 4, and 7 + 4i is the
conjugate of 7 — 4i. We'll use 2* to denote the conjugate of 4 complex number z.

The quotient of two complex numbers y and z is given by the formula

Wz =yztizz*

It turns out that zz* is always a real number, so dividing zz* into yz* is easy (just
divide both the real part and the imaginary part of yz* separately). The following
example shows how to divide 10.5 + 6i by 3 - 2i:

105+6i _ (105+60)(3+2i) _ 195+39 _ | 5 5,

3-2i (3-2i)(3+2i) 13

Complex Types in C99

C99 has considerable built-in support for complex numbers. Without including any
library headers, we can declare variables that represent complex numbers and then
perform arithmetic and other operations on these variables.
27.3 Complex Numbers (C99) 715

C99 provides three complex types, which were first introduced in Section 7.2:
float _Complex, double _Complex, and long double _Complex.
These types can be used in the same way as other types in C: to declare variables,
parameters, return types. array elements, members of structures and unions, and 5o
forth. For example, we could declare three variables as follows:
float _Complex x;
double Complex v;
long double _Complex z;

Each of these variables is stored just like an array of two ordinary floating-point
numbers. Thus, y is stored as two adjacent double values, with the first value
containing the real part of y and the second containing the imaginary part.

C99 also allows implementations to provide imaginary types (the keyword
_Imaginary is reserved for this purpose) but doesn’t make this a requirement.

Operations on Complex Numbers

Complex numbers may be used in expressions, although only the following opera-
tors allow complex operands:

= Unary + and -

= Logical negation (1)

n sizeof

u Cast

= Multiplicative (* and / only)

n Additive (+ and -)

= Equality (== and ! =)

» Logical and (&&)

u Logicalor (| |)

= Conditional (? :)

= Simple assignment (=)

» Compound assignment (*=, /=, +=, and -= only)

= Commaf(,)
Some notable omissions from the list include the relational operators (<, <=, >,
and >=), along with the increment (++) and decrement (- -) operators.

Conversion Rules for Complex Types

Section 7.4 described the C99 rules for type conversion, but without covering the
complex types. It's now time to rectify that situation. Before we get to the conver-
sion rules, though, we'll need some new terminology. For each floating type there is
a corresponding real type. In the case of the real floating types (float, double,
and long double), the corresponding real type is the same as the original type.
716

Chapter 27 Additional C99 Support for Mathematics

For the complex types, the corresponding real type is the original type without the
word _Complex. (The corresponding real type for float Complexis float,
for example.)

We're now ready to discuss the general rules that govern type conversions
involving complex types. I'll group them into three categories.

un Complex to complex. The first rule concerns conversions from one complex
type to another, such as converting from float Complex to double
_Cemplex. In this situation, the real and imaginary parts are converted sepa-
rately, using the rules for the corresponding real types (see Section 7.4). In our
example, the real part of the flocat Complex value would be converted to
double, yielding the real part of the double Complex value; the imagi-
nary part would be converted to double in a similar fashion.

m Real to complex. When a value of a real type is converted to a complex type,
the real part of the number is converted using the rules for converting from one
real type to another. The imaginary part of the result is set to positive or
unsigned zero.

u Complex to real. When a value of a complex type is converted to a real type,
the imaginary part of the number is discarded; the real part is converted using
the rules for converting from one real type to another.

One particular set of type conversions, known as the usual arithmetic conver-
sions, arc automatically applied to the operands of most binary operators. There
are special rules for performing the usual arithmetic conversions when at least one
of the two operands has a complex type:

1. If the corresponding real type of cither operand is long double, convert
the other operand so that its corresponding real type is long double.

2. Otherwise, if the corresponding real type of either operand is double,
convert the other operand so that its corresponding real type is double.

3. Otherwise, one of the operands must have f1oat as its corresponding real
type. Coonvert the other operand so that its corresponding real type is also
float.

A real operand still belongs to a real type after conversion. and a complex operand
still belongs to a complex type.

Normally, the goal of the usual arithmetic conversions is to convert both
operands to a common type. However, when a real operand is mixed with a com-
plex operand, performing the usual arithmetic conversions causes the operands to
have a common real type, but not necessarily the same type. For example, add-
ing a float operand and a double _Complex operand causes the float
operand to be converted to double rather than double _Complex. The type
of the result will be the complex type whose corresponding real type matches the
common real type. In our example, the type of the result will be double
_Complex.
27.4

Table 27.4
<complex.h> Macros

<stdbool . h> header »21.5

27.4 The <complex.h> Header (C99): Complex Arithmetic 717

The <complex.h> Header (C99): Complex
Arithmetic

As we saw in Section 27.3, C99 has significant built-in support for complex num-
bers. The <complex. h> header provides additional support in the form of math-
ematical functions on complex numbers, as well as some very useful macros and a
pragma. Let’s look at the macros first.

<complex.h> Macros

The <complex.h> header defines the macros shown in Table 27.4.

Name : Value K
complex _Complex
_Complex_I  Imaginary unit; has type const float Complex
T _Complex_T

complex serves as an alternative name for the awkward _Complex keyword.
We've scen a situation like this before with the Boolean type: the C99 committee
chose a new keyword (_Bool) that shouldn’t break existing programs, but pro-
vided a better name (bool) as a macro defined in the <stdbool.h> header.
Programs that include <complex . h> may use complex instead of _Complex,
just as programs that include <stdbool . h> may use bool rather than _Bool.

The T macro plays an important role in C99. There's no special language fea-
ture for creating a complex number from its real part and imaginary part. Instead, a
complex number can be constructed by multiplying the imaginary part by I and
adding the real part:

dcuble complex dc = 2.0 + 3.5 * Ij

The value of the variahle dc is 2 + 3.5i.

Note that both _Complex I and I represent the imaginary unit i. Presum-
ably most programmers will use I rather than _Complex_I. However, since I
might already be used in existing code for some other purpose, _Complex T is
available as a backup. If the name I causes a conflict, it can always be undefined:

#include <complex.h>
#undef I

The programmer might then define a different—but still short—name for i, such as
J:

#define J _Complex I
718

Chapter 27  Additional C99 Support for Mathematics

#pragma directive » 14.5

Also note that the type of _Complex_I (and hence the type of I) is float
_Complex, not double _Complex. When it's used in expressions, I will auto-
matically be widened to double _Complex or long double _Complex if
necessary.

The CX_LIMITED RANGE Pragma

The <complex.h> header provides a pragma named CX_LIMITED_ RANGE
that allows the compiler to use the following standard formulas for multiplication,
division, and absolute value:

(a+bi)x(c+di) = (ac— bd) + (be + ad)i
(a+bi)/(c+di) = [(ac+bd) + (b —ad)i] /(2 +d?)

la+bil = Ja?+b2

Using these formulas may cause anomalous results in some cascs because of over-
flow or underflow; moreover, the formulas don’t handle infinities properly.
Because of these potential problems, C99 doesn’t use the formulas without the
programmer’s permission.

The CX_LIMITED_RANGE pragma has the following appearance:

#pragma STDC CX_LIMITED RANGE on-off-switch

where on-off-switch is either ON, OFF, or DEFAULT. If the pragma is used with the
value ON. it allows the compiler to use the formulas listed above. The value OFF
causes the compiler to perform the calculations in a way that’s safer but possibly
slower. The default setting, indicated by the DEFAULT choice, is equivalent to
OFF.

The duration of the CX_LIMITED RANGE pragma depends on where it’s
used in a program. When it appears at the top level of a source file, outside any
external declarations, it remains in effect until the next CX_LIMITED RANGE
pragma or the end of the file. The only other place that a CX LIMITED RANGE
pragma might appear is at the beginning of a compound statement (possibly the
body of a function); in that case, the pragma remains in effect until the next
CX_LTIMTTED_RANGE pragma (even one inside a nested compound statement) or
the end of the compound statement. At the end of a compound statement, the state
of the switch returns to its value before the compound statement was entered.

<complex.h> Functions

The <complex. h> header provides functions similar to those in the C99 version
of <math.h>, The <complex.h> functions are divided into groups, just as they
were in <math.hs>: trigonometric, hyperbolic, exponential and logarithmic, and
power and absolute value. The only functions that are unique to complex numbers
are the manipulation functions, the last group discussed in this section.
errnovarable »24.2

cacos

27.4 The <complex.h> Header (C99): Complex Arithmetic 719

Each <complex.hs> function comes in three versions: a float complex
version, a double complex version, and a long double complex version.
The name of the float complex version ends with f, and the name of the
long double complex version ends with 1.

Before we delve into the <complex . h> functions, a few general comments
are in order. First, as with the <math. h> functions, the <complex.h> functions
expect angle measurements to be in radians, not degrees. Second, when an error
occurs, the <complex.h> functions may store a value in the exxno variable,
but aren’t required to.

There's one last thing we'll need before tackling the <complex.h> func-
tions. The term branch cut often appears in descriptions of functions that might
conceivably have more than one possible return value, In the realm of complex
numbers, choosing which value to return creates a branch cut: a curve (often just a
line) in the complex plane around which a function is discontinuous. Branch cuts
are usually not unique, but rather are determined by convention, An exact definition
of branch cuts takes us further into complex analysis than I'd like to go, so I'll sim-
ply reproduce the restrictions from the 99 standard without further explanation.

Trigonometric Functions

double complex cacos (double complex z);
float complex cacosf (float complex z);
long double complex cacosl (long double complex z);

double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl (long double complex z);

double complex catan(double complex z);
float complex catanf (float complex z);
long double complex catanl (long double complex z);

double complex ccos (double complex z);
float complex ccosf (float complex z);
long double complex ccosl(long double complex z);

double complex csin(double complex z);
float complex csinf (float complex z);
long double complex csinl(long double complex z);

double complex ctan(double complex z);
float complex ctanf (float complex z);
long double complex ctanl(long double complex z);

The cacos function computes the complex arc cosine, with branch cuts outside the
interval [~1, +1] along the real axis. The return value lics in a strip mathematically
unbounded along the imaginary axis and in the interval [0, 7] along the real axis.
720

Chapter 27  Additional C99 Support for Mathematics

casin

catan

ccos
osin
ctan

cacosh

casinh

catanh

The casin function computes the complex arc sine, with branch cuts outside
the interval [-1, +1] along the real axis. The return value lies in a strip mathemati-
cally unbounded along the imaginary axis and in the interval [-m/2. +7/2] along the
real axis.

The catan function computes the complex arc tangent, with branch cuts out-
side the interval [, +i] along the imaginary axis. The return value lies in a strip math-
ematically unbounded along the imaginary axis and in the interval [-1/2, +1/2] along
the real axis.

The ccos function computes the complex cosine, the csin function com-
putes the complex sine, and the ctan function computes the complex tangent.

Hyperbolic Functions

double complex cacosh(double complex z);
float complex cacoshf(float complex z);
long double complex cacoshl(long double complex z);

double complex casinh(double complex z);
float complex casinhf (float complex z);
long double complex casinhl (long double complex z);

double complex catanh(double complex z);
float complex catanhf (float complex z);
long double complex catanhl (long double complex z);

double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl (long double complex z);

double complex csinh(double complex z);
float complex csinhf (float complex z);
long double complex csinhl (long double complex z);

double complex ctanh(double complex z);
float complex ctanhf (float complex z);
long double complex ctanhl(long double complex z);

The cacosh function computes the complex arc hyperbolic cosine, with a branch
cut at values less than 1 along the real axis. The return value lies in a half-strip of
nonnegative values along the real axis and in the interval [—ir, +in] along the imag-
inary axis.

The casinh function computes the complex arc hyperbolic sine, with branch
cuts outside the interval [, +i] along the imaginary axis. The return value lies in a
strip mathematically unbounded along the real axis and in the interval [-im/2,
+in/2] along the imaginary axis.

The catanh function computes the complex arc hyperbolic tangent. with
branch cuts outside the interval [-1, +1] along the real axis. The return value lies in
ccosh
csinh
ctanh

cexp
clog

cabs
cpow

csqrt

27.4 The <complex.h> Header (C99): Complex Arithmetic 721

a strip mathematically unbounded along the real axis and in the interval [~in/2,
+in/2] along the imaginary axis

The ccosh function computes the complex hyperbolic cosine, the csinh
function computes the complex hyperbolic sine, and the ctanh function com-
putes the complex hyperbolic tangent.

Exponential and Logarithmic Functions

double complex cexp(double complex z);
float complex cexpf (float complex z);
long double complex cexpl(long double complex z);

double complex clog(double complex z);
float complex clogf (float complex z);
long double complex clogl (long double complex z);

The cexp function computes the complex base-e exponential value.

The clog function computes the complex natural (base-) logarithm, with a
branch cut along the negative real axis. The return value lies in a strip mathemati-
cally unbounded along the real axis and in the interval [, +in] along the imagi-
nary axis.

Power and Absolute-Value Functions

double cabs(double complex z);
float cabsf(float complex z);
long double cabsl (long double complex z);

double complex cpow(double complex x,
double complex y);
float complex cpowf (float complex X,
float complex y);:
long double complex cpowl(long double complex X,
long double complex ¥);

double complex csqrt (double complex z);
float complex csgrtf(float complex z);
long double complex csgrtl(long double complex z);

The cabs function computes the complex absolute value.

The cpow function returns x raised to the power y, with a branch cut for the
first parameter along the negative real axis.

The caqgrt function computes the complex square root, with a branch cut
along the negative real axis. The return value lies in the right half-plane (including
the imaginary axis).
722 Chapter 27 Additional C99 Support for Mathematics

carg

cimag
conj
cproj

creal

PROGRAM

Manipulation Functions

double carg(double complex z);
float cargf (float complex z);
long double cargl (long double complex z);

double cimag(double complex z);
float cimagf (float complex z);
long double cimagl(long double complex z);

double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);

double complex cproj (double complex z);
float complex cprojf(float complex z);
long double complex cprojl(long double complex Z)y

double creal (double complex z);
float crealf (float complex z);
long double creall(long double complex z);

The carg function returns the argument (phase angle) of z, with a branch cut
along the negative real axis. The return value lies in the interval [, +7].

The cimag function returns the imaginary part of z.

The conj function returns the complex conjugate of z.

The cproj function computes a projection of z onto the Riemann sphere.
The return value is equal to z unless one of its parts is infinite, in which case
cproj returns INFINITY + I * copysign (0.0, cimag(z) ).

The creal function returns the real part of z.

Finding the Roots of a Quadratic Equation
The roots of the quadratic equation

ax +bx+c=0
are given by the quadratic formula:

_ b Jb? dac
2a
In general, the value of x will be a complex number, because the square root of b -
4ac is imaginary if b° - dac (known as the discriminant) is less than 0.
For example, suppose that a =5, b =2, and c = 1, which gives us the equation

5Sc +2x+1=0

The value of the discriminant is 4 20 = 16, so the roots of the equation will be
quadratic.c

27.5

27.5 The <tgmath.h> Header (C99): Type-Generic Math 723

complex numbers. The following program, which uses several <complex.h>
functions, computes and displays the roots.

/* Finds the roots of the equationm 5x**2 + 2x + 1 = 0 */

#include <complex.h>
#include <stdio.h>

int main(void)

{
double a = 5, b =2, c = 1;
double complex discriminant sqrt = csqgrt(b * b - 4 * a * c);
double complex rootl = (-b + discriminant_sqrt) / (2 * a);
double complex root2 = (-b - discriminant sqrt) / (2 * a);

printf ("rootl = %g + %gi\n", creal (rootl), cimag(rootl));
printf ("root2 = %g + %gi\n", creal (root2), cimag(root2));

return 0;

}
Here’s the output of the program:

rootl = -0.2 + 0.44
root2 = -0.2 + -0.4i

The guadratic.c program shows how to display a complex number by
extracting the real and imaginary parts and then writing each as a floating-point
number. printf lacks conversion specifiers for complex numbers, so there’s no
easier technique. There’s also no shortcut for reading complex numbers; a program
will need to obtain the real and imaginary parts separately and then combine them
into a single complex number,

The <tgmath.h> Header (C99): Type-Generic
Math

The <tgmath.h> header provides parameterized macros with names that match
functions in <math.h> and <complex.h>. These fype-generic macros can
detect the types of the arguments passed to them and substitute a call of the appro-
priate version of a <math.h> or <complex.h> function.

In C99, there are multiple versions of many math functions, as we saw in Sec-
tions 23.3, 23.4, and 27.4. For example, the sqrt function comes in a double
version (sqrt), a float version (sqrtf), and a long double version
(sqrtl), as well as three versions for complex numbers (csqrt, csqrtf, and
csqrt1). By using <tgmath.h>, the programmer can simply invoke sgrt
without having to worry about which version is needed: the call sqrt (x) could
be a call of any of the six versions of sqrt, depending on the type of x.
724 Chapter 27 Additional C99 Support for Mathematics

Table 27.5
Type-Generic Macros in
<tgmath.h> (Group 1)

‘Table 27.6
Type-Generic Macros in
<tgmath.h> (Group 2)

One advantage of using <tgmath.h> is that calls of math functions become
easier to write (and read!). More importantly, a call of a type-generic macro won't
have to be modified in the future should the type of its argument(s) change.

The <tgmach. h> header includes both <math . h>and <complex.h>, by
the way, so including «tgmath . h> provides access to the functions in both headers.

Type-Generic Macros

The type-generic macros defined in the <tgmath.h> header fall into three
groups, depending on whether they correspond to functions in <math.h>,
<complex.h>, or both headers.

Table 27.5 lists the type-generic macros that correspond to functions in both
<math.h> and <complex.h>. Note that the name of each type-generic macro
matches the name of the “unsuffixed” <math.h> function (acos as opposed to
acosf or acosl, for example).

<math.h> <complex.h> Type-Generic

Function Function Macro
acos cacos acos
asin casin asin
atan catan atan
acosh cacosh acosh
asinh casinh asinh
atanh catanh atanh
cos ccos cos
sin csin sin
tan ctan tan
cosh ccosh cosh
sinh csinh sinh
tanh ctanh tanh
exp cexp exp
log clog log
pow cpow pow
sqrt csqrt sqrc
fabs cabs fabs

The macros in the second group (Table 27.6) correspond only to functions in
<math.h>. Each macro has the same name as the unsuffixed <math.h> func-
tion. Passing a complex argument to any of these macros causes undefined behavior.

atan2 fma 1lround remainder
chrt fmax log10d remquo
ceil fmin loglp rint
copysign fmod log2 round

erf frexp  logb scalbn
erfc hypot  lrint scalbla
exp2 ilogb  lround tgamma
expml 1dexp nearbyint trunc
fdim lgamma nextafter

floor 1llrint nexttoward
Table 27.7
Type-Generic Macros in
<tgmach.hs> (Group 3)

QzA

QzA

27.5 The <tgmath.h> Header (C99): Type-Generic Math 725

The macros in the final group (Table 27.7) correspond only to functions in
<complex.hs>.

conj  creal |
cprod

Between the three tables, all functions in <math.h> and <complex.hs>
that have multiple versions are accounted for, with the exception of modf.

Invoking a Type-Generic Macro

To understand whal happens when a type-generic macro is invoked, we first need
the concept of a generic parameter. Consider the prototypes for the three versions
of the nextafter function (from <math.h>):

double nextafter (double x, double y);
float nextafterf (float x, float y);
long double nextafterl(long double x, long double y);

The types of both x and y change depending on the version of nextafter, so
both parameters are generic. Now consider the prototypes for the three versions of
the nexttoward function:

double nexttoward(double x, long double y);
float nexttowardf (fleat x, long dcuble y);
long double nexttowardl(long double x, long double y);

“The first parameter is generic, but the second is not (it always has type long
double). Generic parameters always have type double (or double complex)
in the unsuffixed version of a function.

When a type-generic macro is invoked, the first step is to determine whether it
should be replaced by a <math.h> function or a <complex .h> function. (This
step doesn’t apply to the macros in Table 27.6, which are always replaced by a
<math . h> function, or the macros in Table 27.7, which are always replaced by a
<complex. h> function.) The rule is simple: if any argument corresponding to a
generic parameter is complex, then a <complex.h> function is chosen; other-
wise, a <math . h> function is selected.

The next step is to deduce which version of the <math.hs function or
<complex.h> function is being called. Let’s assume that the function being
called belongs to <math.h>. (The rules for the <complex.h> case are analo-
gous.) The following rules are used, in the order listed:

1. If any argument corresponding to a generic parameter has type long dou -
ble, the long double version of the function is called.

2. If any argument corresponding to a generic parameter has type double or
any integer type, the double version of the function is called.

3. Otherwise, the float version of the function is called.

Rule 2 is a little unusual: it states that an integer argument causes the double ver-
sion of a function to be called, not the f1ocat version. which you might expect.
726 Chapter 27  Additional C99 Support for Mathematics

27.6

As an example, assume that the following variables have been declared:

int i;

float f;

double d;

long double 1d;

float complex fc;
double complex dc;

long double complex ldc;

For each macro invocation in the left column below, the corresponding function
call appears in the right column:

Macro Equivalent
Invocation Function Call
sqrt (i) sgre (i)
sqrt (f) sqrez (f)
sqgrt (d) sqrt (d)
sgrt (1d) sqrtl (1d)
sgrt (fc) esqgrtE (fc)
sqrt (de) csqret (dc)

sgrt (1de) csgrtl(lde)

Note that writing sgrt (i) causes the double version of sgrt to be called, not
the float version.

These rules also cover macros with more than one parameter. For example, the
macro invocation pow (1d, f) will be replaced by the call powl (1d, f). Both
of pow’s parameters are generic; because one of the arguments has type long
double, rule | states that the long double version of pow will be called.

The <fenv.h> Header (C99): Floating-Point
Environment

IEEE Standard 754 is the most widely used representation for floating-point num-
bers. (This standard is also known as TEC 60559, which is how the C99 standard
refers to it.) The purpose of the < fenv . h> header is to give programs access (0
the floating-point status flags and control modes specified in the IEEE standard.
Although <fenv.h> was designed in a general fashion that allows it to work with
other floating-point representations, supporting the IEEE standard was the reason
for the header’s creation.

A discussion of why programs might need access to status flags and control
modes is beyond the scope of this book. For good examples, see “What every com-
puter scientist should know about floating-point arithmetic” by David Goldberg
(ACM Computing Surveys, vol. 23, no. 1 (March 1991): 5-48), which can be found
on the Web,
27.6 The <fenv.h> Header (C89): Floating-Point Environment 727

Floating-Point Status Flags and Control Modes

Section 7.2 discussed some of the basic properties of IEEE Standard 754. Sec-
tion 23.4, which covered the C99 additions to the <math.h> header, gave addi-
tional detail. Some of that discussion, particularly concerning exceptions and
rounding directions, is directly relevant to the < fenv . h> header. Before we con-
tinue, let’s review some of the material from Section 23.4 as well as define a few
new terms.

A floating-point status flag is a system variable that's set when a floating-
point exception is raised. In the IEEE standard, there are five types of floating-
point exceptions: overflow, underflow, division by zero, invalid eperation (the
result of an arithmetic operation was NaN), and inexact (the result of an arithmetic
operation had to be rounded). Each exception has a corresponding status flag.

The <fenv.h> header declares a type named fexcept_t that’s used for
working with the floating-point status flags. An fexcept L object represents
the collective value of these flags. Although fexcept_t can simply be an inte-
ger type, with single bits representing individual flags, the C99 standard doesn’t
make this a requirement. Other alternatives exist, including the possibility that
fexcept_t is a structure, with one member for each exception. This member
could store additional information about the corresponding exception, such as the
address of the floating-point instruction that caused the exception to be raised.

A floating-point control mode is a system variable that may be set by a pro-
gram to change the future behavior of floating-point arithmetic. The IEEE standard
requires a “directed-rounding” mode that controls the rounding direction when a
number can’t be represented exactly using a floating-point representation. There
are four rounding directions: (1) Round toward nearest. Rounds to the nearest rep-
resentable value. If a number falls halfway between two values, it’s rounded to the
“even” value (the one whose least significant bit is zero). (2) Round toward zero.
(3) Round toward positive infinity. (4) Round toward negative infinity. The default
rounding direction is round toward nearest. Some implementations of the IEEE
standard provide two additional control modes: a mode that controls rounding pre-
cision and a “trap enablement" mode that determines whether a floating-point pro-
cessor will trap (or stop) when an exception is raised.

The term floating-point environment refers to the combination of floating-
point status flags and control modes supported by a particular implementation. A
value of type fenv_t represents an entire floating-point environment. The
fenv_t type, like the fexcept_t type, is declared in <Eenv.h>.

<fenv.h> Macros

The <fenv.h> header potentially defines the macros listed in Table 27.8. Only
two of these macros (FE_ALL_EXCEPT and FE_DFI,_ ENV) are required, how-
ever. An implementation may define additional macros not listed in the table; the
names of these macros must begin with FE_ and an uppercase letter.
728

Chapter 27 Additional C99 Support for Mathematics

Table 27.8
<fenv.h> Macros

#pracma diective > 14.5

Name Vale Description |
FE DIVBYZERO Integer constant Defined only if the corresponding floating-
FE_INEXACT expressions whose  point exception is supported by the imple-
FE_INVALID bits do not overlap  mentation. An implementation may define
FE_OVERFL.OW additional macros that represent floating-
FE_UNDERFLOW point exceptions. |
FE_ALL_EXCEPT See description Bitwise or of all floating-point exception

macros defined by the implementation. Has
the value 0 if no such macros are defined.

FE_DOWNWARD Integer constant Defined only if the corresponding rounding
FE_TONEAREST expressions with direction can be retricved and set via the
FE_TOWARDZERC  distinct nonnega- fegelround and fesetround func-

FE_UPWARD tive values tions. An implementation may define addi-
tional macros that represent rounding |
directions.

FE_DFL_ENV A value of type Represents the default (program start-up) |

|

const fenv_t *  floating-point environment, An implemen-
tation may define additional macros that
represent floating-point environments.

The FENV_ACCESS Pragma

The <fenv.h> header provides a pragma named FENV_ACCESS that’s used to
notify the compiler of a program’s intention to use the functions provided by this
header, Knowing which portions of a program will use the capabilities of
<fenv.h> is important for the compiler, because some common optimizations
can't be performed if control modes don’t have their customary settings or may
change during program execution,

The FENV_ACCESS pragma has the following appearance:

#pragma STDC FENV_ACCESS on-off-switch

where on-aff-switch is either ON, OFF, or DEFAULT. If the pragma is used with the
value ON, it informs the compiler that the program might test floating-point status
flags or alter a floating-point control mode. The value OFF indicates that flags
won't be tested and default control modes are in effect. The meaning of DEFAULT
is implementation-defined: it represents either ON or OFF.

The duration of the FENV_ACCESS pragma depends on where it’s used in a
program. When it appears at the top level of a source file. outside any external dec-
larations, it remains in effect until the next FENV_ACCESS pragma or the end of
the file. The only other place that an FENV_ACCESS pragma might appear is at
the beginning of a compound statement (possibly the body of a function): in that
case, the pragma remains in effect until the next FENV_ACCESS pragma (even
one inside a nested compound statement) or the end of the compound statement. At
the end of a compound statement, the state of the switch returns to its value before
the compound statement was entered.

It’s the programmer’s responsibility to use the FENV_ACCESS pragma (o
indicate regions of a program in which low-level access to floating-point hardware
feclearexcept

fegetexcepiflag

feraiseexcept

27.6 The <fenv.h> Header (C99): Floating-Point Environment ~ 729

is needed. Undefined behavior occurs if a program tests floating-point status flags
or runs under non-default control modes in a region for which the value of the
pragma switch is OFF.

Typically, an FENV_ACCESS pragma that specifies the ON switch would be
placed at the beginning of a function body:

void f(double x, double y)

{

#pragma STDC FENV_ACCESS ON

.

The function f may test floating-point statws flags or change control modes as
needed. At the end of fs body, the pragma switch will return to its previous state.

When a program goes from an FENV_ACCESS “off” region to an “on” region
during execution, the floating-point status flags have unspecified values and the
control modes have their default settings.

Floating-Point Exception Functions

int feclearexcept (int excepts);
int fegetexceptflag(fexcept t *flagp, int excepts);
int feraiseexcept (int excepts);
int fesetexceptflag(const fexcept_t *flagp,
int excepts);
int fetestexcept (int excepts);

The <fenv.h> functions are divided into three groups. Functions in the first
group deal with the floating-point status flags. Each of the five functions has an
int parameter named excepts, which is the bitwise or of one or more of the
floating-point exception macros (the first group of macros listed in Table 27.8). For
example, the argument passed to one of these functions might be FE_INVALID |
FE_OVERFLOW | FE_UNDERFLOW, to represent the combination of these three
status flags. The argument may also be zero, 1o indicate that no flags are selected.

The feclearexcept function attempts to clear the floating-point excep-
tions represented by excepts. It returns zero if excepts is zero or if all
specified exceptions were successfully cleared; otherwise, it returns a nonzero
value.

The fegetexceptflag function attempts to retrieve the states of the
floating-point status flags represented by excepts. This data is stored in the
fexcept_t object pointed to by Llagp. The fegetexceptflag function
returns zero if the states of the status flags were successfully stored: otherwise, it
returns a nonzero value.

The feraiseexcept function attempts to raise supported floating-point
exceptions represented by excepts. It is implementation-defined whether
feraiseexcept also raises the inexact floating-point exception whenever it
730

Chapter 27  Additional C99 Support for Mathematics

fesetexcepltfiag

fetestexcept

fegetround

fesetround

raises the overflow or underflow exception. (Implementations that conform to the
IEEE standard will have this property.) feraiseexcept returns zero if
excepts is zero or if all specified exceptions were successfully raised; otherwise,
it returns a nonzero value.

The fesetexceptflag function attempts to set the floating-point status
flags represented by excepts. The states of the tlags are stored in the
fexcept_t object pointed to by flagp; this object must have been set by a pre-
vious call of fegetexceptflag. Moreover, the second argument in the prior
call of fegetexceptflag must have included all floating-point exceptions rep-
resented by excepts. The fesetexceptflag function returns zero if
excepts is zero or if all specified exceptions were successfully set: otherwise, it
returns a nonzero value.

The fetestexcept function tests only those floating-point status flags
represented by excepts. It returns the bitwise or of the floating-point excep-
tion macros corresponding to the flags that are currently set. For example, if the
value of excepts is FE_INVALTD | FE_OVERFLOW | FE_UNDERFLOW, the
fetestexcept function might return FE INVALID | FE UNDERFLOW, in-
dicating that, of the exceptions represented by FE_INVALID, FE_OVERFLOW,
and FE UNDERFLOW, only the flags for FE_INVALID and FE_UNDERFLOW
are currently set.

Rounding Functions

int fegetround(void),;
int fesetround(int round);

The fegetround and fesetround functions are used to determine the round-
ing direction and modify it. Both functions rely on the rounding-direction macros
(the third group in Table 27.8).

The fegetround function returns the value of the rounding-direction macro
that matches the current rounding direction. If the current rounding direction can’t
be determined or doesn't match any rounding-direction macro, fegetround
returns a negative number.

When passed the value of a rounding-direction macro, the fesetround
function attempts to establish the corresponding rounding direction. If the call is
suceessful, fesetround returns zero: otherwise, it returns a nonzero value.

Environment Functions

int fegetenv(fenv_t *envp);

int feholdexcept (fenv. t *envp):

int fesetenv(const fenv_t *envp);
int feupdateenv(const fenv_t *envp);
Q&A 731

The last four functions in <fenwv.h> deal with the entire floating-point environ-
ment, not just the status flags or control modes. Each function returns zero if it suc-
ceeds at the operation it was asked to perform. Otherwise, it returns a nonzero

value.
fegetenv The fegetenv function attempts to retrieve the current floating-point envi-
ronment from the processor and store it in the object pointed to by envp.
feholdexcept The feholdexcept function (1) stores the current floating-point environ-

ment in the object pointed to by envp, (2) clears the floating-point status flags,
and (3) attempts to install a non-stop mode—if available—for all floating-point
exceptions (so that future exceptions won’t cause a trap or stop).
fesetenv The fesetenv function attempts to establish the floating-point environment

represented by envp, which either points to a floating-point environment stored
by a previous call of fegetenv or feholdexcept, or is equal (o a floating-
point environment macro such as FE_DFL_ENV. Unlike the feupdateenv
function, fesetenv doesn’t raise any exceptions. If a call of fegetenv is used
to save the current floating-point environment, then a later call of fesetenv can
restore the environment to its previous state.

feupdateenv The feupdateenv function attempts to (1) save the currently raised float-
ing-point exceptions, (2) install the floating-point environment pointed to by
envp, and (3) raise the saved exceptions. envp either points to a floating-point
environment stored by a previous call of fegetenv or feholdexcept, or is
equal to a floating-point environment macro such as FE_DFL_ENV.

Q&A

Q: Ifthe <inttypes.h> header includes the <stdint .h> header, why do we
need the <stdint.h> header at all? [p. 709]
A:  The primary reason that <stdint . h> exists as a separate header is so that pro-
imglementation >14.3  grams in a freestanding implementation may include it. (C99 requires conforming
implementations—both hosted and freestanding—io provide the <stdint.hs>
header, but <inttypes.h> is required only for hosted implementations.) Even
in a hosted environment, it may be advantageous to include <stdint.h> rather
than <inttypes . h> to avoid defining all the macros that belong to the latter.

*Q: There are three versions of the modf function in <math.hs, so why i
there a type-generic macro named modf? [p. 725]

A:  Let's take a look at the prototypes for the three versions of modf:
double wodf (double value, double *iptr);

float modff (flcat value, float *iptr);
long double modfl(long double value, long double *iptr);

modf is unusual in that it has a pointer parameter, and the type of the pointer isn't
the same among the three versions of the function. (frexp and remquo have a

732 Chapter 27  Additional C99 Support for Mathematics

sl aithmtic conversions » 7.4

Section 27.1

Q:

Al

5

pointer parameter, but it always has int * type.) Having a type-generic macro for
modf would pose some difficult problems. For example, the meaning of modf (d,
&f), where d has type double and f has type float, is unclear: are we calling
the modf function or the modff function? Rather than develop a complicated set
of rules for a single function (and probably taking into account that mod f isn't a
very popular function), the C99 committee chose not to provide a type-generic
modf macro.

When a <tgmath.h>macrois invoked with an integer argument, the double
version of the corresponding function is called. Shouldn’t the float version be
called, according to the nsual arithmetic conversions? [p. 725]

We're dealing with a macro, not a function, so the usual arithmetic conversions
don’t come into play. The C99 committce had to create a rule for determining
which version of a function would be called when an integer argument is passed to
a <tgmath.h> macro. Although the committee at one point considered having
the float version called (for consistency with the usual arithmetic conversions),
they eventually decided that choosing the double version was better. First, it’s
safer: converting an integer to float may cause a loss of accuracy, especially for
integer types whose width is 32 bits or more. Second, it causes fewer surprises for
the programmer. Suppose that 1 is an integer variable. If the <tgmath.h> header
isn't included, the call sin (i) calls the sin function. On the other hand, if
<tgmath.hns is included, the call sin (i) invokes the sin macro; because i is
an integer, the preprocessor replaces the sin macro with the sin function, and the
end result is the same.

When a program invokes one of the type-generic macros in <tgmath.h>,
how does the implementation determine which function to call? Is there a way
for a macro to test the types of its arguments?

One unusual aspect of <tgmath.h> is that its macros need to be able to test the
types of the arguments that are passed to them. C has no features for testing types,
50 it would normally be impossible to write such a macro. The <tgmath.h>
macros rely on special facilities provided by a particular compiler to make such
testing possible. We don't know what these facilities are, and they re not guaran-
teed to be portable from one compiler to another.

Exercises

(C99) Locate the declarations of the intA t and uintN t types in the <stdint.h>
header installed on your system, Which values of N are supported?

(C99) Write the parameterized macros INT32_C(n), UINT32_C(n), INT64_C(n),
and UINTE4_C (n) , assuming that the int type and long int types are 32 bits wide and
the long long int type is 64 bits wide, Hini: Use the ## preprocessor operator to altach
Section 27.2

Section 27.5

4.

Programming Projects 733

a suffix to n containing a combination of L and/or U characters. (See Section 7.1 for a dis-
cussion of how to use the I and U suffixes with integer constants.)

(C99) Tn each of the following statements, assume that the variable 3 has the indicated orig-
inal type. Using macros from the <inttypes. h> header, modify cach statement so that it
will work correctly if the type of i is changed to the indicated new type.

(a) printf("4d", 1i); Original type: int New type: int8 t
(b) printf ("%12.4d", i); Original type: int New type: int32 t
(c) printf("%-6o0", i);  Original type: unsigned int New type:uintl6_t

(d) printf ("s#x", 1); Original type: unsigned int New type: uinted_t

(C99) Assume that the following variable declarations are in effect:

int i;
float f;

double d;

long double 1d;
float complex fc:
double complex dc;

long double complex ldc;

Each of the following is an invocation of a macro in <tgmath.h=. Show what it will look
like after preprocessing, when the macro has been replaced by a function from <math.h>
or c<complex.hs.

(a) tan(i)

(b) fabs(ff)

(c) asin(d)

(d) exp (1d)

(e) log(fc)

(f) acosh(de)

(g) nexttoward(d, 1d)

(h) remainder (f, 1)

(i) copysigni(d, ld)

(j) carg(i)

(k) cimag(f)

(1) conj (ldc)

Programming Projects

(€C99) Make the following modifications to the quadratic. e program of Section 27.4:

(a) Have the user enter the coefficients of the polynomial (the values of the variables a, b,
and c).

(b) Have the program test the discriminant before displaying the values of the roots. If the
discriminant is negative, have the program display the roots in the same way as before. If it’s
nonnegative, have the program display the roots as real numbers (without an imaginary part).
For example, if the quadratic equation is ¥’ + x —2 = 0, the output of the program would b

rootl = 1
root2 = -2

734

Chapter 27  Additional C99 Support for Mathematics

() Modify the program so that it displays a complex number with a ncgative imaginary
part as @ — bi instead of @ + —bi. For example, the output of the program with the original
coefficients would be

rootl = -0.2 + 0.41
root2 = -0.2 - 0.4i

(C99) Write a program that converts a complex number in Cartesian coordinates to polar
form. The user will enter 4 and b (the real and imaginary parts of the number); the program
will display the values of rand 6.

(C99) Write a program that converts a complex number in polar coordinates to Cartesian
form. After the user enters the values of 7 and 6, the program will display the number in the
form a + bi, where

cos &
sin

=

b=

(C99) Write a program that displays the nth roots of unity when given a positive integer n.
The nth roots of unity are given by the formula c’ where k is an integer between 0 and
=l
APPENDIX A
C Operators

Precedence Name Symbol(s) Associativity

1 Array subscripting {1 Left
1 Function call (6] Left
1 Structure and union member =5 Left
1 Increment (postfix) ¥ Left
1 Decrement (postfix) -- Left
2 Increment (prefix) e Right
2 Decrement (prefix) - Right
2 Address & Right
2 Indirection o Right
2] Unary plus + Right
2 Unary minus - Right
2 Bitwise complement ~ Right
2 Logical negation 1 Right
2 Size sizeof Right
3 Cast () Right
4 Multiplicative S Left
5 Additive + - Left
6 Bitwise shift e R Left
4 Relational e > <= == Left

737 Equality == = Left
9 Bitwise and & Left
10 Bitwise exclusive or > Left
11 Bitwise inclusive or J= Left
12 Logical and & Left
13 Logical or || Left
14 Conditional 2 Right
15 Assignment %= Right

= se=

16 Comma 5 Left

735
2
// comments

identifiers

keywords

returning from main

4

/ and % operators

APPENDIX B
C99 versus C89

This appendix lists many of the most significant differences between C89 and C99.
(The smaller differences are too numerous to mention here.) The headings indicate
which chapter contains the primary discussion of each C99 feature. Some of the
changes auributed to C99 actually occurred earlier, in Amendment 1 to the C89
standard; these changes are marked “Amendment 1.”

C Fundamentals
(C99 adds a second kind of comment, which begins with / /.

(89 requires compilers to remember the first 31 characters of identifiers; in C99,
the requirement is 63 characters. Only the first six characters of names with external
linkage are significant in C89. Moreover, the case of letters may not matter. In C99,
the first 31 characters are significant, and the case of letters is taken into account.

Five keywords are new in C99: inline, restrict, Bool, Cowplex, and
_Imaginary.

In C89, if a program reaches the end of the `main` function without executing a
`return` statement, the value returned to the operating system is undefined. In C99,
if main is declared to return an int., the program returns 0 to the operating system.

Expressions

The C89 standard states that if either operand is negative, the result of an integer
division can be rounded either up or down. Moreover. if 1 or j is negative, the sign
of 1 % j depends on the implementation. In C99, the result of a division is always
truncated toward zero and the value of i % j has the same sign as 1.

737
738

S5

_Bool fype

6

`for` statements

7

long long
integer types

extended integer types

long long integer
constants

types of integer
constants

hexadecimal floating
constants

implicit conversions

designated initializers

variable-length arrays

no default return type

mixed declarations
and statements

Appendix B C99 versus C89

Selection Statements

C99 provides a Boolean type named _Bool:; C89 has no Boolean type.

Loops

In (99, the first expression in a `for` statement can be replaced by a declaration,
allowing the statement to declare its own control variable(s).

Basic Types

C99 provides two additional standard integer types, long long int and un-
signed long long int.

In addition to the standard integer types, C99 allows implementation-defined
extended signed and unsigned integer types.

C99 provides a way to indicate that an integer constant has type long long int
orunsigned long long int.

C99’s rules for determining the type of an integer constant are different from those
in C89.

C99 provides a way to write floating constants in hexadecimal.

The rules for implicit conversions in C99 are somewhat different from the rules in
€89, primarily because of C99’s additional basic types.

Arrays

C99 supports designated initializers, which can be used to initialize arrays, struc-
tures, and unions.

In C99, the length of an array may be specified by an expression that's not con-
stant, provided that the array doesn’t have static storage duration and its declara-
tion doesn’t contain an initializer.

Functions

If the return type of a function is omitted in C89, the function is presumed to return
a value of type int. In C99, it’s illegal to omit the return type of a function.

In C89, declarations must precede statements within a block (including the body of
a function). In C99, declarations and statements can be mixed, as long as each vari-
able is declared prior to the first statement that uses the variable.
declaration or definition
required prior to
function call

variable-length
array parameters

static array
parameters

compound literals

declaration of main

`return` statement
without expression

14

additional predefined
macros

emply macro
arguments

macros with a variable
number of arguments

__func__ identifier

standard pragmas

_Pragma operator

16

structure type
compatibility

Appendix B C99 versus C89 739

C99 requires that either a declaration or a definition of a function be present prior
to any call of the function. C89 doesn’t have this requirement; if a function is
called without a prior declaration or definition, the compiler assumes that the func
tion returns an int value,

C99 allows variable-length array parameters. In a function declaration, the * sym-
bol may appear inside brackets to indicate a variable-length array parameter.

C99 allows the use of the word static in the declaration of an array parameter,
indicating a minimum length for the first dimension of the array.

(C99 supports the use of compound literals, which allow the creation of unnamed
array and structure values.

C99 allows main to he declared in an implementation-defined manner, with a
return type other than int and/or parameters other than those specified by the
standard.

In C89, executing a `return` statement without an expression in a non-void func-
tion causes undefined behavior (but only if the program attempts to use the value
returned by the function). In C99, such a statement is illegal.

The Preprocessor

C99 provides several new predefined macros.

C99 allows any or all of the arguments in a macro call to be empty, provided that
the call contains the correct number of commas.

In €89, a macro must have a fixed number of arguments, if it has any at all. C99
allows macros that take an unlimited number of arguments.

In C99, the __ func__identifier behaves like 2 string variable that stores the
name of the currently executing function.

In C89, there are no standard pragmas. C99 has three: CX_LIMITED_RANGE,
FENV_ACCESS, and FP_CONTRACT.

C99 provides the Pragma operator, which is used in conjunction with the
#pragma directive.
Structures, Unions, and Enumerations

In CR9, structures defined in different files are compatible if their members have
the same names and appear in the same order, with corresponding members having
740

trailing comma in
enumerations

17
restricted pointers

flexible array members

18

block scopes for
selection and iteration
statements

array, structure, and
union initializers

infine functions

21

<stdbool.h> header

22

~printf conversion
specifications

..scant conversion
specifications

snprintf function

23

additional macros in
<float.h> header

Appendix B C99 versus C89

compatible types. C99 also requires that either both structures have the same tag or
neither has a tag.

In C99, the last constant in an enumeration may be followed by a comma.

Advanced Uses of Pointers

C99 has anew keyword, restrict, that can appear in the declaration of a pointer.

C99 allows the last member of a structure to be an array of unspecified length.

Declarations

In C99. selection statements (i f and switch) and iteration statements (while,
do, and for)—along with the “inner” statements that they control—are consid-
ered to be blocks.

In C89, a brace-enclosed initializer for an array, structurc, or union must contain
only constant expressions. In C99, this restriction applies only if the variable has
static storage duration.

C99 allows functions to be declared inline.

The Standard Library

The <stdbool . h> header, which defines the bool, true, and false macros,
is new in C99.

Input/Output

The conversion specifications for the ..printf functions have undergone a num-
ber of changes in C99, with new length modifiers, new conversion specificrs, the
ability to write infinity and NaN, and support for wide characters. Also, the $1e,
%1E, 31f, %1g, and $1G conversions are legal in C99; they caused undefined
behavior in C89.

In C99. the conversion specifications for the ..scanf functions have new length
modifiers, new conversion specifiers, the ability to read infinity and NaN, and sup-
port for wide characters.

C99 adds the snprintf function to the <gtdic. h> header.

Library Support for Numbers and Character Data

C99 adds the DECIMAL DIG and FLT_EVAL_METHOD macros to the
<float.h> header.
additional macros in
<limits.h> header

math_errhandling
macro

additional functions in
<math.h> header

24

EILSEQ macro

25

digraphs

<i50646 . h> header

universal character
names

<wchar.h> header

<wctype.h> header

26
va_copy macro

additional functions in
<stdio.h> header

additional functions in
<stdlib.h> header

additional st rftime
conversion specifiers

Appendix B C99 versus C89 741

In C99, the <limits.h> header contains three new macros that describe the
characteristics of the long long int types.

C99 gives implementations a choice of how to inform a program that an error
has oceurred in a mathematical function: via a value stored in errno, via a
floating-point exception, or both. The value of the math_errhandling mac-
ro (defined in <math.hs>) indicates how errors are signaled by a particular
implementation.

C99 adds two new versions of most <math . h> functions, one for float and one
for long double. C99 also adds a number of completely new functions and
function-like macros to <math.h>.

Error Handling

C99 adds the ELLSEQ macro to the <errno.h> header.

International Features

Digraphs, which are two-character symbols that can be used as substitutes for the
[,1. {, }. #, and #3# tokens, are new in C99. (Amendment 1)

The <1s0646 . h> header, which defines macros that represent operatars contain-
ing the characters &, |, ~, !, and *, is new in C99. (Amendment 1)

Universal character names, which provide a way to embed UCS characters in the
source code of a program, are new in C99.

The <wchar.h> header, which provides functions for wide-character input/out-
put and wide string manipulation, is new in C99. (Amendment 1)

The <wctype.h> header, the wide-character version of <ctype.hs>, is new in
C99. <wctype . h> provides functions for classifying and changing the case of
wide characters. (Amendment 1)

Miscellaneous Library Functions

C99 adds a function-like macro named va_copy 1o the <stdarg.h> header.

C99 adds the venprintf, viscanf, vscanf, and vsscant functions to the
<gtdio.h> header.

(C99 adds five numeric conversion functions, the _`exit` function, and long long
versions of the abs and div functions to the <stdlib.h> header.

(C99 adds a number of new st rft ime conversion specifiers. It also allows the use
of an E or O character to modify the meaning of certain conversion specifiers.
742 Appendix B C99 versus C89

27

<stdint .h> header

<inttypes.h> header

complex types

<complex.h> header

<tgmath.h> header

<fenv.h> header

Additional C99 Support for Mathematics

The <stdint.h> header, which declares integer types with specified widths, is
new in C99.

The <inttypes.h> header, which provides macros that are useful for input/out-
put of the integer types in <stdint.h>, is new in C99,

C99 provides three complex types: float Complex, double _Complex,
and long double _Complex.

The <complex . h> header, which provides functions that perform mathematical
operations on complex numbers, is new in C99.

The <t.gmath . h> header, which provides type-generic macros that make it easier
to call library functions in <math.h> and <complex.h>, is new in C99.

The <fenv. h> header, which gives programs access to floating-point status flags
and control modes, 1s new in C99,
2
identifiers

keywords

unary +

switch

APPENDIX C
C89 versus K&R C

This appendix lists most of the significant differences between C89 and K&R C
(the language described in the first edition of Kernighan and Ritchie’s The C Pro-
gramming Language). The headings indicate which chapter of this book discusses
each CB9 feature. This appendix doesn’t address the C library, which has changed
much over the years. For other (less important) differences between C89 and K&R
C, consult Appendices A and C in the second edition of K&R.

Most of today’s C compilers can handle all of C89, but this appendix is useful
if you to happen to encounter older programs that were originally written for pre-
C89 compilers.

C Fundamentals

In K&R C, only the first eight characters of an identifier are significant.

K&R C lacks the keywords const, enum, signed, void, and volatile. ln
K&R C, the word entry is a keyword.

Expressions

K&R C doesn’t support the unary + operator.

Selection Statements

In K&R C, the controlling expression (and case labels) in a `switch` statement
must have type int after promotion. In C89, the expression and labels may be of
any integral type, including unsigned int and long int.

743
744 Appendix C C89 versus K&R C

7.
unsigned types
signed

number suffixes

long float

long double

escape sequences

size_t

usual arithmetic
conversions

9

function definitions

function declarations

Basic Types
K&R C provides only one unsigned type (unsigned int).
K&R C doesn’t support the signed type specifier.

K&R C doesn’t support the U (or u) suffix to specify that an integer constant is
unsigned, nor does it support the F (or f) suffix to indicate that a floating constant
is to be stored as a float value instead of a double value. In K&R C, the L (or
1) suffix can't be used with floating constants.

K&R C allows the use of long fflcat as a synonym for double; this usage
isn’t legal in C89.

K&R C doesn’t support the long double type.

The escape sequences \a. \v, and \ ? don’t exist in K&R C. Also, K&R C doesn't
support hexadecimal escape sequences.

In K&R C, the sizeof operator returns a value of type int: in C89, it returns a
value of type size t.

K&R C requires that float operands be converted to double. Also, K&R C
specifies that combining a shorter unsigned integer with a longer signed integer
always produces an unsigned result.

Functions

In a C89 function definition, the types of the parameters are included in the param-
eter list:

double square(double )

{

return X * x;

K&R C requires that the types of parameters be specified in separate lists:

double sguare (x)
double x;

{

return x * x;

}
A C89 function declaration (prototype) specifies the types of the function's param-
eters (and the names as well, if desired):

double square(double x);
double square (double); /* alternate form */
int rand(void); /* no parameters */
function calis

void

12

pointer subtraction

13

string literals

string initialization

14

#elif, ferror,
#pragma

#, #i#, defined

16

structure and union
members and tags

whole-structure
operations

enumerations

Appendix C  C89 versus K&R C 745

A K&R C function declaration omits all information about parameters:

double square();
int rand();

When a K&R C definition or declaration is used, the compiler doesn’t check that
the function is called with arguments of the proper number and type. Furthermore,
the arguments aren’t automatically converted to the types of the corresponding
parameters. Instead, the integral promotions are performed, and float arguments
are converted (o double,

K&R C doesn’t support the void type.

Pointers and Arrays

Subtracting two pointers produces an int value in K&R C but a ptrdiff t
value in C89.

Strings

In K&R C, adjacent string literals aren’t concatenated. Also, K&R C doesn’t pro-
hibit the modification of string literals.

In K&R C, an initializer for a character array of length # is limited to 7 — 1 charac-
ters (leaving room for a null character at the end). C89 allows the initializer to have
length n.

The Preprocessor

K&R C doesn’t support the #eli f, #error, and #pragma directives.

K&R C doesn’t support the #, ##, and de fined operators,

Structures, Unions, and Enumerations

In C89, each structure and union has its own name space for members; structure
and union tags are kept in a separate name space. K&R C uses a single name space
for members and tags, so members can't have the same name (with some excep-
tions), and members and tags can’t overlap.

K&R C doesn't allow structures to be assigned, passed as arguments, or returned
by functions.

K&R C doesn’t support enumerations.
746

17

void *

pointer mixing

pointers to functions

18
censt andvolatile

initialization of arrays,
structures, and unions

25
wide characters
trigraph sequences

26

variable arguments

Appendix C C89 versus K&R C

Advanced Uses of Pointers

In C89, void * is used as a “generic” pointer type; for example, malloc returns
a value of type void *. In K&R C, char * is used for this purpose.

K&R C allows pointers of different types to be mixed in assignments and compar-
isons. In C89, pointers of type void * can be mixed with pointers of other types,
but any other mixing isn’t allowed without casting. Similarly, K&R C allows the
mixing of integers and poinlers in assignments and comparisons; C89 requires
casting.

If pEf is a pointer to a function, C89 permits using either (*pf) (...) orpf (..) to
call the function. K&R C allows only (*pf) (..).

Declarations

K&R C doesn’t support the const and volatile type qualifiers,

K&R C doesn’t allow the initialization of automatic arrays and structures, nor does
it allow initialization of unions (regardless of storage duration).

International Features

K&R C doesn’t support wide character constants and wide string literals.

K&R C doesn’t support trigraph sequences.

Miscellaneous Library Functions

K&R C doesn’t provide a portable way to write functions with a variable number
of arguments, and it lacks the . . . (ellipsis) notation.
APPENDIX D
Standard Library Functions

This appendix describes all library functions supported by C89 and C99.% When
using this appendix, please keep the following points in mind:

In the interest of brevity and clarity, I've omitted many details. Some functions
(notably printf and scanf and their variants) are covered in depth else-
where in the book, so their descriptions here are minimal. For more informa-
tion about a function (including examples of how it’s used). see the section(s)
listed in italic at the lower right corner of the function’s description.

As in other parts of the book. italics arc used to indicate C99 differences. The
names and prototypes of functions that were added in C99 are shown in italics
Changes to C89 prototypes (the addition of the word restrict to the decla-
ration of certain parameters) are also italicized.

Function-like macros are included in this appendix (with the exception of the
type-generic macros in <tgmath.h>). Each prototype for a macro is fol-
lowed by the word macro.

In C99, some <math. h> functions have three versions (one each for float,
double, and long double). All three are grouped into a single entry,
under the name of the double version. For example, there’s only one entry
(under acos) for the acos, acost, and acos1 functions. The name of each
additional version (acosf and acos1, in this example) appears to the left of
its prototype. The <complex.h> functions, which also come in three ver-
sions, are treated in a similar fashion.

Most of the <wchar . h> functions are wide-character versions of functions
found in other headers. Unless there’s a significant difference in behavior, the

*This material is adapted from international standard ISO/IEC 9899:1999,

747
748

Appendix D Standard Library Functions

description of each wide-character function simply refers the reader to the cor-
responding function found elsewhere.

m If some aspect of a functions behavior is described as implementarion-
defined, that means that it depends on how the C library is implemented. The
function will always behave consistently, but the results may vary from one
system to another. (In other words, check the manual to sce what happens.)
Undefined behavior, on the other hand, is bad news: not only may the hehavior
vary between systems, but the program may act strangely or even crash.

= The descriptions of many <math.h> functions refer to the terms domain
error and range error. The way in which these errors are indicated changed
between CR9 and C99. For the C89 treatment of these errors, see Section 23.3.
For the C99 treatment, see Section 23.4.

u The behavior of the following functions is affected by the current locale:
<ctype.h> All functions
<stdio.h> Formatted input/output functions
<stdlib.h> Multibyte/wide-character conversion functions, numeric

conversion functions
<string.h> strcoll, strxfrm
<time.h> strftime
<wchar.h> wescoll, wesftime, wesxfrm, formatted input/output
functions. numeric conversion functions, extended
multibyte/wide-character conversion functions
<wctype.h> All functions
The isalpha function, for example, usually checks whether a character lies
between a and z or A and Z. In some locales, other characters are considered
alphabetic as well.

abort Abort Program <stdlib.h>
void abort (void) ;
Raises the STGABRT signal. If the signal isn't caught (or if the signal handler re-
turns), the program terminates abnormally and returns an implementation-defined
code indicating unsuccessful termination. Whether output buffers arc flushed. open
streams are closed, or temporary files are removed is implementation-defined.
26.2
abs Integer Absolute Value <stdlib.h>
int abs(int j);
Returns  Absolute value of j. The behavior is undefined if the absolute value of j can’t be
represented. 262
acos Arc Cosine <math.h>
double acos(double x);
acosf float acosf(float x);
acosl long double acosl (long double x);
Appendix D Standard Library Functions 749

Returns ~ Arc cosine of x; the return value is in the range 0 to ©t. A domain error occurs if x
isn’t between - 1 and +1. 23.3
acosh Arc Hyperbolic Cosine (C99) <math.h>
double acosh(double x) ;
acoshf float acoshf(float x);
acoshl long double acoshl (long double x);
Returns  Arc hyperbolic cosine of x; the return value is in the range 0 to +2<. A domain error
occurs if x is less than 1, 234
asctime Convert Broken-Down Time to String <time.h>
char *asctime(const struct tm *timeptr):
Returns A pointer to a null-terminated string of the form
Sun Jun 3 17:48:34 2007\n
constructed from the broken-down time in the structure pointed to by t imeptr.
263
asin ArcSine <math.h>
double asin(double x);
asinf float asinf (float x);
asinl long double asinl(long double Xx);
Returns  Arc sine of x; the return value is in the range —1/2 to +7/2. A domain error occurs
if x isn’t between —1 and +1. 23.3
asinh ArcHyperbolic Sine (C99) <math.h>
double asinh(double x);
asinhf float asinhf (float x);
asinhl long double asinhl (long double x);
Returns  Arc hyperbolic sine of x. 234
assert Assert Truth of Expression <assert.h>
void assert (scalar expression) ; macro
If the value of expression is nonzero, assert does nothing. If the value is
zero, assert writes a message to st derr (specifying the text of expressicn,
the name of the source file containing the assert, and the line number of the
assert); it then terminates the program by calling abort. To disable assert,
define the macro NDEBUG before including <assert .h>. C99 changes: The
argument is allowed to have any scalar type: C89 specifics that the type is int.
Also, C99 requires that the message written by assert include the name of the
function in which the assert appears; C89 doesn’t have this requirement.  24.7
atan Arc Tangent <math.h>
double atan (double x);
atanf float atanf (float x);

750

Appendix D Standard Library Functions

atanl long double atanl(long double x);
Returns  Arc tangent of x: the return value is in the range —m/2 to +m/2. 233
atan2 Arc Tangent of Quotient <math.h>
double atan2 (double y, double x);
atan2f float atan2f(float y, float x);
atan2l long double atan2l (long double y, long double x);
Returns ~ Arc tangent of y/x: the return value is in the range —7 to +7. A domain error may
oceur if x and y are both zero. 23,3
atanh Arc Hyperbolic Tangent (C99) <math.h>
double atanh(double x) ;
atanhf float atanhf (float x);
atanhl long double atanhl (long double x);

Returns  Arc hyperbolic tangent of x. A domain error occurs if x is not between —1 and +1.

A range error may occur if x is equal to —1 or +1. 234
atexit Register Function to Be Called at Program Exit <stdlib.h>

int atexit(void (*func) (void));

Registers the function pointed to by func as a termination function. The function

will be called if the program terminates normally (via return or exit but not

abort).

Returns  Zero if successful, nonzero if unsuccessful (an implementation-dependent limit
has been reached). 262

atof Convert String to Floating-Point Number <stdlib.h>
double atof (const char *nptr);

Returns A double value corresponding to the longest initial part of the string pointed to
by nptx that has the form of a floating-point number. Returns zero if no conver-
sion could be performed. The function’s behavior is undefined if the number can’t
be represented. 26.2

atol Convert String to Integer <stdlib.h>
int atodi (const char *nptr);

Returns  An int value corresponding to the longest initial part of the string pointed to by
nptr that has the form of an integer. Returns zero if no conversion could be per-
formed. The function’s behavior is undefined if the number can’t be represented.

262
atol Convert String to Long Integer <stdlib.h>
long int atol (const char *nptr);

Returns A long int value corresponding to the longest initial part of the string point-

ed to by nptxr that has the form of an integer. Returns zero if no conversion
Appendix D Standard Library Functions 751

could be performed. The function’s behavior is undefined if the number can’t be

represented. 26.2
atoll Convert String to Long Long Integer (C99) <stdlib.h>
long long int atoll (const char *nptr);

Returns A long long int value corresponding to the longest initial part of the string
pointed to by nptx that has the form of an integer. Returns zero if no conversion
could be performed. The function’s behavior is undefined if the number can’t be
represented. 262

bsearch Binary Search <stdlib.h>

void *bsearch (const void *key, const void *base,

size_t memb, size t size,

int (*compar) (const void *,

const void *));

Searches for the value pointed to by key in the sorted array pointed to by base.
The array has nmemb elements, each size bytes long. compar is a pointer to a
comparison function. When passed pointers to the key and an array element, in
that order, the comparison function must return a negative, zero, or positive inte-
ger, depending on whether the key is less than, equal to, or greater than the array
element.

Relurns A pointer to an array element that tests equal to the key. Returns a null pointer if
the key isn’t found. 262

btowe Convert Byte to Wide Character (C99) <wchar .h>
wint_t btowc(int c);

Retuns ~ Wide-character representation of c. Returns WEOF if c is cqual to EOF or if c
(when cast to unsigned char) isn’t a valid single-byte character in the initial
shift state. 255

cabs Complex Absolute Value (C99) <complex.h>
double cabs (double complex z);

cabsf float cabsf (float complex z);

cabsl long double cabsl (long double complex z);

Returns  Complex absolute value of z. 274

cacos Complex Arc Cosine (C99) <complex.h>
double complex cacos (double complex z);
cacosf float complex cacosf (float complex z);
cacosl long double complex cacosl (long double complex z);
Returns  Complex arc cosine of z, with branch cuts outside the interval [-1, +1] along the

real axis. The return value lies in a strip mathematically unbounded along the
imaginary axis and in the interval [0, ] along the real axis. 274
752

Appendix D Standard Library Functions

cacosh Complex Arc Hyperbolic Cosine (C99) <complex.hs
double complex cacosh(double complex z);
cacoshf float complex cacoshf (float complex z);
cacoshl long double complex cacoshl(long double complex z);
Returns  Complex arc hyperbolic cosine of z, with a branch cut at values less than 1 along
the real axis. The return value lies in a half-strip of nonnegative values along the
real axis and in the interval [-ir, +i7] along the imaginary axis. 27.4
calloc Allocate and Clear Memory Block <stdlib.h>
void *calloc(size t nmemb, size_t size);
Allocates a block of memory for an array with nmemb elements, each with size
bytes. The block is cleared by setting all bits to zero.
Returns A pointer 1o the beginning of the block. Returns a null pointer if a block of the
requested size can't be allocated. 17.3
carg Complex Argument (C99) <complex.h>
double carg(double complex z);
cargf float cargf(float complex z);
cargl long double cargl (long double complex z);
Returns ~ Argument (phase angle) of z, with a branch cut along the negative real axis. The
return value lies in the interval [-7, +7]. 27.4
casin Complex Arc Sine (C99) <complex.h>
double complex casin(double complex z);
casinf float complex casinf (float complex z);
casinl long double complex casinl (long double complex z);
Returns ~ Complex arc sine of z, with branch cuts outside the interval [-1, +1] along the real
axis. The return value lies in a strip mathematically unbounded along the imagi-
nary axis and in the interval [-n/2, +7/2] along the real axis. 27.4
casinh Complex Arc Hyperbolic Sine (C99) <complex.h>
double complex casinh(double complex z);
caginhf float complex casinhf (float complex z);
casinhl long double complex casinhl(long double complex z);
Returns  Complex arc hyperbolic sine of z, with branch cuts outside the interval [, +i]
along the imaginary axis. The return value lies in a strip mathematically unbounded
along the real axis and in the interval [-in/2, +i7/2] along the imaginary axis. 27.4
catan Complex Arc Tangent (C99) <complex.h>
double complex catan(double complex z);
catanf float complex catanf (float complex z);
catanl long double complex catanl (long double complex z);
Appendix D Standard Library Functions 753

Returns  Complex arc tangent of z, with branch cuts outside the interval [, +i] along the
imaginary axis. The return value lies in a strip mathematically unbounded along
the imaginary axis and in the interval [-n/2, +7/2] along the real axis. 274
catanh Complex Arc Hyperbolic Tangent (C99) <complex.h>
double complex catanh (double complex z);
catanhf float complex catanhf (float complex z);
catanhl long double complex catanhl(long double complex z);
Returns  Complex arc hyperbolic tangent of z, with branch cuts outside the interval (-1, +1]
along the real axis. The return value lies in a strip mathematically unbounded
along the real axis and in the interval [-in/2, +in/2] along the imaginary axis. 27.4
cbrt Cube Root (C99) <math.h>
double cbrt (double x);
ebrtf float cbrif(float x);
cbrtl long double cbrtl(long double x);
Returns  Real cube root of x, 234
ccos Complex Cosine (C99) <complex.h>
double complex ccos(double complex z);
ccosf float complex ccosf (flocat complex z);
ccosl long double complex ccosl(long double complex z);
Returns  Complex cosine of z. 274
ccosh Complex Hyperbolic Cosine (C99) <complex.h>
double complex ccosh(double complex z);
ccoshf float complex ccoshf(float complex z);
ccoshl long double complex ccoshl (long double complex z);
Returns  Complex hyperbolic cosine of z. 274
ceil ceiling <math.h>
double ceil (double x);
ceilf float ceilf(float x);
ceill long double ceill(long double x);
Returns  Smallest integer that is greater than or equal to x. 233
cexp Complex Base-e Exponential (C99) <complex.h>
double complex cexp (double complex z);
cexpf float complex cexpf (float complex z);
cexpl long double complex cexpl (long double complex z);
Returns  Complex base-e exponential of z. 274
cimag Imaginary Part of Complex Number (C99) <complex.h>

double cimag(double complex z);
754

Appendix D Standard Library Functions

cimagf float cimagf(float complex z);
cimagl long double cimagl (long double complex z);
Returns  Imaginary part of z. 274
clearerr Clear Stream Error <stdio.h>
void clearerr (FILE *stream);
Clears the end-of-file and error indicators for the stream pointed to by st ream.
223
cclock Processor Clock <time.h>
clock t clock(void) ;
Returns  Elapsed processor time (measured in “clock ticks") since the beginning of program
execution. (To convert into seconds, divide by CLOCKS_PER_SEC.) Returns
(clock _t) (-1) if the time is unavailable or can't be represented. 263
clog Complex Natural Logarithm (C99) <complex.h>
double complex clog(double complex z);
clogf float complex clogt (float complex z);
clogl long double complex clogl(long double complex z);
Returns ~ Complex natural (base-e) logarithm of z, with a branch cut along the negative real
axis. The refurn value lies in a strip mathematically unbounded along the real axis
and in the interval |, +ir] along the imaginary axis. 274
conj Complex Conjugate (C99) <complex.h>
double complex conj(double complex z);
conjf float complex conjf(float complex z);
conjl long double complex conjl(long double complex z);
Returns  Complex conjugate of z. 27.4
copysign Copy Sign (C99) <math.h>
double copysign(double x, double y);
copysignf float copysignf (float x, float y);
copysignl long double copysignl(long double x, long double y);
Returns A value with the magnitude of x and the sign of y. 234
cos Cosine <math.h>
double cos (double x) ;
cosf float cosf(float x);
cosl long double cosl (long double x);
Returns ~ Cosine of x (measured in radians). 233
cosh Hyperbolic Cosine <math.h>
double cosh(double x) ;
coshf float coshf (float x);
Appendix D Standard Library Functions 755

coshl long double coshl (long double x);
Returns  Hyperbolic cosine of x. A range error occurs if the magnitude of x is too large.
233
cpow Complex Power (C99) <complex.h>
double complex cpow(double complex X,
double complex y);
cpowf float complex cpowf (float complex x,
float complex y);
cpowl long double complex cpowl(long double complex X,
long double complex y);
Returns 3 raised to the power y, with a branch cut for the first parameter along the negative
real axis. 27.4
cproj Complex Projection (C99) <complex.h>
double complex cproj(double complex z);
cprojf float complex cprojf(float complex z);
ecprojl 1long double complex cprojl(long double complex z);
Returns ~ Projection of z onto the Ricmann sphere. z is returned unless one of its parts is
infinite, in which case the return value is INFINITY + I * copysign(0.0,
cimag(z)). 274
creal Real Part of Complex Number (C99) <complex.h>
double creal (double complex z);
crealf float crealf(float complex z);
creall long double creall (long double complex z);
Returns  Real part of 2. 27.4
csin Complex Sine (C99) <complex.h>
double complex csin(double complex z);
csinf float complex csinf (float complex z);
csinl long double complex csinl(long double complex z);
Returns  Complex sine of z. 274
csinh Complex Hyperbolic Sine (C99) <complex.h>
double complex csinh(double complex z);
csinhf float complex csinhf (float complex z);
csinhl long double complex csinhl (long double complex z);
Returns  Complex hyperbolic sine of z. 27.4
csgrt Complex Square Root (C99) <complex.h>
double complex csgrt (double complex z);
csqrtf float complex csgrtf(float complex z);
csgrtl long double complex csqrtl(long double complex z);
756 Appendix D Standard Library Functions
Returns ~ Complex square root of z, with a branch cut along the negative real axis. The
return value lies in the right half-plane (including the imaginary axis). 274
ctan Complex Tangent (C99) <complex.hs
double complex ctan(double complex z);
ctanf float complex ctanf(float complex z);
ctanl long double complex ctanl(long double complex z) ;
Returns  Complex tangent of z. 274
ctanh Complex Hyperbolic Tangent (C99) <complex.h>
double complex ctanh(double complex z);
ctanhf float complex ctanhf (float complex z);
ctanhl long double complex ctanhl (long double complex z);
Returns  Complex hyperbolic tangent of z. 27.4
ctime Convert Calendar Time to String <time.h>
char *ctime(const time_t *timer);
Returns A pointer (o a string deseribing a local time equivalent to the calendar time pointed
to by timer. Equivalent to asctime (localtime (timer) ). 263
difftime Time Difference <time.h>
double difftime(time t timel, time t time0);
Returns  Difference between time0 (the earlier time) and timel, measured in seconds.
263
div Integer Division <stdlib.h>
div_t div(int numer, int denom) ;
Returns A div_t structure containing members named quot (the quotient when numer
is divided by denom) and rem (the remainder). The behavior is undefined if either
part of the result can’t be represented. 262
erf Emor Function (C99) <math.h>
double erf (double x);
erff float erff(float x);
erfl long double erfl(long double x);
Returns  erf(x), where erf is the Gaussian error function. 234
erfc Complementary Error Function (C99) <math.h>
double erfc(double x);
erfcf float erfcf(float x);
erfcl long double erfcl(long double x);
Returns  erfc(x) = | — erf(x), where erf is the Gaussian error function. A Tange error 0ccurs

if x is too large. 234
Appendix D Standard Library Functions 757

exit Exitfrom Program <stdlib.h>
void exit(int status);
Calls all functions registered with atexit, flushes all output buffers, closes all
open streams, removes any files created by tmpfile, and terminates the pro-
gram. The value of status indicates whether the program terminated normally.
The only portable values for status are 0 and EXIT SUCCESS (both indicate
successful termination) plus EXIT FAILURE (unsuccessful termination).
9.5,26.2
_Exit Exitfrom Program (C99) <stdlib.h>
void _Exit (int status);
Causes normal program termination. Doesn’t call functions registered with
atexit or signal handlers registered with signal. The status returned is deter-
mined in the same way as for exit. Whether output buffers are flushed, open
streams are closed, or temporary files are removed is implementation-defined.
262
exp Base-e Exponential <math.h>
double exp (double x) ;
expf float expf(float Xx);:
expl long double expl(long double x);
Returns e raiscd to the power x. A range error oceurs if the magnitude of x is too large.
233
exp2 Base-2 Exponential (C99) <math.h>
double exp2(double x);
exp2f float exp2f(float x);
exp2l long double exp2l(long double X);
Returns 2 raised to the power x. A range error occurs if the magnitude of x is too large.
234
expml Base-e Exponential Minus 1 (C99) <math.h>
double expml (double x);
expmlf float expmilf (float x);
expmll long double expmll (long double x);
Returns e raised to the power x. minus 1. A range error oceurs il x is too large. 234
fabs Floating Absolute Value <math.h>
double fabs (double x);
fabsf float fabsf (float x);
fabsl long double fabsl (long double x);
Relurns ~ Absolute value of x. 23.3
758 Appendix D Standard Library Functions

fclose Close File <stdio.h>
int fclose(FILE *stream);
Closes the stream pointed to by stream. Flushes any unwritten output remaining
in the stream’s buffer. Deallocates the buffer if it was allocated automatically.
Returns ~ Zero if successful, EOF if an error was detected. 222
ffdim Positive Difference (C99) <math.h>
double fdim(double x, double y);
fdimf float fdimf(float x, float y);
fdiml long double fdiml (long double x, long double Yl
Returns  Posilive difference of x and y:
x-y ifx>y
+0 fx<y
A range error may occur. 234
feclearexcept Clear Floating-Point Exceptions (C99) <fenv.hs
int feclearexcept (int excepts);
Attempts to clear the floating-point exceptions represented by excepts
Returns ~ Zero if excepts is zero or if all specificd exceptions were successfully cleared;
otherwise, returns a nonzero value. 276
fegetenv Get Floating-Point Environment (G99) <fenv.h>
int fegetenv(fenv_t *envp);
Attempts to store the current floating-point environment in the object pointed to by
envp.
Returns ~ Zero if the environment was successfully stored; otherwise, returns a nonzero
value, 276
fegetexceptflag Get Floating-Point Exception Flags (C99) <fenv.h>
int fegetexceptflag (fexcept t *flagp, int excepts);
Attempts to retrieve the states of the floating-point status flags represented by
excepts and store them in the object pointed to by f Lagp.
Returns ~ Zero if the states of the status flags were successfully stored; otherwise, returns a
nonzero value. 276
fegetround Get Floating-Point Rounding Direction (C99) <fenv.h>
int fegetround (void) ;
Returns ~ Value of the rounding-direction macro that represents the current rounding direc-

tion. Returns a negative value if the current rounding direction can’t be determined
or doesn’t match any rounding-direction macro. 27.6
Appendix D Standard Library Functions 759

feholdexcept Save Floating-Point Environment (C99) <fenv.h>
int feholdexcept (fenv_t *envp);
Saves the current floating-point environment in the object pointed to by envp,
clears the floating-point status flags, and attempts to install a non-stop mode for all
floating-point exceptions.
Returns ~ Zero if non-stop floating-point exception handling was successfully installed; oth-
erwise, returns a nonzero value. 276
feof Testfor End-of-File <stdio.h>
int feof (FILE *stream) ;
Returns A nonzero value if the end-of-file indicator is set for the stream pointed to by
stream; otherwise, returns zero. 223
feraiseexcept Raise Floating-Point Exceptions (C99) <fenv.h>
int feraiseexcept (int excepts);
Attempts 1o raise supported floating-point exceptions represented by excepts.
Returns ~ Zero if excepts is zero or if all specified exceptions were successfully raised;
otherwise, returns a nonzero value. 27.6
ferror Test/orFile Error <stdio.h>
int ferror (FILE *stream);
Returns A nonzero value if the error indicator is set for the stream pointed to by stream;
otherwise, returns zero. 223
fesetenv Set Floating-Point Environment (C99) <fenv.h>
int fesetenv(const fenv_t *envp);
Attempts to establish the floating-point environment represented by the object
pointed to by envp.
Returns ~ Zero if the environment was successfully established: otherwise, returns a nonzero
value 276
fesetexceptflag Set Floating-Point Exception Flags (C99) <fenv.h>
int fesetexceptflag(const fexcept t #*flagp,
int excepts);
Attempts to set the floating-point status flags represented by excepts to the
states stored in the object pointed to by flagp.
Returns ~ Zero if excepts is zero or if all specified exceptions were successfully set; other-
wise, returns a nonzero value. 27.6
fesetround Set Floating-Point Rounding Direction (C99) <fenv.h>

int fesetround(int round);
760 Appendix D Standard Library Functions

Attempts to establish the rounding direction represented by round.

Returns ~ Zero if the requested rounding direction was established; otherwise, returns a non-
zero value. 276
fetestexcept Test Floating-Point Exception Flags (C99) <fenv.h>
int fetestexcept (int excepts);
Returns  Bitwise or of the floating-point exception macros corresponding to the currently
set flags for the exceptions represented by excepts. 276
feupdateenv Update Floating-Point Environment (C99) <fenv.h>
int feupdateenv(const fenv_t *envp);
Attempts to save the currently raised floating-point exceptions, install the floating-
point environment represented by the object pointed to by envp, and then raise the
saved exceptions.
Returns  Zero if all actions were successfully carried out; otherwise, returns a nonzero
value. 27.6
fflush Flush File Buffer <stdio.h>
int fflush(FILE *stream);
Writes any unwritten data in the buffer associated with stream, which points to a
stream that was opened for output or updating. If streawm is a null pointer,
ff1lush flushes all streams that have unwritten data stored in a buffer.
Returns  Zero if successful, EOF if a write error oceurs. 222
fgetc Read Character from File <stdio.h>
int fgetc(FILE *stream);
Reads a character from the stream pointed to by stream.
Returns  Character read from the stream. If fgetc encounters the end of the stream, it sets
the stream’s end-of-file indicator and returns EOF. If a read error occurs, fgete
sets the stream’s error indicator and returns EOF. 224
fgetpos Get File Position <stdio.h>
int fgetpos (FILE * restrict stream,
fpos t * restrict pos);
Stores the current position of the stream pointed to by stream in the ohject
pointed to by pos.
Returns  Zero if successful. If the call fails, returns a nonzero value and stores an implemen-
tation-defined positive value in exrno, 227
fgets Read String from File <stdio.h>

char *fgets(char * restrict s, int n,
FILE * restrict stream);
Appendix D Standard Library Functions 761

Reads characters from the stream pointed to by stream and stores them in the
array pointed (o by s. Reading stops at the first new-line character (which is stored
in the string), when n — | characters have been read, or at end-of-file. fgets
appends a null character to the string,

Returns s (a pointer to the array in which the input is stored). Returns a null pointer if a
read error oceurs or fgets encounters the end of the stream before it has stored
any characters. 225
fgetwc Read Wide Character from File (C99) <wchar.h>
wint_t fgetwc(FILE *stream);
Wide-character version of fgetc. 255
fgetws Read Wide String from File (C99) <wchar.h>
wchar t *fgetws(wchar t * restrict s, int n,
FILE * restrict stream);
Wide-character version of fgets. 255
flooxr Floor <math.h>
double floor (double x);
floorf float floorf (float x);
floorl long double floorl (long double x);
Returns  Largest integer that is less than or equal to x. 233
fma Floating Multiply-Add (C99) <math.h>
double fma(double x, double y, double z);
fmaf float fmaf(float x, float y, float z);
fmal long double fmal (long double x, long double y,
long double z);
Returns  (x X y) + z. The result is rounded only once, using the rounding mode correspond-
ing to FLT_ROUNDS. A range error may occur. 234
fmax Floating Maximum (C99) <math.h>
double fmax(double x, double y);
fmaxf float fmaxf(float x, float y);
fmaxl long double fmaxl (long double x, long double y);
Returns  Maximum of x and v. If one argument is a NaN and the other is numeric, the
numeric value is returned. 234
fmin Floating Minimum (C99) <math.h>
double fmin(double x, double y);
fminf float fminf(float x, float y);
fminl long double fminl(long double x, long double y);
Returns  Minimum of x and y. If one argument is a NaN and the other is numeric, the

numeric value is returned. 234
762

Appendix D Standard Library Functions

fmod Floating Modulus <math.h>
double fmod(double x, double y)i
fmodf float fmodf(float x, float y);
fmodl long double fmodl(long double x, long double y);
Returns  Remainder when x is divided by y. If y is zero, either a domain error occurs or
zero is returned. 233
fopen Open Fie <stdio.h>
FILE *fopen(const char * restrict filename,
const char * restrict mode);
Opens the file whose name is pointed to by fi lename and associates it with a
stream. mode specifies the mode in which the file is to be opened. Clears the error
and end-of-file indicators for the stream.
Returns A file pointer to be used when performing subsequent operations on the file.
Returns a null pointer if the file can’t be opened. 222
fpclassify Floating-Point Classification (C99) <math.h>
int fpclassify (real-floating x) ; macro
Returns ~ Either FP_INFINITE, FP_NAN. FP_NORMAL, FP_SUBNORMAL, or FP_ZERO,
depending on whether x is infinity. not a number, normal, subnormal, or zero.
respectively. 234
fprintf Formatted File Write <stdio.h>
int fprintf (FILE * restrict stream,
const char * restrict format, ...);
Writes output to the stream pointed to by stream. The stwring pointed to by
format specifies how subsequent arguments will be displayed.
Returns  Number of characters written. Returns a negative value if an error occurs. 223
fputc Write Character to File <stdio.h>
int fputc(int c, FILE *stream);
Writes the character c to the stream pointed to by stream.
Returns c (the character written). If a write error vccurs, fpute sets the stream’s error
indicator and returns EQF. 224
fputs Write String to File <stdio.h>
int fputs(const char * restrict s,
FILE * restrict stream);
Writes the string pointed to by s to the stream pointed to by stream.
Returns A nonnegative value if successful. Returns EOF if a write error oceurs. 225
Appendix D Standard Library Functions ~ 763

fputwe Write Wide Character to File (C99) <wchar.h>
wint t fputwc(wchar t c, FILE *stream);
Wide-character version of fpute. 255
fputws Write Wide String to File (C99) <wchar.h>
int fputws(const wchar t * restrict s,
FILE * restrict stream);
‘Wide-character version of fputs. 255
fread Read Block from File <stdio.h>
size t fread(void * restrict ptr, size t size,
size t nmemb, FILE * restrict stream);
Attempts to read nmemb elements, each size bytes long, from the stream pointed
to by stream and store them in the array pointed to by ptr.
Returns  Number of elements actually read. This number will be less than nmemb if fread
encounters end-of-file or a read error occurs. Returns zero if either nmemb or
size is zero. 226
free Free Memory Block <stdlib.h>
void free(void *ptr);
Releases the memory block pointed to by ptr. (If ptr is a null pointer, the call
has no effect.) The block must have been allocated by a call of calloc, malloc,
or realloc. 17.4
freopen Reopen File <stdio.h>
FILE *freopen(const char * restrict filename,
const char * restrict mode,
FILE * restrict stream);
Closes the file associated with st ream, then opens the file whose name is pointed
to by filename and associates it with stream. The mode parameter has the
same meaning as in a call of fopen. C99 change: If filename is a null pointer,
freopen attemplts to change the stream’s mode to that specified by mode.
Returns ~ Value of stream if the operation succeeds. Returns a null pointer if the file can’t
be opened. 222
frexp Splitinto Fraction and Exponent <math.h>
double frexp(double value, int *exp):
frexpf float frexpf(float value, int *exp);
frexpl Ilong double frexpl(long double value, int *exp);

Splits value into a fractional part f and an exponent n in such a way that
value=fx2"
764

Appendix D Standard Library Functions

Returns

fis normalized so that either 0.5 < f< 1 or f= 0. Stores n in the object pointed to by
exp.

[, the fractional part of value. 233

fscanf

Returns

Formatted File Read <stdio.h>

int fscanf(FILE * restrict stream,
const char * restrict format, ...);

Reads input items from the stream pointed to by stream, The string pointed to by
format specifies the format of the items to be read. The arguments that follow
format point to objects in which the items are to be stored.

Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items can be read. 223

fseek

Returns

File Seek <stdio.h>
int fseek(FILE *stream, long int offset, int whence);

Changes the file position indicator for the stream pointed to by stream. If
whence is SEEK _SET, the new position is the beginning of the file plus of fset
bytes. If whence is SEEK_CUR, the new position is the current position plus
offset bytes. If whence is SEEK_END, the new position is the end of the file
plus of fset bytes. The value of offset may be negative. For text streams,
either of fset must be zero or whence must be SEEK SET and offset a
value obtained by a previous call of ftell. For binary streams, fseek may not
support calls in which whence is SEEK_END.

Zero if the operation is successful, nonzero otherwise. 227

fsetpos

Returns

Set File Position <stdio.h>
int fsetpos(FILE *stream, const fpos_t *pos) ;

Sets the file position indicator for the stream pointed to by stream according to
the value pointed to by pos (obtained from a previous call of fgetpos).

Zero if successful, If the call fails, returns a nonzero value and stores an implemen-
tation-defined positive value in errno. 227

ftell

Returns

Determine File Position <stdio.h>
long int ftell(FILE *stream);

Current file position indicator for the stream pointed to by stream. If the call
fails, returns - 1L and stores an implementation-defined positive value in errno.
227

fwide

Get and Set Stream Orientation (C99) <wchar.h>
int fwide (FILE *stream, int mode);

Determines the current orientation of a stream and, if desired, attempts to set its
orientation. If mode is greater than zero, fwide tries to make the stream wide-
oriented if it has no orientation. If mode is less than zero, it tries to make the
Appendix D Standard Library Functions 765

stream byte-oriented if it has no orientation. If mode is zero, the orientation is not
changed.

Returns A positive value if the stream has wide orientation after the call. a negative value if
it has byte orientation, or zero if it has no orientation. 255
fwprintf Wide-Character Formatted File Write (C99) <wchar . h>
int fwprintf (FILE * restrict stream,
const wchar_t * restrict format, ...);
Wide-character version of fprintf. 255
fwrite Write Block to File <stdio.h>
size t fwrite(const void * restrict ptr, size t size,
size t nmemb, FILE * restrict stream);
Writes nmemb elements, each size bytes long, from the array pointed to by ptxr
to the stream pointed to by stream.
Relurns  Number of elements actually written. This number will be less than nmemb if a
write error occurs. In C99, returns zero if either nmemb or size is zero. 226
fwscanf Wide-Character Formatted File Read (C99) <wchar.h>
int fwscanf (FILE * restrict stream,
const wchar f * restrict format, ...);
‘Wide-character version of fscanf. 255
getc Read Character from File <stdio.h>
int getc(FILE *stream);
Reads a character from the stream pointed to by stream. Note: getc is normally
implemented as a macro: it may evaluate stream more than once.
Returns ~ Character read from the stream. If getc encounters the end of the stream, it sets
the stream’s end-of-file indicator and returns EOF. If a read error occurs, getc sets
the stream’s error indicator and returns EOF. 224
getchar Read Character <stdio.h>
int getchar (void) ;
Reads a character from the stdin stream. Note: getchar is normally imple-
mented as a macro.
Returns  Character read from the stream. If getchar encounters the end of the stream, it
sets the stream’s end-of-file indicator and returns EOF. If a read error occurs,
getchax sets the stream’s error indicator and returns EOF. 7.3,224
getenv Get Environment String <stdlib.h>

char *getenv(const char *name) ;

Searches the operating system’s environment list to see if any string matches the
one pointed to by name.
766 Appendix D Standard Library Functions

Returns A pointer to the string associated with the matching name. Returns a null pointer if
no match is found. 262

gets Read String <stdio.h>
char *gets(char *s);

Reads characters from the stdin stream and stores them in the array pointed to
by s. Reading stops at the first new-line character (which is discarded) or at end-
of-file. gets appends a null character to the string,

Returns s (a pointer to the array in which the input is stored). Returns a null pointer if a
read error oceurs or get s encounters the end of the stream before it has stored any
characters. 13.3,225

getwc Read Wide Character from File (C99) <wchar.h>
wint_t getwc (FILE *stream);
‘Wide-character version of gete. 255
getwchar Read Wide Character (C99) <wchar.h>
wint_t getwchar (void) ;
Wide-character version of getchar. 255
gmtime Convert Calendar Time to Broken-Down UTC Time <time.h>
atruct tm *gmtime(const time_t *timer);

Returns A pointer to a structure containing a broken-down UTC time equivalent to the cal-
endar time pointed to by timer. Returns a null pointer if the calendar time can’t
be converted to UTC. 263

hypot Hypotenuse (C99) <math.h>
double hypot (double x, double y);
hypotf float hypotf (float x, float y);
hypotl long double hypotl (long double x, long double y);
Returns  +/x* + y? (the hypotenuse of a right triangle with legs x and y). A range error may
oceur. 234
ilogb Unbiased Exponent (C99) <math.h>
int ilogb(double x);
ilogbf int ilogbf(float x);
ilogbl int ilogbl (long double x);

Returns  Exponent of x as a signed integer; equivalent to calling the corresponding 1ogb
function and casting the returned value to type int. Returns FP_ILOGBO if x is
zero, INT MAX if x is infinite, and FP_ILOGBNAN if x is a NaN: a domain error
Or range error may occur in these cases. 234

imaxabs Greatssi-Width Integer Absolute Value (C99) <inttypes.h>

intmax t imaxabs (intmax t j);
Appendix D Standard Library Functions 767

Returns  Absolute value of j. The behavior is undefined if the absolute value of j can't be
represented. 272
imaxdiv Greatest-Width Integer Division (C99) <inttypes.h>
imaxdiv_t imaxdiv(intmax t numer, intmax t denom);
Returns A structure of type imaxdiv t containing members named quot (the quotient
when numer is divided by denom) and rem (the remainder). The behavior is
undefined if either part of the result can’t be represented. 272
isalnum Test for Ajphanumeric <ctype.hs
int isalnum(int c);
Returns A nonzero value if c is alphanumeric and zero otherwise. (c is alphanumeric if
either isalpha (c) or isdigit (c) is true.) 235
isalpha T7est for Alphabetic <ctype.h>
int isalpha (int c);
Returns A nonzero value if c is alphabetic and zero otherwise. In the "C" locale, c is
alphabetic if either islower (c) or isupper (c) is true. 235
isblank Test for Blank (C99) <ctype.hs
int isblank(int c);
Returns A nonzero value if c is a blank character that is used to separate words within a
line of text. In the " C" locale. the blank characters are space (! ') and horizontal
tab (*\t'). 235
iscntrl Testfor Control Character <ctype.h>
int iscntrl ERG ) a
Returns A nonzero value if c is a control character and zero otherwise. 235
isdigit Testfor Digit <ctype.h>
int isdigit(int c);
Returns A nonzero value if c is a decimal digit and zero otherwise. 23.5
isfinite Test for Finite Number (C99) <math.hs>
int isfinite (real-floating x) ; macro
Returns A nonzero value if x is finite (zero, subnormal, or normal, but not infinite or NaN)
and zero otherwise. 234
isgraph Test for Graphical Character <ctype.h>
int isgraph(int c);
Returns A nonzero value if c is a printing character (except a space) and zero otherwise.
235
isgreater Testfor Greater Than (C99) <math.h>

int isgreater (real-floating x, realfloating y) ; macro
768

Appendix D Standard Library Functions

Retums  (x) > (y). Unlike the > operator, i sgreater doesn’t raise the invalid floating-
point exception if one or both of the arguments is a NaN. 234
isgreaterequal Testfor Greater Than or Equal (C99) <math.h>
int isgreaterequal (real-floating x, real-floating v) ; macro
Returns  (x) >= (y). Unlike the >= operator, isgreaterequal doesn’t raise the
invalid floating-point exception if one or both of the arguments is a NaN. 234
isinf Testfor Infinity (C99) <math.h>
int isinf (real-floating x) ; macro
Returns A nonzero value if x is infinity (positive or negative) and zero otherwise. 234
isless TestforLess Than (C99) <math.h>
int isless (real-floating x, real-floating y) ; macro

Returns (%) < (y). Unlike the < operator, is1less doesn't raise the invalid floating
point exception if one or both of the arguments is a NaN. 234
islessequal TestforLess Than or Equal (C99) <math.h>
int islessequal (real-floating x, real-floating y) ; macro
Returns  (x) <= (y). Unlike the <= operator, islessequal doesn’t raise the invalid
floating-point exception if one or both of the arguments is a NaN. 234
islessgreater TestforLess Than or Greater Than (C99) <math.h>
int islessgreater (real-floating x, real-floating y) ; macro
Returns  (x) < (y) || (x) > (y). Unlike this expression, islessgreater doesn’t

raise the invalid floating-point exception if one or both of the arguments is a NaN;
also, x and y are evaluated only once. 234

islower Testfor Lower-Case Letter <ctype.h>

int islower (int c);

Returns A nonzero value if c is a lower-case letter and zero otherwise. 235
isnan Testfor NaN (C99) <math.h>

int isnan (realfloating x) ; macro
Returns A nonzero value if x is a NaN value and zero otherwise. 234
isnormal Testfor Normal Number (C99) <math.h>
int isnormal (real-floating x) ; macro

Returns A nonzero value if x has a normal value (not zero, subnormal, infinite, or NaN)
and zero otherwise. 234

isprint Testfor Printing Character <ctype.h>

int isprint(int c);
Appendix D Standard Library Functions 769

Returns A nonzero value if c is a printing character (including a space) and zero otherwise.

235

ispunct Test for Punctuation Character <ctype.h>
int ispunct(int c);

Returns A nonzero value if c is a punctuation character and zero otherwise. All printing
characters except the space (' ') and the alphanumeric characters are considered
punctuation, C99 change: In the "C" locale, all printing characters except those
for which igspace or isalnum is truc are considered punctuation. 235

isspace Testfor White-Space Character <ctype.h>
int isspace(int c);

Returns A nonzero value if c is a white-space character and zero otherwise. In the "C"
locale, the white-space characters are space (' '), form feed (' \f'), new-line
('\n'), carriage return (' \x '), horizontal tab (' \t '), and vertical tab (' \v').

235
isunordered Testfor Unordered (C99) <math.h>
int isunordered (real-floating x, real-floating y) ; macro

Returns 1 if x and y are unordered (at least one is a NaN) and 0 otherwise. 234

isupper Testfor Upper-Case Letter <ctype.h>
int isupper(int c);

Returns A nonzero value if c is an upper-case letter and zero otherwise, 235

iswalnum Test for Alphanumeric Wide Character (C99) <wctype.h>
int iswalnum(wint_t wc);

Returns A nonzero value if wc is alphanumeric and zero otherwise. (wc is alphanumeric if
either iswalpha (wc) or iswdigit (we) is true.) 256

iswalpha Test for Aphabetic Wide Character (C99) <wctype.h>
int iswalpha(wint_t wc);

Returns A nonzero value if wc is alphabetic and zero otherwise. (wc is alphabetic if
iswupper (wc) or iswlower (we) is true, or if we is one of a locale-specific
set of alphabetic wide characters for which none of iswentrl, iswdigit,
iswpunct, or iswspace is true.) 256

iswblank Test for Blank Wide Character (C99) <wectype.hs
int iswblank (wint t wc);

Returns A nonzero value if wc is a standard blank wide character or one of a locale-specific

set of wide characters for which 1swspace is true and that are used to separate
words within a line of text. In the "C" locale, iswblank returns true only for the
standard blank characters: space (L' ') and horizontal tab (L' \t'). 256
770  Appendix D Standard Library Functions

iswentrl Testfor Control Wide Character (C99) <wetype.h>
int iswentrl(wint_t wc);

Returns A nonzero value if we is a control wide character and zero otherwise. 256

iswctype Test Type of Wide Character (C99) <wetype.h>

int iswctype(wint t wc, wctype t desc);

Returns A nonzero value if the wide character we has the property described by desc.

(desc must be a value returned by a call of wetype: the current setting of the

LC_CTYPE category must be the same during both calls.) Returns zero otherwise.

256

iswdigit Testfor Digit Wide Character (C99) <wctype.h>
int iswdigit (wint_t wc);

Returns A nonzero value if we corresponds to a decimal digit and zero otherwise. 256

iswgraph Testfor Graphical Wide Character (C99) <wctype.h>
int iswgraph(wint_t wc);

Returns A nonzero value if iswprint (we) is true and iswspace (wc) is false.

Returns zero otherwise 256

iswlower Testfor Lower-Case Wide Character (C99) : <wctype.hs>
int iswlower (wint_t wc);

Returns A nonzero value if we corresponds to a lower-case letter or is one of a locale-

specific set of wide characters for which none of iswentrl, iswdigit,

iswpunct, or iswspace is true. Returns zero otherwise. 256

iswprint Testfor Printing Wide Character (C99) <wctype.hs
int iswprint(wint t wc);

Returns A nonzero value if we is a printing wide character and zero otherwise. 256

iswpunct Testfor Punctuation Wide Character (CQ.;)) <wctype.h>
int iswpunct(wint_t wc);

Returns A nonzero value if we is a printing wide character that is one of a locale-specific

set of punctuation wide characters for which neither 1swspace nor iswalnum

is true, Returns zero otherwise. 256

iswspace Testfor White-Space Wide Character (C99) <wctype.h>
int iswspace(wint_t we);

Returns A nonzero value if we is one of a locale-specific set of white-space wide characters

for which none of iswalnum, iswgraph, or iswpunct is true. Returns zero
otherwise, 256
Appendix D Standard Library Functions 771

iswupper

Test for Upper-Case Wide Character (C99) <wctype.h>
int iswupper (wint_t wc);

Returns A nonzero value if we corresponds to an upper-case letter or is one of a locale-
specific set of wide characters for which none of iswentrl, iswdigit,
iswpunct, or iswspace is true. Returns zero otherwise. 256

iswxdigit Testfor Hexadecimal-Digit Wide Character (C99) <wctype.h>
int iswxdigit (wint_t we);

Returns A nonzero value if we corresponds to a hexadecimal digit (0-9, a~f, A-F) and
zero otherwise. 256

isxdigit Test for Hexadecimal Digit <ctype.h>
int isxdigit(int c);
Returns A nonzero value if c is a hexadecimal digit (0-9, a—f, A-F) and zero otherwisc.
235
labs Long Integer Absolute Value <stdlib.h>
long int labs(long int j);
Returns  Absolute value of j. The behavior is undefined if the absolute value of j can't be
represented. 26.2
ldexp Combine Fraction and Exponent <math.h>
double ldexp(double x, int exp);
ldexpf float ldexpf(float x, int exp);
ldexpl long double ldexpl (long double x, int exp);

Returns  x % 2°*P_ A range error may occur. 233

1div Long Integer Division <stdlib.h>
ldiv_t ldiv(long int numer, long int denom) ;

Returns  An 1div_t structure containing members named quot (the quotient when
numer is divided by denom) and rem (the remainder). The behavior is undefined
if either part of the result can’t be represented. 26.2

lgamma Logarithm of Gamma Function (C99) <math.h>
double lgamma(double x);
lgammaf float lgammaf (float x);
lgammal long double lgammal (long double x) ;

Returns  In(IT(x)l), where T is the gamma function. A range error occurs if x is too large
and may occur if x is a negative integer or zero. 234

1labs Long Long Integer Absolute Value (C99) <stdlib.hs

long long int llabs(long long int j);
772

Appendix D Standard Library Functions

Returns  Absolute value of j. The behavior is undefined if the absolute value of j can’t be
represented. 262
11div Long Long Inieger Division (C99) <stdlib.h>
lldiv t 1ldiv(long long int numer,
long long int denom);
Returns  An 11div_t structure containing members named quot (the quotient when
numer is divided by denom) and rem (the remainder). The behavior is undefined
if either part of the result can’t be represented. 262
llrint Round to Long Long Integer Using Current Direction (C99) <math.h>
long long int llrint (double Xx);
1lrintf long long int llrintf(float X);
1lrintl long long int llrintl(long double Xx);
Returns  x rounded to the nearest integer using the current rounding direction. If the
rounded value is outside the range of the long long int type. the result is
unspecified and a domain or range error may oceur. 234
1lround Round to NearestLong Long Integer (C99) <math.h>
long long int llround(double x);
llroundf long long int llroundf (float x);
llroundl lcng long int llroundl (iong double x);
Returns  x rounded to the nearest integer, with halfway cases rounded away from zero. If
the rounded value is outside the range of the long long int type, the result is
unspecified and a domain or range error may oceur. 234
localeconv GetLocale Conventions <locale.h>
struct lconv *localeconv(void);
Returns A pointer to a structure containing information about the current locale. 251
localtime Convert Calendar Time to Broken-Down Local Time <time.h>
struct tm *localtime(const time t *timer);
Returns A pointer (o a structure containing a broken-down local time equivalent to the cal-
endar time pointed to by timer. Returns a null pointer if the calendar time can’t
be converted to local time. 263
log Natural Logarithm emath.h>
double log(double x);
logf float logf(float x);
logl long double logl(long double x);
Returns  Logarithm of x to the base e. A domain error occurs if x is negative. A range error

may oceur if x is zero. 233
Appendix D Standard Library Functions 773

logl0 Common Logarithm <math.h>
double 1logl0 (double x) ;
logl0f float loglOf (float x);
log101 long double logl0l (long double x);
Returns  Logarithm of x to the base 10. A domain error occurs if x is negative. A range
error may occeur if x is zero. 23.3
loglp Natural Logarithm of 1 Plus Argument (C99) <math.h>
double loglp (double x) ;
loglpf float loglpf (float x);
loglpl 1long double loglpl (long double x);
Returns  Logarithm of 1 + x to the base e. A domain error occurs if x is less than —1. A
range error may occur if x is equal to —1. 234
log2 Base-2 Logarithm (C99) <math.h>
double log2(double x);
log2f float log2f (float x);
log2l 1long double log2l (long double x);
Returns  Logarithm of x to the base 2. A domain error occurs if x is negative. A range error
may occurif x is zero. 23.4
logb Radix-Independent Exponent (G99) <math.h>
double logb(double x);
logbf float logbf (float x);
logbl 1long double logbl (long double Xx);
Returns  log (Ixl), where r is the radix of floating-point arithmetic (defined by the macro
FLT_RADIX, which typically has the value 2). A domain error or range error may
oceur if x is zero. 234
longjmp Nonlocal Jump <setjmp.h>
void longimp (jmp_buf env, int val);
Restores the environment stored in env and returns from the call of setjmp that
originally saved env. If val is nonzero, it will be setjmp’s return value; if val
is 0, setjmp returns 1. 24.4
lrint Round to Long Integer Using Current Direction (C99) <math.h>
long int lrint (double x);
lrintf long int lrintf(float x);
lrintl long int lrintl(long double x);
Returns  x rounded to the nearest inmteger using the current rounding direction. If the

rounded value is outside the range of the long int type, the result is unspecified
and a domain or range error may occur. 234
774 Appendix D Standard Library Functions
Iround Round to Nearest Long Integer (C99) <math.h>
long int lround(double x);
lroundf long int lroundf(float x);
lroundl long int lround! (long double x);

Returns  x rounded to the nearest integer, with halfway cases rounded away from zero. If
the rounded value is outside the range of the long int type, the result is unspeci-
fied and a domain or range error may oceur. 23.4

malloc Allocate Memory Block <stdlib.h>
void *malloc(size t size);
Allocates a block of memory with size bytes. The block is not cleared.

Returns A pointer to the beginning of the block. Returns a null pointer if a block of the
requested size can’t be allocated. 17.2

mblen Length of Mullibyte Character <stdlib.h>
int wmblen(const char *s, size t n);

Returns  If s is a null pointer, returns a nonzero or zero value, depending on whether or not
multibyte characters have state-dependent encodings. If s points to a null charac-
ter, returns zero. Otherwise, returns the number of bytes in the multibyte character
pointed to by s; returns —1 if the next n or fewer bytes don’t form a valid multibyte
character. 252

mbrlen Length of Multibyte Character — Restartable (C99) <wchar.h>
size t mbrlen(const char * restrict s, size t n,

mbstate t * restrict ps);

Determines the number of bytes in the array pointed to by s that are required to
complete a multibyte character. ps should point to an object of type mbstate_t
that contains the current conversion state. A call of mbrlen is equivalent to
mbrtowe (NULL, s, n, ps)
cxcept that if ps is a null pointer, the address of an internal object is used instead.

Returns  See mbrtowc. 255

mbrtowc Convert Multibyte Character to Wide Character — Restartable <wchar.h>

(C99)

size t mbrtowc(wchar t * restrict pwc,
comst char * restrict s, size t n,
mbstate t * restrict ps);

If s is a null pointer, a call of mbrtowe is equivalent to
mbrtowe (NULL, "", 1, ps)

Otherwise, mbrtowc examines up to n bytes in the array pointed to by s to see if
Returns

Appendix D Standard Library Functions 775

they complete a valid multibyte character. If so, the multibyte character is con-
verted into a wide character. If pwe isn’t a null pointer, the wide character is stored
in the object pointed to by pwe. The value of ps should be a pointer to an object of
type mbstate_t that contains the current conversion state. If ps is a null pointer,
mbrtowc uses an internal object to store the conversion state. If the result of the
conversion is the null wide character, the mbstate_t object used during the call
is left in the initial conversion state.

0 if the conversion produces a null wide character. Returns a number between 1
and n if the conversion produces a wide character other than null, where the value
returned is the number of bytes used to complete the multibyte character. Returns
(size t) (-2) if the n bytes pointed to by s weren't enough to complete a
multibyte character. Returns (size_t) (-1) and stores EILSEQ in exrno if an
encoding error oceurs. 255

mbsinit

Returns

Test for Initial Conversion State (C99) <wchar.h>
int mbsinit (const mbstate t #*ps);

A nonzero value if ps is a null pointer or it points to an mbstate_t object that
describes an initial conversion state; otherwise, returns zero. 255

mbsrtowcs

Returns

Convert Multibyte String to Wide String — Restartable (C99) <wchar.h>

size t mbsrtowcs(wchar t * restrict dst,
const char ** restrict src,
size t len, mbstate t * restrict ps);

Converts a sequence of multibyte characters from the array indirectly pointed to
by src into a sequence of corresponding wide characters. ps should point to an
object of type mbstate_t that contains the current conversion state. If the argu-
ment corresponding to ps is a null pointer, mbsrtowcs uses an internal object to
store the conversion state. If dst isn’t a null pointer, the converted characters are
stored in the array that it points to. Conversion continues up (o and including a ter-
minating null character, which is also stored. Conversion stops earlier if a
sequence of bytes is encountered that doesn't form a valid multibyte character
or if dst isn't a null pointer—when len wide characters have been stored in
the array. If dst isn’t a null pointer, the object pointed to by src is assigned
either a null pointer (if a terminating null character was reached) or the address
just past the last multibyte character converted (if any). If the conversion ends at a
null character and if dst isn't a null pointer, the resulting state is the initial con-
version state,

Number of multibyte characters successfully converted, not including any termi-
nating null character. Returns (size t) (-1) and stores EILSEQ in errno if
an invalid multibyte character is encountered. 255

mbstowcs

Convert Multibyte String to Wide String <stdlib.h>

size_t mbstowcs(wchar t * restrict pwcs,
const char * restrict s, size_t n);
776

Appendix D Standard Library Functions

Returns

Converts the sequence of multibyte characters pointed to by s into a sequence of
wide characters, storing at most n wide characters in the array pointed to by pwcs.
Conversion ends if a null character is encountered: it is converted into a null wide
character.

Number of array elements modified, not including the null wide character, if any.
Returns (size t) (-1) if an invalid multibyte character is encountered. 252

mbtowe

Returns

Convert Multibyte Character to Wide Character <stdlib.h>

int mbtowc(wchar_t * restrict pwc,
eonst char % restrictis, size t n)i;

If s isn’t a null pointer, converts the multibyte character pointed to by s into a wide
character; at most n bytes will be examined. If the multibyte character is valid and
pwe isn’t a null pointer, stores the value of the wide character in the object pointed
to by pwe.

If s is a null pointer, returns a nonzero or zero value, depending on whether or not
multibyte characters have state-dependent encodings. If s points to a null charac-
ter, returns zero. Otherwise, returns the number of bytes in the multibyte character
pointed to by s; returns —1 if the next 1 or fewer bytes don't form a valid multibyte
character. 252

memchr

Returns

Search Memory Block for Character <string.h>
void *memchr (const void *s, int c, size t n);

A pointer (o the first occurrence of the character c among the first n characters of
the object pointed to by s, Returns a null pointer if c isn’t found. 236

memcmp

Returns

Compare Memory Blocks <string.h>
int memcmp (const void *s1, const void *s2, size t n);

A negative, zero, or positive integer, depending on whether the first n characters of
the object pointed to by s1 are less than, equal to, or greater than the first n char-
acters of the object pointed to by 52. 236

memcpy

Returns

Copy Memory Block <string.hs

void *memcpy(void * restrict si,
const void * restrict s2, size t n);

Copies n characters from the object pointed to by s2 into the object pointed to by
21. The behavior is undefined if the objects overlap

s1 (a pointer to the destination). 236

memmove

Returns

Copy Memory Block <string.hs>
void *memmove (void *sl, const void *s2, size t n);

Copies n characters from the object pointed to by s2 into the object pointed o by
1. Will work properly if the objects overlap.

21 (a pointer to the destination). 236
Appendix D Standard Library Functions 777

memset

Initialize Memory Block <string.h>
void *memset (void *s, int c, size t n);

Stores c in each of the first n characters of the object pointed to by s.

Returns s (a pointer to the object). 236
mktime Convert Broken-Down Local Time to Calendar Time <time.h>
time_t mktime(struct tm *timeptz):
Converts a broken-down local time (stored in the structure pointed to by time-
ptr) into a calendar time. The members of the structure aren’t required to be
within their legal ranges; also, the values of Lm_wday (day of the week) and
tm_yday (day of the year) are ignored. mkt ime stores values in tm_wday and
tm_yday after adjusting the other members to bring them into their proper
ranges.
Returns A calendar time corresponding to the structure pointed to by timeptr. Returns
(time_t) (-1) if the calendar time can't be represented. 26.3
modf Splitinto Integer and Fractional Parts <math.h>
double modf (double value, double *iptr);
modff float modff(float value, fleat #*iplr);
modfl long double modfl (long double value, long double *iptr);
Splits value into integer and fractional parts; stores the integer part in the object
pointed to by iptr.
Returns  Fractional part of value. 233
nan Create NaN (C99) <math.h>
double nan(const char *tagp):
nanf float nanf (const char *tagp);
nanl 1long double nanl (const char *tagp);
Returns A “quiet” NaN whose binary pattern is determined by the string pointed to by
tagp. Returns zero if quiet NaNs aren’t supported. 234
nearbyint Round to Integral Value Using Current Direction (C99) <math.h>
double nearbyint (double x);
nearbyintf float nearbyintf (float x);
nearbyintl long double nearbyintl (long double x);
Returns  x rounded to an integer (in floating-point format) using the current rounding direc-
tion. Doesn't raise the inexact floating-point exception. 234
nextafter NextNumber After (C99) <math.h>
double nextafter (double x, double y);
nextafterf float nextafterf (float x, float y);
nextafterl long double nextafterl (long double x, long double y);
778 Appendix D Standard Library Functions

Returns  Next representable value after x in the direction of y. Returns the value just before
xif y < x or the value just after x if x < y. Returns y if x equals y. A range error
may occur if the magnitude of x is the largest representable finite value and the
result is infinite or not representable. 234

nexttoward Next Number Toward (C99) <math.h>
double nexttoward(double x, long double y);
nexttowardf float nexttowardf(float x, long double y);
nexttowardl long double nexttowardl (long double x, long double y);
Returns  Next representable value after x in the direction of y (see nexcafter). Returns
y converted to the function’s type if x equals y. 23.4
perror Print Error Message <stdio.h>
void perror(const char *s);
Werites the following message to the stderr stream:
string : error-message
string is the string pointed to by s and error-message is an implementation-defined
message that matches the one returned by the call st rerror (errno) . 242
pow  Power <math.h>
double pow(double x, double y);
powf float powf(float x, float y);
powl long double powl (long double x, long double y);

Returns  x raised to the power y. A domain or range error may occur in certain cases, which

vary between C89 and C99. 2338
printf Formatied Write <stdio.h>

int printf(const char * restrict format, ...);

Werites output to the stdout stream. The string pointed to by format specifies

how subscquent arguments will be displayed

Returns  Numbcr of characters written. Returns a negative value if an error occurs. 3.1, 22.3

putc Write Character to File <stdio.h>
int putc(int e, FILE *stream);
Writes the character c to the stream pointed to by stream. Nofe: putc is nor-
mally implemented as a macro; it may evaluate st ream more than once.

Returns c (the character written). If a write error occurs, putc sets the stream’s error indi-
cator and returns EOF. 224

putchar Write Character <stdia.h>

int putchar(int c);

Writes the character c to the stdout stream. Nore: putchar is normally imple-
mented as a macro.
Appendix D Standard Library Functions 779

Returns c (the character written). If a write error occurs, putchar sets the stream's error
indicator and returns EOF. 7.3,224
puts Write String <stdio.h>
int puts(const char *s);
Writes the string pointed to by s to the stdout stream, then writes a new-line
character.
Returns A nonnegative value if successful. Returns EOF if a write error oceurs.  13.3, 225
putwc Write Wide Character to File (C99) <wchar.hs
wint_t putwc(wchar t c, FILE *stream);
Wide-character version of putc. 265
putwchar Write Wide Character (C99) <wchar.hs>
wint_t putwchar(wchar t c);
Wide-character version of putchar. 255
gsort Sort Array <stdlib.h>
void gsort(void *base, size t nmemb, size_t size,
int (*compar) (const void *, const void *));
Sorts the array pointed to by base. The array has nmemb elements, each size
bytes long. compar is a pointer to a comparison function. When passed pointers
to two array elements, the comparison function must return a negative, zero, or
positive integer, depending on whether the first array element is less than, equal to,
or greater than the second. 17.7,26.2
raise Raise Signal <signal.h>
int raise(int sig);
Raises the signal whose number is sig.
Returns ~ Zero if successful, nonzero otherwise. 243
rand Generate Pseudo-Random Number <stdlib.h>
int rand(void) ;
Returns A pseudo-random integer between 0 and RAND_MAX (inclusive). 262
realloc Resize Memory Block <stdlib.h>
void *realloc(void *ptr, size t size);
ptr is assumed to point to a block of memory previously obtained from calloc,
malloc, or realloc. realloc allocates a block of size bytes, copying the
contents of the old block if necessary.
Returns A pointer to the beginning of the new memory block. Returns a null pointer if a

block of the requested size can't be allocated. 17.3
780

Appendix D Standard Library Functions

remainder

remainderf

Remainder (C99) <math.h>
double remainder(double x, double y);
float remainderf (float x, float y);

remainderl long double remainderl (long double x, long double y);
Returns  x — ny. where n is the integer nearest the exact value of x/y. (If x/y is halfway
between two integers, n is even.) If x — ny = 0, the return value has the same sign
as x. If y is zero, either a domain error occurs or zero is returned. 234
remove Remove File <stdio.h>
int remove(const char *filename) ;
Deletes the file whose name is pointed to by f1lename.
Returns  Zero if successful, nonzero otherwise. 222
remquo Remainder and Quotient (C99) <math.h>
double remguo(double x, double y, int *quo);
remquof float remquof (float x, float y, int *quo);
remgquol long double remquol (long double x, long double y,
int *quo);
Computes both the remainder and the quotient when x is divided by y. The object
pointed to by quo is modified so that it contains n low-order bits of the integer
quotient |x/yl, where n is implementation-defined but must be at least three. The
value stored in this object will be negative if x/y < 0.
Returns  Same value as the corresponding remainder function. If v is zero, either a
domain error occurs or zero is returned. 234
rename Rename File <stdic.h>
int rename (const char *old, const char *new);
Changes the name of a file. ©1d and new point to strings containing the old name
and new name, Tespectively.
Returns ~ Zero if the renaming is successful. Returns a nonzero value if the operation fails
(perhaps because the old file is currently open). 222
rewind Rewind File <stdio.h>
void rewind(FILE *stream);
Sets the file position indicator for the stream pointed o by stream to the begin-
ning of the file. Clears the error and end-of-file indicators for the stream. 227
rint Round to Integral Value Using Current Direction (C99) <math.h>
double rint (double x);
rintf float rintf(float x);
rintl Ilong double rintl(long double x);
Retums  x rounded to an integer (in floating-point format) using the current rounding direc-
Appendix D Standard Library Functions 781

tion. May raise (he inexact floating-point exception if the result has a different

value than x. 234
round Round to Nearest Integral Value (C99) <math.h>
double round(double x);
roundf float roundf (float x);
roundl Ilong double roundl (long double X);
Returns  x rounded to the ncarest integer (in floating-point format). Halfway cases are
rounded away from zero. 234
scalbln Scale Floating-Point Number Using Long Integer (C99) <math.h>
double scalbln(double x, long int n);
scalblnf float scalblnf(float x, long int n);
scalblnl long double scalblnl (long double x, long int n);
Returns % X FLT_RADIX", computed in an efficient way. A range error may occur. 234
scalbn Scale Floating-Point Number Using Integer (C99) <math.h>
double scalbn(double x, int n);
scalbnf float scalbnf (float x, int n);
scalbnl long double scalbnl (long double X, int n);
Returns  x X FLT_RADIX", computed in an efficient way. A range error may occur. 234
scanf Formatted Read <stdio.h>
int scanf (const char * restrict format, ...);
Reads input items from the st din stream. The string pointed to by format spec-
ifies the format of the items to be read. The arguments that follow format point
to objects in which the items are to be stored.
Returns  Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items can be read. 3.2 223
setbuf SetBuffer <stdio.h>
void setbuf (FILE * restrict stream,
char * restrict buf);
If buf isn’t a null pointer. a call of setbuf is equivalent to:
(void) setvbuf (stream, buf, _IOFBF, BUFSIZ);
Otherwise, it’s equivalent to:
(void) setvbuf(stream, NULL, _TIONBF, 0); 222
setjmp Prepare for Nonlocal Jump <setjmp.h>
int setjmp(jmp_buf env); macro
Stores the current environment in env for use in a later call of longjmp.
Returns  Zero when called directly. Returns a nonzero value when returning from a call of

longjmp. 244
782

Appendix D Standard Library Functions

setlocale Setlocale <locale.h>
char *setlccale(int category, const char *locale);
Sets a portion of the program’s locale. category indicates which portion is
affected. 1ocale points to a string representing the new locale.

Returns  1f 1ocale is a null pointer, returns a pointer to the string associated with cate-
gory for the current locale. Otherwise, returns a pointer to the string associated
with category for the new locale. Returns a null pointer if the operation fails.

251
setvbuf SetBuffer <stdio.h>
int setvbuf (FILE * restrict stream,
char *“pestrict buf,
int mode, size t size);
Changes the buffering of the stream pointed to by stream. The value of mode
can be either _TOFBF (full buffering), TOLBF (line buffering), or _ IONEF (no
buffering). If buf is a null pointer, a buffer is automatically allocated if needed.
Otherwise, buf points to a memory block that can be used as the buffer; size is
the number of bytes in the block. Nore: setvbuf must be called after the stream
is opened but before any other operations are performed on it.

Returns  Zero if the operation is successful. Returns a nonzero value if mode is invalid or
the request can’t be honored. 222

signal Install Signal Handler <signal.h>
void (*signal (int sig, void (*func) (int))) (int);
Installs the function pointed to by func as the handler for the signal whose num-
beris sig. Passing SIG_DFL as the second argument causes default handling for
the signal: passing STG_IGN causes the signal to be ignored.

Returns A pointer to the previous handler for this signal; returns SIG_ERR and stores a
positive value in errno if the handler can’t be installed. 243

signbit SignBit (C99) <math_h>
int signbit (real-floating x) ; macro

Returns A nonzero value if the sign of x is negative and zero otherwise. The value of x may
be any number, including infinity and NaN, 234

sin Sine <math.hs
double sin(double x);

sinf float sinf(float x);

sinl long double sinl(long double x);

Returns  Sine of x (measured in radians). 238

sinh Hyperbolic Sine <math.h>

double sinh(double x);
Appendix D Standard Library Functions ~ 783

sinhf float sinhf(float x);
sinhl long double sinhl (long double X);
Returns  Hyperbolic sine of x. A range error occurs if the magnitude of x is too large. 233
snprintf Bounded Formatted Stiing Write (C99) <stdio.h>
int snprintf (char * restrict s, size t n,
const char * restrict format, ...);:
Equivalent to fprintf, but stores characters in the array pointed to by s instead
of writing them to a stream. No more than n — 1 characters will be written to the
array. The string pointed to by format specifies how subsequent arguments will
be displayed. Stores a null character in the array at the end of output.
Returns  Number of characters that would have been stored in the array (not including the
null character) had there been no length restriction. Returns a negative value if an
encoding error oceurs. 228
sprintf Formatted String Write <stdio.h>
int sprintf (char * restrict s,
const char * restrict format, ...);
Equivalent to fprintf, but stores characters in the array pointed to by s instead
of writing them to a stream. The string pointed to by format specifies how subse-
quent arguments will be displayed. Stores a null character in the array at the end of
output.
Returns  Number of characters stored in the array, not including the null character. In C99,
returns a negative value if an encoding error occurs. 228
sgrt Square Root <math.h>
double sgrt (double x);
sgqrtf float sqrtf(fleat x);
sgrtl long double sqgrtl(long double x);
Returns  Nonnegative square root of x. A domain error oceurs if x is negative. 233
srand Seed Pseudo-Random Number Generator <stdlib.h>
void srand(unsigned int seed);
Uses seed to initialize the sequence of pscudo-random numbers produced by call-
ing rand. 26.2
sscanf Formatted String Read <stdic.h>

int sscanf(censt char * restrict s,
const char * restrict format, ...);

Equivalent to fscanf, but reads characters from the string pointed to by s instead
of reading them from a stream. The string pointed to by format specifies the for-
mat of the items to be read. The arguments that follow format point to objects in
which the items are to be stored.
784

Appendix D Standard Library Functions

Returns  Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items could be read. 228
trcat String Concatenation <string.hs
char *strcat(char * restrict si,
const char * restrict s2);
Appends characters from the string pointed to by s2 to the string pointed to by &1,
Returns  s1 (a pointer to the concatenated string). 13.5,23.6
strchr Search String for Character <string.hs
char *strchr(const char *s, int c);

Returns A pointer o the first occurrence of the character c in the string pointed to by s.

Returns a null pointer if c isn't found. 236
stremp String Comparison <string.h>
int strcmp(const char *sl, const char *s2);

Returns A negative, zero. or positive integer, depending on whether the stri ng pointed to by
s1 is less than, equal to, or greater than the string pointed to by s2. 135, 23.6

strcoll Sting Comparison Using Locale-Specific Collating <string.h>
Sequence
int strcoll (const char *s1, const char *s2);

Returns A negative, zero, or positive integer, depending on whether the string pointed to by
sl is less than, equal to, or greater than the string pointed to by s2. The comparison
is performed according to the rules of the current locale’s L.C COLLATE category.

236
strecpy Sting Copy <string.h>
char *strcpy(char * restrict si,
const char * restrict s2);
Copies the string pointed to by s2 into the array pointed to by s1.
Returns  s1 (a pointer to the destination). 185,236
strespn  Search String for Initial Span of Characters Not in Set <string.h>
size t strcspn(const char *sl, const char *s2);

Returns  Length of the longest initial segment of the string pointed to by s1 that doesn’t

contain any character in the string pointed to by s2. 236
strerror Convert Error Number to String <string.h>
char *strerror(int errnum);

Returns A pointer to a string containing an error message corresponding to the value of

errnum. 242
Appendix D  Standard Library Functions ~ 785

strftime

Returns

Write Formatted Date and Time to String <time.h>

size t strftime(char * restrict s, size t maxsize,
const char * restrict format,
const struct tm * restrict timeptr);

Stores characters in the array pointed to by s under control of the string pointed to
by format. The format string may contain ordinary characters, which are copied
unchanged, and conversion specifiers, which are replaced by values from the struc-
ture pointed to by timeptr. The maxsize parameter limits the number of char-
acters (including the null character) that can be stored.

Number of characters stored (not including the terminating null character). Returns
zero if the number of characters to be stored (including the null character) exceeds
maxsize. 26.3

strlen

Returns

String Length <string.h>
size t strlen(const char *s);

Length of the string pointed to by s, not including the null character. 135,236

strncat

Returns

Bounded String Concatenation <string.hs

char *strncat(char * restrict si,
const char * restrict s2, size_t n);

Appends characters from the array pointed to by s2 to the string pointed to by
s1. Copying stops when a null character is encountered or n characters have been
copied.

s1 (a pointer to the concatenated string). 135,236

strncmp

Returns

Bounded String Comparison <string.h>
int strncmp(const char *sl, const char *s2, size t n);

A negative, zero, or positive integer, depending on whether the first n characters of
the array pointed to by s1 are less than, equal (o, or greater than the first n charac-
ters of the array pointed to by s2. Comparison stops if a null character is encoun-
tered in either array. 236

strncpy

Returns

Bounded String Copy <string.h>

char *strncpy(char * restrict si,
const char * restrict s2, size t n);

Copies the first i characters of the array pointed to by 52 into the array pointed to
by s1. If it encounters a null character in the array pointed to by s2, strnepy
adds null characters to the array pointed to by s1 until a total of n characters have
been written.

=1 (a pointer to the destination). 13.5,23.6
786

Appendix D Standard Library Functions

strpbrk

Returns

Search String for One of a Set of Characters <string.hs
char *strpbrk(const char *sl, const char *s2);

A pointer to the leftmost character in the string pointed 1o by s1 that matches any
character in the string pointed to by s2. Returns a null pointer if no match is found.
236

strrchr

Returns

Search String in Reverse for Character <string.hs
char *strrchr(const char *s, int c);

A pointer to the last occurrence of the character c in the string pointed to by &.
Returns a null pointer if c isn’t found. 236

strspn

Returns

Search String for Initial Span of Characters in Set <string.h>
size t strspn(const char *sl, const char *s2);

Length of the longest initial segment in the string pointed to by s1 that consists
entirely of characters in the string pointed to by s2. 236

strstr

Returns

Search String for Substring <string.h>
char *strstr(const char *sl, const char *s2);

A pointer to the first occurrence in the string pointed to by s1 of the sequence of
characters in the string pointed to by s2. Returns a null pointer if no match is
found. 236

strtod

Returns

Convert String to Double <stdlib.h>

double strtod(const char * restrict nptr,
char ** restrict endptr);

Skips white-space characters in the string pointed to by nptx, then converts subse-
quent characters into a double value. If endptr isn’t a null pointer, strtod
modifies the object pointed to by endptr so that it points to the first leftover char-
acter. If no double value is found, or if it has the wrong form, strtod stores
nptr in the object pointed to by endptr. If the number is too large or small to
represent, it stores ERANGE in exrrno. C99 changes: The string pointed to by
nptr may contain a hexadecimal floating-point number, infinity, or NaN.
Whether ERANGE is stored in errno when the number is too small to represent is
implementation-defined.

The converted number. Returns zero if no conversion could be performed. If the
number is too large fo represent, returns plus or minus KUGE_VAL, depending on
the number’s sign. Returns zero if the number is too small to represent. C99
change: If the number is too small (o represent, strtod returns a value whose
magnitude is no greater than the smallest normalized positive double. 262

strtof

Convert String to Float (C99) <stdlib.h>

float strtof (const char * restrict nptr,
char #** restrict endptr);
Returns

Appendix D Standard Library Functions 787

strtof is identical to st rtod, except that it converts a string to a float value.

The converted number. Returns zero if no conversion could be performed. If the
number is too large to represent, returns plus or minus HUGE_VALF, depending on
the number’s sign. If the number is too small to represent, returns a value whose
magnitude is no greater than the smallest normalized positive float. 26.2

strtoimax

Returns

Convert String to Greatest-Width Integer (C99) <inttypes.h>
intmax t strtoimax(const char * restrict nptr,
char ** restrict endptr, int base);

strtoimax is identical to st rtol, except that it converts a string to a value of
type intmax_t (the widest signed integer type).

The converted number. Returns zero if no conversion could be performed, If the
number can’t be represented, returns INTMAX MAX or INTMAX MIN, depending
on the number’s sign. 272

strtok

Returns

Search String for Token <string.h>

char *strtok(char * restrict si,
const char * restrict s2);

Searches the string pointed to by s1 for a “token” consisting of characters not in
the string pointed to by s2. If a token exists, the character following it is changed
to a null character. If s1 is a null pointer, a search begun by the most recent call of
strtok is continued: the search begins immediately after the null character at the
end of the previous token.

A pointer to the first character of the token, Returns a null pointer if no token could
be found. 236

strtol

Returns

Convert String to Long Integer <stdlib.h>

long int strtol (const char * restrict nptr,
char ** restrict endptr, int base) ;

Skips white-space characters in the string pointed to by npt r, then converts subse-
quent characters into a long int value. If base is between 2 and 36, it is used as
the radix of the number. If base is zero, the number is assumed to be decimal
unless it begins with 0 (octal) or with 0x or 0X (hexadecimal). If endptr isn’t a
null pointer, strtol modifies the object pointed to by endptr so that it points
to the first leftover character. If no long int value is found, or if it has the wrong
form, strtol stores nptx in the object pointed to by endptr. If the number
can't be represented, it stores ERANGE in exrrno.

The converted number. Returns zero if no conversion could be performed. If the
number can’t be represented, returns LONG_MAX or LONG_MIN, depending on the
number’s sign, 262

strtold

Convert String to Long Double (C399) <stdlib.h>

long double strtold(const char * restrict nptr,
char ** restrict endptr);
788

Appendix D  Standard Library Functions

Returns

strtoldis identical to strtod, except that it converts a string to a Long dou-
ble value.

The converted number. Returns zero if no conversion could be performed. If the num-
ber is too large to represent, returns plus or minus HUGE_VALL, depending on the
number’s sign. If the number is too small to represent, returns a value whose mag-
nitude is no greater than the smallest normalized positive long double. 262

strtoll

Returns

Convert String to Long Long Integer (C99) <stdlib.h>

long long int strtoll (const char * restrict nptr,

char ** restrict endptr,

int base);
strtoll isidentical to strtol, except that it converts a string to a long long
int value.
The converted number. Returns zero if no conversion could be performed. If the
number can’t be represented, returns LLONG_MAX or LLONG_MIN, depending on
the number’s sign. 262

strtoul

Returns

Convert String to Unsigned Long Integer <stdlib.h>

unsigned long int strtoul (const char * restrict nptr,
char ** restrict endptr,
int base) ;

strtoul is identical to strtol, except that it converts a sting to an
unsigned long int value.

The converted number. Returns zero if no conversion could be performed. If the
number can’t be represented, returns ULONG_MAX. 26.2

strtoull

Returns

Convert String to Unsigned Long Long Integer (C99) <stdlib.h>
unsigned long long int strtoull (

const char * restrict nptr,

char ** restrict endptr, int base);
strcoull is identical to strtol, except that it converts a slring to an
uneigned long long int valuc.

The converted number. Returns zero if no conversion could be performed, If the
number can’t be represented, returns ULLONG_MAX. 26.2

strtoumax

Returns

Convert String to Unsigned Greatest-Width Integer (C99) <inttypes.hs
uintmax t strtoumax(const char * restrict nptr,

char ** restrict endptr,

int base);
strtoumax is identical to strtol, except that it converts a string to a value of
type uintmax_t (the widest unsigned integer type).

The converted number. Returns zero if no conversion could be performed. If the
number can’t be represented, returns UTNTMAX MAX, 272

Appendix D Standard Library Functions 789

strxfrm Transform String <string.h>
size t strxfrm(char * restrict si,
const char * restrict s2, size t n);
Transforms the string pointed to by s2, placing the first n characters of the
result—including the null character—in the array pointed to by s1. Calling
stremp with two transformed strings should produce the same outcome (nega-
tive, zero, or positive) as calling strcoll with the original strings. If n is zero,
s1 is allowed to be a null pointer.
Returns  Length of the transformed string. If this value is n or more, the contents of the
array pointed (o by s1 are indeterminate. 236
swprintf Wide-Character Formatted String Write (C99) <wchar . h>
int swprintf(wchar t * restrict s, size t n,
const wchar t * restrict format, ...);
Equivalent to fwprintf, but stores wide characters in the array pointed to by s
instead of writing them to a stream. The string pointed to by format specifics
how subsequent arguments will be displayed. No more than n wide characters will
be written to the array, including a terminating null wide character.
Returns  Number of wide characters stored in the array, not including the null wide charac-
ter. Returns a negative value if an encoding error occurs or the number of wide
characters to be written is n or more. 255
swscanf Wide-Character Formatted String Read (C99) <wchar.h>
int swscanf (const wchar t * restrict s,
const wchar t * restrict format, ...);
‘Wide-character version of sscanf. 255
system Perform Operating-System Command <stdlib.h>
int system(const char *string);
Passes the string pointed to by string to the operating system's command pro-
cessor (shell) to be executed. Program termination may oceur as a result of execut-
ing the command.
Returns  If string is a null pointer, rcturns a nonzero valuc if a command processor is
available. If string isn’t a null pointer, system returns an implementation-
defined value (if it returns at all). 26.2
tan Tangent <math.h>
double tan(double x);
tanf float tanf(float x);
tanl Iong double tanl(long double Xx);
Returns  Tangent of x (measured in radians). 233
790  Appendix D Standard Library Functions
tanh Hyperbolic Tangent <math.h>
double tanh(double x) ;
tanhf [loat tanhf(float x);
tanhl long double tanhl (long double x);
Returns  Hyperbolic tangent of x. 233
tgamma Gamma Function (C99) <math.h>
double tgamma (double x);
tgammaf float tgammaf (float x);
tgammal long double tgammal (long double x);
Returns  1'(>), where I is the gamma function. A domain error or range error may occur if 3
is a negative integer or zero. A range error may oceur if the magnitude of x is o
large or too small. 234
time curent Time <time.h>
time_t time(time_t *timer) ;
Returns ~ Current calendar time, Returns (time_t) (-1) if the calendar time isn’t avail-
able. If t imex isn’t a null pointer, also stores the return value in the object pointed
toby timer. 263
tmpfile Create Temporary File <stdio.h>
FILE *tmpfile (void);
Creates a temporary file that will automatically be removed when it’s closed or the
program ends. Opens the file in "wb+" mode.
Returns A file pointer to be used when performing subsequent operations on the file.
Returns a null pointer if a temporary file can’t be created. 222
tmpnam Generate Temporary File Name <stdio.h>
char *Lmpnam(char *s);
Generates a name for a temporary file. If s is a null pointer, tmpnam stores the file
name in a static object. Otherwise, it copies the file name into the character array
pointed to by s. (The array must be long cnough to store L_tmpnam characters.)
Returns A pointer to the file name. Returns a null pointer if a file name can’t be generated.
222
tolower Convert to Lower Case <ctype.h>
int tolower (int c);
Returns  1f c is an upper-case letter, returns the corresponding lower-case letter. If c isn’t an
upper-case letter, returns c unchanged. 235
toupper Convert to Upper Case <ctype.h>

int toupper(int c);
Appendix D Standard Library Functions ~ 791

Returns  If c is a lower-case letter, returns the corresponding upper-case letter. If c isn’t a
lower-case letter, returns c unchanged. 235
towctrans Transliterate Wide Character (C99) <wctype.h>
wint_t towctrans(wint_t wc, wctrans_t desc);
Returns  Mapped value of wc using the mapping described by desc. (desc must be a
value returned by a call of wetrans: the current setting of the LC_CTYPE cate-
gory must be the same during both calls.) 256
towlower Convert Wide Character to Lower Case (C99) <wctype.h>
wint_t towlower (wint_t wc);
Returns  If iswupper (wc) is true, returns a corresponding wide character for which
iswlower is true in the current locale, if such a character exists. Otherwise,
returns we unchanged. 25.6
towupper Convert Wide Character to Upper Case (C99) <wctype.h>
wint t towupper (wint t wc);
Returns I iswlower (wc) is true, returns a corresponding wide character for which
iswupper is true in the current locale, if such a character exists. Otherwise,
returns we unchanged. 25.6
trunc Twuncale o Nearest Integral Value (C99) <math.h>
double trunc (double x) ;
truncf float truncf(float x);
truncl long double truncl (long double x);
Returns % rounded to the integer (in floating-point formar) nearest to it but no larger in
magnitude. 234
ungetc Unread Character <stdio.h>
int ungetc(int c, FILE *stream);
Pushes the character c back onto the stream pointed to by stream and clears the
stream’s end-of-file indicator. The number of characters that can be pushed back
by consecutive calls of ungetc varies; only the first call is guaranteed to succeed.
Calling a file positioning function (Eseek, fsetpos, or rewind) causes the
pushed-back character(s) to be lost.
Returns c (the pushed-back character). Returns EOF if an attempt is made to push back
EOF or to push back too many characters without a read or file positioning opera-
tion. 224
ungetwc Unread Wide Character (C99) <wchar.h>

wint_t ungetwc (wint_t c, FILE *stream);

Wide-character version of ungete. 255
792 Appendix D Standard Library Functions
va_arg Feich Argument from Variable Argument List <stdarg.h>
type va_arg(va list ap, type); macro
Fetches an argument in the variable argument list associated with ap, then modi-
fies ap so that the next use of va_arg fetches the following argument. ap must
have been initialized by va_start (or va_copy in C99) prior to the first use of
va_arg.
Returns  Value of the argument, assuming that its type (after the default argument promo-
tions have been applied) is compatible with zype. 26.1
va _copy Copy Variable Argument List (C99) <stdarg.h>
void va_copy(va list dest, va list src); macro
Copies src into dest. The value of dest will be the same as if va_start had
been applied to dest followed by the same sequence of va_arg applications that
was used to reach the present state of sre. 26.1
va_end End Processing of Variable Argument List <stdarg.h>
void va_end(va_list ap); macro
Ends the processing of the variable argument list associated with ap. 26.1
va_start Start Processing of Variable Argument List <stdarg.h>
void va start(va t ap, parmN) ; macro
Must be invoked before accessing a variable argument list. Initializes ap for later
use by va_arg and va_end. parmN is the name of the last ordinary parameter
(the one followed by , .. .). 26.1
vEprintf Formatted File Write Using Variable Argument List <stdio.h>
int vfprintf (FILE * restrict stream,
const char * restrict format,
va_list arg);
Equivalent to fprintf with the variable argument list replaced by arg.
Returns  Number of characters written. Returns a negative value if an error oceurs. 261
viscanf Formatted File Read Using Variable Argument List (C99) <stdio.h>
int vfscanf (FILE * restrict stream,
const char * restrict format,
va_list arg);
Equivalent to tscanf with the variable argument list replaced by arg.
Returns  Number of input items successfully read and stored. Returns EOF if an input fail
ure occurs before any items can be read. 26.1
vEwprintf Wide-Character Formatted File Write Using Variable <wchar.h>

Argument List (C99)
Appendix D Standard Library Functions 793

int viwprintf (FILE * restrict stream,
const wchar t * restrict format,
va_list argl;

Wide-character version of vEprintf. 255
vEifwscanf Wide-Character Formatted File Read Using Variable <wchar.h>
Argument List (C99)
int vfwscanf (FILE * restrict stream,
const wchar t * restrict format,
va_list arg);
Wide-character version of vEscant. 255
vprintf Formatted Write Using Variable Argument List estdio.hs
int vprintf(const char * restrict format, va list arg);
Equivalent to printf with the variable argument list replaced by arg.
Returns  Number of characters written. Returns a negative value if an error occurs. 26.1
vscanf Formatted Read Using Variable Argument List (C99) <stdio.h>
int vscanf (const char * restrict format, va list arg);
Equivalent to scanf with the variable argument list replaced by arg.
Returns  Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items can be read. 26.1
vsnprintf Bounded Formatted String Write Using Variable Argument <stdio.h>
List (C99)
int vsnprintf(char * restrict s, size t n,
const char * restrict format,
va_list arg);
Equivalent to snprintf with the variable argument list replaced by arg.
Returns  Number of characters that would have been stored in the array pointed to by s (not
including the null character) had there been no length restriction. Returns a nega-
tive value if an encoding error occurs. 26.1
vsprintf Formatted String Write Using Variable Argument List <stdio.h>
int vsprintf (char * restrict s,
const char * restrict format,
va_list arg);
Equivalent to sprintf with the variable argument list replaced by arg.
Returns  Number of characters stored in the array pointed to by s, not including the null

character. In C99, returns a negative value if an encoding error occurs. 26.1
794

Appendix D Standard Library Functions

vsscanf Formatted String Read Using Variable Argument List (C99)  <stdio.h>
int vsscanf (const char * restrict s,
const char * restrict format,
va_list arg);:
Equivalent to sscanf with the variable argument list replaced by arg.
Returns  Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items can be read. 26.1
vewprintf Wide-Character Formatted String Write Using Variable <wchar.h>
Argument List (C99)
int vswprintf(wchar_t * restrict s, size t n,
const wchar_t * restrict format,
va_list arg);
Equivalent to swprintf with the variable argument list replaced by arg.
Returns  Number of wide characters stored in the array pointed to by s, not including the
null wide character. Returns a negative value if an encoding error occurs or the
number of wide characters 1o be written is n or more. 255
vewscanf Wide-Character Formatted String Read Using Variable <wchar.h>
Argument List (C99)
int vswscanf(const wchar t * restrict s,
const wechar t * restrict format,
va_list arg);
Wide-character version of vescang. 255
vwprintf Wide-Character Formatted Write Using Variable Argument ~ <wchar .h>
List (C99)
int vwprintf (const wchar t * restrict format,
va_list arg);
Wide-character version of vprintf. 255
vwscanf Wide-Character Formatted Read Using Variable Argument  <wchar.h>
List (C99)
int vwscanf (const wchar t * restrict format,
va_list arg);
Wide-character version of vecant. 255
wertomb Convert Wide Character to Multibyte Character — Restartable <wchar . h>

(C99)

size t wertomb(char * restrict s, wchar t we,
mbstate t * restrict ps);

If s is a null pointer, a call of wertomb is equivalent to

wertomb (buf, L'\0', ps)
Appendix D Standard Library Functions 795

where buf is an internal buffer. Otherwise, wertomb converts we from a wide
character into a multibyte character (possibly including shift sequences), which it
stores in the array pointed to by s. The value of ps should be a pointer to an object
of type mbstate_t that contains the current conversion state. If ps is a null
pointer, wertomb uses an internal object to store the conversion state. If we is a
null wide character, wertomb stores a null byte, preceded by a shift sequence if
necessary to restore the initial shift state, and the mbstate_t object used during
the call is left in the initial conversion state.

Returns  Number of bytes stored in the array, including shift sequences. If we isn’t a valid
wide character, returns (size_t) (-1) and stores EILSEQ in errne. 255
wcscat  Wide-String Concatenation (C99) <wchar.h>
wchar t *wcscat (wchar t * restrict si,
const wchar t * restrict s2);
Wide-character version of strcat. 255
wcschr  Search Wide String for Character (C99) <wehar.h>
wchar_t *weschr (const wechar_ t *s, wchar_t c);
Wide-character version of strchr, 255
wcscmp  Wide-String Comparison (C99) <wchar.h>
int wesemp (const wehar t *s1, const wchar t *s2);
Wide-character version of stremp. 255
wcscoll Wide-String Comparison Using Locale-Specific Collating <wchar.h>
Sequence (C399)
int wcscoll (const wchar t *sl, const wchar t *s2);
Wide-character version of strcoll. 255
wcscpy Wide-String Copy (C99) <wchar .h>
wchar_t *wescpy(wchar t * restrict sl,
const wchar t * restrict s2);
Wide-character version of strepy. 255
wescspn  Search Wide String for Initial Span of Characters Not in Set  <wchar.h>
(C99)
size t wescspn(const wchar t *sl, const wchar t *s2);
Wide-character version of strespn. 255
wcsftime Write Formatted Date and Time to Wide String (C99) <wchar.hs>

size t wesftime(wchar t * restrict s, size t maxsize,
const wchar t * restrict format,
const struct tm * restrict timeptr);

Wide-characler version of stz Lt ime. 255
796 Appendix D Standard Library Functions
wcslen Wide-String Length (C99) <wchar.hs
size t wcslen(const wchar t *s);
Wide-character version of strlen. 255
wcsncat Bounded Wide-String Concatenation (C99) <wchar.h>
wehar_t *wesncat (wchar t * restrict si,
const wechar_t * restrict s2,
size t n);
Wide-character version of strncat. 255
wcsncemp  Bounded Wide-String Comparison (C99) <wchar.h>
int wesnemp (const wchar t *s1, const wchar t *s2,
size t n);
Wide-character version of st zncup. 255
wcsncpy Bounded Wide-String Copy (C99) <wchar.h>
wchar_t *wesncpy (wehar t * restrict si,
const wchar_ t * restrict s2,
size t n);
‘Wide-character version of strncpy. 255
wespbrk Search Wide String for One of a Set of Characters (C99) <wchar.h>
wchar t *wcspbrk(const wchar t *si,
const wchar t *s2);
Wide-character version of strpbrk. 255
weszrchr Search Wide String in Reverse for Character (C99) <wchar.h>
wchar t *wcsrchr (const wchar t *s, wchar t c);
‘Wide-character version of strrchr. 255
wcsrtombs Convert Wide String to Multibyte String — Restartable (C99)  <wchar.h>

size t wcsrtombs (char * restrict dst,
congt wchar_t ** restrict src,
gize t len,
mbetate t * restrict ps);

Converts a sequence of wide characters from the array indirectly pointed to by
src into a sequence of corresponding multibyte characters that begins in the con-
version state described by the object pointed to by ps. If ps is a null pointer,
weertombs uses an internal object to store the conversion state. If dst isn't a
null pointer, the converted characters are then stored in the array pointed to by
dst. Conversion continues up to and including a terminating null wide character,
which is also stored. Conversion stops earlier if a wide character is reached that
doesn’t correspond to a valid multibyte character or—if dst isn't a null pointer—
Appendix D Standard Library Functions 797

when the next multibyte character would exceed the limit of 1en total bytes to be
stored in the array pointed to by dst. If dst isn’t a null pointer, the object pointed
to by src is assigned either a null pointer (if a terminating null wide character was
reached) or the address just past the last wide character converted (if any). If the
conversion ends at a null wide character, the resulting state is the initial conversion
state.

Returns  Number of bytes in the resulting multibyte character sequence, not including any
terminating null character. Returns (size t) (-1) and stores EILSEQ in
errno if a wide character is encountered that doesn’t correspond to a valid multi-
byte character. 255
wcsspn Search Wide String for Initial Span of Characters in Set (C99) <wchar .h>

size t wcsspn(const wchar t *sl, const wchar t *s2);

Wide-character version of strspn, 255
wecsstr Search Wide String for Substring (C99) <wchar.hs

wchar_t *wcsstr(const wchar t *sl, const wchar t *s2);

Wide-character version of strstr. 255
westod Convert Wide String to Double (C99) <wchar.hs

double wcstod(const wchar t * restrict nptr,

wchar t ** restrict endptr);

Wide-character version of strtod. 255
wcstof Convert Wide Siring to Float (C99) <wchar.hs

float wcstof (const wchar t * restrict nptr,

wchar t ** restrict endptr);
Wide-character version of strtof. 255
wcstoimax Convert Wide String to Greatest-Width Integer (C99) zinttypes.h>
intmax t westoimax(const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base);

Wide-character version of strtoimax. 272

wcstok Search Wide Siring for Token (C99) <wchar.hs

wchar t *wcstok(wchar t * restrict si,

const wchar_t * restrict s2,

wchar & #*irestrictiptr);
Searches the wide string pointed to by s1 for a “token” consisting of wide charac-
ters not in the wide string pointed to by s2. If a token exists, the character follow-
ing it is changed to a null wide character. If s1 is a null pointer, a search begun by
a previous call of westok is continued; the search begins immediately after the
null wide character at the end of the previous token. ptr points to an object of
798

Appendix D Standard Library Functions

type wehar_t * that westok modifies to keep track of its progress. If s1 is a
null pointer, this object must be the same one used in a previous call of westok; it
determines which wide string is to be searched and where the search is to begin.

Returns A pointer to the first wide character of the token. Returns a null pointer if no token
could be found. 255
westol Convert Wide String to Long Integer (C99) <wchar.h>
long int wcstol (const wchar t * restrict nptr,
wchar t #*#% restrict endptr, int base);
Wide-character version of strtol. 255
westold Convert Wide String to Long Double (C99) <wchar.h>
long double wcstold(const wchar t * restrict nptr,
wchar t ** restrict endptr);
Wide-character version of strtald. 255
wcstoll Convert Wide String to Long Long Integer (C989) <wchar.h>
long long int wcstoll (const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base);
Wide-character version of strtoll. 255
wcstombs Convert Wide String to Multibyte String <stdlib.h>
size_t wcstombs(char * restrict s,
const wchar_t * restrict pwcs,
size t n);
Converts a sequence of wide characters into corresponding multibyte characters.
pwcs points to an array containing the wide characters. The multibyte characters
are stored in the array pointed to by s. Conversion ends if a null character is stored
or if storing a multibyte character would exceed the limit of n bytes,
Returns  Number of bytes stored, not including the terminating null character, if any.
Returns (size_t) (-1) if a wide character is encountered that doesn’t corre-
spond to a valid multibyte character. 252
wcstoul Convert Wide String to Unsigned Long Integer (C99) <wchar.h>
unsigned long int westoul (
const wchar_t * restrict nptr,
wchar_t ** restrict endptr, int base);
‘Wide-character version of strtoul. 255
wecstoull Convert Wide String to Unsigned Long Long Integer (C99)  <wchar.h>

unsigned long long int westoull (
const wchar t # restrict nptr,
wchar t ** restrict endptr, int base);
Wide-character version of strtoull. 255
Appendix D Standard Library Functions 799

westoumax Convert Wide String to Unsigned Greatest-Widith Integer <inttypes.h>
(C99)
uintmax_t wecstoumax(const wchar t * restrict nptr,
wehar_t ** restrict endptr,
int base);
Wide-character version of strtoumax. 272
wesxfrm Transform Wide String (C99) <wchar.h>
size t wesxfrm(wchar t * restrict si,
const wchar t * restrict s2, size t n);
‘Wide-character version of strxfrm. 255
wctob  Convert Wide Character to Byte (C99) <wchar . h>
int wctob(wint_t c);

Returns  Single-byte representation of c as an unsigned char converted to int. Returns

EQF if c doesn’t correspond to one multibyte character in the initial shift state.
255
wctomb Convert Wide Character to Multibyte Character <stdlib.h>
int wctomb(char *s, wchar_t we);
Converts the wide character stored in we into a multibyte character. If s isn’t a null
pointer, stores the result in the array that & points to.

Returns  If & is a null pointer, returns a nonzero or zero value, depending on whether or not
multibyte characters have state-dependent encodings. Otherwise, returns the num-
ber of bytes in the multibyte character that corresponds to we; returns —1 if we
doesn’t correspond to a valid multibyte character. 252

wctrans Define Wide-Character Mapping (C99) <wetype.h>
wctrans t wctrans(const char *property);

Returns  If property identifies a valid mapping of wide characters according to the
LC_CTYPE category of the current locale, returns a nonzero value that can be used
as the second argument to the towctrans function; otherwise, returns zero,

256
wctype Define Wide-Character Class (C99) <wctype.hs
wctype t wctype(const char *property);

Returns  If property identifies a valid class of wide characters according 1o the
LC_CTYPE category of the current locale, returns a nonzero value that can be used
as the second argument to the iswctype function; otherwise, returns zero. 256

wmemchr Search Wide-Character Memory Block for Character (C99)  <wchar.h>

wechar t *wmemchr (const wchar t *s, wchar t c,
Bize T3k 2

Wide-character version of memchzx. 255
800 Appendix D Standard Library Functions
wmemcmp Compare Wide-Character Memory Blocks (C99) <wchar.h>
int wmemcmp (const wchar t * sl, const wchar t * s2,
size t n);
‘Wide-character version of memcmp. 255
wmemcpy Copy Wide-Character Memory Block (C99) <wchar.h>
wehar_t *wmemcpy (wehar_t * restrict si1,
const wchar t * restrict s2,
size it n);
‘Wide-character version of memcpy. 255
wmemmove Copy Wide-Character Memory Block (C99) <wchar.hs
wchar t *wmemmove (wchar t *sl, const wchar t *s2,
silze t n);
Wide-character version of memmove 255
wmemset Initialize Wide-Character Memory Block (C99) <wchar.h>
wchar t *wmemset (wchar t *s, wchar_t c, size t n);
‘Wide-character version of memset. 255
wprintf Wide-Character Formatted Write (C99) <wchar.h»
int wprintf (const wchar t * restrict format, ...);
Wide-character version of printf. 255
wscanf Wide-Character Formatted Read (C99) <wchar.hs
int wscanf (const wchar t * restrict format, ...);

‘Wide-character version of scanf. 255
APPENDIX E
ASCII Character Set

Escape Sequence
Decimal  Oct  Hex  Char  Character
0 \o \x00 nul 32 04 @ 96
1 N \x01 soh (*A) | 33 ! 6y A 97 a
2 \2 \x02 sk (#B) | 34 " 66 B 98 b
3 \3 \x03 e ((AC) | 35 f i67 € i
4 \4 \x04 eat (CDYNINS6:  Ba63 D) 100 d
5 \5 \x05 eng I(PB) |1 3710 %1 169 E: 101 e
6 \6 \x06 ack ("F) I8 & L T0 B 102 r
7 \7 \oe0iz S Na helli(0G) |30 R ST EEGT g3
8 \10 \x08 \b bs (“H) | 40 ( 72 H 104 h
9 \11 \x09 \t At (1) 41 ) 73 I 105 i
10 \12 \x0a \n if ((20) 42 LN ) S| 106 i
11 13 \x0b, \v A gl - N PR S [ S € 107 k
12 \14 \x0c NE LY |44 7% D 108 I
13 NI FAx0ds. Nzt e AN A5 TR 109 m
14 \16 \x0e so  ("N) | 46 5 78 N 110 o
15 \Z7 \xof si (r0) | 47 / 79 © 111 0
16 \20 \x10 dle ("P). 48 0 |8 P 1120 p
17 NEEE At del (*Q) | 49 1 81 Q 113 g
18 22 N0 G2 (R [+50 12 82 R 114 r
19 Vgl e dc3 (7S) 51 3|8 S 115 s
20 \2c \x14 ded ("T) 52 4|8 T 116 t
21 N25  \x15 nak ("U) | 53 5 |8 U 117 u
22 \26 \x16 syn ("V) 54 6 86 v 118 v
23 X270 \xLT eb Wl S5 T 18T Wl 119w
24 \30 \x18 can ("X) | 56 8 | 8 X 1200 x
25 \31  \x19 em (0X) | 5T 9|89 X 121 Y
26 \32  \xia sub ("Z) 58 ! 90, Z 122 7
27 \33 \xib esc 59 s 91 i 123 {
28 \32 \xlc fs 60 < ['92 \ 124 |
2! \35 \xid gs 61 =711598 | 125 }
30 \36 \xle s 62 > | 94 X 126 ~
31 NAD NTLE us 63 1| 98 127 del

801

BIBLIOGRAPHY

The best book on programming for the layman is
“Alice in Wonderland”; but that's because it's
the best book on anything for the layman.

C Programming

Feuer, A. R., The C Puzzle Book, Revised Printing, Addison-Wesley, Reading,
Mass., 1999. Contains numerous “puzzles”—small C programs whose output
the reader is asked to predict. The book shows the correct output of each pro-
gram and provides a detailed explanation of how it works. Good for testing
your C knowledge and reviewing the fine points of the language.

Harbison, S. P, III, and G. L. Steele, Jr., C: A Reference Manual, Fifth Edition,
Prentice-Hall, Upper Saddle River, N.J., 2002. The ultimate C reference—
essential reading for the would be C expert. Covers both C89 and C99 in con-
siderable detail, with frequent discussions of implementation differences
found in C compilers. Not a tutorial—assumes that the reader is already well
versed in C.

Kernighan, B. W, and D. M. Ritchie, The C Programming Language, Second Edi-
tion, Prentice-Hall, Englewood Cliffs, N.J., 1988. The original C book, affec-
tionately known as K&R or simply “the White Book.” Includes both a tutorial
and a complete C reference manual. The second edition reflects the changes
made in C89.

Koenig, A., C Traps and Pitfalls, Addison-Wesley, Reading, Mass., 1989. An
excellent compendium of common (and some not-so-common) C pitfalls.
Forewarned is forearmed.

Plauger, P. I.. The Standard C Library. Prentice-Hall, Englewood Cliffs, N.I.,
1992. Not only explains all aspects of the C89 standard library, but provides
complete source code! There’s no better way to learn the library than to study
this book. Even if your interest in the library is minimal, the book is worth get-
ting just for the opportunity to study C code written by a master.

803
804

Bibliography

Ritchie, D. M., The development of the C programming language, in History of
Programming Languages II, edited by T. . Bergin, Jr., and R. G. Gibson, Jr.,
Addison-Wesley, Reading, Mass., 1996, pages 671-687. A brief history of C
written by the language’s designer for the Second ACM SIGPI.AN History of
Programming 1.anguages Conference, which was held in 1993, The article is
followed by transcripts of Ritchie’s presentation at the conference and the
question-and-answer session with the audience.

Ritchie, D. M., S. C. Johnson, M. E. Lesk, and B. W. Kernighan, UNIX time-
sharing system: the C programming language, Bell System Technical Journal
57, 6 (July-August 1978), 1991-2019. A famous article that discusses the
origins of C and describes the language as it looked in 1978.

Rosler, L., The UNIX system: the evolution of C—past and future, AT&T Bell
Laboratories Technical Journal 63, 8 (October 1984), 1685-1699. Traces the
evolution of C from 1978 to 1984 and beyond.

Summit, S., C Programming FAQs: Frequently Asked Questions, Addison-Wesley,
Reading, Mass., 1996. An expanded version of the FAQ list that has appeared
for years in the Usenet comp.lang.c newsgroup.

van der Linden, P., Expert C Programming, Prentice-Hall, Englewood Cliffs, N.J.,
1994. Written by one of the C wizards at Sun Microsystems, this book man-
ages 1o entertain and inform in equal amounts, With its profusion of anecdotes
and jokes, it makes learning the fine points of C seem almost fun.

UNIX Programming

Rochkind, M. J., Advanced UNIX Programming, Second Edition, Addison-Wesley,
Boston, Mass., 2004. Covers UNIX system calls in considerable detail. This
book, along with the one by Stevens and Rago, is a must-have for C program-
mers who use the UNIX operating system or one of its variants.

Stevens, W. R., and S. A. Rago, Advanced Programming in the UNIX Environment,
Second Edition, Addison-Wesley, Upper Saddle River, N.J., 2005. An excel-
lent follow-up to this book for programmers working under the UNIX operat-
ing system. Focuses on using UNIX system calls, including standard C library
functions as well as functions that are specific to UNIX.

Programming in General

Bentley, J., Programming Pearls, Second Edition, Addison-Wesley, Reading,
Mass., 2000, This updated version of Bentley’s classic programming book
emphasizes writing efficient programs, but touches on other topics that are
crucial for the professional programmer. The author’s light touch makes the
book as enjoyable to read as it is informative.
Bibliography ~ 805

Kernighan, B. W., and R. Pike, The Practice of Programming, Addison-Wesley,
Reading, Mass.. 1999. Read this book for advice on programming style, choos-
ing the right algorithm, testing and debugging, and writing portable programs.
Examples are drawn from C, C++, and Java.

McConnell, S., Code Complete, Second Edition, Microsoft Press, Redmond, Wash.,
2004 Tries to bridge the gap between programming theory and practice by pro-
viding down-to-earth coding advice based on proven research. Includes plenty
of examples in a variety of programming languages. Highly recommended.

Raymond, E. S, ed., The New Hacker’s Dictionary, Third Edition, MIT Press, Cam-
bridge, Mass., 1996. Explains much of the jargon that programmers use, and it’s
great fun to read as well.

Web Resources

ANSI eStandards Store (webstore.ansi.org). The C99 standard (ISO/IEC
9899:1999) can be purchased at this site. Each set of corrections to the stan-
dard (known as a Technical Corrigendum) can be downloaded for free.

comp.lang.c Frequently Asked Questions (c-fag.com). Steve Summit’s FAQ list for
the comp.lang.c newsgroup is a must-read for any C programmer.

Dinkumware (www.dinkumware.com). Dinkumware is owned by P. J. Plauger, the
acknowledged master of the C and C++ standard libraries. The web site in-
cludes a handy C99 library reference, among other things.

Google Groups (groups.google.com). One of the best ways to find answers to pro-
gramming questions is to search the Usenct newsgroups using the Google
Groups search engine. If you have a question, it’s likely that someone else has
already asked the question on a newsgroup and the answer has been posted.
Groups of particular interest to C programmers include alr.comp.lang.learn.c-
c++ (for C and C++ beginners), comp.lang.c (the primary C language group),
and comp.std.c (devoted to discussion of the C standard).

International Obfuscated C Code Contest (www.iocce.org). Home of an annual con-
testin which participants vie to see who can write the most obscure C programs,

ISOMEC JTC1/SC22/WG14 (www.open-std.org/jtc1/sc22/wgl4/). The official web
site of WG14, the international working group that created the C99 standard
and is responsible for updating it. Of particular interest among the many docu-
ments available at the site is the rationale for C99, which explains the reasons
for the changes made in the standard.

Lysator (www.lysaror.lin.se/c/). A collection of links to C-related web sites main-
tained by Lysator, an academic computer society located at Sweden’s Lin-
képing University.
